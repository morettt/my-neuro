import json
import random
import time
import threading
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, asdict
from enum import Enum

class GameType(Enum):
    """Ê∏∏ÊàèÁ±ªÂûãÊûö‰∏æ"""
    GUESS_DRAW = "‰Ω†ÁîªÊàëÁåú"
    WORD_GAME = "ÊñáÂ≠óÊ∏∏Êàè"
    RIDDLE = "ÁåúË∞úÊ∏∏Êàè"
    STORY_GAME = "ÊïÖ‰∫ãÊé•Èæô"
    TRIVIA = "Áü•ËØÜÈóÆÁ≠î"
    TWENTY_QUESTIONS = "‰∫åÂçÅ‰∏™ÈóÆÈ¢ò"
    ROCK_PAPER_SCISSORS = "Áü≥Â§¥Ââ™ÂàÄÂ∏É"
    NUMBER_GUESS = "ÁåúÊï∞Â≠ó"

class GameState(Enum):
    """Ê∏∏ÊàèÁä∂ÊÄÅÊûö‰∏æ"""
    NOT_STARTED = "Êú™ÂºÄÂßã"
    IN_PROGRESS = "ËøõË°å‰∏≠"
    PAUSED = "ÊöÇÂÅú"
    COMPLETED = "Â∑≤ÂÆåÊàê"
    ABORTED = "Â∑≤‰∏≠Ê≠¢"

@dataclass
class GameSession:
    """Ê∏∏Êàè‰ºöËØùÊï∞ÊçÆÁ±ª"""
    session_id: str
    game_type: GameType
    state: GameState
    start_time: float
    end_time: Optional[float]
    players: List[str]
    current_turn: int
    game_data: Dict[str, Any]
    score: Dict[str, int]
    moves_history: List[Dict[str, Any]]
    
    def to_dict(self):
        return asdict(self)

class GameCompanionSystem:
    """Ê∏∏ÊàèÈô™Áé©Á≥ªÁªü - ÊîØÊåÅÂ§öÁßç‰∫íÂä®Ê∏∏Êàè"""
    
    def __init__(self, games_data_path="game_mod/games_data.json"):
        self.games_data_path = games_data_path
        self.active_sessions = {}  # Ê¥ªË∑ÉÁöÑÊ∏∏Êàè‰ºöËØù
        self.game_rules = {}       # Ê∏∏ÊàèËßÑÂàô
        self.game_data = {}        # Ê∏∏ÊàèÊï∞ÊçÆÔºàÈ¢òÂ∫ì„ÄÅËØçÂ∫ìÁ≠âÔºâ
        
        # Âä†ËΩΩÊ∏∏ÊàèÊï∞ÊçÆÂíåËßÑÂàô
        self.load_game_data()
        self.initialize_game_rules()
        
        print("üéÆ Ê∏∏ÊàèÈô™Áé©Á≥ªÁªüÂ∑≤ÂàùÂßãÂåñ")
    
    def load_game_data(self):
        """Âä†ËΩΩÊ∏∏ÊàèÊï∞ÊçÆ"""
        try:
            with open(self.games_data_path, 'r', encoding='utf-8') as f:
                self.game_data = json.load(f)
        except FileNotFoundError:
            # ÂàõÂª∫ÈªòËÆ§Ê∏∏ÊàèÊï∞ÊçÆ
            self.game_data = self._create_default_game_data()
            self.save_game_data()
    
    def save_game_data(self):
        """‰øùÂ≠òÊ∏∏ÊàèÊï∞ÊçÆ"""
        import os
        os.makedirs(os.path.dirname(self.games_data_path), exist_ok=True)
        
        with open(self.games_data_path, 'w', encoding='utf-8') as f:
            json.dump(self.game_data, f, ensure_ascii=False, indent=2)
    
    def _create_default_game_data(self):
        """ÂàõÂª∫ÈªòËÆ§Ê∏∏ÊàèÊï∞ÊçÆ"""
        return {
            "‰Ω†ÁîªÊàëÁåú": {
                "words": [
                    "ËãπÊûú", "Ê±ΩËΩ¶", "ÊàøÂ≠ê", "Áå´Âí™", "Â§™Èò≥", "‰π¶Á±ç", "ÊâãÊú∫", "Ëä±Êúµ",
                    "È£ûÊú∫", "Ëù¥Ëù∂", "Èõ®‰ºû", "ÁúºÈïú", "Èü≥‰πê", "Ê∏∏Ê≥≥", "Ë∑≥Ëàû", "ÁîªÁîª",
                    "ÁîµËÑë", "ÂíñÂï°", "ËõãÁ≥ï", "Ë∂≥ÁêÉ", "Âêâ‰ªñ", "ÁîµËßÜ", "ÈíüË°®", "ÈûãÂ≠ê"
                ],
                "categories": {
                    "Âä®Áâ©": ["Áå´", "Áãó", "È∏ü", "È±º", "ÂÖîÂ≠ê", "ËÄÅËôé", "Â§ßË±°", "ÁÜäÁå´"],
                    "Ê∞¥Êûú": ["ËãπÊûú", "È¶ôËïâ", "Ê©ôÂ≠ê", "Ëë°ËêÑ", "ËçâËéì", "Ë•øÁìú", "Ê°ÉÂ≠ê"],
                    "‰∫§ÈÄöÂ∑•ÂÖ∑": ["Ê±ΩËΩ¶", "È£ûÊú∫", "ÁÅ´ËΩ¶", "Ëá™Ë°åËΩ¶", "Ëàπ", "Êë©ÊâòËΩ¶"]
                }
            },
            "Áü•ËØÜÈóÆÁ≠î": {
                "categories": {
                    "ÁßëÂ≠¶": [
                        {"question": "Âú∞ÁêÉ‰∏äÊúÄÂ§ßÁöÑÂì∫‰π≥Âä®Áâ©ÊòØ‰ªÄ‰πàÔºü", "answer": "ËìùÈ≤∏", "options": ["ËìùÈ≤∏", "Â§ßË±°", "È≤∏È±º", "Ê≤≥È©¨"]},
                        {"question": "‰∏ÄÂπ¥ÊúâÂ§öÂ∞ëÂ§©Ôºü", "answer": "365Â§©", "options": ["364Â§©", "365Â§©", "366Â§©", "367Â§©"]},
                        {"question": "Â§™Èò≥Á≥ªÊúâÂá†È¢óË°åÊòüÔºü", "answer": "8È¢ó", "options": ["7È¢ó", "8È¢ó", "9È¢ó", "10È¢ó"]}
                    ],
                    "ÂéÜÂè≤": [
                        {"question": "‰∏≠ÂõΩÁöÑÈ¶ñÈÉΩÊòØÂì™ÈáåÔºü", "answer": "Âåó‰∫¨", "options": ["‰∏äÊµ∑", "Âåó‰∫¨", "ÂπøÂ∑û", "Ê∑±Âú≥"]},
                        {"question": "‰∏áÈáåÈïøÂüéÂª∫‰∫éÂì™‰∏™Êúù‰ª£Ôºü", "answer": "Áß¶Êúù", "options": ["Ê±âÊúù", "ÂîêÊúù", "Áß¶Êúù", "ÊòéÊúù"]}
                    ],
                    "ÊñáÂ≠¶": [
                        {"question": "„ÄäÁ∫¢Ê•ºÊ¢¶„ÄãÁöÑ‰ΩúËÄÖÊòØË∞ÅÔºü", "answer": "ÊõπÈõ™Ëäπ", "options": ["ÊõπÈõ™Ëäπ", "ÊñΩËÄêÂ∫µ", "Âê¥ÊâøÊÅ©", "ÁΩóË¥Ø‰∏≠"]},
                        {"question": "ÊùéÁôΩË¢´Áß∞‰∏∫‰ªÄ‰πàÔºü", "answer": "ËØó‰ªô", "options": ["ËØóÂú£", "ËØó‰ªô", "ËØóÈ¨º", "ËØó‰Ωõ"]}
                    ]
                }
            },
            "ÁåúË∞úÊ∏∏Êàè": {
                "riddles": [
                    {"riddle": "ÊúâÊó∂ÂúÜÔºåÊúâÊó∂ÂºØÔºåÊúâÊó∂‰∫ÆÔºåÊúâÊó∂Êöó„ÄÇËøúÁúãÂÉè‰∏™ÁôΩÁéâÁõòÔºåËøëÁúã‰ªÄ‰πàÈÉΩ‰∏çËßÅ„ÄÇ", "answer": "Êúà‰∫Æ"},
                    {"riddle": "ÂçÉÊù°Á∫øÔºå‰∏áÊù°Á∫øÔºåÊéâÂú®Ê∞¥ÈáåÁúã‰∏çËßÅ„ÄÇ", "answer": "Èõ®"},
                    {"riddle": "Á∫¢Á∫¢ËÑ∏ÔºåÂúÜÂèàÂúÜÔºå‰∫≤‰∏ÄÂè£ÔºåËÑÜÂèàÁîú„ÄÇ", "answer": "ËãπÊûú"},
                    {"riddle": "Ë∫´Á©øÁªøË°£Ë£≥ÔºåËÇöÈáåÊ∞¥Ê±™Ê±™ÔºåÁîüÁöÑÂ≠êÂÑøÂ§öÔºå‰∏™‰∏™ÈªëËÑ∏ËÜõ„ÄÇ", "answer": "Ë•øÁìú"}
                ]
            },
            "ÊñáÂ≠óÊ∏∏Êàè": {
                "word_chains": {
                    "Âä®Áâ©": ["Áå´", "Áãó", "È∏ü", "È±º", "ÁÜä", "Ëôé", "ÂÖî", "È©¨"],
                    "È¢úËâ≤": ["Á∫¢", "Ê©ô", "ÈªÑ", "Áªø", "Ëìù", "Á¥´", "Èªë", "ÁôΩ"],
                    "È£üÁâ©": ["Á±≥", "Èù¢", "ËÇâ", "Ëèú", "Êûú", "Ëå∂", "ÈÖí", "Ê∞¥"]
                },
                "ÊàêËØ≠": [
                    "‰∏ÄÂøÉ‰∏ÄÊÑè", "‰∏âÂøÉ‰∫åÊÑè", "ÂõõÈù¢ÂÖ´Êñπ", "‰∫îÂÖâÂçÅËâ≤", "ÂÖ≠Á•ûÊó†‰∏ª",
                    "‰∏É‰∏äÂÖ´‰∏ã", "‰πùÁâõ‰∏ÄÊØõ", "ÂçÅÂÖ®ÂçÅÁæé", "ÁôæÂèëÁôæ‰∏≠", "ÂçÉÈáåËø¢Ëø¢"
                ]
            }
        }
    
    def initialize_game_rules(self):
        """ÂàùÂßãÂåñÊ∏∏ÊàèËßÑÂàô"""
        self.game_rules = {
            GameType.GUESS_DRAW: {
                "max_players": 2,
                "turn_time_limit": 180,  # 3ÂàÜÈíü
                "max_rounds": 5,
                "description": "‰∏Ä‰∏™‰∫∫ÁîªÁîªÔºåÂè¶‰∏Ä‰∏™‰∫∫ÁåúËØçËØ≠"
            },
            GameType.TRIVIA: {
                "max_players": 2,
                "turn_time_limit": 30,   # 30Áßí
                "max_rounds": 10,
                "description": "ÂõûÁ≠îÂêÑÁßçÁü•ËØÜÈóÆÈ¢ò"
            },
            GameType.RIDDLE: {
                "max_players": 2,
                "turn_time_limit": 60,   # 1ÂàÜÈíü
                "max_rounds": 5,
                "description": "ÁåúË∞úËØ≠Ê∏∏Êàè"
            },
            GameType.WORD_GAME: {
                "max_players": 2,
                "turn_time_limit": 45,   # 45Áßí
                "max_rounds": 10,
                "description": "ÊñáÂ≠óÊé•ÈæôÊàñÊàêËØ≠Ê∏∏Êàè"
            },
            GameType.STORY_GAME: {
                "max_players": 2,
                "turn_time_limit": 120,  # 2ÂàÜÈíü
                "max_rounds": 6,
                "description": "ËΩÆÊµÅÊé•ÊïÖ‰∫ã"
            },
            GameType.ROCK_PAPER_SCISSORS: {
                "max_players": 2,
                "turn_time_limit": 10,   # 10Áßí
                "max_rounds": 5,
                "description": "ÁªèÂÖ∏Áü≥Â§¥Ââ™ÂàÄÂ∏ÉÊ∏∏Êàè"
            },
            GameType.NUMBER_GUESS: {
                "max_players": 2,
                "turn_time_limit": 60,   # 1ÂàÜÈíü
                "max_rounds": 10,
                "description": "ÁåúÊï∞Â≠óÊ∏∏Êàè"
            }
        }
    
    def start_game(self, game_type: GameType, player_name: str = "Áî®Êà∑") -> str:
        """ÂºÄÂßãÊ∏∏Êàè"""
        session_id = f"game_{int(time.time())}"
        
        # ÂàõÂª∫Ê∏∏Êàè‰ºöËØù
        session = GameSession(
            session_id=session_id,
            game_type=game_type,
            state=GameState.IN_PROGRESS,
            start_time=time.time(),
            end_time=None,
            players=[player_name, "ËÇ•Áâõ"],
            current_turn=0,
            game_data={
                "round": 1,
                "max_rounds": self.game_rules[game_type]["max_rounds"],
                "current_question": None,
                "correct_answer": None,
                "hints_used": 0
            },
            score={player_name: 0, "ËÇ•Áâõ": 0},
            moves_history=[]
        )
        
        self.active_sessions[session_id] = session
        
        # ÁîüÊàêÊ∏∏ÊàèÂºÄÂßãÊ∂àÊÅØ
        start_message = self._generate_game_start_message(session)
        
        print(f"üéÆ ÂºÄÂßãÊ∏∏Êàè: {game_type.value}")
        return start_message
    
    def _generate_game_start_message(self, session: GameSession) -> str:
        """ÁîüÊàêÊ∏∏ÊàèÂºÄÂßãÊ∂àÊÅØ"""
        game_type = session.game_type
        rules = self.game_rules[game_type]
        
        message = f"üéÆ {game_type.value} ÂºÄÂßãÔºÅ\n\n"
        message += f"üìã Ê∏∏ÊàèËßÑÂàô: {rules['description']}\n"
        message += f"üîÑ ÊÄªÂÖ± {session.game_data['max_rounds']} ËΩÆ\n"
        message += f"‚è±Ô∏è ÊØèËΩÆÊó∂Èó¥ÈôêÂà∂: {rules['turn_time_limit']} Áßí\n\n"
        
        # ÂºÄÂßãÁ¨¨‰∏ÄËΩÆ
        first_round = self._start_new_round(session)
        message += first_round
        
        return message
    
    def _start_new_round(self, session: GameSession) -> str:
        """ÂºÄÂßãÊñ∞‰∏ÄËΩÆÊ∏∏Êàè"""
        game_type = session.game_type
        round_num = session.game_data["round"]
        
        if game_type == GameType.TRIVIA:
            return self._start_trivia_round(session)
        elif game_type == GameType.RIDDLE:
            return self._start_riddle_round(session)
        elif game_type == GameType.GUESS_DRAW:
            return self._start_guess_draw_round(session)
        elif game_type == GameType.WORD_GAME:
            return self._start_word_game_round(session)
        elif game_type == GameType.STORY_GAME:
            return self._start_story_round(session)
        elif game_type == GameType.ROCK_PAPER_SCISSORS:
            return self._start_rps_round(session)
        elif game_type == GameType.NUMBER_GUESS:
            return self._start_number_guess_round(session)
        else:
            return f"Á¨¨ {round_num} ËΩÆÂºÄÂßãÔºÅ"
    
    def _start_trivia_round(self, session: GameSession) -> str:
        """ÂºÄÂßãÁü•ËØÜÈóÆÁ≠îËΩÆ"""
        trivia_data = self.game_data.get("Áü•ËØÜÈóÆÁ≠î", {})
        categories = trivia_data.get("categories", {})
        
        if not categories:
            return "‚ùå Ê≤°ÊúâÂèØÁî®ÁöÑÈóÆÁ≠îÈ¢òÁõÆ„ÄÇ"
        
        # ÈöèÊú∫ÈÄâÊã©ÂàÜÁ±ªÂíåÈóÆÈ¢ò
        category = random.choice(list(categories.keys()))
        questions = categories[category]
        question_data = random.choice(questions)
        
        session.game_data["current_question"] = question_data
        session.game_data["category"] = category
        
        message = f"üß† Á¨¨ {session.game_data['round']} ËΩÆ - {category} ÈóÆÈ¢ò:\n\n"
        message += f"‚ùì {question_data['question']}\n\n"
        
        if "options" in question_data:
            for i, option in enumerate(question_data["options"], 1):
                message += f"{i}. {option}\n"
            message += "\nËØ∑ÈÄâÊã©Á≠îÊ°àÁºñÂè∑ÊàñÁõ¥Êé•ËØ¥Âá∫Á≠îÊ°àÔºÅ"
        else:
            message += "ËØ∑ËØ¥Âá∫‰Ω†ÁöÑÁ≠îÊ°àÔºÅ"
        
        return message
    
    def _start_riddle_round(self, session: GameSession) -> str:
        """ÂºÄÂßãÁåúË∞úËΩÆ"""
        riddle_data = self.game_data.get("ÁåúË∞úÊ∏∏Êàè", {})
        riddles = riddle_data.get("riddles", [])
        
        if not riddles:
            return "‚ùå Ê≤°ÊúâÂèØÁî®ÁöÑË∞úËØ≠„ÄÇ"
        
        riddle = random.choice(riddles)
        session.game_data["current_question"] = riddle
        
        message = f"ü§î Á¨¨ {session.game_data['round']} ËΩÆ - ÁåúË∞úËØ≠:\n\n"
        message += f"üîç {riddle['riddle']}\n\n"
        message += "ËØ∑ËØ¥Âá∫‰Ω†ÁöÑÁ≠îÊ°àÔºÅ"
        
        return message
    
    def _start_guess_draw_round(self, session: GameSession) -> str:
        """ÂºÄÂßã‰Ω†ÁîªÊàëÁåúËΩÆ"""
        draw_data = self.game_data.get("‰Ω†ÁîªÊàëÁåú", {})
        words = draw_data.get("words", [])
        
        if not words:
            return "‚ùå Ê≤°ÊúâÂèØÁî®ÁöÑËØçËØ≠„ÄÇ"
        
        word = random.choice(words)
        session.game_data["current_word"] = word
        
        # Á°ÆÂÆöË∞ÅÁîªË∞ÅÁåú
        current_player = session.players[session.current_turn % 2]
        
        if current_player == "ËÇ•Áâõ":
            # AIÁîªÔºåÁî®Êà∑Áåú
            message = f"üé® Á¨¨ {session.game_data['round']} ËΩÆ:\n\n"
            message += "ÊàëÊù•ÁîªÔºå‰Ω†Êù•ÁåúÔºÅ\n"
            message += "üñºÔ∏è *ÊàëÊ≠£Âú®Áîª‰∏Ä‰∏™‰∏úË•ø...*\n\n"
            message += f"ÊèêÁ§∫ÔºöËøôÊòØ‰∏Ä‰∏™{len(word)}Â≠óÁöÑËØçËØ≠\n"
            message += "‰Ω†ËßâÂæóÊàëÁîªÁöÑÊòØ‰ªÄ‰πàÔºü"
        else:
            # Áî®Êà∑ÁîªÔºåAIÁåú
            message = f"üé® Á¨¨ {session.game_data['round']} ËΩÆ:\n\n"
            message += f"ËØ∑‰Ω†Áîª: **{word}**\n\n"
            message += "ÁîªÂ•ΩÂêéÂëäËØâÊàëÔºåÊàëÊù•ÁåúÔºÅ"
        
        return message
    
    def _start_word_game_round(self, session: GameSession) -> str:
        """ÂºÄÂßãÊñáÂ≠óÊ∏∏ÊàèËΩÆ"""
        word_data = self.game_data.get("ÊñáÂ≠óÊ∏∏Êàè", {})
        
        # ÈöèÊú∫ÈÄâÊã©Ê∏∏ÊàèÁ±ªÂûã
        game_modes = ["word_chain", "idiom"]
        mode = random.choice(game_modes)
        
        if mode == "word_chain":
            # ËØçËØ≠Êé•Èæô
            categories = word_data.get("word_chains", {})
            category = random.choice(list(categories.keys()))
            words = categories[category]
            start_word = random.choice(words)
            
            session.game_data["mode"] = "word_chain"
            session.game_data["category"] = category
            session.game_data["last_word"] = start_word
            
            message = f"üî§ Á¨¨ {session.game_data['round']} ËΩÆ - ËØçËØ≠Êé•Èæô ({category}):\n\n"
            message += f"Ëµ∑ÂßãËØç: **{start_word}**\n\n"
            message += "ËØ∑ËØ¥‰∏Ä‰∏™Áõ∏ÂÖ≥ÁöÑËØçËØ≠ÔºÅ"
        else:
            # ÊàêËØ≠Êé•Èæô
            idioms = word_data.get("ÊàêËØ≠", [])
            start_idiom = random.choice(idioms)
            
            session.game_data["mode"] = "idiom"
            session.game_data["last_word"] = start_idiom
            
            message = f"üÄÑ Á¨¨ {session.game_data['round']} ËΩÆ - ÊàêËØ≠Êé•Èæô:\n\n"
            message += f"Ëµ∑ÂßãÊàêËØ≠: **{start_idiom}**\n\n"
            message += "ËØ∑ËØ¥‰∏Ä‰∏™ÊàêËØ≠ÔºÅ"
        
        return message
    
    def _start_story_round(self, session: GameSession) -> str:
        """ÂºÄÂßãÊïÖ‰∫ãÊé•ÈæôËΩÆ"""
        # ÊïÖ‰∫ãÂºÄÂ§¥
        story_starts = [
            "‰ªéÂâçÊúâ‰∏Ä‰∏™ÂãáÊï¢ÁöÑÂ∞èÂ•≥Â≠©ÔºåÂ•π‰ΩèÂú®Ê£ÆÊûóËæπÁöÑÂ∞èÂ±ãÈáå...",
            "Âú®ÈÅ•ËøúÁöÑÊòüÁêÉ‰∏äÔºåÊúâ‰∏Ä‰∏™Á•ûÂ•áÁöÑÂüéÂ∏Ç...",
            "‰∏Ä‰∏™‰∏ãÈõ®Â§©ÔºåÂ∞èÊòéÂú®Ë∑Ø‰∏äÊç°Âà∞‰∫Ü‰∏ÄÊú¨Â•áÊÄ™ÁöÑ‰π¶...",
            "Êµ∑ËæπÁöÑÁÅØÂ°îÈáå‰ΩèÁùÄ‰∏Ä‰ΩçËÄÅËàπÈïø...",
            "È≠îÊ≥ïÂ≠¶Èô¢ÁöÑÊñ∞Â≠¶ÊúüÂºÄÂßã‰∫ÜÔºåËâæÁ±≥ÂèëÁé∞Ëá™Â∑±ÊúâÁâπÊÆäËÉΩÂäõ..."
        ]
        
        if session.game_data["round"] == 1:
            # Á¨¨‰∏ÄËΩÆÔºåAIÂºÄÂßãÊïÖ‰∫ã
            start = random.choice(story_starts)
            session.game_data["story"] = start
            
            message = f"üìñ ÊïÖ‰∫ãÊé•Èæô Á¨¨ {session.game_data['round']} ËΩÆ:\n\n"
            message += f"{start}\n\n"
            message += "ËØ∑ÁªßÁª≠Ëøô‰∏™ÊïÖ‰∫ãÔºÅ"
        else:
            # ÁªßÁª≠‰πãÂâçÁöÑÊïÖ‰∫ã
            message = f"üìñ ÊïÖ‰∫ãÊé•Èæô Á¨¨ {session.game_data['round']} ËΩÆ:\n\n"
            message += f"ÊïÖ‰∫ãÂà∞ÁõÆÂâç‰∏∫Ê≠¢:\n{session.game_data.get('story', '')}\n\n"
            message += "ËØ∑ÁªßÁª≠ÊïÖ‰∫ãÔºÅ"
        
        return message
    
    def _start_rps_round(self, session: GameSession) -> str:
        """ÂºÄÂßãÁü≥Â§¥Ââ™ÂàÄÂ∏ÉËΩÆ"""
        message = f"‚úÇÔ∏è Á¨¨ {session.game_data['round']} ËΩÆ - Áü≥Â§¥Ââ™ÂàÄÂ∏É:\n\n"
        message += "ËØ∑Âá∫ÊãõÔºöÁü≥Â§¥ üóø / Ââ™ÂàÄ ‚úÇÔ∏è / Â∏É üìÑ"
        
        return message
    
    def _start_number_guess_round(self, session: GameSession) -> str:
        """ÂºÄÂßãÁåúÊï∞Â≠óËΩÆ"""
        # ÁîüÊàêÈöèÊú∫Êï∞Â≠ó
        target_number = random.randint(1, 100)
        session.game_data["target_number"] = target_number
        session.game_data["guesses"] = 0
        session.game_data["max_guesses"] = 7
        
        message = f"üî¢ Á¨¨ {session.game_data['round']} ËΩÆ - ÁåúÊï∞Â≠ó:\n\n"
        message += "ÊàëÊÉ≥‰∫Ü‰∏Ä‰∏™1Âà∞100‰πãÈó¥ÁöÑÊï∞Â≠óÔºå‰Ω†Êù•ÁåúÔºÅ\n"
        message += f"‰Ω†Êúâ {session.game_data['max_guesses']} Ê¨°Êú∫‰ºö„ÄÇ\n\n"
        message += "ËØ∑ËØ¥Âá∫‰Ω†ÁöÑÁ¨¨‰∏Ä‰∏™ÁåúÊµãÔºÅ"
        
        return message
    
    def process_player_move(self, session_id: str, player_input: str) -> str:
        """Â§ÑÁêÜÁé©ÂÆ∂ËæìÂÖ•"""
        if session_id not in self.active_sessions:
            return "‚ùå Êâæ‰∏çÂà∞ÂØπÂ∫îÁöÑÊ∏∏Êàè‰ºöËØù„ÄÇ"
        
        session = self.active_sessions[session_id]
        if session.state != GameState.IN_PROGRESS:
            return "‚ùå Ê∏∏ÊàèÊú™Âú®ËøõË°å‰∏≠„ÄÇ"
        
        # ËÆ∞ÂΩïÁé©ÂÆ∂ÁßªÂä®
        move = {
            "player": session.players[session.current_turn % 2],
            "input": player_input,
            "timestamp": time.time(),
            "round": session.game_data["round"]
        }
        session.moves_history.append(move)
        
        # Ê†πÊçÆÊ∏∏ÊàèÁ±ªÂûãÂ§ÑÁêÜËæìÂÖ•
        game_type = session.game_type
        
        if game_type == GameType.TRIVIA:
            result = self._process_trivia_answer(session, player_input)
        elif game_type == GameType.RIDDLE:
            result = self._process_riddle_answer(session, player_input)
        elif game_type == GameType.GUESS_DRAW:
            result = self._process_guess_draw_move(session, player_input)
        elif game_type == GameType.WORD_GAME:
            result = self._process_word_game_move(session, player_input)
        elif game_type == GameType.STORY_GAME:
            result = self._process_story_move(session, player_input)
        elif game_type == GameType.ROCK_PAPER_SCISSORS:
            result = self._process_rps_move(session, player_input)
        elif game_type == GameType.NUMBER_GUESS:
            result = self._process_number_guess_move(session, player_input)
        else:
            result = "Êú™Áü•Ê∏∏ÊàèÁ±ªÂûã„ÄÇ"
        
        # Ê£ÄÊü•Ê∏∏ÊàèÊòØÂê¶ÁªìÊùü
        if session.game_data["round"] > session.game_data["max_rounds"]:
            end_result = self._end_game(session)
            result += f"\n\n{end_result}"
        
        return result
    
    def _process_trivia_answer(self, session: GameSession, answer: str) -> str:
        """Â§ÑÁêÜÁü•ËØÜÈóÆÁ≠îÁ≠îÊ°à"""
        question_data = session.game_data["current_question"]
        correct_answer = question_data["answer"]
        
        # Ê£ÄÊü•Á≠îÊ°à
        is_correct = False
        answer_lower = answer.lower().strip()
        correct_lower = correct_answer.lower()
        
        # ÊîØÊåÅÈÄâÈ°πÁºñÂè∑ÂõûÁ≠î
        if answer.isdigit() and "options" in question_data:
            option_index = int(answer) - 1
            if 0 <= option_index < len(question_data["options"]):
                is_correct = question_data["options"][option_index] == correct_answer
        else:
            # Áõ¥Êé•ÊñáÊú¨ÂåπÈÖç
            is_correct = answer_lower in correct_lower or correct_lower in answer_lower
        
        result = ""
        if is_correct:
            session.score[session.players[0]] += 1
            result = f"üéâ Ê≠£Á°ÆÔºÅÁ≠îÊ°àÊòØÔºö{correct_answer}\n"
            result += f"ÂæóÂàÜÔºö{session.score[session.players[0]]} ÂàÜ"
        else:
            result = f"‚ùå ‰∏çÊ≠£Á°Æ„ÄÇÊ≠£Á°ÆÁ≠îÊ°àÊòØÔºö{correct_answer}"
        
        # ËøõÂÖ•‰∏ã‰∏ÄËΩÆ
        session.game_data["round"] += 1
        session.current_turn += 1
        
        if session.game_data["round"] <= session.game_data["max_rounds"]:
            result += f"\n\n{self._start_new_round(session)}"
        
        return result
    
    def _process_riddle_answer(self, session: GameSession, answer: str) -> str:
        """Â§ÑÁêÜÁåúË∞úÁ≠îÊ°à"""
        riddle_data = session.game_data["current_question"]
        correct_answer = riddle_data["answer"]
        
        # Ê£ÄÊü•Á≠îÊ°à
        is_correct = answer.strip() == correct_answer or correct_answer in answer
        
        result = ""
        if is_correct:
            session.score[session.players[0]] += 1
            result = f"üéâ Ê≠£Á°ÆÔºÅÁ≠îÊ°àÊòØÔºö{correct_answer}\n"
            result += f"ÂæóÂàÜÔºö{session.score[session.players[0]]} ÂàÜ"
        else:
            # ÁªôÊèêÁ§∫
            if session.game_data["hints_used"] < 2:
                session.game_data["hints_used"] += 1
                hints = self._generate_riddle_hint(correct_answer, session.game_data["hints_used"])
                result = f"‚ùå ‰∏çÂØπÂì¶„ÄÇÊèêÁ§∫ {session.game_data['hints_used']}: {hints}\n\nÂÜçÁåú‰∏ÄÊ¨°ÔºÅ"
                return result
            else:
                result = f"‚ùå ‰∏çÊ≠£Á°Æ„ÄÇÊ≠£Á°ÆÁ≠îÊ°àÊòØÔºö{correct_answer}"
        
        # ËøõÂÖ•‰∏ã‰∏ÄËΩÆ
        session.game_data["round"] += 1
        session.current_turn += 1
        session.game_data["hints_used"] = 0
        
        if session.game_data["round"] <= session.game_data["max_rounds"]:
            result += f"\n\n{self._start_new_round(session)}"
        
        return result
    
    def _generate_riddle_hint(self, answer: str, hint_level: int) -> str:
        """ÁîüÊàêË∞úËØ≠ÊèêÁ§∫"""
        if hint_level == 1:
            return f"Á≠îÊ°àÊúâ {len(answer)} ‰∏™Â≠ó"
        elif hint_level == 2:
            if len(answer) > 1:
                return f"Á≠îÊ°àÁöÑÁ¨¨‰∏Ä‰∏™Â≠óÊòØÔºö{answer[0]}"
            else:
                return f"Á≠îÊ°àÊòØÔºö{answer[0]}"
        return ""
    
    def _process_guess_draw_move(self, session: GameSession, move: str) -> str:
        """Â§ÑÁêÜ‰Ω†ÁîªÊàëÁåúÁßªÂä®"""
        current_word = session.game_data["current_word"]
        current_player = session.players[session.current_turn % 2]
        
        if current_player == session.players[0]:  # Áî®Êà∑ÂõûÂêà
            # Áî®Êà∑ÁåúËØç
            if move.strip() == current_word or current_word in move:
                session.score[session.players[0]] += 1
                result = f"üéâ ÁåúÂØπ‰∫ÜÔºÅÊòØ {current_word}ÔºÅ\n"
                result += f"ÂæóÂàÜÔºö{session.score[session.players[0]]} ÂàÜ"
            else:
                result = f"‚ùå ‰∏çÂØπÂì¶ÔºåÂÜçÊÉ≥ÊÉ≥ÔºÅ"
                if session.game_data.get("hints_used", 0) < 1:
                    session.game_data["hints_used"] = 1
                    result += f"\nüí° ÊèêÁ§∫ÔºöËøô‰∏™ËØçËØ≠Âíå{current_word[0]}ÊúâÂÖ≥"
                    return result
                else:
                    result += f"\nÊ≠£Á°ÆÁ≠îÊ°àÊòØÔºö{current_word}"
        else:  # AIÂõûÂêà
            # AIÁåúÁî®Êà∑ÁöÑÁîª
            result = f"ü§î ËÆ©ÊàëÁåúÁåú...ËøôÊòØ {move} ÂêóÔºü"
            # ÁÆÄÂçïÊ®°ÊãüAIÁåúÊµã
            if random.random() > 0.3:  # 70%Ê≠£Á°ÆÁéá
                session.score["ËÇ•Áâõ"] += 1
                result += f"\nüéâ ÊàëÁåúÂØπ‰∫ÜÔºÅÂæóÂàÜÔºö{session.score['ËÇ•Áâõ']} ÂàÜ"
            else:
                result += f"\n‚ùå ÊàëÁåúÈîô‰∫ÜÔºÅÊ≠£Á°ÆÁ≠îÊ°àÊòØ‰ªÄ‰πàÔºü"
        
        # ËøõÂÖ•‰∏ã‰∏ÄËΩÆ
        session.game_data["round"] += 1
        session.current_turn += 1
        session.game_data["hints_used"] = 0
        
        if session.game_data["round"] <= session.game_data["max_rounds"]:
            result += f"\n\n{self._start_new_round(session)}"
        
        return result
    
    def _process_rps_move(self, session: GameSession, move: str) -> str:
        """Â§ÑÁêÜÁü≥Â§¥Ââ™ÂàÄÂ∏ÉÁßªÂä®"""
        move_map = {
            "Áü≥Â§¥": "rock", "üóø": "rock",
            "Ââ™ÂàÄ": "scissors", "‚úÇÔ∏è": "scissors", 
            "Â∏É": "paper", "üìÑ": "paper"
        }
        
        player_move = None
        for key, value in move_map.items():
            if key in move:
                player_move = value
                break
        
        if not player_move:
            return "‚ùå Êó†ÊïàÁöÑËæìÂÖ•„ÄÇËØ∑ËØ¥ÔºöÁü≥Â§¥„ÄÅÂâ™ÂàÄÊàñÂ∏É"
        
        # AIÈöèÊú∫Âá∫Êãõ
        ai_moves = ["rock", "scissors", "paper"]
        ai_move = random.choice(ai_moves)
        
        # Âà§Êñ≠ËÉúË¥ü
        result = ""
        if player_move == ai_move:
            result = "ü§ù Âπ≥Â±ÄÔºÅ"
        elif (player_move == "rock" and ai_move == "scissors") or \
             (player_move == "scissors" and ai_move == "paper") or \
             (player_move == "paper" and ai_move == "rock"):
            session.score[session.players[0]] += 1
            result = f"üéâ ‰Ω†Ëµ¢‰∫ÜÔºÅ"
        else:
            session.score["ËÇ•Áâõ"] += 1
            result = f"üòÑ ÊàëËµ¢‰∫ÜÔºÅ"
        
        # ÊòæÁ§∫ÂèåÊñπÂá∫Êãõ
        move_display = {
            "rock": "Áü≥Â§¥üóø", "scissors": "Ââ™ÂàÄ‚úÇÔ∏è", "paper": "Â∏ÉüìÑ"
        }
        result += f"\n‰Ω†Ôºö{move_display[player_move]} vs ÊàëÔºö{move_display[ai_move]}"
        result += f"\nÂΩìÂâçÊØîÂàÜ - ‰Ω†Ôºö{session.score[session.players[0]]} | ÊàëÔºö{session.score['ËÇ•Áâõ']}"
        
        # ËøõÂÖ•‰∏ã‰∏ÄËΩÆ
        session.game_data["round"] += 1
        session.current_turn += 1
        
        if session.game_data["round"] <= session.game_data["max_rounds"]:
            result += f"\n\n{self._start_new_round(session)}"
        
        return result
    
    def _process_number_guess_move(self, session: GameSession, guess: str) -> str:
        """Â§ÑÁêÜÁåúÊï∞Â≠óÁßªÂä®"""
        try:
            guess_num = int(guess.strip())
        except ValueError:
            return "‚ùå ËØ∑ËæìÂÖ•‰∏Ä‰∏™Êï∞Â≠óÔºÅ"
        
        target = session.game_data["target_number"]
        session.game_data["guesses"] += 1
        guesses_left = session.game_data["max_guesses"] - session.game_data["guesses"]
        
        if guess_num == target:
            session.score[session.players[0]] += 1
            result = f"üéâ ÊÅ≠ÂñúÔºÅ‰Ω†ÁåúÂØπ‰∫ÜÔºÅÊï∞Â≠óÂ∞±ÊòØ {target}ÔºÅ\n"
            result += f"Áî®‰∫Ü {session.game_data['guesses']} Ê¨°ÁåúÊµã„ÄÇ"
            
            # ËøõÂÖ•‰∏ã‰∏ÄËΩÆ
            session.game_data["round"] += 1
            session.current_turn += 1
            
            if session.game_data["round"] <= session.game_data["max_rounds"]:
                result += f"\n\n{self._start_new_round(session)}"
            
            return result
        
        elif guesses_left <= 0:
            result = f"üòÖ Êú∫‰ºöÁî®ÂÆå‰∫ÜÔºÅÊ≠£Á°ÆÊï∞Â≠óÊòØ {target}„ÄÇ"
            
            # ËøõÂÖ•‰∏ã‰∏ÄËΩÆ
            session.game_data["round"] += 1
            session.current_turn += 1
            
            if session.game_data["round"] <= session.game_data["max_rounds"]:
                result += f"\n\n{self._start_new_round(session)}"
            
            return result
        
        else:
            if guess_num < target:
                hint = "Â§™Â∞è‰∫ÜÔºÅ"
            else:
                hint = "Â§™Â§ß‰∫ÜÔºÅ"
            
            result = f"{hint} ËøòÊúâ {guesses_left} Ê¨°Êú∫‰ºö„ÄÇ"
            return result
    
    def _process_word_game_move(self, session: GameSession, word: str) -> str:
        """Â§ÑÁêÜÊñáÂ≠óÊ∏∏ÊàèÁßªÂä®"""
        mode = session.game_data.get("mode", "word_chain")
        
        if mode == "word_chain":
            return self._process_word_chain(session, word)
        else:
            return self._process_idiom_chain(session, word)
    
    def _process_word_chain(self, session: GameSession, word: str) -> str:
        """Â§ÑÁêÜËØçËØ≠Êé•Èæô"""
        # ÁÆÄÂçïÈ™åËØÅÔºàÂÆûÈôÖÂèØ‰ª•Êõ¥Â§çÊùÇÔºâ
        category = session.game_data["category"]
        word_data = self.game_data.get("ÊñáÂ≠óÊ∏∏Êàè", {})
        valid_words = word_data.get("word_chains", {}).get(category, [])
        
        is_valid = word.strip() in valid_words or len(word.strip()) > 0
        
        if is_valid:
            session.score[session.players[0]] += 1
            
            # AIÊé•ËØç
            ai_word = random.choice(valid_words)
            session.game_data["last_word"] = ai_word
            
            result = f"‚úÖ ÂæàÂ•ΩÔºÅ‰Ω†ËØ¥‰∫ÜÔºö{word}\n"
            result += f"ÊàëÊù•Êé•Ôºö{ai_word}\n"
            result += f"ÂæóÂàÜÔºö{session.score[session.players[0]]} ÂàÜ"
        else:
            result = f"‚ùå Ëøô‰∏™ËØç‰∏çÂ§™ÂêàÈÄÇÔºåÊç¢‰∏Ä‰∏™ËØïËØïÔºÅ"
            return result
        
        # ËøõÂÖ•‰∏ã‰∏ÄËΩÆ
        session.game_data["round"] += 1
        session.current_turn += 1
        
        if session.game_data["round"] <= session.game_data["max_rounds"]:
            result += f"\n\nËØ∑Êé•Ôºö{ai_word}"
        
        return result
    
    def _process_story_move(self, session: GameSession, story_part: str) -> str:
        """Â§ÑÁêÜÊïÖ‰∫ãÊé•ÈæôÁßªÂä®"""
        # Ê∑ªÂä†Áé©ÂÆ∂ÁöÑÊïÖ‰∫ãÈÉ®ÂàÜ
        current_story = session.game_data.get("story", "")
        updated_story = current_story + " " + story_part.strip()
        session.game_data["story"] = updated_story
        
        # AIÁªßÁª≠ÊïÖ‰∫ã
        ai_continuations = [
            "Á™ÅÁÑ∂Ôºå‰∏ÄÈòµÁ•ûÁßòÁöÑÈ£éÂêπËøá...",
            "ËøôÊó∂ÂÄôÔºåËøúÂ§Ñ‰º†Êù•‰∫ÜÂ•áÊÄ™ÁöÑÂ£∞Èü≥...",
            "Â∞±Âú®Ëøô‰∏™Êó∂ÂÄôÔºåÊÑèÊÉ≥‰∏çÂà∞ÁöÑ‰∫ãÊÉÖÂèëÁîü‰∫Ü...",
            "ÁÑ∂ËÄåÔºå‰∫ãÊÉÖÂπ∂Ê≤°ÊúâËøô‰πàÁÆÄÂçï...",
            "Êé•‰∏ãÊù•ÂèëÁîüÁöÑ‰∫ãÊÉÖËÆ©ÊâÄÊúâ‰∫∫ÈÉΩÊÑüÂà∞ÊÉäËÆ∂..."
        ]
        
        ai_part = random.choice(ai_continuations)
        updated_story += " " + ai_part
        session.game_data["story"] = updated_story
        
        result = f"üìù ‰Ω†ÁöÑÁª≠ÂÜôÂæàÁ≤æÂΩ©ÔºÅ\n\n"
        result += f"ÊàëÊù•ÁªßÁª≠Ôºö{ai_part}\n\n"
        
        # ËøõÂÖ•‰∏ã‰∏ÄËΩÆ
        session.game_data["round"] += 1
        session.current_turn += 1
        
        if session.game_data["round"] <= session.game_data["max_rounds"]:
            result += "ËØ∑ÁªßÁª≠Ëøô‰∏™ÊïÖ‰∫ãÔºÅ"
        
        return result
    
    def _end_game(self, session: GameSession) -> str:
        """ÁªìÊùüÊ∏∏Êàè"""
        session.state = GameState.COMPLETED
        session.end_time = time.time()
        
        # ÁîüÊàêÊ∏∏ÊàèÁªìÊûú
        duration = session.end_time - session.start_time
        user_score = session.score[session.players[0]]
        ai_score = session.score.get("ËÇ•Áâõ", 0)
        
        result = f"üèÅ Ê∏∏ÊàèÁªìÊùüÔºÅ\n\n"
        result += f"üìä ÊúÄÁªàÂæóÂàÜ:\n"
        result += f"   ‰Ω†: {user_score} ÂàÜ\n"
        result += f"   Êàë: {ai_score} ÂàÜ\n\n"
        
        if user_score > ai_score:
            result += "üéâ ÊÅ≠Âñú‰Ω†Ëé∑ËÉúÔºÅ"
        elif user_score < ai_score:
            result += "üòÑ ËøôÊ¨°ÊàëËµ¢‰∫ÜÔºÅ"
        else:
            result += "ü§ù Âπ≥Â±ÄÔºÅÊâìÂæó‰∏çÈîôÔºÅ"
        
        result += f"\n\n‚è±Ô∏è Ê∏∏ÊàèÊó∂Èïø: {duration/60:.1f} ÂàÜÈíü"
        result += f"\nüéÆ Ê∏∏ÊàèÁ±ªÂûã: {session.game_type.value}"
        
        # ÁßªÈô§‰ºöËØù
        if session.session_id in self.active_sessions:
            del self.active_sessions[session.session_id]
        
        return result
    
    def get_available_games(self) -> str:
        """Ëé∑ÂèñÂèØÁî®Ê∏∏ÊàèÂàóË°®"""
        games_list = "üéÆ ÂèØÁî®Ê∏∏Êàè:\n\n"
        
        for game_type in GameType:
            rule = self.game_rules.get(game_type, {})
            games_list += f"**{game_type.value}**\n"
            games_list += f"   {rule.get('description', 'ÊöÇÊó†ÊèèËø∞')}\n"
            games_list += f"   ÊúÄÂ§ö {rule.get('max_rounds', 'N/A')} ËΩÆ\n\n"
        
        games_list += "üí° ËØ¥ 'ÂºÄÂßã[Ê∏∏ÊàèÂêç]' Êù•ÂºÄÂßãÊ∏∏ÊàèÔºÅ"
        return games_list
    
    def get_game_status(self) -> str:
        """Ëé∑ÂèñÊ∏∏ÊàèÁä∂ÊÄÅ"""
        active_count = len(self.active_sessions)
        
        if active_count == 0:
            return "üéÆ ÂΩìÂâçÊ≤°ÊúâËøõË°å‰∏≠ÁöÑÊ∏∏Êàè„ÄÇ"
        
        status = f"üéÆ Ê∏∏ÊàèÁä∂ÊÄÅ:\n"
        for session_id, session in self.active_sessions.items():
            duration = time.time() - session.start_time
            status += f"- {session.game_type.value}: Á¨¨{session.game_data['round']}ËΩÆ ({duration/60:.1f}ÂàÜÈíü)\n"
        
        return status

class GameTools:
    """Ê∏∏ÊàèÂ∑•ÂÖ∑Á±ª - Êèê‰æõÁªôAgent‰ΩøÁî®ÁöÑÊ∏∏ÊàèÂäüËÉΩ"""
    
    def __init__(self):
        self.game_system = GameCompanionSystem()
        self.current_session = None
    
    def start_game(self, game_name: str) -> str:
        """ÂºÄÂßãÊ∏∏Êàè"""
        game_map = {
            "‰Ω†ÁîªÊàëÁåú": GameType.GUESS_DRAW,
            "ÁåúÁîª": GameType.GUESS_DRAW,
            "Áü•ËØÜÈóÆÁ≠î": GameType.TRIVIA,
            "ÈóÆÁ≠î": GameType.TRIVIA,
            "ÁåúË∞ú": GameType.RIDDLE,
            "Ë∞úËØ≠": GameType.RIDDLE,
            "ÊñáÂ≠óÊ∏∏Êàè": GameType.WORD_GAME,
            "Êé•Èæô": GameType.WORD_GAME,
            "ÊïÖ‰∫ãÊé•Èæô": GameType.STORY_GAME,
            "Áü≥Â§¥Ââ™ÂàÄÂ∏É": GameType.ROCK_PAPER_SCISSORS,
            "Ââ™ÂàÄÁü≥Â§¥Â∏É": GameType.ROCK_PAPER_SCISSORS,
            "ÁåúÊï∞Â≠ó": GameType.NUMBER_GUESS
        }
        
        game_type = None
        for name, gtype in game_map.items():
            if name in game_name:
                game_type = gtype
                break
        
        if not game_type:
            return f"‚ùå ‰∏çËÆ§ËØÜÁöÑÊ∏∏Êàè: {game_name}\n\n{self.game_system.get_available_games()}"
        
        result = self.game_system.start_game(game_type)
        
        # ËÆ∞ÂΩïÂΩìÂâç‰ºöËØù
        for session_id, session in self.game_system.active_sessions.items():
            if session.game_type == game_type:
                self.current_session = session_id
                break
        
        return result
    
    def play_move(self, move: str) -> str:
        """ËøõË°åÊ∏∏ÊàèÊìç‰Ωú"""
        if not self.current_session:
            return "‚ùå Ê≤°ÊúâËøõË°å‰∏≠ÁöÑÊ∏∏Êàè„ÄÇËØ∑ÂÖàÂºÄÂßã‰∏Ä‰∏™Ê∏∏Êàè„ÄÇ"
        
        result = self.game_system.process_player_move(self.current_session, move)
        
        # Ê£ÄÊü•Ê∏∏ÊàèÊòØÂê¶ÁªìÊùü
        if self.current_session not in self.game_system.active_sessions:
            self.current_session = None
        
        return result
    
    def list_games(self) -> str:
        """ÂàóÂá∫ÂèØÁî®Ê∏∏Êàè"""
        return self.game_system.get_available_games()
    
    def game_status(self) -> str:
        """Ëé∑ÂèñÊ∏∏ÊàèÁä∂ÊÄÅ"""
        return self.game_system.get_game_status()