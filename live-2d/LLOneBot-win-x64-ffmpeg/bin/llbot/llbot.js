import * as path from "node:path";
import path__default, { resolve } from "node:path";
import { fileURLToPath, pathToFileURL } from "node:url";
import { defineProperty, isNullable, remove, deepEqual, isPlainObject as isPlainObject$1, valueMap, pick as pick$1, clone as clone$1, Binary, filterKeys, noop, hyphenate, makeArray, camelize, isNonNullable, is as is$1, omit as omit$1, mapValues, deduplicate, difference, Time } from "cosmokit";
import Logger from "reggol";
import * as fs from "node:fs";
import fs__default, { existsSync, mkdirSync, appendFile, statSync, promises, appendFileSync } from "node:fs";
import * as os from "node:os";
import os__default from "node:os";
import require$$0$4 from "fs";
import fsPromise, { unlink, stat, access, copyFile, writeFile, readFile } from "node:fs/promises";
import crypto$1, { randomUUID, randomBytes, createHash } from "node:crypto";
import require$$4$1, { gzipSync, gunzipSync, deflateSync, inflateSync } from "node:zlib";
import path$1 from "path";
import require$$1$2 from "util";
import require$$0$7 from "events";
import require$$0$5 from "child_process";
import require$$1$1 from "os";
import require$$0$6 from "stream";
import { WebSocketServer, WebSocket as WebSocket$2 } from "ws";
import require$$0$9 from "debug";
import require$$0$8 from "buffer";
import require$$1$3 from "string_decoder";
import require$$2$1 from "object-inspect";
import require$$1$5 from "node:events";
import require$$0$a, { fileURLToPath as fileURLToPath$1 } from "url";
import require$$2$2 from "node:http";
import require$$0$b, { randomUUID as randomUUID$1 } from "crypto";
import require$$6$1 from "node:querystring";
import require$$7$1 from "node:buffer";
import require$$1$4 from "node:net";
import require$$8 from "ms";
import * as fileType from "file-type";
import { promisify, isDeepStrictEqual, inspect } from "node:util";
import { isSilk, isWav, getWavFileInfo, encode as encode$2, getDuration, decode as decode$2 } from "silk-wasm";
import fsPromise$1, { unlink as unlink$1 } from "fs/promises";
import { createRequire } from "node:module";
import init from "@minatojs/sql.js";
import https from "node:https";
var __defProp$b = Object.defineProperty;
var __name$a = (target, value) => __defProp$b(target, "name", { value, configurable: true });
var symbols = {
  // internal symbols
  shadow: /* @__PURE__ */ Symbol.for("cordis.shadow"),
  receiver: /* @__PURE__ */ Symbol.for("cordis.receiver"),
  original: /* @__PURE__ */ Symbol.for("cordis.original"),
  // context symbols
  store: /* @__PURE__ */ Symbol.for("cordis.store"),
  events: /* @__PURE__ */ Symbol.for("cordis.events"),
  static: /* @__PURE__ */ Symbol.for("cordis.static"),
  filter: /* @__PURE__ */ Symbol.for("cordis.filter"),
  expose: /* @__PURE__ */ Symbol.for("cordis.expose"),
  isolate: /* @__PURE__ */ Symbol.for("cordis.isolate"),
  internal: /* @__PURE__ */ Symbol.for("cordis.internal"),
  intercept: /* @__PURE__ */ Symbol.for("cordis.intercept"),
  // service symbols
  setup: /* @__PURE__ */ Symbol.for("cordis.setup"),
  invoke: /* @__PURE__ */ Symbol.for("cordis.invoke"),
  extend: /* @__PURE__ */ Symbol.for("cordis.extend"),
  tracker: /* @__PURE__ */ Symbol.for("cordis.tracker"),
  provide: /* @__PURE__ */ Symbol.for("cordis.provide"),
  immediate: /* @__PURE__ */ Symbol.for("cordis.immediate")
};
var GeneratorFunction = function* () {
}.constructor;
var AsyncGeneratorFunction = async function* () {
}.constructor;
function isConstructor(func) {
  if (!func.prototype) return false;
  if (func instanceof GeneratorFunction) return false;
  if (AsyncGeneratorFunction !== Function && func instanceof AsyncGeneratorFunction) return false;
  return true;
}
__name$a(isConstructor, "isConstructor");
function resolveConfig(plugin, config2) {
  const schema = plugin["Config"] || plugin["schema"];
  if (schema && plugin["schema"] !== false) config2 = schema(config2);
  return config2 ?? {};
}
__name$a(resolveConfig, "resolveConfig");
function isUnproxyable(value) {
  return [Map, Set, Date, Promise].some((constructor) => value instanceof constructor);
}
__name$a(isUnproxyable, "isUnproxyable");
function joinPrototype(proto1, proto2) {
  if (proto1 === Object.prototype) return proto2;
  const result = Object.create(joinPrototype(Object.getPrototypeOf(proto1), proto2));
  for (const key2 of Reflect.ownKeys(proto1)) {
    Object.defineProperty(result, key2, Object.getOwnPropertyDescriptor(proto1, key2));
  }
  return result;
}
__name$a(joinPrototype, "joinPrototype");
function isObject$1(value) {
  return value && (typeof value === "object" || typeof value === "function");
}
__name$a(isObject$1, "isObject");
function getTraceable(ctx, value, noTrap) {
  if (!isObject$1(value)) return value;
  if (Object.hasOwn(value, symbols.shadow)) {
    return Object.getPrototypeOf(value);
  }
  const tracker = value[symbols.tracker];
  if (!tracker) return value;
  return createTraceable(ctx, value, tracker, noTrap);
}
__name$a(getTraceable, "getTraceable");
function withProps(target, props) {
  if (!props) return target;
  return new Proxy(target, {
    get: /* @__PURE__ */ __name$a((target2, prop, receiver) => {
      if (prop in props && prop !== "constructor") return Reflect.get(props, prop, receiver);
      return Reflect.get(target2, prop, receiver);
    }, "get"),
    set: /* @__PURE__ */ __name$a((target2, prop, value, receiver) => {
      if (prop in props && prop !== "constructor") return Reflect.set(props, prop, value, receiver);
      return Reflect.set(target2, prop, value, receiver);
    }, "set")
  });
}
__name$a(withProps, "withProps");
function withProp(target, prop, value) {
  return withProps(target, Object.defineProperty(/* @__PURE__ */ Object.create(null), prop, {
    value,
    writable: false
  }));
}
__name$a(withProp, "withProp");
function createShadow(ctx, target, property, receiver) {
  if (!property) return receiver;
  const origin = Reflect.getOwnPropertyDescriptor(target, property)?.value;
  if (!origin) return receiver;
  return withProp(receiver, property, ctx.extend({ [symbols.shadow]: origin }));
}
__name$a(createShadow, "createShadow");
function createShadowMethod(ctx, value, outer, shadow) {
  return new Proxy(value, {
    apply: /* @__PURE__ */ __name$a((target, thisArg, args) => {
      if (thisArg === outer) thisArg = shadow;
      args = args.map((arg) => {
        if (typeof arg !== "function" || arg[symbols.original]) return arg;
        return new Proxy(arg, {
          get: /* @__PURE__ */ __name$a((target2, prop, receiver) => {
            if (prop === symbols.original) return target2;
            const value2 = Reflect.get(target2, prop, receiver);
            if (prop === "toString" && value2 === Function.prototype.toString) {
              return function(...args2) {
                return Reflect.apply(value2, this === receiver ? target2 : this, args2);
              };
            }
            return value2;
          }, "get"),
          apply: /* @__PURE__ */ __name$a((target2, thisArg2, args2) => {
            return Reflect.apply(target2, getTraceable(ctx, thisArg2), args2.map((arg2) => getTraceable(ctx, arg2)));
          }, "apply"),
          construct: /* @__PURE__ */ __name$a((target2, args2, newTarget) => {
            return Reflect.construct(target2, args2.map((arg2) => getTraceable(ctx, arg2)), newTarget);
          }, "construct")
        });
      });
      return getTraceable(ctx, Reflect.apply(target, thisArg, args));
    }, "apply")
  });
}
__name$a(createShadowMethod, "createShadowMethod");
function createTraceable(ctx, value, tracker, noTrap) {
  if (ctx[symbols.shadow]) {
    ctx = Object.getPrototypeOf(ctx);
  }
  const proxy = new Proxy(value, {
    get: /* @__PURE__ */ __name$a((target, prop, receiver) => {
      if (prop === symbols.original) return target;
      if (prop === tracker.property) return ctx;
      if (typeof prop === "symbol") {
        return Reflect.get(target, prop, receiver);
      }
      if (tracker.associate && ctx[symbols.internal][`${tracker.associate}.${prop}`]) {
        return Reflect.get(ctx, `${tracker.associate}.${prop}`, withProp(ctx, symbols.receiver, receiver));
      }
      const shadow = createShadow(ctx, target, tracker.property, receiver);
      const innerValue = Reflect.get(target, prop, shadow);
      const innerTracker = innerValue?.[symbols.tracker];
      if (innerTracker) {
        return createTraceable(ctx, innerValue, innerTracker);
      } else if (!noTrap && typeof innerValue === "function") {
        return createShadowMethod(ctx, innerValue, receiver, shadow);
      } else {
        return innerValue;
      }
    }, "get"),
    set: /* @__PURE__ */ __name$a((target, prop, value2, receiver) => {
      if (prop === symbols.original) return false;
      if (prop === tracker.property) return false;
      if (typeof prop === "symbol") {
        return Reflect.set(target, prop, value2, receiver);
      }
      if (tracker.associate && ctx[symbols.internal][`${tracker.associate}.${prop}`]) {
        return Reflect.set(ctx, `${tracker.associate}.${prop}`, value2, withProp(ctx, symbols.receiver, receiver));
      }
      const shadow = createShadow(ctx, target, tracker.property, receiver);
      return Reflect.set(target, prop, value2, shadow);
    }, "set"),
    apply: /* @__PURE__ */ __name$a((target, thisArg, args) => {
      return applyTraceable(proxy, target, thisArg, args);
    }, "apply")
  });
  return proxy;
}
__name$a(createTraceable, "createTraceable");
function applyTraceable(proxy, value, thisArg, args) {
  if (!value[symbols.invoke]) return Reflect.apply(value, thisArg, args);
  return value[symbols.invoke].apply(proxy, args);
}
__name$a(applyTraceable, "applyTraceable");
function createCallable(name, proto, tracker) {
  const self2 = /* @__PURE__ */ __name$a(function(...args) {
    const proxy = createTraceable(self2["ctx"], self2, tracker);
    return applyTraceable(proxy, self2, this, args);
  }, "self");
  defineProperty(self2, "name", name);
  return Object.setPrototypeOf(self2, proto);
}
__name$a(createCallable, "createCallable");
var ReflectService = class _ReflectService {
  constructor(ctx) {
    this.ctx = ctx;
    defineProperty(this, symbols.tracker, {
      associate: "reflect",
      property: "ctx"
    });
    this._mixin("reflect", ["get", "set", "provide", "accessor", "mixin", "alias"]);
    this._mixin("scope", ["config", "runtime", "effect", "collect", "accept", "decline"]);
    this._mixin("registry", ["using", "inject", "plugin"]);
    this._mixin("lifecycle", ["on", "once", "parallel", "emit", "serial", "bail", "start", "stop"]);
  }
  static {
    __name$a(this, "ReflectService");
  }
  static resolveInject(ctx, name) {
    let internal2 = ctx[symbols.internal][name];
    while (internal2?.type === "alias") {
      name = internal2.name;
      internal2 = ctx[symbols.internal][name];
    }
    return [name, internal2];
  }
  static checkInject(ctx, name, error2) {
    ctx = ctx[symbols.shadow] ?? ctx;
    if (["prototype", "then", "registry", "lifecycle"].includes(name)) return;
    if (name[0] === "$" || name[0] === "_") return;
    if (!ctx.runtime.plugin) return;
    if (ctx.bail(ctx, "internal/inject", name)) return;
    const lines = error2.stack.split("\n");
    lines.splice(1, 1);
    error2.stack = lines.join("\n");
    ctx.emit(ctx, "internal/warning", error2);
  }
  static handler = {
    get: /* @__PURE__ */ __name$a((target, prop, ctx) => {
      if (typeof prop !== "string") return Reflect.get(target, prop, ctx);
      if (Reflect.has(target, prop)) {
        return getTraceable(ctx, Reflect.get(target, prop, ctx), true);
      }
      const [name, internal2] = _ReflectService.resolveInject(target, prop);
      const error2 = new Error(`property ${name} is not registered, declare it as \`inject\` to suppress this warning`);
      if (!internal2) {
        _ReflectService.checkInject(ctx, name, error2);
        return Reflect.get(target, name, ctx);
      } else if (internal2.type === "accessor") {
        return internal2.get.call(ctx, ctx[symbols.receiver]);
      } else {
        if (!internal2.builtin) _ReflectService.checkInject(ctx, name, error2);
        return ctx.reflect.get(name);
      }
    }, "get"),
    set: /* @__PURE__ */ __name$a((target, prop, value, ctx) => {
      if (typeof prop !== "string") return Reflect.set(target, prop, value, ctx);
      const [name, internal2] = _ReflectService.resolveInject(target, prop);
      if (!internal2) {
        return Reflect.set(target, name, value, ctx);
      }
      if (internal2.type === "accessor") {
        if (!internal2.set) return false;
        return internal2.set.call(ctx, value, ctx[symbols.receiver]);
      } else {
        ctx.reflect.set(name, value);
        return true;
      }
    }, "set"),
    has: /* @__PURE__ */ __name$a((target, prop) => {
      if (typeof prop !== "string") return Reflect.has(target, prop);
      if (Reflect.has(target, prop)) return true;
      const [, internal2] = _ReflectService.resolveInject(target, prop);
      return !!internal2;
    }, "has")
  };
  get(name) {
    const internal2 = this.ctx[symbols.internal][name];
    if (internal2?.type !== "service") return;
    const key2 = this.ctx[symbols.isolate][name];
    const value = this.ctx[symbols.store][key2]?.value;
    return getTraceable(this.ctx, value);
  }
  set(name, value) {
    this.provide(name);
    const key2 = this.ctx[symbols.isolate][name];
    const oldValue = this.ctx[symbols.store][key2]?.value;
    value ??= void 0;
    let dispose = /* @__PURE__ */ __name$a(() => {
    }, "dispose");
    if (oldValue === value) return dispose;
    if (!isNullable(value) && !isNullable(oldValue)) {
      throw new Error(`service ${name} has been registered`);
    }
    const ctx = this.ctx;
    if (!isNullable(value)) {
      dispose = ctx.effect(() => () => {
        ctx.set(name, void 0);
      });
    }
    if (isUnproxyable(value)) {
      ctx.emit(ctx, "internal/warning", new Error(`service ${name} is an unproxyable object, which may lead to unexpected behavior`));
    }
    const self2 = Object.create(ctx);
    self2[symbols.filter] = (ctx2) => {
      return ctx[symbols.isolate][name] === ctx2[symbols.isolate][name];
    };
    ctx.emit(self2, "internal/before-service", name, value);
    ctx[symbols.store][key2] = { value, source: ctx };
    ctx.emit(self2, "internal/service", name, oldValue);
    return dispose;
  }
  provide(name, value, builtin) {
    const internal2 = this.ctx.root[symbols.internal];
    if (name in internal2) return;
    const key2 = Symbol(name);
    internal2[name] = { type: "service", builtin };
    this.ctx.root[symbols.isolate][name] = key2;
    if (!isObject$1(value)) return;
    this.ctx[symbols.store][key2] = { value, source: null };
    defineProperty(value, symbols.tracker, {
      associate: name,
      property: "ctx"
    });
  }
  _accessor(name, options) {
    const internal2 = this.ctx.root[symbols.internal];
    if (name in internal2) return () => {
    };
    internal2[name] = { type: "accessor", ...options };
    return () => delete this.ctx.root[symbols.isolate][name];
  }
  accessor(name, options) {
    this.ctx.scope.effect(() => {
      return this._accessor(name, options);
    });
  }
  alias(name, aliases) {
    const internal2 = this.ctx.root[symbols.internal];
    if (name in internal2) return;
    for (const key2 of aliases) {
      internal2[key2] ||= { type: "alias", name };
    }
  }
  _mixin(source2, mixins2) {
    const entries = Array.isArray(mixins2) ? mixins2.map((key2) => [key2, key2]) : Object.entries(mixins2);
    const getTarget = typeof source2 === "string" ? (ctx) => ctx[source2] : () => source2;
    const disposables = entries.map(([key2, value]) => {
      return this._accessor(value, {
        get(receiver) {
          const service = getTarget(this);
          if (isNullable(service)) return service;
          const mixin = receiver ? withProps(receiver, service) : service;
          const value2 = Reflect.get(service, key2, mixin);
          if (typeof value2 !== "function") return value2;
          return value2.bind(mixin ?? service);
        },
        set(value2, receiver) {
          const service = getTarget(this);
          const mixin = receiver ? withProps(receiver, service) : service;
          return Reflect.set(service, key2, value2, mixin);
        }
      });
    });
    return () => disposables.forEach((dispose) => dispose());
  }
  mixin(source2, mixins2) {
    this.ctx.scope.effect(() => {
      return this._mixin(source2, mixins2);
    });
  }
  trace(value) {
    return getTraceable(this.ctx, value);
  }
  bind(callback) {
    return new Proxy(callback, {
      apply: /* @__PURE__ */ __name$a((target, thisArg, args) => {
        return target.apply(this.trace(thisArg), args.map((arg) => this.trace(arg)));
      }, "apply")
    });
  }
};
var reflect_default = ReflectService;
function isBailed(value) {
  return value !== null && value !== false && value !== void 0;
}
__name$a(isBailed, "isBailed");
var Lifecycle = class {
  constructor(ctx) {
    this.ctx = ctx;
    defineProperty(this, symbols.tracker, {
      associate: "lifecycle",
      property: "ctx"
    });
    defineProperty(this.on("internal/listener", function(name, listener, options) {
      const method = options.prepend ? "unshift" : "push";
      if (name === "ready") {
        if (!this.lifecycle.isActive) return;
        this.scope.ensure(async () => listener());
        return () => false;
      } else if (name === "dispose") {
        this.scope.disposables[method](listener);
        defineProperty(listener, "name", "event <dispose>");
        return () => remove(this.scope.disposables, listener);
      } else if (name === "fork") {
        this.scope.runtime.forkables[method](listener);
        return this.scope.collect("event <fork>", () => remove(this.scope.runtime.forkables, listener));
      }
    }), Context.static, ctx.scope);
    for (const level of ["info", "error", "warning"]) {
      defineProperty(this.on(`internal/${level}`, (format, ...param) => {
        if (this._hooks[`internal/${level}`].length > 1) return;
        console.info(format, ...param);
      }), Context.static, ctx.scope);
    }
    defineProperty(this.on("internal/before-service", function(name) {
      for (const runtime of this.registry.values()) {
        if (!runtime.inject[name]?.required) continue;
        const scopes = runtime.isReusable ? runtime.children : [runtime];
        for (const scope of scopes) {
          if (!this[symbols.filter](scope.ctx)) continue;
          scope.updateStatus();
          scope.reset();
        }
      }
    }, { global: true }), Context.static, ctx.scope);
    defineProperty(this.on("internal/service", function(name) {
      for (const runtime of this.registry.values()) {
        if (!runtime.inject[name]?.required) continue;
        const scopes = runtime.isReusable ? runtime.children : [runtime];
        for (const scope of scopes) {
          if (!this[symbols.filter](scope.ctx)) continue;
          scope.start();
        }
      }
    }, { global: true }), Context.static, ctx.scope);
    const checkInject = /* @__PURE__ */ __name$a((scope, name) => {
      if (!scope.runtime.plugin) return false;
      for (const key2 in scope.runtime.inject) {
        if (name === reflect_default.resolveInject(scope.ctx, key2)[0]) return true;
      }
      return checkInject(scope.parent.scope, name);
    }, "checkInject");
    defineProperty(this.on("internal/inject", function(name) {
      return checkInject(this.scope, name);
    }, { global: true }), Context.static, ctx.scope);
  }
  static {
    __name$a(this, "Lifecycle");
  }
  isActive = false;
  _tasks = /* @__PURE__ */ new Set();
  _hooks = {};
  async flush() {
    while (this._tasks.size) {
      await Promise.all(Array.from(this._tasks));
    }
  }
  filterHooks(hooks, thisArg) {
    thisArg = getTraceable(this.ctx, thisArg);
    return hooks.slice().filter((hook) => {
      const filter = thisArg?.[Context.filter];
      return hook.global || !filter || filter.call(thisArg, hook.ctx);
    });
  }
  *dispatch(type2, args) {
    const thisArg = typeof args[0] === "object" || typeof args[0] === "function" ? args.shift() : null;
    const name = args.shift();
    if (name !== "internal/event") {
      this.emit("internal/event", type2, name, args, thisArg);
    }
    for (const hook of this.filterHooks(this._hooks[name] || [], thisArg)) {
      yield hook.callback.apply(thisArg, args);
    }
  }
  async parallel(...args) {
    await Promise.all(this.dispatch("emit", args));
  }
  emit(...args) {
    Array.from(this.dispatch("emit", args));
  }
  async serial(...args) {
    for await (const result of this.dispatch("serial", args)) {
      if (isBailed(result)) return result;
    }
  }
  bail(...args) {
    for (const result of this.dispatch("bail", args)) {
      if (isBailed(result)) return result;
    }
  }
  register(label, hooks, callback, options) {
    const method = options.prepend ? "unshift" : "push";
    hooks[method]({ ctx: this.ctx, callback, ...options });
    return this.ctx.state.collect(label, () => this.unregister(hooks, callback));
  }
  unregister(hooks, callback) {
    const index2 = hooks.findIndex((hook) => hook.callback === callback);
    if (index2 >= 0) {
      hooks.splice(index2, 1);
      return true;
    }
  }
  on(name, listener, options) {
    if (typeof options !== "object") {
      options = { prepend: options };
    }
    this.ctx.scope.assertActive();
    listener = this.ctx.reflect.bind(listener);
    const result = this.bail(this.ctx, "internal/listener", name, listener, options);
    if (result) return result;
    const hooks = this._hooks[name] ||= [];
    const label = typeof name === "string" ? `event <${name}>` : "event (Symbol)";
    return this.register(label, hooks, listener, options);
  }
  once(name, listener, options) {
    const dispose = this.on(name, function(...args) {
      dispose();
      return listener.apply(this, args);
    }, options);
    return dispose;
  }
  async start() {
    this.isActive = true;
    const hooks = this._hooks.ready || [];
    while (hooks.length) {
      const { ctx, callback } = hooks.shift();
      ctx.scope.ensure(async () => callback());
    }
    await this.flush();
  }
  async stop() {
    this.isActive = false;
    this.ctx.scope.reset();
  }
};
var events_default = Lifecycle;
var CordisError = class _CordisError extends Error {
  constructor(code, message) {
    super(message ?? _CordisError.Code[code]);
    this.code = code;
  }
  static {
    __name$a(this, "CordisError");
  }
};
((CordisError2) => {
  CordisError2.Code = {
    INACTIVE_EFFECT: "cannot create effect on inactive context"
  };
})(CordisError || (CordisError = {}));
var EffectScope = class {
  constructor(parent, config2) {
    this.parent = parent;
    this.config = config2;
    this.uid = parent.registry ? parent.registry.counter : 0;
    this.ctx = this.context = parent.extend({ scope: this });
    this.proxy = new Proxy({}, {
      get: /* @__PURE__ */ __name$a((target, key2) => Reflect.get(this.config, key2), "get")
    });
  }
  static {
    __name$a(this, "EffectScope");
  }
  uid;
  ctx;
  disposables = [];
  error;
  status = 0;
  isActive = false;
  // Same as `this.ctx`, but with a more specific type.
  context;
  proxy;
  acceptors = [];
  tasks = /* @__PURE__ */ new Set();
  hasError = false;
  get _config() {
    return this.runtime.isReactive ? this.proxy : this.config;
  }
  assertActive() {
    if (this.uid !== null || this.isActive) return;
    throw new CordisError("INACTIVE_EFFECT");
  }
  effect(callback, config2) {
    this.assertActive();
    const result = isConstructor(callback) ? new callback(this.ctx, config2) : callback(this.ctx, config2);
    let disposed = false;
    const original = typeof result === "function" ? result : result.dispose.bind(result);
    const wrapped = /* @__PURE__ */ __name$a((...args) => {
      if (disposed) return;
      disposed = true;
      remove(this.disposables, wrapped);
      return original(...args);
    }, "wrapped");
    this.disposables.push(wrapped);
    if (typeof result === "function") return wrapped;
    result.dispose = wrapped;
    return result;
  }
  collect(label, callback) {
    const dispose = defineProperty(() => {
      remove(this.disposables, dispose);
      return callback();
    }, "name", label);
    this.disposables.push(dispose);
    return dispose;
  }
  restart() {
    this.reset();
    this.error = null;
    this.hasError = false;
    this.status = 0;
    this.start();
  }
  _getStatus() {
    if (this.uid === null) return 4;
    if (this.hasError) return 3;
    if (this.tasks.size) return 1;
    if (this.ready) return 2;
    return 0;
  }
  updateStatus(callback) {
    const oldValue = this.status;
    callback?.();
    this.status = this._getStatus();
    if (oldValue !== this.status) {
      this.context.emit("internal/status", this, oldValue);
    }
  }
  ensure(callback) {
    const task = callback().catch((reason) => {
      this.context.emit(this.ctx, "internal/error", reason);
      this.cancel(reason);
    }).finally(() => {
      this.updateStatus(() => this.tasks.delete(task));
      this.context.events._tasks.delete(task);
    });
    this.updateStatus(() => this.tasks.add(task));
    this.context.events._tasks.add(task);
  }
  cancel(reason) {
    this.error = reason;
    this.updateStatus(() => this.hasError = true);
    this.reset();
  }
  get ready() {
    return Object.entries(this.runtime.inject).every(([name, inject]) => {
      return !inject.required || !isNullable(this.ctx.get(name));
    });
  }
  reset() {
    this.isActive = false;
    this.disposables = this.disposables.splice(0).filter((dispose) => {
      if (this.uid !== null && dispose[Context.static] === this) return true;
      (async () => dispose())().catch((reason) => {
        this.context.emit(this.ctx, "internal/error", reason);
      });
    });
  }
  init(error2) {
    if (!this.config) {
      this.cancel(error2);
    } else {
      this.start();
    }
  }
  start() {
    if (!this.ready || this.isActive || this.uid === null) return true;
    this.isActive = true;
    this.updateStatus(() => this.hasError = false);
  }
  accept(...args) {
    const keys = Array.isArray(args[0]) ? args.shift() : null;
    const acceptor = { keys, callback: args[0], ...args[1] };
    return this.effect(() => {
      this.acceptors.push(acceptor);
      if (acceptor.immediate) acceptor.callback?.(this.config);
      return () => remove(this.acceptors, acceptor);
    });
  }
  decline(keys) {
    return this.accept(keys, () => true);
  }
  checkUpdate(resolved, forced) {
    if (forced || !this.config) return [true, true];
    if (forced === false) return [false, false];
    const modified = /* @__PURE__ */ Object.create(null);
    const checkPropertyUpdate = /* @__PURE__ */ __name$a((key2) => {
      const result = modified[key2] ??= !deepEqual(this.config[key2], resolved[key2]);
      hasUpdate ||= result;
      return result;
    }, "checkPropertyUpdate");
    const ignored = /* @__PURE__ */ new Set();
    let hasUpdate = false, shouldRestart = false;
    let fallback = this.runtime.isReactive || null;
    for (const { keys, callback, passive } of this.acceptors) {
      if (!keys) {
        fallback ||= !passive;
      } else if (passive) {
        keys?.forEach((key2) => ignored.add(key2));
      } else {
        let hasUpdate2 = false;
        for (const key2 of keys) {
          hasUpdate2 ||= checkPropertyUpdate(key2);
        }
        if (!hasUpdate2) continue;
      }
      const result = callback?.(resolved);
      if (result) shouldRestart = true;
    }
    for (const key2 in { ...this.config, ...resolved }) {
      if (fallback === false) continue;
      if (!(key2 in modified) && !ignored.has(key2)) {
        const hasUpdate2 = checkPropertyUpdate(key2);
        if (fallback === null) shouldRestart ||= hasUpdate2;
      }
    }
    return [hasUpdate, shouldRestart];
  }
};
var ForkScope = class extends EffectScope {
  constructor(parent, runtime, config2, error2) {
    super(parent, config2);
    this.runtime = runtime;
    this.dispose = defineProperty(parent.scope.collect(`fork <${parent.runtime.name}>`, () => {
      this.uid = null;
      this.reset();
      this.context.emit("internal/fork", this);
      const result = remove(runtime.disposables, this.dispose);
      if (remove(runtime.children, this) && !runtime.children.length) {
        parent.registry.delete(runtime.plugin);
      }
      return result;
    }), Context.static, runtime);
    runtime.children.push(this);
    runtime.disposables.push(this.dispose);
    this.context.emit("internal/fork", this);
    this.init(error2);
  }
  static {
    __name$a(this, "ForkScope");
  }
  dispose;
  start() {
    if (super.start()) return true;
    for (const fork of this.runtime.forkables) {
      this.ensure(async () => fork(this.context, this._config));
    }
  }
  update(config2, forced) {
    const oldConfig = this.config;
    const state2 = this.runtime.isForkable ? this : this.runtime;
    if (state2.config !== oldConfig) return;
    let resolved;
    try {
      resolved = resolveConfig(this.runtime.plugin, config2);
    } catch (error2) {
      this.context.emit("internal/error", error2);
      return this.cancel(error2);
    }
    const [hasUpdate, shouldRestart] = state2.checkUpdate(resolved, forced);
    this.context.emit("internal/before-update", this, config2);
    this.config = resolved;
    state2.config = resolved;
    if (hasUpdate) {
      this.context.emit("internal/update", this, oldConfig);
    }
    if (shouldRestart) state2.restart();
  }
};
var MainScope = class extends EffectScope {
  constructor(ctx, plugin, config2, error2) {
    super(ctx, config2);
    this.plugin = plugin;
    if (!plugin) {
      this.name = "root";
      this.isActive = true;
    } else {
      this.setup();
      this.init(error2);
    }
  }
  static {
    __name$a(this, "MainScope");
  }
  value;
  runtime = this;
  schema;
  name;
  inject = /* @__PURE__ */ Object.create(null);
  forkables = [];
  children = [];
  isReusable = false;
  isReactive = false;
  get isForkable() {
    return this.forkables.length > 0;
  }
  fork(parent, config2, error2) {
    return new ForkScope(parent, this, config2, error2);
  }
  dispose() {
    this.uid = null;
    this.reset();
    this.context.emit("internal/runtime", this);
    return true;
  }
  setup() {
    const { name } = this.plugin;
    if (name && name !== "apply") this.name = name;
    this.schema = this.plugin["Config"] || this.plugin["schema"];
    this.inject = Inject.resolve(this.plugin["using"] || this.plugin["inject"]);
    this.isReusable = this.plugin["reusable"];
    this.isReactive = this.plugin["reactive"];
    this.context.emit("internal/runtime", this);
    if (this.isReusable) {
      this.forkables.push(this.apply);
    }
  }
  apply = /* @__PURE__ */ __name$a((context, config2) => {
    if (typeof this.plugin !== "function") {
      return this.plugin.apply(context, config2);
    } else if (isConstructor(this.plugin)) {
      const instance = new this.plugin(context, config2);
      const name = instance[Context.expose];
      if (name) {
        context.set(name, instance);
      }
      if (instance["fork"]) {
        this.forkables.push(instance["fork"].bind(instance));
      }
      return instance;
    } else {
      return this.plugin(context, config2);
    }
  }, "apply");
  reset() {
    super.reset();
    for (const fork of this.children) {
      fork.reset();
    }
  }
  start() {
    if (super.start()) return true;
    if (!this.isReusable && this.plugin) {
      this.ensure(async () => this.value = this.apply(this.ctx, this._config));
    }
    for (const fork of this.children) {
      fork.start();
    }
  }
  update(config2, forced) {
    if (this.isForkable) {
      const warning = new Error(`attempting to update forkable plugin "${this.plugin.name}", which may lead to unexpected behavior`);
      this.context.emit(this.ctx, "internal/warning", warning);
    }
    const oldConfig = this.config;
    let resolved;
    try {
      resolved = resolveConfig(this.runtime.plugin || this.context.constructor, config2);
    } catch (error2) {
      this.context.emit("internal/error", error2);
      return this.cancel(error2);
    }
    const [hasUpdate, shouldRestart] = this.checkUpdate(resolved, forced);
    const state2 = this.children.find((fork) => fork.config === oldConfig);
    this.config = resolved;
    if (state2) {
      this.context.emit("internal/before-update", state2, config2);
      state2.config = resolved;
      if (hasUpdate) {
        this.context.emit("internal/update", state2, oldConfig);
      }
    }
    if (shouldRestart) this.restart();
  }
};
function isApplicable(object2) {
  return object2 && typeof object2 === "object" && typeof object2.apply === "function";
}
__name$a(isApplicable, "isApplicable");
function Inject(inject) {
  return function(value, ctx) {
    if (ctx.kind === "class") {
      value.inject = inject;
    } else if (ctx.kind === "method") {
      ctx.addInitializer(function() {
        const property = this[symbols.tracker]?.property;
        if (!property) throw new Error("missing context tracker");
        this[property].inject(inject, (ctx2) => {
          value.call(withProps(this, { [property]: ctx2 }));
        });
      });
    } else {
      throw new Error("@Inject can only be used on class or class methods");
    }
  };
}
__name$a(Inject, "Inject");
((Inject2) => {
  function resolve2(inject) {
    if (!inject) return {};
    if (Array.isArray(inject)) {
      return Object.fromEntries(inject.map((name) => [name, { required: true }]));
    }
    const { required: required2, optional: optional2, ...rest } = inject;
    if (Array.isArray(required2)) {
      Object.assign(rest, Object.fromEntries(required2.map((name) => [name, { required: true }])));
    }
    if (Array.isArray(optional2)) {
      Object.assign(rest, Object.fromEntries(optional2.map((name) => [name, { required: false }])));
    }
    return rest;
  }
  Inject2.resolve = resolve2;
  __name$a(resolve2, "resolve");
})(Inject || (Inject = {}));
var Registry = class {
  constructor(ctx, config2) {
    this.ctx = ctx;
    defineProperty(this, symbols.tracker, {
      associate: "registry",
      property: "ctx"
    });
    this.context = ctx;
    const runtime = new MainScope(ctx, null, config2);
    ctx.scope = runtime;
    runtime.ctx = ctx;
    this.set(null, runtime);
  }
  static {
    __name$a(this, "Registry");
  }
  _counter = 0;
  _internal = /* @__PURE__ */ new Map();
  context;
  get counter() {
    return ++this._counter;
  }
  get size() {
    return this._internal.size;
  }
  resolve(plugin, assert2 = false) {
    if (plugin === null) return plugin;
    if (typeof plugin === "function") return plugin;
    if (isApplicable(plugin)) return plugin.apply;
    if (assert2) throw new Error('invalid plugin, expect function or object with an "apply" method, received ' + typeof plugin);
  }
  get(plugin) {
    const key2 = this.resolve(plugin);
    return key2 && this._internal.get(key2);
  }
  has(plugin) {
    const key2 = this.resolve(plugin);
    return !!key2 && this._internal.has(key2);
  }
  set(plugin, state2) {
    const key2 = this.resolve(plugin);
    this._internal.set(key2, state2);
  }
  delete(plugin) {
    const key2 = this.resolve(plugin);
    const runtime = key2 && this._internal.get(key2);
    if (!runtime) return;
    this._internal.delete(key2);
    runtime.dispose();
    return runtime;
  }
  keys() {
    return this._internal.keys();
  }
  values() {
    return this._internal.values();
  }
  entries() {
    return this._internal.entries();
  }
  forEach(callback) {
    return this._internal.forEach(callback);
  }
  using(inject, callback) {
    return this.inject(inject, callback);
  }
  inject(inject, callback) {
    return this.plugin({ inject, apply: callback, name: callback.name });
  }
  plugin(plugin, config2, error2) {
    this.resolve(plugin, true);
    this.ctx.scope.assertActive();
    if (!error2) {
      try {
        config2 = resolveConfig(plugin, config2);
      } catch (reason) {
        this.context.emit(this.ctx, "internal/error", reason);
        error2 = reason;
        config2 = null;
      }
    }
    let runtime = this.get(plugin);
    if (runtime) {
      if (!runtime.isForkable) {
        this.context.emit(this.ctx, "internal/warning", new Error(`duplicate plugin detected: ${plugin.name}`));
      }
      return runtime.fork(this.ctx, config2, error2);
    }
    runtime = new MainScope(this.ctx, plugin, config2, error2);
    this.set(plugin, runtime);
    return runtime.fork(this.ctx, config2, error2);
  }
};
var registry_default = Registry;
var Context = class _Context {
  static {
    __name$a(this, "Context");
  }
  static store = symbols.store;
  static events = symbols.events;
  static static = symbols.static;
  static filter = symbols.filter;
  static expose = symbols.expose;
  static isolate = symbols.isolate;
  static internal = symbols.internal;
  static intercept = symbols.intercept;
  static origin = "ctx";
  static current = "ctx";
  static is(value) {
    return !!value?.[_Context.is];
  }
  static {
    _Context.is[Symbol.toPrimitive] = () => /* @__PURE__ */ Symbol.for("cordis.is");
    _Context.prototype[_Context.is] = true;
  }
  /** @deprecated use `Service.traceable` instead */
  static associate(object2, name) {
    return object2;
  }
  constructor(config2) {
    config2 = resolveConfig(this.constructor, config2);
    this[symbols.store] = /* @__PURE__ */ Object.create(null);
    this[symbols.isolate] = /* @__PURE__ */ Object.create(null);
    this[symbols.internal] = /* @__PURE__ */ Object.create(null);
    this[symbols.intercept] = /* @__PURE__ */ Object.create(null);
    const self2 = new Proxy(this, reflect_default.handler);
    self2.root = self2;
    self2.reflect = new reflect_default(self2);
    self2.registry = new registry_default(self2, config2);
    self2.lifecycle = new events_default(self2);
    const attach = /* @__PURE__ */ __name$a((internal2) => {
      if (!internal2) return;
      attach(Object.getPrototypeOf(internal2));
      for (const key2 of Object.getOwnPropertyNames(internal2)) {
        const constructor = internal2[key2]["prototype"]?.constructor;
        if (!constructor) continue;
        self2[internal2[key2]["key"]] = new constructor(self2, config2);
        defineProperty(self2[internal2[key2]["key"]], "ctx", self2);
      }
    }, "attach");
    attach(this[symbols.internal]);
    return self2;
  }
  [/* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom")]() {
    return `Context <${this.name}>`;
  }
  get name() {
    let runtime = this.runtime;
    while (runtime && !runtime.name) {
      runtime = runtime.parent.runtime;
    }
    return runtime?.name;
  }
  get events() {
    return this.lifecycle;
  }
  /** @deprecated */
  get state() {
    return this.scope;
  }
  extend(meta2 = {}) {
    const source2 = Reflect.getOwnPropertyDescriptor(this, symbols.shadow)?.value;
    const self2 = Object.assign(Object.create(getTraceable(this, this)), meta2);
    if (!source2) return self2;
    return Object.assign(Object.create(self2), { [symbols.shadow]: source2 });
  }
  isolate(name, label) {
    const shadow = Object.create(this[symbols.isolate]);
    shadow[name] = label ?? Symbol(name);
    return this.extend({ [symbols.isolate]: shadow });
  }
  intercept(name, config2) {
    const intercept = Object.create(this[symbols.intercept]);
    intercept[name] = config2;
    return this.extend({ [symbols.intercept]: intercept });
  }
};
Context.prototype[Context.internal] = /* @__PURE__ */ Object.create(null);
var Service = class _Service {
  static {
    __name$a(this, "Service");
  }
  static setup = symbols.setup;
  static invoke = symbols.invoke;
  static extend = symbols.extend;
  static tracker = symbols.tracker;
  static provide = symbols.provide;
  static immediate = symbols.immediate;
  start() {
  }
  stop() {
  }
  ctx;
  name;
  config;
  constructor(...args) {
    let _ctx, name, immediate, config2;
    if (Context.is(args[0])) {
      _ctx = args[0];
      if (typeof args[1] === "string") {
        name = args[1];
        immediate = args[2];
      } else {
        config2 = args[1];
      }
    } else {
      config2 = args[0];
    }
    name ??= this.constructor[symbols.provide];
    immediate ??= this.constructor[symbols.immediate];
    let self2 = this;
    const tracker = {
      associate: name,
      property: "ctx"
    };
    if (self2[symbols.invoke]) {
      self2 = createCallable(name, joinPrototype(Object.getPrototypeOf(this), Function.prototype), tracker);
    }
    if (_ctx) {
      self2.ctx = _ctx;
    } else {
      self2[symbols.setup]();
    }
    self2.name = name;
    self2.config = config2;
    defineProperty(self2, symbols.tracker, tracker);
    self2.ctx.provide(name);
    self2.ctx.runtime.name = name;
    if (immediate) {
      if (_ctx) self2[symbols.expose] = name;
      else self2.ctx.set(name, self2);
    }
    self2.ctx.on("ready", async () => {
      await Promise.resolve();
      await self2.start();
      if (!immediate) self2.ctx.set(name, self2);
    });
    self2.ctx.on("dispose", () => self2.stop());
    return self2;
  }
  [symbols.filter](ctx) {
    return ctx[symbols.isolate][this.name] === this.ctx[symbols.isolate][this.name];
  }
  [symbols.setup]() {
    this.ctx = new Context();
  }
  [symbols.extend](props) {
    let self2;
    if (this[_Service.invoke]) {
      self2 = createCallable(this.name, this, this[symbols.tracker]);
    } else {
      self2 = Object.create(this);
    }
    return Object.assign(self2, props);
  }
  static [Symbol.hasInstance](instance) {
    let constructor = instance.constructor;
    while (constructor) {
      constructor = constructor.prototype?.constructor;
      if (constructor === this) return true;
      constructor = Object.getPrototypeOf(constructor);
    }
    return false;
  }
};
var __defProp$a = Object.defineProperty;
var __name$9 = (target, value) => __defProp$a(target, "name", { value, configurable: true });
var LoggerService = class _LoggerService extends Service {
  static {
    __name$9(this, "LoggerService");
  }
  constructor(ctx) {
    super(ctx, "logger", true);
    ctx.on("internal/info", function(format, ...args) {
      this.logger("app").info(format, ...args);
    });
    ctx.on("internal/error", function(format, ...args) {
      this.logger("app").error(format, ...args);
    });
    ctx.on("internal/warning", function(format, ...args) {
      this.logger("app").warn(format, ...args);
    });
  }
  [Service.invoke](name) {
    return new Logger(name, defineProperty({}, "ctx", this.ctx));
  }
  static {
    for (const type2 of ["success", "error", "info", "warn", "debug", "extend"]) {
      _LoggerService.prototype[type2] = function(...args) {
        return this(this.ctx.name)[type2](...args);
      };
    }
  }
};
var __defProp$9 = Object.defineProperty;
var __getOwnPropNames$1 = Object.getOwnPropertyNames;
var __name$8 = (target, value) => __defProp$9(target, "name", { value, configurable: true });
var __commonJS$1 = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames$1(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_index$1 = __commonJS$1({
  "src/index.ts"(exports$1, module) {
    var kSchema = /* @__PURE__ */ Symbol.for("schemastery");
    var kValidationError = /* @__PURE__ */ Symbol.for("ValidationError");
    globalThis.__schemastery_index__ ??= 0;
    globalThis.__schemastery_refs__ = void 0;
    var ValidationError = class extends TypeError {
      constructor(message, options) {
        let prefix = "$";
        for (const segment of options.path || []) {
          if (typeof segment === "string") {
            prefix += "." + segment;
          } else if (typeof segment === "number") {
            prefix += "[" + segment + "]";
          } else if (typeof segment === "symbol") {
            prefix += `[Symbol(${segment.toString()})]`;
          }
        }
        if (prefix.startsWith(".")) prefix = prefix.slice(1);
        super((prefix === "$" ? "" : `${prefix} `) + message);
        this.options = options;
      }
      static {
        __name$8(this, "ValidationError");
      }
      name = "ValidationError";
      static is(error2) {
        return !!error2?.[kValidationError];
      }
    };
    Object.defineProperty(ValidationError.prototype, kValidationError, {
      value: true
    });
    var Schema = /* @__PURE__ */ __name$8(function(options) {
      const schema = /* @__PURE__ */ __name$8(function(data, options2 = {}) {
        return Schema.resolve(data, schema, options2)[0];
      }, "schema");
      if (options.refs) {
        const refs = valueMap(options.refs, (options2) => new Schema(options2));
        const getRef = /* @__PURE__ */ __name$8((uid) => refs[uid], "getRef");
        for (const key2 in refs) {
          const options2 = refs[key2];
          options2.sKey = getRef(options2.sKey);
          options2.inner = getRef(options2.inner);
          options2.list = options2.list && options2.list.map(getRef);
          options2.dict = options2.dict && valueMap(options2.dict, getRef);
        }
        return refs[options.uid];
      }
      Object.assign(schema, options);
      if (typeof schema.callback === "string") {
        try {
          schema.callback = new Function("return " + schema.callback)();
        } catch {
        }
      }
      Object.defineProperty(schema, "uid", { value: globalThis.__schemastery_index__++ });
      Object.setPrototypeOf(schema, Schema.prototype);
      schema.meta ||= {};
      schema.toString = schema.toString.bind(schema);
      return schema;
    }, "Schema");
    Schema.prototype = Object.create(Function.prototype);
    Schema.prototype[kSchema] = true;
    Schema.ValidationError = ValidationError;
    Schema.prototype.toJSON = /* @__PURE__ */ __name$8(function toJSON() {
      if (globalThis.__schemastery_refs__) {
        globalThis.__schemastery_refs__[this.uid] ??= JSON.parse(JSON.stringify({ ...this }));
        return this.uid;
      }
      globalThis.__schemastery_refs__ = { [this.uid]: { ...this } };
      globalThis.__schemastery_refs__[this.uid] = JSON.parse(JSON.stringify({ ...this }));
      const result = { uid: this.uid, refs: globalThis.__schemastery_refs__ };
      globalThis.__schemastery_refs__ = void 0;
      return result;
    }, "toJSON");
    Schema.prototype.set = /* @__PURE__ */ __name$8(function set2(key2, value) {
      this.dict[key2] = value;
      return this;
    }, "set");
    Schema.prototype.push = /* @__PURE__ */ __name$8(function push2(value) {
      this.list.push(value);
      return this;
    }, "push");
    function mergeDesc(original, messages) {
      const result = typeof original === "string" ? { "": original } : { ...original };
      for (const locale in messages) {
        const value = messages[locale];
        if (value?.$description || value?.$desc) {
          result[locale] = value.$description || value.$desc;
        } else if (typeof value === "string") {
          result[locale] = value;
        }
      }
      return result;
    }
    __name$8(mergeDesc, "mergeDesc");
    function getInner(value) {
      return value?.$value ?? value?.$inner;
    }
    __name$8(getInner, "getInner");
    function extractKeys(data) {
      return filterKeys(data ?? {}, (key2) => !key2.startsWith("$"));
    }
    __name$8(extractKeys, "extractKeys");
    Schema.prototype.i18n = /* @__PURE__ */ __name$8(function i18n(messages) {
      const schema = Schema(this);
      const desc = mergeDesc(schema.meta.description, messages);
      if (Object.keys(desc).length) schema.meta.description = desc;
      if (schema.dict) {
        schema.dict = valueMap(schema.dict, (inner, key2) => {
          return inner.i18n(valueMap(messages, (data) => getInner(data)?.[key2] ?? data?.[key2]));
        });
      }
      if (schema.list) {
        schema.list = schema.list.map((inner, index2) => {
          return inner.i18n(valueMap(messages, (data = {}) => {
            if (Array.isArray(getInner(data))) return getInner(data)[index2];
            if (Array.isArray(data)) return data[index2];
            return extractKeys(data);
          }));
        });
      }
      if (schema.inner) {
        schema.inner = schema.inner.i18n(valueMap(messages, (data) => {
          if (getInner(data)) return getInner(data);
          return extractKeys(data);
        }));
      }
      if (schema.sKey) {
        schema.sKey = schema.sKey.i18n(valueMap(messages, (data) => data?.$key));
      }
      return schema;
    }, "i18n");
    Schema.prototype.extra = /* @__PURE__ */ __name$8(function extra(key2, value) {
      const schema = Schema(this);
      schema.meta = { ...schema.meta, [key2]: value };
      return schema;
    }, "extra");
    for (const key2 of ["required", "disabled", "collapse", "hidden", "loose"]) {
      Object.assign(Schema.prototype, {
        [key2](value = true) {
          const schema = Schema(this);
          schema.meta = { ...schema.meta, [key2]: value };
          return schema;
        }
      });
    }
    Schema.prototype.deprecated = /* @__PURE__ */ __name$8(function deprecated() {
      const schema = Schema(this);
      schema.meta.badges ||= [];
      schema.meta.badges.push({ text: "deprecated", type: "danger" });
      return schema;
    }, "deprecated");
    Schema.prototype.experimental = /* @__PURE__ */ __name$8(function experimental() {
      const schema = Schema(this);
      schema.meta.badges ||= [];
      schema.meta.badges.push({ text: "experimental", type: "warning" });
      return schema;
    }, "experimental");
    Schema.prototype.pattern = /* @__PURE__ */ __name$8(function pattern2(regexp) {
      const schema = Schema(this);
      const pattern22 = pick$1(regexp, ["source", "flags"]);
      schema.meta = { ...schema.meta, pattern: pattern22 };
      return schema;
    }, "pattern");
    Schema.prototype.simplify = /* @__PURE__ */ __name$8(function simplify(value) {
      if (deepEqual(value, this.meta.default, this.type === "dict")) return null;
      if (isNullable(value)) return value;
      if (this.type === "object" || this.type === "dict") {
        const result = {};
        for (const key2 in value) {
          const schema = this.type === "object" ? this.dict[key2] : this.inner;
          const item = schema?.simplify(value[key2]);
          if (this.type === "dict" || !isNullable(item)) result[key2] = item;
        }
        if (deepEqual(result, this.meta.default, this.type === "dict")) return null;
        return result;
      } else if (this.type === "array" || this.type === "tuple") {
        const result = [];
        value.forEach((value2, index2) => {
          const schema = this.type === "array" ? this.inner : this.list[index2];
          const item = schema ? schema.simplify(value2) : value2;
          result.push(item);
        });
        return result;
      } else if (this.type === "intersect") {
        const result = {};
        for (const item of this.list) {
          Object.assign(result, item.simplify(value));
        }
        return result;
      } else if (this.type === "union") {
        for (const schema of this.list) {
          try {
            Schema.resolve(value, schema, {});
            return schema.simplify(value);
          } catch {
          }
        }
      }
      return value;
    }, "simplify");
    Schema.prototype.toString = /* @__PURE__ */ __name$8(function toString(inline) {
      return formatters[this.type]?.(this, inline) ?? `Schema<${this.type}>`;
    }, "toString");
    Schema.prototype.role = /* @__PURE__ */ __name$8(function role(role, extra) {
      const schema = Schema(this);
      schema.meta = { ...schema.meta, role, extra };
      return schema;
    }, "role");
    for (const key2 of ["default", "link", "comment", "description", "max", "min", "step"]) {
      Object.assign(Schema.prototype, {
        [key2](value) {
          const schema = Schema(this);
          schema.meta = { ...schema.meta, [key2]: value };
          return schema;
        }
      });
    }
    var resolvers = {};
    Schema.extend = /* @__PURE__ */ __name$8(function extend2(type2, resolve2) {
      resolvers[type2] = resolve2;
    }, "extend");
    Schema.resolve = /* @__PURE__ */ __name$8(function resolve2(data, schema, options = {}, strict = false) {
      if (!schema) return [data];
      if (options.ignore?.(data, schema)) return [data];
      if (isNullable(data) && schema.type !== "lazy") {
        if (schema.meta.required) throw new ValidationError(`missing required value`, options);
        let current = schema;
        let fallback = schema.meta.default;
        while (current?.type === "intersect" && isNullable(fallback)) {
          current = current.list[0];
          fallback = current?.meta.default;
        }
        if (isNullable(fallback)) return [data];
        data = clone$1(fallback);
      }
      const callback = resolvers[schema.type];
      if (!callback) throw new ValidationError(`unsupported type "${schema.type}"`, options);
      try {
        return callback(data, schema, options, strict);
      } catch (error2) {
        if (!schema.meta.loose) throw error2;
        return [schema.meta.default];
      }
    }, "resolve");
    Schema.from = /* @__PURE__ */ __name$8(function from2(source2) {
      if (isNullable(source2)) {
        return Schema.any();
      } else if (["string", "number", "boolean"].includes(typeof source2)) {
        return Schema.const(source2).required();
      } else if (source2[kSchema]) {
        return source2;
      } else if (typeof source2 === "function") {
        switch (source2) {
          case String:
            return Schema.string().required();
          case Number:
            return Schema.number().required();
          case Boolean:
            return Schema.boolean().required();
          case Function:
            return Schema.function().required();
          default:
            return Schema.is(source2).required();
        }
      } else {
        throw new TypeError(`cannot infer schema from ${source2}`);
      }
    }, "from");
    Schema.lazy = /* @__PURE__ */ __name$8(function lazy2(builder) {
      const toJSON = /* @__PURE__ */ __name$8(() => {
        if (!schema.inner[kSchema]) {
          schema.inner = schema.builder();
          schema.inner.meta = { ...schema.meta, ...schema.inner.meta };
        }
        return schema.inner.toJSON();
      }, "toJSON");
      const schema = new Schema({ type: "lazy", builder, inner: { toJSON } });
      return schema;
    }, "lazy");
    Schema.natural = /* @__PURE__ */ __name$8(function natural() {
      return Schema.number().step(1).min(0);
    }, "natural");
    Schema.percent = /* @__PURE__ */ __name$8(function percent() {
      return Schema.number().step(0.01).min(0).max(1).role("slider");
    }, "percent");
    Schema.date = /* @__PURE__ */ __name$8(function date2() {
      return Schema.union([
        Schema.is(Date),
        Schema.transform(Schema.string().role("datetime"), (value, options) => {
          const date22 = new Date(value);
          if (isNaN(+date22)) throw new ValidationError(`invalid date "${value}"`, options);
          return date22;
        }, true)
      ]);
    }, "date");
    Schema.regExp = /* @__PURE__ */ __name$8(function regExp(flag = "") {
      return Schema.union([
        Schema.is(RegExp),
        Schema.transform(Schema.string().role("regexp", { flag }), (value, options) => {
          try {
            return new RegExp(value, flag);
          } catch (e) {
            throw new ValidationError(e.message, options);
          }
        }, true)
      ]);
    }, "regExp");
    Schema.arrayBuffer = /* @__PURE__ */ __name$8(function arrayBuffer(encoding2) {
      return Schema.union([
        Schema.is(ArrayBuffer),
        Schema.is(SharedArrayBuffer),
        Schema.transform(Schema.any(), (value, options) => {
          if (Binary.isSource(value)) return Binary.fromSource(value);
          throw new ValidationError(`expected ArrayBufferSource but got ${value}`, options);
        }, true),
        ...encoding2 ? [Schema.transform(Schema.string(), (value, options) => {
          try {
            return encoding2 === "base64" ? Binary.fromBase64(value) : Binary.fromHex(value);
          } catch (e) {
            throw new ValidationError(e.message, options);
          }
        }, true)] : []
      ]);
    }, "arrayBuffer");
    Schema.extend("lazy", (data, schema, options, strict) => {
      if (!schema.inner[kSchema]) {
        schema.inner = schema.builder();
        schema.inner.meta = { ...schema.meta, ...schema.inner.meta };
      }
      return Schema.resolve(data, schema.inner, options, strict);
    });
    Schema.extend("any", (data) => {
      return [data];
    });
    Schema.extend("never", (data, _, options) => {
      throw new ValidationError(`expected nullable but got ${data}`, options);
    });
    Schema.extend("const", (data, { value }, options) => {
      if (deepEqual(data, value)) return [value];
      throw new ValidationError(`expected ${value} but got ${data}`, options);
    });
    function checkWithinRange(data, meta2, description, options, skipMin = false) {
      const { max: max2 = Infinity, min: min2 = -Infinity } = meta2;
      if (data > max2) throw new ValidationError(`expected ${description} <= ${max2} but got ${data}`, options);
      if (data < min2 && !skipMin) throw new ValidationError(`expected ${description} >= ${min2} but got ${data}`, options);
    }
    __name$8(checkWithinRange, "checkWithinRange");
    Schema.extend("string", (data, { meta: meta2 }, options) => {
      if (typeof data !== "string") throw new ValidationError(`expected string but got ${data}`, options);
      if (meta2.pattern) {
        const regexp = new RegExp(meta2.pattern.source, meta2.pattern.flags);
        if (!regexp.test(data)) throw new ValidationError(`expect string to match regexp ${regexp}`, options);
      }
      checkWithinRange(data.length, meta2, "string length", options);
      return [data];
    });
    function decimalShift(data, digits) {
      const str = data.toString();
      if (str.includes("e")) return data * Math.pow(10, digits);
      const index2 = str.indexOf(".");
      if (index2 === -1) return data * Math.pow(10, digits);
      const frac = str.slice(index2 + 1);
      const integer2 = str.slice(0, index2);
      if (frac.length <= digits) return +(integer2 + frac.padEnd(digits, "0"));
      return +(integer2 + frac.slice(0, digits) + "." + frac.slice(digits));
    }
    __name$8(decimalShift, "decimalShift");
    function isMultipleOf(data, min2, step) {
      step = Math.abs(step);
      if (!/^\d+\.\d+$/.test(step.toString())) {
        return (data - min2) % step === 0;
      }
      const index2 = step.toString().indexOf(".");
      const digits = step.toString().slice(index2 + 1).length;
      return Math.abs(decimalShift(data, digits) - decimalShift(min2, digits)) % decimalShift(step, digits) === 0;
    }
    __name$8(isMultipleOf, "isMultipleOf");
    Schema.extend("number", (data, { meta: meta2 }, options) => {
      if (typeof data !== "number") throw new ValidationError(`expected number but got ${data}`, options);
      checkWithinRange(data, meta2, "number", options);
      const { step } = meta2;
      if (step && !isMultipleOf(data, meta2.min ?? 0, step)) {
        throw new ValidationError(`expected number multiple of ${step} but got ${data}`, options);
      }
      return [data];
    });
    Schema.extend("boolean", (data, _, options) => {
      if (typeof data === "boolean") return [data];
      throw new ValidationError(`expected boolean but got ${data}`, options);
    });
    Schema.extend("bitset", (data, { bits, meta: meta2 }, options) => {
      let value = 0, keys = [];
      if (typeof data === "number") {
        value = data;
        for (const key2 in bits) {
          if (data & bits[key2]) {
            keys.push(key2);
          }
        }
      } else if (Array.isArray(data)) {
        keys = data;
        for (const key2 of keys) {
          if (typeof key2 !== "string") throw new ValidationError(`expected string but got ${key2}`, options);
          if (key2 in bits) value |= bits[key2];
        }
      } else {
        throw new ValidationError(`expected number or array but got ${data}`, options);
      }
      if (value === meta2.default) return [value];
      return [value, keys];
    });
    Schema.extend("function", (data, _, options) => {
      if (typeof data === "function") return [data];
      throw new ValidationError(`expected function but got ${data}`, options);
    });
    Schema.extend("is", (data, { constructor }, options) => {
      if (typeof constructor === "function") {
        if (data instanceof constructor) return [data];
        throw new ValidationError(`expected ${constructor.name} but got ${data}`, options);
      } else {
        if (isNullable(data)) {
          throw new ValidationError(`expected ${constructor} but got ${data}`, options);
        }
        let prototype = Object.getPrototypeOf(data);
        while (prototype) {
          if (prototype.constructor?.name === constructor) return [data];
          prototype = Object.getPrototypeOf(prototype);
        }
        throw new ValidationError(`expected ${constructor} but got ${data}`, options);
      }
    });
    function property(data, key2, schema, options) {
      try {
        const [value, adapted] = Schema.resolve(data[key2], schema, {
          ...options,
          path: [...options.path || [], key2]
        });
        if (adapted !== void 0) data[key2] = adapted;
        return value;
      } catch (e) {
        if (!options?.autofix) throw e;
        delete data[key2];
        return schema.meta.default;
      }
    }
    __name$8(property, "property");
    Schema.extend("array", (data, { inner, meta: meta2 }, options) => {
      if (!Array.isArray(data)) throw new ValidationError(`expected array but got ${data}`, options);
      checkWithinRange(data.length, meta2, "array length", options, !isNullable(inner.meta.default));
      return [data.map((_, index2) => property(data, index2, inner, options))];
    });
    Schema.extend("dict", (data, { inner, sKey }, options, strict) => {
      if (!isPlainObject$1(data)) throw new ValidationError(`expected object but got ${data}`, options);
      const result = {};
      for (const key2 in data) {
        let rKey;
        try {
          rKey = Schema.resolve(key2, sKey, options)[0];
        } catch (error2) {
          if (strict) continue;
          throw error2;
        }
        result[rKey] = property(data, key2, inner, options);
        data[rKey] = data[key2];
        if (key2 !== rKey) delete data[key2];
      }
      return [result];
    });
    Schema.extend("tuple", (data, { list }, options, strict) => {
      if (!Array.isArray(data)) throw new ValidationError(`expected array but got ${data}`, options);
      const result = list.map((inner, index2) => property(data, index2, inner, options));
      if (strict) return [result];
      result.push(...data.slice(list.length));
      return [result];
    });
    function merge2(result, data) {
      for (const key2 in data) {
        if (key2 in result) continue;
        result[key2] = data[key2];
      }
    }
    __name$8(merge2, "merge");
    Schema.extend("object", (data, { dict }, options, strict) => {
      if (!isPlainObject$1(data)) throw new ValidationError(`expected object but got ${data}`, options);
      const result = {};
      for (const key2 in dict) {
        const value = property(data, key2, dict[key2], options);
        if (!isNullable(value) || key2 in data) {
          result[key2] = value;
        }
      }
      if (!strict) merge2(result, data);
      return [result];
    });
    Schema.extend("union", (data, { list, toString }, options, strict) => {
      for (const inner of list) {
        try {
          return Schema.resolve(data, inner, options, strict);
        } catch (error2) {
        }
      }
      throw new ValidationError(`expected ${toString()} but got ${JSON.stringify(data)}`, options);
    });
    Schema.extend("intersect", (data, { list, toString }, options, strict) => {
      if (!list.length) return [data];
      let result;
      for (const inner of list) {
        const value = Schema.resolve(data, inner, options, true)[0];
        if (isNullable(value)) continue;
        if (isNullable(result)) {
          result = value;
        } else if (typeof result !== typeof value) {
          throw new ValidationError(`expected ${toString()} but got ${JSON.stringify(data)}`, options);
        } else if (typeof value === "object") {
          merge2(result ??= {}, value);
        } else if (result !== value) {
          throw new ValidationError(`expected ${toString()} but got ${JSON.stringify(data)}`, options);
        }
      }
      if (!strict && isPlainObject$1(data)) merge2(result, data);
      return [result];
    });
    Schema.extend("transform", (data, { inner, callback, preserve }, options) => {
      const [result, adapted = data] = Schema.resolve(data, inner, options, true);
      if (preserve) {
        return [callback(result)];
      } else {
        return [callback(result), callback(adapted)];
      }
    });
    var formatters = {};
    function defineMethod(name, keys, format) {
      formatters[name] = format;
      Object.assign(Schema, {
        [name](...args) {
          const schema = new Schema({ type: name });
          keys.forEach((key2, index2) => {
            switch (key2) {
              case "sKey":
                schema.sKey = args[index2] ?? Schema.string();
                break;
              case "inner":
                schema.inner = Schema.from(args[index2]);
                break;
              case "list":
                schema.list = args[index2].map(Schema.from);
                break;
              case "dict":
                schema.dict = valueMap(args[index2], Schema.from);
                break;
              case "bits": {
                schema.bits = {};
                for (const key22 in args[index2]) {
                  if (typeof args[index2][key22] !== "number") continue;
                  schema.bits[key22] = args[index2][key22];
                }
                break;
              }
              case "callback": {
                const callback = schema.callback = args[index2];
                callback["toJSON"] ||= () => callback.toString();
                break;
              }
              case "constructor": {
                const constructor = schema.constructor = args[index2];
                if (typeof constructor === "function") {
                  constructor["toJSON"] ||= () => constructor["name"];
                }
                break;
              }
              default:
                schema[key2] = args[index2];
            }
          });
          if (name === "object" || name === "dict") {
            schema.meta.default = {};
          } else if (name === "array" || name === "tuple") {
            schema.meta.default = [];
          } else if (name === "bitset") {
            schema.meta.default = 0;
          }
          return schema;
        }
      });
    }
    __name$8(defineMethod, "defineMethod");
    defineMethod("is", ["constructor"], ({ constructor }) => {
      if (typeof constructor === "function") {
        return constructor.name;
      } else {
        return constructor;
      }
    });
    defineMethod("any", [], () => "any");
    defineMethod("never", [], () => "never");
    defineMethod("const", ["value"], ({ value }) => typeof value === "string" ? JSON.stringify(value) : value);
    defineMethod("string", [], () => "string");
    defineMethod("number", [], () => "number");
    defineMethod("boolean", [], () => "boolean");
    defineMethod("bitset", ["bits"], () => "bitset");
    defineMethod("function", [], () => "function");
    defineMethod("array", ["inner"], ({ inner }) => `${inner.toString(true)}[]`);
    defineMethod("dict", ["inner", "sKey"], ({ inner, sKey }) => `{ [key: ${sKey.toString()}]: ${inner.toString()} }`);
    defineMethod("tuple", ["list"], ({ list }) => `[${list.map((inner) => inner.toString()).join(", ")}]`);
    defineMethod("object", ["dict"], ({ dict }) => {
      if (Object.keys(dict).length === 0) return "{}";
      return `{ ${Object.entries(dict).map(([key2, inner]) => {
        return `${key2}${inner.meta.required ? "" : "?"}: ${inner.toString()}`;
      }).join(", ")} }`;
    });
    defineMethod("union", ["list"], ({ list }, inline) => {
      const result = list.map(({ toString: format }) => format()).join(" | ");
      return inline ? `(${result})` : result;
    });
    defineMethod("intersect", ["list"], ({ list }) => {
      return `${list.map((inner) => inner.toString(true)).join(" & ")}`;
    });
    defineMethod("transform", ["inner", "callback", "preserve"], ({ inner }, isInner) => inner.toString(isInner));
    module.exports = Schema;
  }
});
const z$2 = require_index$1();
var __defProp$8 = Object.defineProperty;
var __name$7 = (target, value) => __defProp$8(target, "name", { value, configurable: true });
var kSchemaOrder = /* @__PURE__ */ Symbol("cordis.schema.order");
var SchemaService = class {
  constructor(ctx) {
    this.ctx = ctx;
    defineProperty(this, Service.tracker, {
      property: "ctx"
    });
  }
  static {
    __name$7(this, "SchemaService");
  }
  _data = z$2.intersect([]);
  extend(schema, order = 0) {
    const index2 = this._data.list.findIndex((a) => a[kSchemaOrder] < order);
    schema[kSchemaOrder] = order;
    return this.ctx.effect(() => {
      if (index2 >= 0) {
        this._data.list.splice(index2, 0, schema);
      } else {
        this._data.list.push(schema);
      }
      this.ctx.emit("internal/service-schema");
      return () => {
        remove(this._data.list, schema);
        this.ctx.emit("internal/service-schema");
      };
    });
  }
  toJSON() {
    return this._data.toJSON();
  }
};
var __defProp$7 = Object.defineProperty;
var __name$6 = (target, value) => __defProp$7(target, "name", { value, configurable: true });
var TimerService = class extends Service {
  static {
    __name$6(this, "TimerService");
  }
  constructor(ctx) {
    super(ctx, "timer", true);
    ctx.mixin("timer", ["setTimeout", "setInterval", "sleep", "throttle", "debounce"]);
  }
  setTimeout(callback, delay) {
    const dispose = this[Context.current].effect(() => {
      const timer = setTimeout(() => {
        dispose();
        callback();
      }, delay);
      return () => clearTimeout(timer);
    });
    return dispose;
  }
  setInterval(callback, delay) {
    return this[Context.current].effect(() => {
      const timer = setInterval(callback, delay);
      return () => clearInterval(timer);
    });
  }
  sleep(delay) {
    const caller = this[Context.current];
    return new Promise((resolve2, reject) => {
      const dispose1 = this.setTimeout(() => {
        dispose1();
        dispose2();
        resolve2();
      }, delay);
      const dispose2 = caller.on("dispose", () => {
        dispose1();
        dispose2();
        reject(new Error("Context has been disposed"));
      });
    });
  }
  createWrapper(callback, isDisposed = false) {
    const caller = this[Context.current];
    caller.scope.assertActive();
    let timer;
    const dispose = /* @__PURE__ */ __name$6(() => {
      isDisposed = true;
      remove(caller.scope.disposables, dispose);
      clearTimeout(timer);
    }, "dispose");
    const wrapper = /* @__PURE__ */ __name$6((...args) => {
      clearTimeout(timer);
      timer = callback(args, () => !isDisposed && caller.scope.isActive);
    }, "wrapper");
    wrapper.dispose = dispose;
    caller.scope.disposables.push(dispose);
    return wrapper;
  }
  throttle(callback, delay, noTrailing) {
    let lastCall = -Infinity;
    const execute = /* @__PURE__ */ __name$6((...args) => {
      lastCall = Date.now();
      callback(...args);
    }, "execute");
    return this.createWrapper((args, isActive) => {
      const now = Date.now();
      const remaining = delay - (now - lastCall);
      if (remaining <= 0) {
        execute(...args);
      } else if (isActive()) {
        return setTimeout(execute, remaining, ...args);
      }
    }, noTrailing);
  }
  debounce(callback, delay) {
    return this.createWrapper((args, isActive) => {
      if (!isActive())
        return;
      return setTimeout(callback, delay, ...args);
    });
  }
};
var __defProp$6 = Object.defineProperty;
var __name$5 = (target, value) => __defProp$6(target, "name", { value, configurable: true });
var Context2 = class extends Context {
  static {
    __name$5(this, "Context");
  }
  baseDir;
  constructor(config2) {
    super(config2);
    this.baseDir = globalThis.process?.cwd?.() || "";
    this.provide("logger", void 0, true);
    this.provide("timer", void 0, true);
    this.plugin(LoggerService);
    this.plugin(TimerService);
  }
};
var Service2 = class extends Service {
  static {
    __name$5(this, "Service");
  }
  /** @deprecated use `this.ctx.logger` instead */
  logger;
  schema;
  constructor(...args) {
    super(...args);
    this.logger = this.ctx.logger(this.name);
    this.schema = new SchemaService(this.ctx);
  }
  [Service.setup]() {
    this.ctx = new Context2();
  }
};
function src_default$2() {
}
__name$5(src_default$2, "default");
const DATA_DIR = path__default.resolve("data");
if (!existsSync(DATA_DIR)) {
  mkdirSync(DATA_DIR);
}
const TEMP_DIR = path__default.join(DATA_DIR, "temp");
const LOG_DIR = path__default.join(DATA_DIR, "logs");
const dbDir = path__default.join(DATA_DIR, "database");
if (!existsSync(dbDir)) {
  mkdirSync(dbDir);
}
const selfInfo = {
  uid: "",
  uin: "",
  nick: "",
  online: false
};
const LOG_CACHE_SIZE = 1e3;
const logCache = [];
function getLogCache() {
  return logCache;
}
class Log {
  static name = "logger";
  constructor(ctx, cfg) {
    Logger.targets.splice(0, Logger.targets.length);
    let enable = cfg.enable;
    const file2 = path__default.join(LOG_DIR, cfg.filename);
    const target = {
      colors: 0,
      record: (record2) => {
        const dateTime = new Date(record2.timestamp);
        const dateTimeStr = `${dateTime.getFullYear()}-${(dateTime.getMonth() + 1).toString().padStart(2, "0")}-${dateTime.getDate().toString().padStart(2, "0")} ${dateTime.getHours().toString().padStart(2, "0")}:${dateTime.getMinutes().toString().padStart(2, "0")}:${dateTime.getSeconds().toString().padStart(2, "0")}`;
        let content = `${dateTimeStr} | ${record2.content}

`;
        console.log(content);
        const logRecord = {
          timestamp: record2.timestamp,
          type: record2.type,
          content: record2.content,
          dateTimeStr
        };
        logCache.push(logRecord);
        if (logCache.length > LOG_CACHE_SIZE) {
          logCache.shift();
        }
        ctx.parallel("llob/log", logRecord);
        if (!enable) {
          return;
        }
        content = `[${record2.type}] | ${content}`;
        appendFile(file2, content, noop);
      }
    };
    Logger.targets.push(target);
    ctx.on("llob/config-updated", (input) => {
      enable = input.log;
    });
  }
}
function deepStringifyMap(obj) {
  if (typeof obj !== "object" || obj === null) return obj;
  if (Array.isArray(obj)) {
    return obj.map((item) => deepStringifyMap(item));
  }
  if (obj instanceof Map) {
    return {
      __dataType: "Map",
      data: Array.from(obj.entries()).map(([k, v]) => [
        deepStringifyMap(k),
        //  key
        deepStringifyMap(v)
        //  value
      ])
    };
  }
  const convertedObj = {};
  for (const key2 in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key2)) {
      convertedObj[key2] = deepStringifyMap(obj[key2]);
    }
  }
  return convertedObj;
}
function deepConvertMap(obj) {
  if (typeof obj !== "object" || obj === null) return obj;
  if (Array.isArray(obj)) {
    return obj.map((item) => deepConvertMap(item));
  }
  const potentialMap = obj;
  if (potentialMap.__dataType === "Map" && "data" in potentialMap) {
    const entries = Array.isArray(potentialMap.data) ? potentialMap.data.map(([k, v]) => [
      deepConvertMap(k),
      deepConvertMap(v)
    ]) : [];
    return new Map(entries);
  }
  const convertedObj = {};
  for (const key2 in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key2)) {
      convertedObj[key2] = deepConvertMap(obj[key2]);
    }
  }
  return convertedObj;
}
class PMHQBase {
  reconnectTimer;
  httpUrl = "http://127.0.0.1:13000";
  wsUrl = "ws://127.0.0.1:13000/ws";
  ws;
  resListeners = /* @__PURE__ */ new Map();
  constructor() {
    console.log(process.argv);
    const { pmhqHost, pmhqPort } = this.getPMHQHostPort();
    this.httpUrl = `http://${pmhqHost}:${pmhqPort}/`;
    this.wsUrl = `ws://${pmhqHost}:${pmhqPort}/ws`;
    this.connectWebSocket().then();
  }
  get_is_connected() {
    return this.ws && this.ws.readyState === WebSocket.OPEN;
  }
  getPMHQHostPort() {
    let pmhqPort = "13000";
    let pmhqHost = "127.0.0.1";
    for (const pArg of process.argv) {
      if (pArg.startsWith("--pmhq-port=")) {
        pmhqPort = pArg.replace("--pmhq-port=", "");
      } else if (pArg.startsWith("--pmhq-host=")) {
        pmhqHost = pArg.replace("--pmhq-host=", "");
      }
    }
    return { pmhqPort, pmhqHost };
  }
  addResListener(listener) {
    const listenerId = randomUUID();
    this.resListeners.set(listenerId, listener);
    return listenerId;
  }
  removeResListener(listenerId) {
    this.resListeners.delete(listenerId);
  }
  async connectWebSocket() {
    const reconnect = () => {
      this.ws = void 0;
      if (this.reconnectTimer) {
        clearTimeout(this.reconnectTimer);
        this.reconnectTimer = void 0;
      }
      this.reconnectTimer = setTimeout(() => {
        this.connectWebSocket();
      }, 1e3);
    };
    try {
      this.ws = new WebSocket(this.wsUrl);
    } catch (e) {
      return reconnect();
    }
    this.ws.onmessage = async (event) => {
      let data;
      try {
        data = JSON.parse(event.data.toString());
      } catch (e) {
        console.error(" PMHQ ", event.data, e);
        return;
      }
      data = deepConvertMap(data);
      for (const func of this.resListeners.values()) {
        setImmediate(() => {
          try {
            func(data);
          } catch (e) {
            console.error("PMHQ res listener error", e);
          }
        });
      }
    };
    this.ws.onerror = () => {
      selfInfo.online = false;
      console.error("PMHQ WebSocket  QQ ", " QQ ...");
      reconnect();
    };
    this.ws.onclose = () => {
      selfInfo.online = false;
      console.info("PMHQ WebSocket ...");
      reconnect();
    };
    this.ws.onopen = () => {
      console.info("PMHQ WebSocket ");
    };
  }
  async call(func, args, timeout2 = 1e4) {
    const payload = {
      type: "call",
      data: { func, args }
    };
    const result = (await this.wsSend(payload, timeout2)).data?.result;
    return result;
  }
  async waitConnected() {
    return new Promise((resolve2) => {
      const check2 = () => {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          resolve2(true);
        } else {
          setTimeout(check2, 1e3);
        }
      };
      check2();
    });
  }
  async tellPort(webuiPort) {
    const echo = randomUUID();
    const payload = {
      type: "broadcast_event",
      data: { echo, type: "llbot_web_ui_port", data: { echo, port: webuiPort } }
    };
    return await this.wsSend(payload, 5e3);
  }
  async wsSend(data, timeout2 = 15e3) {
    await this.waitConnected();
    let echo = data.data?.echo;
    if (!data.data?.echo) {
      echo = randomUUID();
      data.data.echo = echo;
    }
    const payload = JSON.stringify(deepStringifyMap(data));
    const p = new Promise((resolve2, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error("pmhq ws send: wait result timeout"));
        this.removeResListener(listenerId);
      }, timeout2);
      const listenerId = this.addResListener((res) => {
        if (!res.data) {
          console.error(`PMHQ WS send error: payload ${JSON.stringify(data)}, response ${JSON.stringify(res)}`);
        }
        if (res.data?.echo == echo) {
          resolve2(res);
          clearTimeout(timeoutId);
          this.removeResListener(listenerId);
        }
      });
    });
    this.ws.send(payload);
    return p;
  }
  async httpSend(data) {
    const payload = JSON.stringify(deepStringifyMap(data));
    const response2 = await fetch(this.httpUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: payload
    });
    if (!response2.ok) {
      const errorBody = await response2.text();
      throw new Error(`PMHQPMHQ ${response2.status} - ${errorBody}`);
    }
    let result = await response2.json();
    result = deepConvertMap(result);
    return result;
  }
  async httpSendPB(cmd, pb) {
    return (await this.httpSend({
      type: "send",
      data: { cmd, pb: Buffer.from(pb).toString("hex") }
    })).data;
  }
  async wsSendPB(cmd, pb) {
    return (await this.wsSend({
      type: "send",
      data: { cmd, pb: Buffer.from(pb).toString("hex") }
    })).data;
  }
  async sendPB(cmd, hex2) {
    return (await this.wsSend({
      type: "send",
      data: { cmd, pb: hex2 }
    })).data;
  }
  async getProcessInfo() {
    try {
      return await this.call("getProcessInfo", []);
    } catch {
      return null;
    }
  }
}
var __defProp$5 = Object.defineProperty;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp$5(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField = (obj, key2, value) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
var CodedReader = class {
  constructor(buffer2) {
    __publicField(this, "buffer");
    __publicField(this, "offset");
    __publicField(this, "length");
    this.buffer = buffer2;
    this.offset = 0;
    this.length = buffer2.length;
  }
  readByte() {
    return this.buffer[this.offset++];
  }
  readBytes(length) {
    const bytes2 = this.buffer.subarray(this.offset, this.offset + length);
    this.offset += length;
    return bytes2;
  }
  readVarint() {
    let result = 0;
    let shift = 0;
    while (true) {
      const byte = this.readByte();
      result |= (byte & 127) << shift;
      if ((byte & 128) === 0) {
        break;
      }
      shift += 7;
    }
    return result >>> 0;
  }
  readVarintToBigint() {
    let result = BigInt(0);
    let shift = BigInt(0);
    while (true) {
      const byte = BigInt(this.readByte());
      result |= (byte & BigInt(127)) << shift;
      if ((byte & BigInt(128)) === BigInt(0)) {
        break;
      }
      shift += BigInt(7);
    }
    return result;
  }
  readFixed32() {
    const value = this.buffer.readUInt32LE(this.offset);
    this.offset += 4;
    return value;
  }
  readFixed64() {
    const low = this.readFixed32();
    const high = this.readFixed32();
    return BigInt(low) | BigInt(high) << BigInt(32);
  }
  readFloat() {
    const value = this.buffer.readFloatLE(this.offset);
    this.offset += 4;
    return value;
  }
  readDouble() {
    const value = this.buffer.readDoubleLE(this.offset);
    this.offset += 8;
    return value;
  }
  readTag() {
    const tag = this.readVarint();
    return {
      fieldNumber: tag >>> 3,
      wireType: tag & 7
    };
  }
  skip(wireType) {
    if (wireType === 0) {
      this.readVarint();
    } else if (wireType === 1) {
      this.offset += 8;
    } else if (wireType === 5) {
      this.offset += 4;
    } else if (wireType === 2) {
      const length = this.readVarint();
      this.offset += length;
    }
  }
};
var CodedWriter = class {
  constructor(size) {
    __publicField(this, "buffer");
    __publicField(this, "offset");
    this.buffer = Buffer.allocUnsafe(size);
    this.offset = 0;
  }
  writeRawByte(value) {
    this.buffer[this.offset++] = value;
  }
  writeRawBytes(bytes2) {
    bytes2.copy(this.buffer, this.offset);
    this.offset += bytes2.length;
  }
  writeVarint(value) {
    while (value > 127) {
      this.writeRawByte(value & 127 | 128);
      value >>>= 7;
    }
    this.writeRawByte(value & 127);
  }
  writeBigVarint(value) {
    while (value > BigInt(127)) {
      this.writeRawByte(Number(value & BigInt(127) | BigInt(128)));
      value >>= BigInt(7);
    }
    this.writeRawByte(Number(value & BigInt(127)));
  }
  writeFixed32(value) {
    this.buffer.writeUInt32LE(value, this.offset);
    this.offset += 4;
  }
  writeFixed64(value) {
    const low = Number(value & BigInt(4294967295));
    const high = Number(value >> BigInt(32) & BigInt(4294967295));
    this.writeFixed32(low);
    this.writeFixed32(high);
  }
  writeFloat(value) {
    this.buffer.writeFloatLE(value, this.offset);
    this.offset += 4;
  }
  writeDouble(value) {
    this.buffer.writeDoubleLE(value, this.offset);
    this.offset += 8;
  }
  build() {
    return this.buffer;
  }
};
var MAX_UINT64 = 2n ** 64n;
var MAX_INT64 = 2n ** 63n;
var Converter = class {
  static tag(fieldNumber, wireType) {
    return fieldNumber << 3 | wireType;
  }
  static toSigned32(value) {
    return value | 0;
  }
  static toSigned64(value) {
    return value >= MAX_INT64 ? value - MAX_UINT64 : value;
  }
  static toUnsigned32(value) {
    return value >>> 0;
  }
  static toUnsigned64(value) {
    return value < 0 ? value + MAX_UINT64 : value;
  }
  static zigzagEncode32(n) {
    return n << 1 ^ n >> 31;
  }
  static zigzagEncode64(n) {
    return n << BigInt(1) ^ n >> BigInt(63);
  }
  static zigzagDecode32(n) {
    return n >>> 1 ^ -(n & 1);
  }
  static zigzagDecode64(n) {
    return n >> BigInt(1) ^ -(n & BigInt(1));
  }
};
var Fixed32Size = 4;
var Fixed64Size = 8;
var FloatSize = Fixed32Size;
var DoubleSize = Fixed64Size;
var ScalarDeserializerCompiler = {
  double: (key2, spec) => spec.repeated ? (draft, reader, wireType) => {
    if (wireType === 2) {
      const count = reader.readVarint() / DoubleSize;
      for (let i = 0; i < count; i++) {
        draft[key2].push(reader.readDouble());
      }
    } else {
      draft[key2].push(reader.readDouble());
    }
  } : (draft, reader) => {
    draft[key2] = reader.readDouble();
  },
  float: (key2, spec) => spec.repeated ? (draft, reader, wireType) => {
    if (wireType === 2) {
      const count = reader.readVarint() / FloatSize;
      for (let i = 0; i < count; i++) {
        draft[key2].push(reader.readFloat());
      }
    } else {
      draft[key2].push(reader.readFloat());
    }
  } : (draft, reader) => {
    draft[key2] = reader.readFloat();
  },
  int64: (key2, spec) => spec.repeated ? (draft, reader, wireType) => {
    if (wireType === 2) {
      const length = reader.readVarint();
      const endOffset = reader.offset + length;
      while (reader.offset < endOffset) {
        draft[key2].push(Converter.toSigned64(reader.readVarintToBigint()));
      }
    } else {
      draft[key2].push(Converter.toSigned64(reader.readVarintToBigint()));
    }
  } : (draft, reader) => {
    draft[key2] = Converter.toSigned64(reader.readVarintToBigint());
  },
  uint64: (key2, spec) => spec.repeated ? (draft, reader, wireType) => {
    if (wireType === 2) {
      const length = reader.readVarint();
      const endOffset = reader.offset + length;
      while (reader.offset < endOffset) {
        draft[key2].push(reader.readVarintToBigint());
      }
    } else {
      draft[key2].push(reader.readVarintToBigint());
    }
  } : (draft, reader) => {
    draft[key2] = reader.readVarintToBigint();
  },
  int32: (key2, spec) => spec.repeated ? (draft, reader, wireType) => {
    if (wireType === 2) {
      const length = reader.readVarint();
      const endOffset = reader.offset + length;
      while (reader.offset < endOffset) {
        draft[key2].push(Converter.toSigned32(reader.readVarint()));
      }
    } else {
      draft[key2].push(Converter.toSigned32(reader.readVarint()));
    }
  } : (draft, reader) => {
    draft[key2] = Converter.toSigned32(reader.readVarint());
  },
  fixed64: (key2, spec) => spec.repeated ? (draft, reader, wireType) => {
    if (wireType === 2) {
      const count = reader.readVarint() / Fixed64Size;
      for (let i = 0; i < count; i++) {
        draft[key2].push(reader.readFixed64());
      }
    } else {
      draft[key2].push(reader.readFixed64());
    }
  } : (draft, reader) => {
    draft[key2] = reader.readFixed64();
  },
  fixed32: (key2, spec) => spec.repeated ? (draft, reader, wireType) => {
    if (wireType === 2) {
      const count = reader.readVarint() / Fixed32Size;
      for (let i = 0; i < count; i++) {
        draft[key2].push(reader.readFixed32());
      }
    } else {
      draft[key2].push(reader.readFixed32());
    }
  } : (draft, reader) => {
    draft[key2] = reader.readFixed32();
  },
  bool: (key2, spec) => spec.repeated ? (draft, reader, wireType) => {
    if (wireType === 2) {
      const count = reader.readVarint();
      for (let i = 0; i < count; i++) {
        draft[key2].push(reader.readVarint() !== 0);
      }
    } else {
      draft[key2].push(reader.readVarint() !== 0);
    }
  } : (draft, reader) => {
    draft[key2] = reader.readVarint() !== 0;
  },
  string: (key2, spec) => spec.repeated ? (draft, reader) => {
    draft[key2].push(reader.readBytes(reader.readVarint()).toString());
  } : (draft, reader) => {
    draft[key2] = reader.readBytes(reader.readVarint()).toString();
  },
  bytes: (key2, spec) => spec.repeated ? (draft, reader) => {
    draft[key2].push(reader.readBytes(reader.readVarint()));
  } : (draft, reader) => {
    draft[key2] = reader.readBytes(reader.readVarint());
  },
  uint32: (key2, spec) => spec.repeated ? (draft, reader, wireType) => {
    if (wireType === 2) {
      const length = reader.readVarint();
      const endOffset = reader.offset + length;
      while (reader.offset < endOffset) {
        draft[key2].push(reader.readVarint());
      }
    } else {
      draft[key2].push(reader.readVarint());
    }
  } : (draft, reader) => {
    draft[key2] = reader.readVarint();
  },
  sfixed32: (key2, spec) => spec.repeated ? (draft, reader, wireType) => {
    if (wireType === 2) {
      const count = reader.readVarint() / Fixed32Size;
      for (let i = 0; i < count; i++) {
        draft[key2].push(Converter.zigzagDecode32(reader.readFixed32()));
      }
    } else {
      draft[key2].push(Converter.zigzagDecode32(reader.readFixed32()));
    }
  } : (draft, reader) => {
    draft[key2] = Converter.zigzagDecode32(reader.readFixed32());
  },
  sfixed64: (key2, spec) => spec.repeated ? (draft, reader, wireType) => {
    if (wireType === 2) {
      const count = reader.readVarint() / Fixed64Size;
      for (let i = 0; i < count; i++) {
        draft[key2].push(Converter.zigzagDecode64(reader.readFixed64()));
      }
    } else {
      draft[key2].push(Converter.zigzagDecode64(reader.readFixed64()));
    }
  } : (draft, reader) => {
    draft[key2] = Converter.zigzagDecode64(reader.readFixed64());
  },
  sint32: (key2, spec) => spec.repeated ? (draft, reader, wireType) => {
    if (wireType === 2) {
      const length = reader.readVarint();
      const endOffset = reader.offset + length;
      while (reader.offset < endOffset) {
        draft[key2].push(Converter.zigzagDecode32(reader.readVarint()));
      }
    } else {
      draft[key2].push(Converter.zigzagDecode32(reader.readVarint()));
    }
  } : (draft, reader) => {
    draft[key2] = Converter.zigzagDecode32(reader.readVarint());
  },
  sint64: (key2, spec) => spec.repeated ? (draft, reader, wireType) => {
    if (wireType === 2) {
      const length = reader.readVarint();
      const endOffset = reader.offset + length;
      while (reader.offset < endOffset) {
        draft[key2].push(Converter.zigzagDecode64(reader.readVarintToBigint()));
      }
    } else {
      draft[key2].push(Converter.zigzagDecode64(reader.readVarintToBigint()));
    }
  } : (draft, reader) => {
    draft[key2] = Converter.zigzagDecode64(reader.readVarintToBigint());
  }
};
var VARINT32_BYTE_2 = 128;
var VARINT32_BYTE_3 = 16384;
var VARINT32_BYTE_4 = 2097152;
var VARINT32_BYTE_5 = 268435456;
var VARINT64_BYTE_2 = BigInt(1) << BigInt(7);
var VARINT64_BYTE_3 = BigInt(1) << BigInt(14);
var VARINT64_BYTE_4 = BigInt(1) << BigInt(21);
var VARINT64_BYTE_5 = BigInt(1) << BigInt(28);
var VARINT64_BYTE_6 = BigInt(1) << BigInt(35);
var VARINT64_BYTE_7 = BigInt(1) << BigInt(42);
var VARINT64_BYTE_8 = BigInt(1) << BigInt(49);
var VARINT64_BYTE_9 = BigInt(1) << BigInt(56);
var VARINT64_BYTE_10 = BigInt(1) << BigInt(63);
function sumVarint32Array(data, mapper) {
  let total = 0;
  if (mapper) {
    for (let i = 0; i < data.length; i++) {
      total += SizeOf.varint32(mapper(data[i]));
    }
  } else {
    for (let i = 0; i < data.length; i++) {
      total += SizeOf.varint32(data[i]);
    }
  }
  return total;
}
function sumVarint64Array(data, mapper) {
  let total = 0;
  if (mapper) {
    for (let i = 0; i < data.length; i++) {
      total += SizeOf.varint64(mapper(data[i]));
    }
  } else {
    for (let i = 0; i < data.length; i++) {
      total += SizeOf.varint64(data[i]);
    }
  }
  return total;
}
function sumLengthDelimited(data, sizeOfItem) {
  let total = 0;
  for (let i = 0; i < data.length; i++) {
    const itemSize = sizeOfItem(data[i]);
    total += SizeOf.varint32(itemSize) + itemSize;
  }
  return total;
}
var SizeOf = class {
  static varint32(value) {
    value >>>= 0;
    if (value < VARINT32_BYTE_2) return 1;
    if (value < VARINT32_BYTE_3) return 2;
    if (value < VARINT32_BYTE_4) return 3;
    if (value < VARINT32_BYTE_5) return 4;
    return 5;
  }
  static varint64(value) {
    if (value < VARINT64_BYTE_2) return 1;
    if (value < VARINT64_BYTE_3) return 2;
    if (value < VARINT64_BYTE_4) return 3;
    if (value < VARINT64_BYTE_5) return 4;
    if (value < VARINT64_BYTE_6) return 5;
    if (value < VARINT64_BYTE_7) return 6;
    if (value < VARINT64_BYTE_8) return 7;
    if (value < VARINT64_BYTE_9) return 8;
    if (value < VARINT64_BYTE_10) return 9;
    return 10;
  }
};
var ScalarSizeCalculatorCompiler = {
  double: (spec) => spec.repeated ? spec.packed ? (data) => {
    const bodySize = data.length * DoubleSize;
    return spec[kTagLength] + SizeOf.varint32(bodySize) + bodySize;
  } : (data) => data.length * (DoubleSize + spec[kTagLength]) : () => spec[kTagLength] + DoubleSize,
  float: (spec) => spec.repeated ? spec.packed ? (data) => {
    const bodySize = data.length * FloatSize;
    return spec[kTagLength] + SizeOf.varint32(bodySize) + bodySize;
  } : (data) => data.length * (FloatSize + spec[kTagLength]) : () => spec[kTagLength] + FloatSize,
  int64: (spec) => spec.repeated ? spec.packed ? (data, cache) => {
    const bodySize = sumVarint64Array(data, Converter.toUnsigned64);
    cache.set(data, bodySize);
    return spec[kTagLength] + SizeOf.varint32(bodySize) + bodySize;
  } : (data) => sumVarint64Array(data, Converter.toUnsigned64) + spec[kTagLength] * data.length : (data) => spec[kTagLength] + SizeOf.varint64(Converter.toUnsigned64(data)),
  uint64: (spec) => spec.repeated ? spec.packed ? (data, cache) => {
    const bodySize = sumVarint64Array(data);
    cache.set(data, bodySize);
    return spec[kTagLength] + SizeOf.varint32(bodySize) + bodySize;
  } : (data) => sumVarint64Array(data) + spec[kTagLength] * data.length : (data) => spec[kTagLength] + SizeOf.varint64(data),
  int32: (spec) => spec.repeated ? spec.packed ? (data, cache) => {
    const bodySize = sumVarint32Array(data, Converter.toUnsigned32);
    cache.set(data, bodySize);
    return spec[kTagLength] + SizeOf.varint32(bodySize) + bodySize;
  } : (data) => sumVarint32Array(data, Converter.toUnsigned32) + spec[kTagLength] * data.length : (data) => spec[kTagLength] + SizeOf.varint32(Converter.toUnsigned32(data)),
  fixed64: (spec) => spec.repeated ? spec.packed ? (data) => {
    const bodySize = data.length * Fixed64Size;
    return spec[kTagLength] + SizeOf.varint32(bodySize) + bodySize;
  } : (data) => data.length * (Fixed64Size + spec[kTagLength]) : () => spec[kTagLength] + Fixed64Size,
  fixed32: (spec) => spec.repeated ? spec.packed ? (data) => {
    const bodySize = data.length * Fixed32Size;
    return spec[kTagLength] + SizeOf.varint32(bodySize) + bodySize;
  } : (data) => data.length * (Fixed32Size + spec[kTagLength]) : () => spec[kTagLength] + Fixed32Size,
  bool: (spec) => spec.repeated ? spec.packed ? (data) => {
    const bodySize = data.length;
    return spec[kTagLength] + SizeOf.varint32(bodySize) + bodySize;
  } : (data) => data.length * (1 + spec[kTagLength]) : () => spec[kTagLength] + 1,
  string: (spec) => spec.repeated ? (data) => {
    return sumLengthDelimited(data, (item) => Buffer.byteLength(item)) + spec[kTagLength] * data.length;
  } : (data) => {
    const itemSize = Buffer.byteLength(data);
    return spec[kTagLength] + SizeOf.varint32(itemSize) + itemSize;
  },
  bytes: (spec) => spec.repeated ? (data) => {
    return sumLengthDelimited(data, (item) => item.length) + spec[kTagLength] * data.length;
  } : (data) => {
    const itemSize = data.length;
    return spec[kTagLength] + SizeOf.varint32(itemSize) + itemSize;
  },
  uint32: (spec) => spec.repeated ? spec.packed ? (data, cache) => {
    const bodySize = sumVarint32Array(data);
    cache.set(data, bodySize);
    return spec[kTagLength] + SizeOf.varint32(bodySize) + bodySize;
  } : (data) => sumVarint32Array(data) + spec[kTagLength] * data.length : (data) => spec[kTagLength] + SizeOf.varint32(data),
  sfixed32: (spec) => spec.repeated ? spec.packed ? (data) => {
    const bodySize = data.length * Fixed32Size;
    return spec[kTagLength] + SizeOf.varint32(bodySize) + bodySize;
  } : (data) => data.length * (Fixed32Size + spec[kTagLength]) : () => spec[kTagLength] + Fixed32Size,
  sfixed64: (spec) => spec.repeated ? spec.packed ? (data) => {
    const bodySize = data.length * Fixed64Size;
    return spec[kTagLength] + SizeOf.varint32(bodySize) + bodySize;
  } : (data) => data.length * (Fixed64Size + spec[kTagLength]) : () => spec[kTagLength] + Fixed64Size,
  sint32: (spec) => spec.repeated ? spec.packed ? (data, cache) => {
    const bodySize = sumVarint32Array(data, Converter.zigzagEncode32);
    cache.set(data, bodySize);
    return spec[kTagLength] + SizeOf.varint32(bodySize) + bodySize;
  } : (data) => sumVarint32Array(data, Converter.zigzagEncode32) + spec[kTagLength] * data.length : (data) => spec[kTagLength] + SizeOf.varint32(Converter.zigzagEncode32(data)),
  sint64: (spec) => spec.repeated ? spec.packed ? (data, cache) => {
    const bodySize = sumVarint64Array(data, Converter.zigzagEncode64);
    cache.set(data, bodySize);
    return spec[kTagLength] + SizeOf.varint32(bodySize) + bodySize;
  } : (data) => sumVarint64Array(data, Converter.zigzagEncode64) + spec[kTagLength] * data.length : (data) => spec[kTagLength] + SizeOf.varint64(Converter.zigzagEncode64(data))
};
var kTag = /* @__PURE__ */ Symbol("Cached Tag");
var kTagLength = /* @__PURE__ */ Symbol("Cached Tag Length");
var ScalarTypeToWireType = {
  double: 1,
  float: 5,
  int64: 0,
  uint64: 0,
  int32: 0,
  fixed64: 1,
  fixed32: 5,
  bool: 0,
  string: 2,
  bytes: 2,
  uint32: 0,
  sfixed32: 5,
  sfixed64: 1,
  sint32: 0,
  sint64: 0
  /* Varint */
};
function ProtoField(fieldNumber, type2, modifier, options) {
  if (modifier === "repeated" && options?.packed === void 0) {
    options = { ...options, packed: true };
  }
  const tag = Converter.tag(
    fieldNumber,
    typeof type2 === "function" || typeof type2 === "object" ? 2 : options?.packed ? 2 : ScalarTypeToWireType[type2]
  );
  return {
    fieldNumber,
    type: type2,
    optional: modifier === "optional",
    repeated: modifier === "repeated",
    packed: options?.packed,
    [kTag]: tag,
    [kTagLength]: SizeOf.varint32(tag)
  };
}
function defineSerializer(s) {
  return s;
}
var ScalarSerializerCompiler = {
  double: (spec) => spec.repeated ? spec.packed ? defineSerializer((data, writer) => {
    const length = data.length * DoubleSize;
    writer.writeVarint(spec[kTag]);
    writer.writeVarint(length);
    for (const value of data) {
      writer.writeDouble(value);
    }
  }) : defineSerializer((data, writer) => {
    for (const value of data) {
      writer.writeVarint(spec[kTag]);
      writer.writeDouble(value);
    }
  }) : defineSerializer((data, writer) => {
    writer.writeVarint(spec[kTag]);
    writer.writeDouble(data);
  }),
  float: (spec) => spec.repeated ? spec.packed ? defineSerializer((data, writer) => {
    const length = data.length * FloatSize;
    writer.writeVarint(spec[kTag]);
    writer.writeVarint(length);
    for (const value of data) {
      writer.writeFloat(value);
    }
  }) : defineSerializer((data, writer) => {
    for (const value of data) {
      writer.writeVarint(spec[kTag]);
      writer.writeFloat(value);
    }
  }) : defineSerializer((data, writer) => {
    writer.writeVarint(spec[kTag]);
    writer.writeFloat(data);
  }),
  int64: (spec) => spec.repeated ? spec.packed ? defineSerializer((data, writer, lengthCache) => {
    const length = lengthCache.get(data);
    writer.writeVarint(spec[kTag]);
    writer.writeVarint(length);
    for (const value of data) {
      writer.writeBigVarint(Converter.toUnsigned64(value));
    }
  }) : defineSerializer((data, writer) => {
    for (const value of data) {
      writer.writeVarint(spec[kTag]);
      writer.writeBigVarint(Converter.toUnsigned64(value));
    }
  }) : defineSerializer((data, writer) => {
    writer.writeVarint(spec[kTag]);
    writer.writeBigVarint(Converter.toUnsigned64(data));
  }),
  uint64: (spec) => spec.repeated ? spec.packed ? defineSerializer((data, writer, lengthCache) => {
    const length = lengthCache.get(data);
    writer.writeVarint(spec[kTag]);
    writer.writeVarint(length);
    for (const value of data) {
      writer.writeBigVarint(value);
    }
  }) : defineSerializer((data, writer) => {
    for (const value of data) {
      writer.writeVarint(spec[kTag]);
      writer.writeBigVarint(value);
    }
  }) : defineSerializer((data, writer) => {
    writer.writeVarint(spec[kTag]);
    writer.writeBigVarint(data);
  }),
  int32: (spec) => spec.repeated ? spec.packed ? defineSerializer((data, writer, lengthCache) => {
    const length = lengthCache.get(data);
    writer.writeVarint(spec[kTag]);
    writer.writeVarint(length);
    for (const value of data) {
      writer.writeVarint(Converter.toUnsigned32(value));
    }
  }) : defineSerializer((data, writer) => {
    for (const value of data) {
      writer.writeVarint(spec[kTag]);
      writer.writeVarint(Converter.toUnsigned32(value));
    }
  }) : defineSerializer((data, writer) => {
    writer.writeVarint(spec[kTag]);
    writer.writeVarint(Converter.toUnsigned32(data));
  }),
  fixed64: (spec) => spec.repeated ? spec.packed ? defineSerializer((data, writer) => {
    const length = data.length * Fixed64Size;
    writer.writeVarint(spec[kTag]);
    writer.writeVarint(length);
    for (const value of data) {
      writer.writeFixed64(value);
    }
  }) : defineSerializer((data, writer) => {
    for (const value of data) {
      writer.writeVarint(spec[kTag]);
      writer.writeFixed64(value);
    }
  }) : defineSerializer((data, writer) => {
    writer.writeVarint(spec[kTag]);
    writer.writeFixed64(data);
  }),
  fixed32: (spec) => spec.repeated ? spec.packed ? defineSerializer((data, writer) => {
    const length = data.length * Fixed32Size;
    writer.writeVarint(spec[kTag]);
    writer.writeVarint(length);
    for (const value of data) {
      writer.writeFixed32(value);
    }
  }) : defineSerializer((data, writer) => {
    for (const value of data) {
      writer.writeVarint(spec[kTag]);
      writer.writeFixed32(value);
    }
  }) : defineSerializer((data, writer) => {
    writer.writeVarint(spec[kTag]);
    writer.writeFixed32(data);
  }),
  bool: (spec) => spec.repeated ? spec.packed ? defineSerializer((data, writer) => {
    const length = data.length;
    writer.writeVarint(spec[kTag]);
    writer.writeVarint(length);
    for (const value of data) {
      writer.writeRawByte(value ? 1 : 0);
    }
  }) : defineSerializer((data, writer) => {
    for (const value of data) {
      writer.writeVarint(spec[kTag]);
      writer.writeRawByte(value ? 1 : 0);
    }
  }) : defineSerializer((data, writer) => {
    writer.writeVarint(spec[kTag]);
    writer.writeRawByte(data ? 1 : 0);
  }),
  string: (spec) => spec.repeated ? defineSerializer((data, writer) => {
    for (const value of data) {
      writer.writeVarint(spec[kTag]);
      writer.writeVarint(Buffer.byteLength(value));
      writer.writeRawBytes(Buffer.from(value));
    }
  }) : defineSerializer((data, writer) => {
    writer.writeVarint(spec[kTag]);
    writer.writeVarint(Buffer.byteLength(data));
    writer.writeRawBytes(Buffer.from(data));
  }),
  bytes: (spec) => spec.repeated ? defineSerializer((data, writer) => {
    for (const value of data) {
      writer.writeVarint(spec[kTag]);
      writer.writeVarint(value.length);
      writer.writeRawBytes(value);
    }
  }) : defineSerializer((data, writer) => {
    writer.writeVarint(spec[kTag]);
    writer.writeVarint(data.length);
    writer.writeRawBytes(data);
  }),
  uint32: (spec) => spec.repeated ? spec.packed ? defineSerializer((data, writer, lengthCache) => {
    const length = lengthCache.get(data);
    writer.writeVarint(spec[kTag]);
    writer.writeVarint(length);
    for (const value of data) {
      writer.writeVarint(Converter.toUnsigned32(value));
    }
  }) : defineSerializer((data, writer) => {
    for (const value of data) {
      writer.writeVarint(spec[kTag]);
      writer.writeVarint(Converter.toUnsigned32(value));
    }
  }) : defineSerializer((data, writer) => {
    writer.writeVarint(spec[kTag]);
    writer.writeVarint(Converter.toUnsigned32(data));
  }),
  sfixed32: (spec) => spec.repeated ? spec.packed ? defineSerializer((data, writer) => {
    const length = data.length * Fixed32Size;
    writer.writeVarint(spec[kTag]);
    writer.writeVarint(length);
    for (const value of data) {
      writer.writeFixed32(Converter.zigzagEncode32(value));
    }
  }) : defineSerializer((data, writer) => {
    for (const value of data) {
      writer.writeVarint(spec[kTag]);
      writer.writeFixed32(Converter.zigzagEncode32(value));
    }
  }) : defineSerializer((data, writer) => {
    writer.writeVarint(spec[kTag]);
    writer.writeFixed32(Converter.zigzagEncode32(data));
  }),
  sfixed64: (spec) => spec.repeated ? spec.packed ? defineSerializer((data, writer) => {
    const length = data.length * Fixed64Size;
    writer.writeVarint(spec[kTag]);
    writer.writeVarint(length);
    for (const value of data) {
      writer.writeFixed64(Converter.zigzagEncode64(value));
    }
  }) : defineSerializer((data, writer) => {
    for (const value of data) {
      writer.writeVarint(spec[kTag]);
      writer.writeFixed64(Converter.zigzagEncode64(value));
    }
  }) : defineSerializer((data, writer) => {
    writer.writeVarint(spec[kTag]);
    writer.writeFixed64(Converter.zigzagEncode64(data));
  }),
  sint32: (spec) => spec.repeated ? spec.packed ? defineSerializer((data, writer) => {
    const length = data.length * Fixed32Size;
    writer.writeVarint(spec[kTag]);
    writer.writeVarint(length);
    for (const value of data) {
      writer.writeVarint(Converter.zigzagEncode32(value));
    }
  }) : defineSerializer((data, writer) => {
    for (const value of data) {
      writer.writeVarint(spec[kTag]);
      writer.writeVarint(Converter.zigzagEncode32(value));
    }
  }) : defineSerializer((data, writer) => {
    writer.writeVarint(spec[kTag]);
    writer.writeVarint(Converter.zigzagEncode32(data));
  }),
  sint64: (spec) => spec.repeated ? spec.packed ? defineSerializer((data, writer, lengthCache) => {
    const length = lengthCache.get(data);
    writer.writeVarint(spec[kTag]);
    writer.writeVarint(length);
    for (const value of data) {
      writer.writeBigVarint(Converter.zigzagEncode64(value));
    }
  }) : defineSerializer((data, writer) => {
    for (const value of data) {
      writer.writeVarint(spec[kTag]);
      writer.writeBigVarint(Converter.zigzagEncode64(value));
    }
  }) : defineSerializer((data, writer) => {
    writer.writeVarint(spec[kTag]);
    writer.writeBigVarint(Converter.zigzagEncode64(data));
  })
};
var ScalarTypeDefaultValue = {
  double: 0,
  float: 0,
  int64: BigInt(0),
  uint64: BigInt(0),
  int32: 0,
  fixed64: BigInt(0),
  fixed32: 0,
  bool: false,
  string: "",
  bytes: () => Buffer.alloc(0),
  uint32: 0,
  sfixed32: 0,
  sfixed64: BigInt(0),
  sint32: 0,
  sint64: BigInt(0)
};
var _ProtoMessage = class _ProtoMessage2 {
  constructor(model) {
    this.model = model;
    __publicField(this, "fieldSizeCalculators", /* @__PURE__ */ new Map());
    __publicField(this, "fieldSerializers", /* @__PURE__ */ new Map());
    __publicField(this, "fieldDefaultValues", []);
    __publicField(this, "fieldDeserializers", /* @__PURE__ */ new Map());
    for (const key2 in model) {
      const spec = model[key2];
      const type2 = spec.type;
      if (typeof type2 === "function" || typeof type2 === "object") {
        let resolveModel2 = function() {
          if (modelOrLazy === void 0) {
            if (typeof type2 === "function") {
              const modelOrMessage = type2();
              if (modelOrMessage instanceof _ProtoMessage2) {
                modelOrLazy = modelOrMessage.model;
              } else {
                modelOrLazy = modelOrMessage;
              }
            } else if (typeof type2 === "object") {
              if (type2 instanceof _ProtoMessage2) {
                modelOrLazy = type2.model;
              } else {
                modelOrLazy = type2;
              }
            } else {
              throw new Error("Unexpected type");
            }
          }
          return modelOrLazy;
        };
        let modelOrLazy;
        if (spec.repeated) {
          this.fieldSizeCalculators.set(key2, (data, cache) => {
            let size = spec[kTagLength] * data.length;
            const message = _ProtoMessage2.of(resolveModel2());
            for (const item of data) {
              const bodySize = message.calculateSerializedSize(item, cache);
              cache.set(item, bodySize);
              size += SizeOf.varint32(bodySize) + bodySize;
            }
            return size;
          });
          this.fieldSerializers.set(key2, (data, writer, cache) => {
            const message = _ProtoMessage2.of(resolveModel2());
            for (const item of data) {
              const bodySize = cache.get(item);
              writer.writeVarint(spec[kTag]);
              writer.writeVarint(bodySize);
              message.write(item, writer, cache);
            }
          });
          this.fieldDefaultValues.push([key2, () => []]);
          this.fieldDeserializers.set(spec.fieldNumber, (draft, reader) => {
            const message = _ProtoMessage2.of(resolveModel2());
            const item = message.createDraft();
            const length = reader.readVarint();
            const offset = reader.offset;
            message.read(item, reader, offset + length);
            draft[key2].push(item);
          });
        } else {
          this.fieldSizeCalculators.set(key2, (data, cache) => {
            const message = _ProtoMessage2.of(resolveModel2());
            const bodySize = message.calculateSerializedSize(data, cache);
            return spec[kTagLength] + SizeOf.varint32(bodySize) + bodySize;
          });
          this.fieldSerializers.set(key2, (data, writer, cache) => {
            const message = _ProtoMessage2.of(resolveModel2());
            const bodySize = cache.get(data);
            writer.writeVarint(spec[kTag]);
            writer.writeVarint(bodySize);
            message.write(data, writer, cache);
          });
          if (spec.optional) {
            this.fieldDefaultValues.push([key2, void 0]);
          } else {
            this.fieldDefaultValues.push([key2, () => {
              const message = _ProtoMessage2.of(resolveModel2());
              return message.createDraft();
            }]);
          }
          this.fieldDeserializers.set(spec.fieldNumber, (draft, reader) => {
            const message = _ProtoMessage2.of(resolveModel2());
            const item = message.createDraft();
            const length = reader.readVarint();
            const offset = reader.offset;
            message.read(item, reader, offset + length);
            draft[key2] = item;
          });
        }
      } else {
        this.fieldSizeCalculators.set(key2, ScalarSizeCalculatorCompiler[type2](spec));
        this.fieldSerializers.set(key2, ScalarSerializerCompiler[type2](spec));
        if (spec.repeated) {
          this.fieldDefaultValues.push([key2, () => []]);
        } else if (spec.optional) {
          this.fieldDefaultValues.push([key2, void 0]);
        } else {
          this.fieldDefaultValues.push([key2, ScalarTypeDefaultValue[type2]]);
        }
        this.fieldDeserializers.set(
          spec.fieldNumber,
          ScalarDeserializerCompiler[type2](
            key2,
            // @ts-ignore
            spec
          )
        );
      }
    }
  }
  calculateSerializedSize(message, cache) {
    let size = 0;
    for (const key2 in message) {
      const value = message[key2];
      if (value === void 0) {
        continue;
      }
      const calculator = this.fieldSizeCalculators.get(key2);
      const addSize = calculator(value, cache);
      size += addSize;
    }
    cache.set(message, size);
    return size;
  }
  write(message, writer, cache) {
    for (const key2 in message) {
      const value = message[key2];
      if (value === void 0) {
        continue;
      }
      const serializer = this.fieldSerializers.get(key2);
      serializer(
        // @ts-ignore
        value,
        writer,
        cache
      );
    }
  }
  createDraft() {
    const draft = {};
    for (const [key2, valueOrSupplier] of this.fieldDefaultValues) {
      draft[key2] = typeof valueOrSupplier === "function" ? valueOrSupplier() : valueOrSupplier;
    }
    return draft;
  }
  read(draft, reader, limit = reader.length) {
    while (reader.offset < limit) {
      const { fieldNumber, wireType } = reader.readTag();
      if (!this.fieldDeserializers.has(fieldNumber)) {
        reader.skip(wireType);
        continue;
      }
      const deserializer = this.fieldDeserializers.get(fieldNumber);
      deserializer(draft, reader, wireType);
    }
  }
  encode(message) {
    const cache = /* @__PURE__ */ new WeakMap();
    const size = this.calculateSerializedSize(message, cache);
    const writer = new CodedWriter(size);
    this.write(message, writer, cache);
    return writer.build();
  }
  decode(buffer2) {
    const reader = new CodedReader(buffer2);
    const draft = this.createDraft();
    this.read(draft, reader);
    return draft;
  }
  static of(model) {
    let message = this.compiledMessages.get(model);
    if (message === void 0) {
      message = new _ProtoMessage2(model);
      this.compiledMessages.set(model, message);
    }
    return message;
  }
};
__publicField(_ProtoMessage, "compiledMessages", /* @__PURE__ */ new WeakMap());
var ProtoMessage = _ProtoMessage;
function hasBuffer() {
  return typeof globalThis !== "undefined" && typeof globalThis.Buffer !== "undefined" && typeof globalThis.Buffer.from === "function";
}
if (!hasBuffer()) {
  throw new Error("Buffer is not available in this environment. TypeProto requires Buffer API support.");
}
var Action;
((Action2) => {
  const LongMsgPeer = ProtoMessage.of({
    uid: ProtoField(2, "string")
  });
  const LongMsgSettings = ProtoMessage.of({
    field1: ProtoField(1, "uint32"),
    field2: ProtoField(2, "uint32"),
    field3: ProtoField(3, "uint32"),
    field4: ProtoField(4, "uint32")
  });
  Action2.SendLongMsgReq = ProtoMessage.of({
    info: ProtoField(2, {
      type: ProtoField(1, "uint32"),
      peer: ProtoField(2, LongMsgPeer),
      groupCode: ProtoField(3, "uint32"),
      payload: ProtoField(4, "bytes")
    }),
    settings: ProtoField(15, LongMsgSettings)
  });
  Action2.SendLongMsgResp = ProtoMessage.of({
    result: ProtoField(2, {
      resId: ProtoField(3, "string")
    }),
    settings: ProtoField(15, LongMsgSettings)
  });
  Action2.PullPicsReq = ProtoMessage.of({
    uin: ProtoField(2, "uint32"),
    field3: ProtoField(3, "uint32"),
    word: ProtoField(6, "string"),
    word2: ProtoField(7, "string"),
    field8: ProtoField(8, "uint32"),
    field9: ProtoField(9, "uint32"),
    field14: ProtoField(14, "uint32")
  });
  Action2.PullPicsResp = ProtoMessage.of({
    info: ProtoField(3, {
      url: ProtoField(5, "string")
    }, "repeated")
  });
  Action2.RecvLongMsgReq = ProtoMessage.of({
    info: ProtoField(1, {
      peer: ProtoField(1, LongMsgPeer),
      resId: ProtoField(2, "string"),
      acquire: ProtoField(3, "bool")
    }),
    settings: ProtoField(15, LongMsgSettings)
  });
  Action2.RecvLongMsgResp = ProtoMessage.of({
    result: ProtoField(1, {
      resId: ProtoField(3, "string"),
      payload: ProtoField(4, "bytes")
    }),
    settings: ProtoField(15, LongMsgSettings)
  });
  Action2.FetchUserLoginDaysReq = ProtoMessage.of({
    field2: ProtoField(2, "uint32"),
    json: ProtoField(3, "string")
  });
  Action2.FetchUserLoginDaysResp = ProtoMessage.of({
    json: ProtoField(4, "string")
  });
})(Action || (Action = {}));
var Notify;
((Notify2) => {
  Notify2.GroupMemberChange = ProtoMessage.of({
    groupCode: ProtoField(1, "uint32"),
    memberUid: ProtoField(3, "string"),
    type: ProtoField(4, "uint32"),
    adminUid: ProtoField(5, "string")
  });
  Notify2.ProfileLike = ProtoMessage.of({
    msgType: ProtoField(1, "uint32"),
    subType: ProtoField(2, "uint32"),
    content: ProtoField(203, {
      msg: ProtoField(14, {
        count: ProtoField(1, "uint32"),
        time: ProtoField(2, "uint32"),
        detail: ProtoField(3, {
          txt: ProtoField(1, "string"),
          uin: ProtoField(3, "uint32"),
          nickname: ProtoField(5, "string")
        })
      })
    })
  });
  const GroupAdminExtra = ProtoMessage.of({
    adminUid: ProtoField(1, "string"),
    isPromote: ProtoField(2, "bool")
  });
  Notify2.GroupAdminChange = ProtoMessage.of({
    groupCode: ProtoField(1, "uint32"),
    flag: ProtoField(2, "uint32"),
    isPromote: ProtoField(3, "bool"),
    body: ProtoField(4, {
      extraDisable: ProtoField(1, GroupAdminExtra, "optional"),
      extraEnable: ProtoField(2, GroupAdminExtra, "optional")
    })
  });
})(Notify || (Notify = {}));
var Media;
((Media2) => {
  Media2.IndexNode = ProtoMessage.of({
    info: ProtoField(1, {
      fileSize: ProtoField(1, "uint32"),
      md5HexStr: ProtoField(2, "string"),
      sha1HexStr: ProtoField(3, "string"),
      fileName: ProtoField(4, "string"),
      fileType: ProtoField(5, {
        type: ProtoField(1, "uint32"),
        picFormat: ProtoField(2, "uint32"),
        videoFormat: ProtoField(3, "uint32"),
        pttFormat: ProtoField(4, "uint32")
      }),
      width: ProtoField(6, "uint32"),
      height: ProtoField(7, "uint32"),
      time: ProtoField(8, "uint32"),
      original: ProtoField(9, "uint32")
    }),
    fileUuid: ProtoField(2, "string"),
    storeID: ProtoField(3, "uint32"),
    uploadTime: ProtoField(4, "uint32"),
    expire: ProtoField(5, "uint32"),
    type: ProtoField(6, "uint32")
  });
  Media2.NTV2RichMediaReq = ProtoMessage.of({
    reqHead: ProtoField(1, {
      common: ProtoField(1, {
        requestId: ProtoField(1, "uint32"),
        command: ProtoField(2, "uint32")
      }),
      scene: ProtoField(2, {
        requestType: ProtoField(101, "uint32"),
        businessType: ProtoField(102, "uint32"),
        field103: ProtoField(103, "uint32"),
        sceneType: ProtoField(200, "uint32"),
        c2c: ProtoField(201, {
          accountType: ProtoField(1, "uint32"),
          targetUid: ProtoField(2, "string")
        }),
        group: ProtoField(202, {
          groupId: ProtoField(1, "uint32")
        })
      }),
      client: ProtoField(3, {
        agentType: ProtoField(1, "uint32")
      })
    }),
    download: ProtoField(3, {
      node: ProtoField(1, Media2.IndexNode)
    })
  });
  Media2.MsgInfo = ProtoMessage.of({
    msgInfoBody: ProtoField(1, {
      index: ProtoField(1, Media2.IndexNode),
      pic: ProtoField(2, {
        urlPath: ProtoField(1, "string"),
        ext: ProtoField(2, {
          originalParam: ProtoField(1, "string"),
          bigParam: ProtoField(2, "string"),
          thumbParam: ProtoField(3, "string")
        }),
        domain: ProtoField(3, "string")
      }),
      fileExist: ProtoField(5, "bool")
    }, "repeated"),
    extBizInfo: ProtoField(2, {
      pic: ProtoField(1, {
        bizType: ProtoField(1, "uint32"),
        summary: ProtoField(2, "string"),
        fromScene: ProtoField(1001, "uint32"),
        toScene: ProtoField(1002, "uint32"),
        oldFileId: ProtoField(1003, "uint32")
      }),
      video: ProtoField(2, {
        pbReserve: ProtoField(3, "bytes")
      }),
      busiType: ProtoField(10, "uint32")
    })
  });
  Media2.FileIdInfo = ProtoMessage.of({
    sha1: ProtoField(2, "bytes"),
    size: ProtoField(3, "uint32"),
    appid: ProtoField(4, "uint32"),
    time: ProtoField(5, "uint32"),
    expire: ProtoField(10, "uint32")
  });
  Media2.NTV2RichMediaResp = ProtoMessage.of({
    download: ProtoField(3, {
      rKeyParam: ProtoField(1, "string"),
      rKeyTtlSecond: ProtoField(2, "uint32"),
      info: ProtoField(3, {
        domain: ProtoField(1, "string"),
        urlPath: ProtoField(2, "string"),
        httpsPort: ProtoField(3, "uint32")
      }),
      rKeyCreateTime: ProtoField(4, "uint32")
    })
  });
})(Media || (Media = {}));
var Oidb;
((Oidb2) => {
  Oidb2.Base = ProtoMessage.of({
    command: ProtoField(1, "uint32"),
    subCommand: ProtoField(2, "uint32"),
    errorCode: ProtoField(3, "uint32"),
    body: ProtoField(4, "bytes"),
    errorMsg: ProtoField(5, "string"),
    isReserved: ProtoField(12, "uint32")
  });
  Oidb2.SendPokeReq = ProtoMessage.of({
    toUin: ProtoField(1, "uint32"),
    groupCode: ProtoField(2, "uint32"),
    friendUin: ProtoField(5, "uint32")
  });
  Oidb2.SetSpecialTitleReq = ProtoMessage.of({
    groupCode: ProtoField(1, "uint32"),
    body: ProtoField(3, {
      targetUid: ProtoField(1, "string"),
      specialTitle: ProtoField(5, "string"),
      expireTime: ProtoField(6, "int32"),
      uidName: ProtoField(7, "string")
    })
  });
  Oidb2.GetRKeyResp = ProtoMessage.of({
    result: ProtoField(4, {
      rkeyItems: ProtoField(1, {
        rkey: ProtoField(1, "string"),
        ttlSec: ProtoField(2, "uint32"),
        storeId: ProtoField(3, "uint32"),
        createTime: ProtoField(4, "uint32"),
        type: ProtoField(5, "uint32")
      }, "repeated")
    })
  });
  Oidb2.FetchUserInfoReq = ProtoMessage.of({
    uin: ProtoField(1, "uint32"),
    field2: ProtoField(2, "uint32"),
    keys: ProtoField(3, {
      key: ProtoField(1, "uint32")
    }, "repeated")
  });
  Oidb2.FetchUserInfoResp = ProtoMessage.of({
    body: ProtoField(1, {
      properties: ProtoField(2, {
        numberProperties: ProtoField(1, {
          key: ProtoField(1, "uint32"),
          value: ProtoField(2, "uint32")
        }, "repeated"),
        bytesProperties: ProtoField(2, {
          key: ProtoField(1, "uint32"),
          value: ProtoField(2, "bytes")
        }, "repeated")
      }),
      uin: ProtoField(3, "uint32")
    })
  });
  Oidb2.FetchAiCharacterListReq = ProtoMessage.of({
    groupId: ProtoField(1, "uint32"),
    chatType: ProtoField(2, "uint32")
  });
  Oidb2.FetchAiCharacterListResp = ProtoMessage.of({
    property: ProtoField(1, {
      type: ProtoField(1, "string"),
      characters: ProtoField(2, {
        characterId: ProtoField(1, "string"),
        characterName: ProtoField(2, "string"),
        previewUrl: ProtoField(3, "string")
      }, "repeated")
    }, "repeated")
  });
  Oidb2.GetGroupGenerateAiRecordReq = ProtoMessage.of({
    groupId: ProtoField(1, "uint32"),
    voiceId: ProtoField(2, "string"),
    text: ProtoField(3, "string"),
    chatType: ProtoField(4, "uint32"),
    clientMsgInfo: ProtoField(5, {
      msgRandom: ProtoField(1, "uint32")
    })
  });
  Oidb2.GetGroupFileReq = ProtoMessage.of({
    download: ProtoField(3, {
      groupCode: ProtoField(1, "uint32"),
      appId: ProtoField(2, "uint32"),
      busId: ProtoField(3, "uint32"),
      fileId: ProtoField(4, "string")
    })
  });
  Oidb2.GetGroupFileResp = ProtoMessage.of({
    download: ProtoField(3, {
      downloadDns: ProtoField(5, "string"),
      downloadUrl: ProtoField(6, "bytes")
    })
  });
  Oidb2.GetPrivateFileReq = ProtoMessage.of({
    subCommand: ProtoField(1, "uint32"),
    field2: ProtoField(2, "uint32"),
    body: ProtoField(14, {
      receiverUid: ProtoField(10, "string"),
      fileUuid: ProtoField(20, "string"),
      type: ProtoField(30, "uint32"),
      fileHash: ProtoField(60, "string"),
      t2: ProtoField(601, "uint32")
    }),
    field101: ProtoField(101, "uint32"),
    field102: ProtoField(102, "uint32"),
    field200: ProtoField(200, "uint32"),
    field99999: ProtoField(99999, "bytes")
  });
  Oidb2.GetPrivateFileResp = ProtoMessage.of({
    command: ProtoField(1, "uint32"),
    subCommand: ProtoField(2, "uint32"),
    body: ProtoField(14, {
      field10: ProtoField(10, "uint32"),
      state: ProtoField(20, "string"),
      result: ProtoField(30, {
        extra: ProtoField(120, {
          field100: ProtoField(100, "uint32"),
          download: ProtoField(102, {
            downloadUrl: ProtoField(8, "bytes"),
            downloadDns: ProtoField(11, "string")
          })
        })
      }),
      metadata: ProtoField(40, {
        fileName: ProtoField(7, "string")
      })
    }),
    field50: ProtoField(50, "uint32")
  });
  Oidb2.GroupClockInReq = ProtoMessage.of({
    body: ProtoField(2, {
      uin: ProtoField(1, "string"),
      groupCode: ProtoField(2, "string"),
      appVersion: ProtoField(3, "string")
    })
  });
})(Oidb || (Oidb = {}));
var Msg;
((Msg2) => {
  Msg2.Elem = ProtoMessage.of({
    text: ProtoField(1, {
      str: ProtoField(1, "string"),
      link: ProtoField(2, "string"),
      attr6Buf: ProtoField(3, "bytes"),
      attr7Buf: ProtoField(4, "bytes"),
      buf: ProtoField(11, "bytes"),
      pbReserve: ProtoField(12, "bytes")
    }, "optional"),
    face: ProtoField(2, {
      index: ProtoField(1, "uint32"),
      old: ProtoField(2, "bytes"),
      buf: ProtoField(11, "bytes")
    }, "optional"),
    richMsg: ProtoField(12, {
      template: ProtoField(1, "bytes"),
      serviceId: ProtoField(2, "int32")
    }, "optional"),
    srcMsg: ProtoField(45, {
      origSeqs: ProtoField(1, "uint32", "repeated"),
      senderUin: ProtoField(2, "uint32"),
      time: ProtoField(3, "int32"),
      elems: ProtoField(5, "bytes", "repeated"),
      pbReserve: ProtoField(8, "bytes"),
      srcMsg: ProtoField(9, "bytes"),
      toUin: ProtoField(10, "uint32")
    }, "optional"),
    lightApp: ProtoField(51, {
      data: ProtoField(1, "bytes"),
      msgResid: ProtoField(2, "bytes")
    }, "optional"),
    commonElem: ProtoField(53, {
      serviceType: ProtoField(1, "uint32"),
      pbElem: ProtoField(2, "bytes"),
      businessType: ProtoField(3, "uint32")
    }, "optional")
  });
  Msg2.Message = ProtoMessage.of({
    routingHead: ProtoField(1, {
      fromUin: ProtoField(1, "uint32"),
      fromUid: ProtoField(2, "string"),
      fromAppid: ProtoField(3, "uint32"),
      fromInstid: ProtoField(4, "uint32"),
      toUin: ProtoField(5, "uint64"),
      toUid: ProtoField(6, "string"),
      c2c: ProtoField(7, {
        friendName: ProtoField(6, "string")
      }),
      group: ProtoField(8, {
        groupCode: ProtoField(1, "uint32"),
        groupType: ProtoField(2, "uint32"),
        groupInfoSeq: ProtoField(3, "uint64"),
        groupCard: ProtoField(4, "string"),
        groupCardType: ProtoField(5, "uint32"),
        groupLevel: ProtoField(6, "uint32"),
        groupName: ProtoField(7, "string"),
        extGroupKeyInfo: ProtoField(8, "string"),
        msgFlag: ProtoField(9, "uint32")
      })
    }),
    contentHead: ProtoField(2, {
      msgType: ProtoField(1, "uint32"),
      subType: ProtoField(2, "uint32"),
      c2cCmd: ProtoField(3, "uint32"),
      random: ProtoField(4, "uint32"),
      msgSeq: ProtoField(5, "uint32"),
      msgTime: ProtoField(6, "uint32"),
      pkgNum: ProtoField(7, "uint32"),
      pkgIndex: ProtoField(8, "uint32"),
      divSeq: ProtoField(9, "uint32"),
      autoReply: ProtoField(10, "uint32"),
      ntMsgSeq: ProtoField(11, "uint64"),
      msgUid: ProtoField(12, "uint64"),
      forward: ProtoField(15, {
        field1: ProtoField(1, "uint32"),
        field2: ProtoField(2, "uint32"),
        field3: ProtoField(3, "uint32"),
        field4: ProtoField(4, "string"),
        avatar: ProtoField(5, "string")
      }, "optional")
    }),
    body: ProtoField(3, {
      richText: ProtoField(1, {
        attr: ProtoField(1, {
          codePage: ProtoField(1, "int32"),
          time: ProtoField(2, "int32"),
          random: ProtoField(3, "int32"),
          color: ProtoField(4, "int32"),
          size: ProtoField(5, "int32"),
          effect: ProtoField(6, "int32"),
          charSet: ProtoField(7, "int32"),
          pitchAndFamily: ProtoField(8, "int32"),
          fontName: ProtoField(9, "string"),
          reserveData: ProtoField(10, "bytes")
        }),
        elems: ProtoField(2, Msg2.Elem, "repeated")
      }),
      msgContent: ProtoField(2, "bytes"),
      msgEncryptContent: ProtoField(3, "bytes")
    })
  });
  Msg2.PbMultiMsgItem = ProtoMessage.of({
    fileName: ProtoField(1, "string"),
    buffer: ProtoField(2, {
      msg: ProtoField(1, Msg2.Message, "repeated")
    })
  });
  Msg2.PbMultiMsgTransmit = ProtoMessage.of({
    msg: ProtoField(1, Msg2.Message, "repeated"),
    pbItemList: ProtoField(2, Msg2.PbMultiMsgItem, "repeated")
  });
  Msg2.PushMsg = ProtoMessage.of({
    message: ProtoField(1, Msg2.Message)
  });
  Msg2.NotifyMessageBody = ProtoMessage.of({
    type: ProtoField(1, "uint32"),
    groupCode: ProtoField(4, "uint32"),
    field13: ProtoField(13, "uint32"),
    essenceMessage: ProtoField(33, {
      groupCode: ProtoField(1, "uint32"),
      msgSequence: ProtoField(2, "uint32"),
      random: ProtoField(3, "uint32"),
      setFlag: ProtoField(4, "uint32"),
      memberUin: ProtoField(5, "uint32"),
      operatorUin: ProtoField(6, "uint32"),
      timeStamp: ProtoField(7, "uint32"),
      msgSequence2: ProtoField(8, "uint32"),
      operatorNickName: ProtoField(9, "string"),
      memberNickName: ProtoField(10, "string"),
      setFlag2: ProtoField(11, "uint32")
    }),
    reaction: ProtoField(44, {
      data: ProtoField(1, {
        body: ProtoField(1, {
          target: ProtoField(2, {
            sequence: ProtoField(1, "uint32")
          }),
          info: ProtoField(3, {
            code: ProtoField(1, "string"),
            count: ProtoField(3, "uint32"),
            operatorUid: ProtoField(4, "string"),
            type: ProtoField(5, "uint32")
          })
        })
      })
    })
  });
  Msg2.QSmallFaceExtra = ProtoMessage.of({
    faceId: ProtoField(1, "uint32"),
    text: ProtoField(2, "string"),
    compatText: ProtoField(3, "string")
  });
})(Msg || (Msg = {}));
function FriendMixin(Base) {
  return class extends Base {
    async sendFriendPoke(uin) {
      const body = Oidb.SendPokeReq.encode({
        toUin: uin,
        friendUin: uin
      });
      const data = Oidb.Base.encode({
        command: 3795,
        subCommand: 1,
        body
      });
      return await this.wsSendPB("OidbSvcTrpcTcp.0xed3_1", data);
    }
    async getPrivateFileUrl(receiverUid, fileUuid) {
      const body = Oidb.GetPrivateFileReq.encode({
        subCommand: 1200,
        field2: 1,
        body: {
          receiverUid,
          fileUuid,
          type: 2,
          t2: 0
        },
        field101: 3,
        field102: 103,
        field200: 1,
        field99999: Buffer.from([192, 133, 44, 1])
      });
      const data = Oidb.Base.encode({
        command: 3639,
        subCommand: 1200,
        body
      });
      const res = await this.httpSendPB("OidbSvcTrpcTcp.0xe37_1200", data);
      const oidbRespBody = Oidb.Base.decode(Buffer.from(res.pb, "hex")).body;
      const file2 = Oidb.GetPrivateFileResp.decode(oidbRespBody);
      if (file2.body?.field10 !== 0) {
        throw new Error(file2.body.state);
      }
      const { download: download2 } = file2.body.result.extra;
      const { fileName } = file2.body.metadata;
      return `https://${download2?.downloadDns}/ftn_handler/${Buffer.from(download2.downloadUrl).toString("hex")}/?fname=${encodeURIComponent(fileName)}`;
    }
  };
}
function GroupMixin(Base) {
  return class extends Base {
    async sendGroupPoke(groupCode, memberUin) {
      const body = Oidb.SendPokeReq.encode({
        toUin: memberUin,
        groupCode
      });
      const data = Oidb.Base.encode({
        command: 3795,
        subCommand: 1,
        body
      });
      return await this.wsSendPB("OidbSvcTrpcTcp.0xed3_1", data);
    }
    async setSpecialTitle(groupCode, memberUid, title) {
      const body = Oidb.SetSpecialTitleReq.encode({
        groupCode,
        body: {
          targetUid: memberUid,
          uidName: title,
          specialTitle: title,
          expireTime: -1
        }
      });
      const data = Oidb.Base.encode({
        command: 2300,
        subCommand: 2,
        body
      });
      return await this.httpSendPB("OidbSvcTrpcTcp.0x8fc_2", data);
    }
    async groupClockIn(groupCode) {
      const body = Oidb.GroupClockInReq.encode({
        body: {
          uin: selfInfo.uin,
          groupCode
        }
      });
      const data = Oidb.Base.encode({
        command: 3767,
        subCommand: 1,
        body
      });
      await this.httpSendPB("OidbSvcTrpcTcp.0xeb7_1", data);
    }
    async getGroupFileUrl(groupCode, fileId) {
      const body = Oidb.GetGroupFileReq.encode({
        download: {
          groupCode,
          appId: 7,
          busId: 102,
          fileId
        }
      });
      const data = Oidb.Base.encode({
        command: 1750,
        subCommand: 2,
        body
      });
      const res = await this.httpSendPB("OidbSvcTrpcTcp.0x6d6_2", data);
      const oidbRespBody = Oidb.Base.decode(Buffer.from(res.pb, "hex")).body;
      const { download: download2 } = Oidb.GetGroupFileResp.decode(oidbRespBody);
      return `https://${download2?.downloadDns}/ftn_handler/${Buffer.from(download2.downloadUrl).toString("hex")}/?fname=`;
    }
  };
}
function MediaMixin(Base) {
  return class extends Base {
    async getRKey() {
      const hexStr = "08e7a00210ca01221c0a130a05080110ca011206a80602b006011a02080122050a030a1400";
      const data = Buffer.from(hexStr, "hex");
      const resp = await this.wsSendPB("OidbSvcTrpcTcp.0x9067_202", data);
      const rkeyBody = Oidb.Base.decode(Buffer.from(resp.pb, "hex")).body;
      const rkeyItems = Oidb.GetRKeyResp.decode(rkeyBody).result.rkeyItems;
      return {
        privateRKey: rkeyItems[0].rkey,
        groupRKey: rkeyItems[1].rkey,
        expiredTime: rkeyItems[0].createTime + rkeyItems[0].ttlSec
      };
    }
    async getGroupImageUrl(groupId, node) {
      const body = Media.NTV2RichMediaReq.encode({
        reqHead: {
          common: { requestId: 1, command: 200 },
          scene: { requestType: 2, businessType: 1, sceneType: 2, group: { groupId } },
          client: { agentType: 2 }
        },
        download: { node }
      });
      const data = Oidb.Base.encode({ command: 4548, subCommand: 200, body });
      const res = await this.httpSendPB("OidbSvcTrpcTcp.0x11c4_200", data);
      const oidbRespBody = Oidb.Base.decode(Buffer.from(res.pb, "hex")).body;
      const { download: download2 } = Media.NTV2RichMediaResp.decode(oidbRespBody);
      return `https://${download2?.info?.domain}${download2?.info?.urlPath}${download2?.rKeyParam}`;
    }
    async getC2cImageUrl(node) {
      const body = Media.NTV2RichMediaReq.encode({
        reqHead: {
          common: { requestId: 1, command: 200 },
          scene: { requestType: 2, businessType: 1, sceneType: 1, c2c: { accountType: 2, targetUid: selfInfo.uid } },
          client: { agentType: 2 }
        },
        download: { node }
      });
      const data = Oidb.Base.encode({ command: 4549, subCommand: 200, body });
      const res = await this.httpSendPB("OidbSvcTrpcTcp.0x11c5_200", data);
      const oidbRespBody = Oidb.Base.decode(Buffer.from(res.pb, "hex")).body;
      const { download: download2 } = Media.NTV2RichMediaResp.decode(oidbRespBody);
      return `https://${download2?.info?.domain}${download2?.info?.urlPath}${download2?.rKeyParam}`;
    }
    async getPrivatePttUrl(fileUuid) {
      const body = Media.NTV2RichMediaReq.encode({
        reqHead: {
          common: { requestId: 1, command: 200 },
          scene: { requestType: 1, businessType: 3, field103: 0, sceneType: 1, c2c: { accountType: 2, targetUid: selfInfo.uid } },
          client: { agentType: 2 }
        },
        download: { node: { fileUuid, storeID: 1, uploadTime: 0, expire: 0, type: 0 } }
      });
      const data = Oidb.Base.encode({ command: 4717, subCommand: 200, body });
      const res = await this.httpSendPB("OidbSvcTrpcTcp.0x126d_200", data);
      const oidbRespBody = Oidb.Base.decode(Buffer.from(res.pb, "hex")).body;
      const { download: download2 } = Media.NTV2RichMediaResp.decode(oidbRespBody);
      return `https://${download2?.info?.domain}${download2?.info?.urlPath}${download2?.rKeyParam}`;
    }
    async getGroupPttUrl(fileUuid) {
      const body = Media.NTV2RichMediaReq.encode({
        reqHead: {
          common: { requestId: 1, command: 200 },
          scene: { requestType: 1, businessType: 3, field103: 0, sceneType: 2, group: { groupId: 0 } },
          client: { agentType: 2 }
        },
        download: { node: { fileUuid, storeID: 1, uploadTime: 0, expire: 0, type: 0 } }
      });
      const data = Oidb.Base.encode({ command: 4718, subCommand: 200, body });
      const res = await this.httpSendPB("OidbSvcTrpcTcp.0x126e_200", data);
      const oidbRespBody = Oidb.Base.decode(Buffer.from(res.pb, "hex")).body;
      const { download: download2 } = Media.NTV2RichMediaResp.decode(oidbRespBody);
      return `https://${download2.info.domain}${download2.info.urlPath}${download2.rKeyParam}`;
    }
    async getGroupVideoUrl(fileUuid) {
      const body = Media.NTV2RichMediaReq.encode({
        reqHead: {
          common: { requestId: 1, command: 200 },
          scene: { requestType: 2, businessType: 2, field103: 0, sceneType: 2, group: { groupId: 0 } },
          client: { agentType: 2 }
        },
        download: { node: { fileUuid, storeID: 1, uploadTime: 0, expire: 0, type: 0 } }
      });
      const data = Oidb.Base.encode({ command: 4586, subCommand: 200, body });
      const res = await this.httpSendPB("OidbSvcTrpcTcp.0x11ea_200", data);
      const oidbRespBody = Oidb.Base.decode(Buffer.from(res.pb, "hex")).body;
      const { download: download2 } = Media.NTV2RichMediaResp.decode(oidbRespBody);
      return `https://${download2.info.domain}${download2.info.urlPath}${download2.rKeyParam}`;
    }
    async getPrivateVideoUrl(fileUuid) {
      const body = Media.NTV2RichMediaReq.encode({
        reqHead: {
          common: { requestId: 1, command: 200 },
          scene: { requestType: 2, businessType: 2, field103: 0, sceneType: 1, c2c: { accountType: 2, targetUid: selfInfo.uid } },
          client: { agentType: 2 }
        },
        download: { node: { fileUuid, storeID: 1, uploadTime: 0, expire: 0, type: 0 } }
      });
      const data = Oidb.Base.encode({ command: 4585, subCommand: 200, body });
      const res = await this.httpSendPB("OidbSvcTrpcTcp.0x11e9_200", data);
      const oidbRespBody = Oidb.Base.decode(Buffer.from(res.pb, "hex")).body;
      const { download: download2 } = Media.NTV2RichMediaResp.decode(oidbRespBody);
      return `https://${download2.info.domain}${download2.info.urlPath}${download2.rKeyParam}`;
    }
  };
}
var ElementType = /* @__PURE__ */ ((ElementType2) => {
  ElementType2[ElementType2["Text"] = 1] = "Text";
  ElementType2[ElementType2["Pic"] = 2] = "Pic";
  ElementType2[ElementType2["File"] = 3] = "File";
  ElementType2[ElementType2["Ptt"] = 4] = "Ptt";
  ElementType2[ElementType2["Video"] = 5] = "Video";
  ElementType2[ElementType2["Face"] = 6] = "Face";
  ElementType2[ElementType2["Reply"] = 7] = "Reply";
  ElementType2[ElementType2["GrayTip"] = 8] = "GrayTip";
  ElementType2[ElementType2["Ark"] = 10] = "Ark";
  ElementType2[ElementType2["MarketFace"] = 11] = "MarketFace";
  ElementType2[ElementType2["LiveGift"] = 12] = "LiveGift";
  ElementType2[ElementType2["StructLongMsg"] = 13] = "StructLongMsg";
  ElementType2[ElementType2["Markdown"] = 14] = "Markdown";
  ElementType2[ElementType2["Giphy"] = 15] = "Giphy";
  ElementType2[ElementType2["MultiForward"] = 16] = "MultiForward";
  ElementType2[ElementType2["InlineKeyboard"] = 17] = "InlineKeyboard";
  ElementType2[ElementType2["Calendar"] = 19] = "Calendar";
  ElementType2[ElementType2["YoloGameResult"] = 20] = "YoloGameResult";
  ElementType2[ElementType2["AvRecord"] = 21] = "AvRecord";
  ElementType2[ElementType2["TofuRecord"] = 23] = "TofuRecord";
  ElementType2[ElementType2["FaceBubble"] = 27] = "FaceBubble";
  ElementType2[ElementType2["ShareLocation"] = 28] = "ShareLocation";
  ElementType2[ElementType2["TaskTopMsg"] = 29] = "TaskTopMsg";
  ElementType2[ElementType2["RecommendedMsg"] = 43] = "RecommendedMsg";
  ElementType2[ElementType2["ActionBar"] = 44] = "ActionBar";
  return ElementType2;
})(ElementType || {});
var AtType = /* @__PURE__ */ ((AtType2) => {
  AtType2[AtType2["Unknown"] = 0] = "Unknown";
  AtType2[AtType2["All"] = 1] = "All";
  AtType2[AtType2["One"] = 2] = "One";
  return AtType2;
})(AtType || {});
const IMAGE_HTTP_HOST = "https://gchat.qpic.cn";
const IMAGE_HTTP_HOST_NT = "https://multimedia.nt.qq.com.cn";
var PicType = /* @__PURE__ */ ((PicType2) => {
  PicType2[PicType2["GIF"] = 2e3] = "GIF";
  PicType2[PicType2["JPEG"] = 1e3] = "JPEG";
  return PicType2;
})(PicType || {});
var TipGroupElementType = /* @__PURE__ */ ((TipGroupElementType2) => {
  TipGroupElementType2[TipGroupElementType2["Unknown"] = 0] = "Unknown";
  TipGroupElementType2[TipGroupElementType2["MemberAdd"] = 1] = "MemberAdd";
  TipGroupElementType2[TipGroupElementType2["Disbanded"] = 2] = "Disbanded";
  TipGroupElementType2[TipGroupElementType2["Quitted"] = 3] = "Quitted";
  TipGroupElementType2[TipGroupElementType2["Created"] = 4] = "Created";
  TipGroupElementType2[TipGroupElementType2["GroupNameModified"] = 5] = "GroupNameModified";
  TipGroupElementType2[TipGroupElementType2["Block"] = 6] = "Block";
  TipGroupElementType2[TipGroupElementType2["Unblock"] = 7] = "Unblock";
  TipGroupElementType2[TipGroupElementType2["ShutUp"] = 8] = "ShutUp";
  TipGroupElementType2[TipGroupElementType2["BeRecycled"] = 9] = "BeRecycled";
  TipGroupElementType2[TipGroupElementType2["DisbandOrBeRecycled"] = 10] = "DisbandOrBeRecycled";
  return TipGroupElementType2;
})(TipGroupElementType || {});
var GrayTipElementSubType = /* @__PURE__ */ ((GrayTipElementSubType2) => {
  GrayTipElementSubType2[GrayTipElementSubType2["Revoke"] = 1] = "Revoke";
  GrayTipElementSubType2[GrayTipElementSubType2["Proclamation"] = 2] = "Proclamation";
  GrayTipElementSubType2[GrayTipElementSubType2["EmojiReply"] = 3] = "EmojiReply";
  GrayTipElementSubType2[GrayTipElementSubType2["Group"] = 4] = "Group";
  GrayTipElementSubType2[GrayTipElementSubType2["Buddy"] = 5] = "Buddy";
  GrayTipElementSubType2[GrayTipElementSubType2["Feed"] = 6] = "Feed";
  GrayTipElementSubType2[GrayTipElementSubType2["Essence"] = 7] = "Essence";
  GrayTipElementSubType2[GrayTipElementSubType2["GroupNotify"] = 8] = "GroupNotify";
  GrayTipElementSubType2[GrayTipElementSubType2["BuddyNotify"] = 9] = "BuddyNotify";
  GrayTipElementSubType2[GrayTipElementSubType2["File"] = 10] = "File";
  GrayTipElementSubType2[GrayTipElementSubType2["FeedChannelMsg"] = 11] = "FeedChannelMsg";
  GrayTipElementSubType2[GrayTipElementSubType2["XmlMsg"] = 12] = "XmlMsg";
  GrayTipElementSubType2[GrayTipElementSubType2["LocalMsg"] = 13] = "LocalMsg";
  GrayTipElementSubType2[GrayTipElementSubType2["Block"] = 14] = "Block";
  GrayTipElementSubType2[GrayTipElementSubType2["AioOp"] = 15] = "AioOp";
  GrayTipElementSubType2[GrayTipElementSubType2["Wallet"] = 16] = "Wallet";
  GrayTipElementSubType2[GrayTipElementSubType2["JSON"] = 17] = "JSON";
  return GrayTipElementSubType2;
})(GrayTipElementSubType || {});
var JsonGrayTipBusId = /* @__PURE__ */ ((JsonGrayTipBusId2) => {
  JsonGrayTipBusId2["AddedFriend"] = "19324";
  JsonGrayTipBusId2["Poke"] = "1061";
  JsonGrayTipBusId2["GroupMemberTitleChanged"] = "2407";
  JsonGrayTipBusId2["GroupEssenceMsg"] = "2401";
  JsonGrayTipBusId2["GroupNewMemberInvited"] = "19217";
  return JsonGrayTipBusId2;
})(JsonGrayTipBusId || {});
var FaceIndex = /* @__PURE__ */ ((FaceIndex2) => {
  FaceIndex2[FaceIndex2["Dice"] = 358] = "Dice";
  FaceIndex2[FaceIndex2["RPS"] = 359] = "RPS";
  return FaceIndex2;
})(FaceIndex || {});
var FaceType = /* @__PURE__ */ ((FaceType2) => {
  FaceType2[FaceType2["Normal"] = 1] = "Normal";
  FaceType2[FaceType2["Super"] = 3] = "Super";
  FaceType2[FaceType2["Poke"] = 5] = "Poke";
  return FaceType2;
})(FaceType || {});
var ChatType = /* @__PURE__ */ ((ChatType2) => {
  ChatType2[ChatType2["C2C"] = 1] = "C2C";
  ChatType2[ChatType2["Group"] = 2] = "Group";
  ChatType2[ChatType2["TempC2CFromGroup"] = 100] = "TempC2CFromGroup";
  return ChatType2;
})(ChatType || {});
function MessageMixin(Base) {
  return class extends Base {
    async uploadForward(peer, items) {
      const transmit = Msg.PbMultiMsgTransmit.encode({ pbItemList: items });
      const isGroup = peer.chatType === ChatType.Group;
      const data = Action.SendLongMsgReq.encode({
        info: {
          type: isGroup ? 3 : 1,
          peer: { uid: isGroup ? peer.peerUid : selfInfo.uid },
          groupCode: isGroup ? +peer.peerUid : 0,
          payload: gzipSync(transmit)
        },
        settings: { field1: 4, field2: 1, field3: 7, field4: 0 }
      });
      const res = await this.httpSendPB("trpc.group.long_msg_interface.MsgService.SsoSendLongMsg", data);
      return Action.SendLongMsgResp.decode(Buffer.from(res.pb, "hex")).result.resId;
    }
    async getMultiMsg(resId) {
      const data = Action.RecvLongMsgReq.encode({
        info: {
          peer: { uid: selfInfo.uid },
          resId,
          acquire: true
        },
        settings: { field1: 2, field2: 0, field3: 0, field4: 0 }
      });
      const res = await this.httpSendPB("trpc.group.long_msg_interface.MsgService.SsoRecvLongMsg", data);
      const payload = Action.RecvLongMsgResp.decode(Buffer.from(res.pb, "hex")).result.payload;
      if (payload.length === 0) {
        throw new Error("");
      }
      const inflate = gunzipSync(payload);
      return Msg.PbMultiMsgTransmit.decode(inflate).pbItemList;
    }
    async pullPics(word) {
      const data = Action.PullPicsReq.encode({
        uin: +selfInfo.uin,
        field3: 1,
        word,
        word2: word,
        field8: 0,
        field9: 0,
        field14: 1
      });
      const res = await this.httpSendPB("PicSearchSvr.PullPics", data);
      return Action.PullPicsResp.decode(Buffer.from(res.pb, "hex"));
    }
    async fetchAiCharacterList(groupId, chatType) {
      const body = Oidb.FetchAiCharacterListReq.encode({ groupId, chatType });
      const data = Oidb.Base.encode({ command: 37533, subCommand: 0, body });
      const res = await this.httpSendPB("OidbSvcTrpcTcp.0x929d_0", data);
      const oidbRespBody = Oidb.Base.decode(Buffer.from(res.pb, "hex")).body;
      return Oidb.FetchAiCharacterListResp.decode(oidbRespBody);
    }
    async getGroupGenerateAiRecord(groupId, character, text, chatType) {
      const body = Oidb.GetGroupGenerateAiRecordReq.encode({
        groupId,
        voiceId: character,
        text,
        chatType,
        clientMsgInfo: { msgRandom: randomBytes(4).readUInt32BE(0) }
      });
      const data = Oidb.Base.encode({ command: 37531, subCommand: 0, body });
      await this.httpSendPB("OidbSvcTrpcTcp.0x929b_0", data);
    }
  };
}
function UserMixin(Base) {
  return class extends Base {
    async fetchUserLevel(uin) {
      const body = Oidb.FetchUserInfoReq.encode({
        uin,
        keys: [{ key: 105 }]
      });
      const data = Oidb.Base.encode({
        command: 4065,
        subCommand: 2,
        body,
        isReserved: 1
      });
      const res = await this.httpSendPB("OidbSvcTrpcTcp.0xfe1_2", data);
      const oidbRespBody = Oidb.Base.decode(Buffer.from(res.pb, "hex")).body;
      const info = Oidb.FetchUserInfoResp.decode(oidbRespBody);
      return info.body.properties.numberProperties[0].value;
    }
    async fetchUserLoginDays(uin) {
      const body = Action.FetchUserLoginDaysReq.encode({
        field2: 0,
        json: JSON.stringify({
          msg_req_basic_info: { uint64_request_uin: [uin] },
          uint32_req_login_info: 1
        })
      });
      const res = await this.httpSendPB("MQUpdateSvc_com_qq_ti.web.OidbSvc.0xdef_1", body);
      const { json: json2 } = Action.FetchUserLoginDaysResp.decode(Buffer.from(res.pb, "hex"));
      return JSON.parse(json2).msg_rsp_basic_info.rpt_msg_basic_info.find((e) => e.uint64_uin === uin)?.uint32_login_days || 0;
    }
  };
}
function applyMixins(Base, mixins2) {
  return mixins2.reduce((acc, mixin) => mixin(acc), Base);
}
const mixins = [GroupMixin, FriendMixin, MediaMixin, MessageMixin, UserMixin];
const PMHQ = applyMixins(PMHQBase, mixins);
const pmhq = new PMHQ();
class ProtobufParser {
  data;
  pos = 0;
  constructor(data) {
    this.data = data;
  }
  /**
   *  varint 
   *  BigInt  number  bigint
   */
  readVarint() {
    let result = 0n;
    let shift = 0n;
    while (this.pos < this.data.length) {
      const byte = this.data[this.pos++];
      result |= BigInt(byte & 127) << shift;
      if (!(byte & 128)) {
        if (result <= BigInt(Number.MAX_SAFE_INTEGER)) {
          return Number(result);
        }
        return result;
      }
      shift += 7n;
    }
    return Number(result);
  }
  /**
   *  32 
   */
  readFixed32() {
    const value = this.data.readUInt32LE(this.pos);
    this.pos += 4;
    return value;
  }
  /**
   *  64 
   */
  readFixed64() {
    const value = this.data.readBigUInt64LE(this.pos);
    this.pos += 8;
    return value;
  }
  /**
   * 
   */
  readBytes(length) {
    const data = this.data.slice(this.pos, this.pos + length);
    this.pos += length;
    return data;
  }
  /**
   *  length-delimited 
   */
  parseLengthDelimited(data) {
    try {
      const str = data.toString("utf-8");
      if (Buffer.from(str, "utf-8").equals(data)) {
        return str;
      }
    } catch {
    }
    try {
      const nested = new ProtobufParser(data).parse();
      if (Object.keys(nested).length > 0) {
        return nested;
      }
    } catch {
    }
    return data.toString("hex");
  }
  /**
   *  Protobuf 
   */
  parse() {
    const result = {};
    while (this.pos < this.data.length) {
      const tag = this.readVarint();
      const tagBig = typeof tag === "bigint" ? tag : BigInt(tag);
      const fieldNumber = Number(tagBig >> 3n);
      const wireType = Number(tagBig & 7n);
      let value;
      switch (wireType) {
        case 0:
          value = this.readVarint();
          break;
        case 1:
          value = Number(this.readFixed64());
          break;
        case 2:
          const length = Number(this.readVarint());
          const data = this.readBytes(length);
          value = this.parseLengthDelimited(data);
          break;
        case 5:
          value = this.readFixed32();
          break;
        default:
          continue;
      }
      if (fieldNumber in result) {
        if (!Array.isArray(result[fieldNumber])) {
          result[fieldNumber] = [result[fieldNumber]];
        }
        result[fieldNumber].push(value);
      } else {
        result[fieldNumber] = value;
      }
    }
    return result;
  }
}
function parseProtobuf(data) {
  const parser = new ProtobufParser(data);
  return parser.parse();
}
function parseProtobufFromHex(hexString) {
  const cleaned = hexString.replace(/^0x|\s/g, "");
  const buffer2 = Buffer.from(cleaned, "hex");
  return parseProtobuf(buffer2);
}
var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
var unicode = {
  Space_Separator,
  ID_Start,
  ID_Continue
};
var util$1 = {
  isSpaceSeparator(c2) {
    return typeof c2 === "string" && unicode.Space_Separator.test(c2);
  },
  isIdStartChar(c2) {
    return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_" || unicode.ID_Start.test(c2));
  },
  isIdContinueChar(c2) {
    return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "$" || c2 === "_" || c2 === "" || c2 === "" || unicode.ID_Continue.test(c2));
  },
  isDigit(c2) {
    return typeof c2 === "string" && /[0-9]/.test(c2);
  },
  isHexDigit(c2) {
    return typeof c2 === "string" && /[0-9A-Fa-f]/.test(c2);
  }
};
let source;
let parseState;
let stack;
let pos;
let line;
let column;
let token;
let key;
let root;
var parse$3 = function parse(text, reviver) {
  source = String(text);
  parseState = "start";
  stack = [];
  pos = 0;
  line = 1;
  column = 0;
  token = void 0;
  key = void 0;
  root = void 0;
  do {
    token = lex();
    parseStates[parseState]();
  } while (token.type !== "eof");
  if (typeof reviver === "function") {
    return internalize({ "": root }, "", reviver);
  }
  return root;
};
function internalize(holder, name, reviver) {
  const value = holder[name];
  if (value != null && typeof value === "object") {
    if (Array.isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        const key2 = String(i);
        const replacement = internalize(value, key2, reviver);
        if (replacement === void 0) {
          delete value[key2];
        } else {
          Object.defineProperty(value, key2, {
            value: replacement,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
    } else {
      for (const key2 in value) {
        const replacement = internalize(value, key2, reviver);
        if (replacement === void 0) {
          delete value[key2];
        } else {
          Object.defineProperty(value, key2, {
            value: replacement,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
    }
  }
  return reviver.call(holder, name, value);
}
let lexState;
let buffer;
let doubleQuote$1;
let sign$1;
let c;
function lex() {
  lexState = "default";
  buffer = "";
  doubleQuote$1 = false;
  sign$1 = 1;
  for (; ; ) {
    c = peek();
    const token2 = lexStates[lexState]();
    if (token2) {
      return token2;
    }
  }
}
function peek() {
  if (source[pos]) {
    return String.fromCodePoint(source.codePointAt(pos));
  }
}
function read() {
  const c2 = peek();
  if (c2 === "\n") {
    line++;
    column = 0;
  } else if (c2) {
    column += c2.length;
  } else {
    column++;
  }
  if (c2) {
    pos += c2.length;
  }
  return c2;
}
const lexStates = {
  default() {
    switch (c) {
      case "	":
      case "\v":
      case "\f":
      case " ":
      case "":
      case "\uFEFF":
      case "\n":
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        return;
      case "/":
        read();
        lexState = "comment";
        return;
      case void 0:
        read();
        return newToken("eof");
    }
    if (util$1.isSpaceSeparator(c)) {
      read();
      return;
    }
    return lexStates[parseState]();
  },
  comment() {
    switch (c) {
      case "*":
        read();
        lexState = "multiLineComment";
        return;
      case "/":
        read();
        lexState = "singleLineComment";
        return;
    }
    throw invalidChar(read());
  },
  multiLineComment() {
    switch (c) {
      case "*":
        read();
        lexState = "multiLineCommentAsterisk";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
  },
  multiLineCommentAsterisk() {
    switch (c) {
      case "*":
        read();
        return;
      case "/":
        read();
        lexState = "default";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
    lexState = "multiLineComment";
  },
  singleLineComment() {
    switch (c) {
      case "\n":
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        lexState = "default";
        return;
      case void 0:
        read();
        return newToken("eof");
    }
    read();
  },
  value() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
      case "n":
        read();
        literal$1("ull");
        return newToken("null", null);
      case "t":
        read();
        literal$1("rue");
        return newToken("boolean", true);
      case "f":
        read();
        literal$1("alse");
        return newToken("boolean", false);
      case "-":
      case "+":
        if (read() === "-") {
          sign$1 = -1;
        }
        lexState = "sign";
        return;
      case ".":
        buffer = read();
        lexState = "decimalPointLeading";
        return;
      case "0":
        buffer = read();
        lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer = read();
        lexState = "decimalInteger";
        return;
      case "I":
        read();
        literal$1("nfinity");
        return newToken("numeric", Infinity);
      case "N":
        read();
        literal$1("aN");
        return newToken("numeric", NaN);
      case '"':
      case "'":
        doubleQuote$1 = read() === '"';
        buffer = "";
        lexState = "string";
        return;
    }
    throw invalidChar(read());
  },
  identifierNameStartEscape() {
    if (c !== "u") {
      throw invalidChar(read());
    }
    read();
    const u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
        break;
      default:
        if (!util$1.isIdStartChar(u)) {
          throw invalidIdentifier();
        }
        break;
    }
    buffer += u;
    lexState = "identifierName";
  },
  identifierName() {
    switch (c) {
      case "$":
      case "_":
      case "":
      case "":
        buffer += read();
        return;
      case "\\":
        read();
        lexState = "identifierNameEscape";
        return;
    }
    if (util$1.isIdContinueChar(c)) {
      buffer += read();
      return;
    }
    return newToken("identifier", buffer);
  },
  identifierNameEscape() {
    if (c !== "u") {
      throw invalidChar(read());
    }
    read();
    const u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
      case "":
      case "":
        break;
      default:
        if (!util$1.isIdContinueChar(u)) {
          throw invalidIdentifier();
        }
        break;
    }
    buffer += u;
    lexState = "identifierName";
  },
  sign() {
    switch (c) {
      case ".":
        buffer = read();
        lexState = "decimalPointLeading";
        return;
      case "0":
        buffer = read();
        lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer = read();
        lexState = "decimalInteger";
        return;
      case "I":
        read();
        literal$1("nfinity");
        return newToken("numeric", sign$1 * Infinity);
      case "N":
        read();
        literal$1("aN");
        return newToken("numeric", NaN);
    }
    throw invalidChar(read());
  },
  zero() {
    switch (c) {
      case ".":
        buffer += read();
        lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
      case "x":
      case "X":
        buffer += read();
        lexState = "hexadecimal";
        return;
    }
    return newToken("numeric", sign$1 * 0);
  },
  decimalInteger() {
    switch (c) {
      case ".":
        buffer += read();
        lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util$1.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign$1 * Number(buffer));
  },
  decimalPointLeading() {
    if (util$1.isDigit(c)) {
      buffer += read();
      lexState = "decimalFraction";
      return;
    }
    throw invalidChar(read());
  },
  decimalPoint() {
    switch (c) {
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util$1.isDigit(c)) {
      buffer += read();
      lexState = "decimalFraction";
      return;
    }
    return newToken("numeric", sign$1 * Number(buffer));
  },
  decimalFraction() {
    switch (c) {
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util$1.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign$1 * Number(buffer));
  },
  decimalExponent() {
    switch (c) {
      case "+":
      case "-":
        buffer += read();
        lexState = "decimalExponentSign";
        return;
    }
    if (util$1.isDigit(c)) {
      buffer += read();
      lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentSign() {
    if (util$1.isDigit(c)) {
      buffer += read();
      lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentInteger() {
    if (util$1.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign$1 * Number(buffer));
  },
  hexadecimal() {
    if (util$1.isHexDigit(c)) {
      buffer += read();
      lexState = "hexadecimalInteger";
      return;
    }
    throw invalidChar(read());
  },
  hexadecimalInteger() {
    if (util$1.isHexDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign$1 * Number(buffer));
  },
  string() {
    switch (c) {
      case "\\":
        read();
        buffer += escape$1();
        return;
      case '"':
        if (doubleQuote$1) {
          read();
          return newToken("string", buffer);
        }
        buffer += read();
        return;
      case "'":
        if (!doubleQuote$1) {
          read();
          return newToken("string", buffer);
        }
        buffer += read();
        return;
      case "\n":
      case "\r":
        throw invalidChar(read());
      case "\u2028":
      case "\u2029":
        separatorChar(c);
        break;
      case void 0:
        throw invalidChar(read());
    }
    buffer += read();
  },
  start() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
    }
    lexState = "value";
  },
  beforePropertyName() {
    switch (c) {
      case "$":
      case "_":
        buffer = read();
        lexState = "identifierName";
        return;
      case "\\":
        read();
        lexState = "identifierNameStartEscape";
        return;
      case "}":
        return newToken("punctuator", read());
      case '"':
      case "'":
        doubleQuote$1 = read() === '"';
        lexState = "string";
        return;
    }
    if (util$1.isIdStartChar(c)) {
      buffer += read();
      lexState = "identifierName";
      return;
    }
    throw invalidChar(read());
  },
  afterPropertyName() {
    if (c === ":") {
      return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  beforePropertyValue() {
    lexState = "value";
  },
  afterPropertyValue() {
    switch (c) {
      case ",":
      case "}":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  beforeArrayValue() {
    if (c === "]") {
      return newToken("punctuator", read());
    }
    lexState = "value";
  },
  afterArrayValue() {
    switch (c) {
      case ",":
      case "]":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  end() {
    throw invalidChar(read());
  }
};
function newToken(type2, value) {
  return {
    type: type2,
    value,
    line,
    column
  };
}
function literal$1(s) {
  for (const c2 of s) {
    const p = peek();
    if (p !== c2) {
      throw invalidChar(read());
    }
    read();
  }
}
function escape$1() {
  const c2 = peek();
  switch (c2) {
    case "b":
      read();
      return "\b";
    case "f":
      read();
      return "\f";
    case "n":
      read();
      return "\n";
    case "r":
      read();
      return "\r";
    case "t":
      read();
      return "	";
    case "v":
      read();
      return "\v";
    case "0":
      read();
      if (util$1.isDigit(peek())) {
        throw invalidChar(read());
      }
      return "\0";
    case "x":
      read();
      return hexEscape();
    case "u":
      read();
      return unicodeEscape();
    case "\n":
    case "\u2028":
    case "\u2029":
      read();
      return "";
    case "\r":
      read();
      if (peek() === "\n") {
        read();
      }
      return "";
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      throw invalidChar(read());
    case void 0:
      throw invalidChar(read());
  }
  return read();
}
function hexEscape() {
  let buffer2 = "";
  let c2 = peek();
  if (!util$1.isHexDigit(c2)) {
    throw invalidChar(read());
  }
  buffer2 += read();
  c2 = peek();
  if (!util$1.isHexDigit(c2)) {
    throw invalidChar(read());
  }
  buffer2 += read();
  return String.fromCodePoint(parseInt(buffer2, 16));
}
function unicodeEscape() {
  let buffer2 = "";
  let count = 4;
  while (count-- > 0) {
    const c2 = peek();
    if (!util$1.isHexDigit(c2)) {
      throw invalidChar(read());
    }
    buffer2 += read();
  }
  return String.fromCodePoint(parseInt(buffer2, 16));
}
const parseStates = {
  start() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    push();
  },
  beforePropertyName() {
    switch (token.type) {
      case "identifier":
      case "string":
        key = token.value;
        parseState = "afterPropertyName";
        return;
      case "punctuator":
        pop();
        return;
      case "eof":
        throw invalidEOF();
    }
  },
  afterPropertyName() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    parseState = "beforePropertyValue";
  },
  beforePropertyValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    push();
  },
  beforeArrayValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    if (token.type === "punctuator" && token.value === "]") {
      pop();
      return;
    }
    push();
  },
  afterPropertyValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    switch (token.value) {
      case ",":
        parseState = "beforePropertyName";
        return;
      case "}":
        pop();
    }
  },
  afterArrayValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    switch (token.value) {
      case ",":
        parseState = "beforeArrayValue";
        return;
      case "]":
        pop();
    }
  },
  end() {
  }
};
function push() {
  let value;
  switch (token.type) {
    case "punctuator":
      switch (token.value) {
        case "{":
          value = {};
          break;
        case "[":
          value = [];
          break;
      }
      break;
    case "null":
    case "boolean":
    case "numeric":
    case "string":
      value = token.value;
      break;
  }
  if (root === void 0) {
    root = value;
  } else {
    const parent = stack[stack.length - 1];
    if (Array.isArray(parent)) {
      parent.push(value);
    } else {
      Object.defineProperty(parent, key, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  if (value !== null && typeof value === "object") {
    stack.push(value);
    if (Array.isArray(value)) {
      parseState = "beforeArrayValue";
    } else {
      parseState = "beforePropertyName";
    }
  } else {
    const current = stack[stack.length - 1];
    if (current == null) {
      parseState = "end";
    } else if (Array.isArray(current)) {
      parseState = "afterArrayValue";
    } else {
      parseState = "afterPropertyValue";
    }
  }
}
function pop() {
  stack.pop();
  const current = stack[stack.length - 1];
  if (current == null) {
    parseState = "end";
  } else if (Array.isArray(current)) {
    parseState = "afterArrayValue";
  } else {
    parseState = "afterPropertyValue";
  }
}
function invalidChar(c2) {
  if (c2 === void 0) {
    return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
  }
  return syntaxError(`JSON5: invalid character '${formatChar(c2)}' at ${line}:${column}`);
}
function invalidEOF() {
  return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
}
function invalidIdentifier() {
  column -= 5;
  return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
}
function separatorChar(c2) {
  console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
}
function formatChar(c2) {
  const replacements = {
    "'": "\\'",
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\v": "\\v",
    "\0": "\\0",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  if (replacements[c2]) {
    return replacements[c2];
  }
  if (c2 < " ") {
    const hexString = c2.charCodeAt(0).toString(16);
    return "\\x" + ("00" + hexString).substring(hexString.length);
  }
  return c2;
}
function syntaxError(message) {
  const err = new SyntaxError(message);
  err.lineNumber = line;
  err.columnNumber = column;
  return err;
}
var stringify = function stringify2(value, replacer, space) {
  const stack2 = [];
  let indent = "";
  let propertyList;
  let replacerFunc;
  let gap = "";
  let quote;
  if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
    space = replacer.space;
    quote = replacer.quote;
    replacer = replacer.replacer;
  }
  if (typeof replacer === "function") {
    replacerFunc = replacer;
  } else if (Array.isArray(replacer)) {
    propertyList = [];
    for (const v of replacer) {
      let item;
      if (typeof v === "string") {
        item = v;
      } else if (typeof v === "number" || v instanceof String || v instanceof Number) {
        item = String(v);
      }
      if (item !== void 0 && propertyList.indexOf(item) < 0) {
        propertyList.push(item);
      }
    }
  }
  if (space instanceof Number) {
    space = Number(space);
  } else if (space instanceof String) {
    space = String(space);
  }
  if (typeof space === "number") {
    if (space > 0) {
      space = Math.min(10, Math.floor(space));
      gap = "          ".substr(0, space);
    }
  } else if (typeof space === "string") {
    gap = space.substr(0, 10);
  }
  return serializeProperty("", { "": value });
  function serializeProperty(key2, holder) {
    let value2 = holder[key2];
    if (value2 != null) {
      if (typeof value2.toJSON5 === "function") {
        value2 = value2.toJSON5(key2);
      } else if (typeof value2.toJSON === "function") {
        value2 = value2.toJSON(key2);
      }
    }
    if (replacerFunc) {
      value2 = replacerFunc.call(holder, key2, value2);
    }
    if (value2 instanceof Number) {
      value2 = Number(value2);
    } else if (value2 instanceof String) {
      value2 = String(value2);
    } else if (value2 instanceof Boolean) {
      value2 = value2.valueOf();
    }
    switch (value2) {
      case null:
        return "null";
      case true:
        return "true";
      case false:
        return "false";
    }
    if (typeof value2 === "string") {
      return quoteString(value2);
    }
    if (typeof value2 === "number") {
      return String(value2);
    }
    if (typeof value2 === "object") {
      return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
    }
    return void 0;
  }
  function quoteString(value2) {
    const quotes = {
      "'": 0.1,
      '"': 0.2
    };
    const replacements = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    let product = "";
    for (let i = 0; i < value2.length; i++) {
      const c2 = value2[i];
      switch (c2) {
        case "'":
        case '"':
          quotes[c2]++;
          product += c2;
          continue;
        case "\0":
          if (util$1.isDigit(value2[i + 1])) {
            product += "\\x00";
            continue;
          }
      }
      if (replacements[c2]) {
        product += replacements[c2];
        continue;
      }
      if (c2 < " ") {
        let hexString = c2.charCodeAt(0).toString(16);
        product += "\\x" + ("00" + hexString).substring(hexString.length);
        continue;
      }
      product += c2;
    }
    const quoteChar = quote || Object.keys(quotes).reduce((a, b) => quotes[a] < quotes[b] ? a : b);
    product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
    return quoteChar + product + quoteChar;
  }
  function serializeObject(value2) {
    if (stack2.indexOf(value2) >= 0) {
      throw TypeError("Converting circular structure to JSON5");
    }
    stack2.push(value2);
    let stepback = indent;
    indent = indent + gap;
    let keys = propertyList || Object.keys(value2);
    let partial2 = [];
    for (const key2 of keys) {
      const propertyString = serializeProperty(key2, value2);
      if (propertyString !== void 0) {
        let member = serializeKey(key2) + ":";
        if (gap !== "") {
          member += " ";
        }
        member += propertyString;
        partial2.push(member);
      }
    }
    let final;
    if (partial2.length === 0) {
      final = "{}";
    } else {
      let properties;
      if (gap === "") {
        properties = partial2.join(",");
        final = "{" + properties + "}";
      } else {
        let separator = ",\n" + indent;
        properties = partial2.join(separator);
        final = "{\n" + indent + properties + ",\n" + stepback + "}";
      }
    }
    stack2.pop();
    indent = stepback;
    return final;
  }
  function serializeKey(key2) {
    if (key2.length === 0) {
      return quoteString(key2);
    }
    const firstChar = String.fromCodePoint(key2.codePointAt(0));
    if (!util$1.isIdStartChar(firstChar)) {
      return quoteString(key2);
    }
    for (let i = firstChar.length; i < key2.length; i++) {
      if (!util$1.isIdContinueChar(String.fromCodePoint(key2.codePointAt(i)))) {
        return quoteString(key2);
      }
    }
    return key2;
  }
  function serializeArray(value2) {
    if (stack2.indexOf(value2) >= 0) {
      throw TypeError("Converting circular structure to JSON5");
    }
    stack2.push(value2);
    let stepback = indent;
    indent = indent + gap;
    let partial2 = [];
    for (let i = 0; i < value2.length; i++) {
      const propertyString = serializeProperty(String(i), value2);
      partial2.push(propertyString !== void 0 ? propertyString : "null");
    }
    let final;
    if (partial2.length === 0) {
      final = "[]";
    } else {
      if (gap === "") {
        let properties = partial2.join(",");
        final = "[" + properties + "]";
      } else {
        let separator = ",\n" + indent;
        let properties = partial2.join(separator);
        final = "[\n" + indent + properties + ",\n" + stepback + "]";
      }
    }
    stack2.pop();
    indent = stepback;
    return final;
  }
};
const JSON5 = {
  parse: parse$3,
  stringify
};
var lib$5 = JSON5;
function isNumeric(str) {
  return /^\d+$/.test(str);
}
function calcQQLevel(level) {
  const { penguinNum, crownNum, sunNum, moonNum, starNum } = level;
  return (penguinNum || 0) * 256 + crownNum * 64 + sunNum * 16 + moonNum * 4 + starNum;
}
function mergeNewProperties(newObj, oldObj) {
  Object.keys(newObj).forEach((key2) => {
    if (!oldObj.hasOwnProperty(key2)) {
      oldObj[key2] = newObj[key2];
    } else {
      if (typeof oldObj[key2] === "object" && typeof newObj[key2] === "object") {
        mergeNewProperties(newObj[key2], oldObj[key2]);
      } else if (typeof oldObj[key2] === "object" || typeof newObj[key2] === "object") {
        oldObj[key2] = newObj[key2];
      }
    }
  });
}
function filterNullable(array2) {
  return array2.filter((e) => !isNullable(e));
}
function parseBool(value) {
  if (["", "true", "1"].includes(value)) {
    return true;
  }
  return false;
}
class DetailedError extends Error {
  data;
  constructor(message, data) {
    super(message);
    defineProperty(this, "data", data);
  }
}
const cloneObj = (obj) => Object.assign(
  Object.create(Object.getPrototypeOf(obj)),
  obj
);
const ob11Default = {
  enable: true,
  connect: []
};
const satoriDefault = {
  enable: false,
  port: 5600,
  token: ""
};
const milkyDefault = {
  enable: false,
  reportSelfMessage: false,
  http: {
    port: 3010,
    prefix: "",
    accessToken: ""
  },
  webhook: {
    urls: [],
    accessToken: ""
  }
};
const webuiDefault = {
  enable: true,
  port: 3080
};
const defaultConfig = {
  webui: webuiDefault,
  onlyLocalhost: true,
  milky: milkyDefault,
  satori: satoriDefault,
  ob11: ob11Default,
  enableLocalFile2Url: false,
  log: true,
  autoDeleteFile: false,
  autoDeleteFileSecond: 60,
  musicSignUrl: "https://llob.linyuchen.net/sign/music",
  msgCacheExpire: 120,
  ffmpeg: "",
  rawMsgPB: false
};
class ConfigUtil {
  configPath;
  config = null;
  watch = false;
  defaultConfigPath = path__default.join(path__default.dirname(fileURLToPath(import.meta.url)), "default_config.json");
  constructor(configPath) {
    this.configPath = configPath;
  }
  setConfigPath(configPath) {
    this.configPath = configPath;
  }
  listenChange(cb) {
    console.log("", this.configPath);
    this.setConfig(this.getConfig());
    if (this.configPath) {
      fs__default.watchFile(this.configPath, { persistent: true, interval: 1e3 }, () => {
        if (!this.watch) {
          return;
        }
        console.log("");
        const c2 = this.reloadConfig();
        cb(c2);
      });
    }
  }
  getConfig(cache = true) {
    if (this.config && cache) {
      return this.config;
    }
    return this.reloadConfig();
  }
  getDefaultConfig() {
    const _defaultConfig = { ...defaultConfig };
    const defaultConfigFromFile = fs__default.readFileSync(this.defaultConfigPath, "utf-8");
    try {
      const parsedDefaultConfig = lib$5.parse(defaultConfigFromFile);
      Object.assign(_defaultConfig, parsedDefaultConfig);
    } catch (e) {
      console.error(" default_config.json ", e);
    }
    return _defaultConfig;
  }
  reloadConfig() {
    if (!this.configPath) {
      return this.getDefaultConfig();
    }
    if (!fs__default.existsSync(this.configPath)) {
      this.config = this.getDefaultConfig();
      this.setConfig(this.config);
      return this.config;
    } else {
      const data = fs__default.readFileSync(this.configPath, "utf-8");
      let jsonData = defaultConfig;
      try {
        jsonData = lib$5.parse(data);
        console.info("");
        jsonData = this.migrateConfig(jsonData);
        mergeNewProperties(defaultConfig, jsonData);
        jsonData.webui = this.migrateWebUIToken(jsonData.webui);
        jsonData = this.cleanupConfig(defaultConfig, jsonData);
        this.setConfig(jsonData);
        this.config = jsonData;
        return this.config;
      } catch (e) {
        console.error(`${this.configPath} json `, e);
        this.config = this.getDefaultConfig();
        return this.config;
      }
    }
  }
  setConfig(config2) {
    this.config = config2;
    this.writeConfig(config2);
  }
  writeConfig(config2, watch = false) {
    if (!this.configPath) {
      return;
    }
    this.watch = watch;
    fs__default.writeFileSync(this.configPath, JSON.stringify(config2, null, 2), "utf-8");
    setTimeout(() => {
      this.watch = true;
    }, 3e3);
  }
  /**
   *  defaultConfig  oldConfig  defaultConfig  key
   */
  cleanupConfig(defaultConfig2, oldConfig) {
    if (typeof defaultConfig2 !== "object" || defaultConfig2 === null || Array.isArray(defaultConfig2)) {
      return oldConfig;
    }
    if (typeof oldConfig !== "object" || oldConfig === null) {
      return oldConfig;
    }
    const cleaned = {};
    for (const key2 in defaultConfig2) {
      if (defaultConfig2.hasOwnProperty(key2)) {
        if (oldConfig.hasOwnProperty(key2)) {
          const defaultValue = defaultConfig2[key2];
          const oldValue = oldConfig[key2];
          if (typeof defaultValue === "object" && defaultValue !== null && !Array.isArray(defaultValue) && typeof oldValue === "object" && oldValue !== null && !Array.isArray(oldValue)) {
            cleaned[key2] = this.cleanupConfig(defaultValue, oldValue);
          } else {
            cleaned[key2] = oldValue;
          }
        } else {
          cleaned[key2] = defaultConfig2[key2];
        }
      }
    }
    return cleaned;
  }
  migrateConfig(oldConfig) {
    let migratedConfig = oldConfig;
    if (!Array.isArray(oldConfig.ob11.connect)) {
      const ob11 = oldConfig.ob11 || {};
      migratedConfig = {
        ...oldConfig,
        ob11: {
          enable: ob11.enable || false,
          connect: [
            {
              type: "ws",
              enable: ob11.enableWs || false,
              port: ob11.wsPort || 3001,
              heartInterval: oldConfig.heartInterval || 3e4,
              token: ob11.token || "",
              messageFormat: ob11.messagePostFormat || "array",
              reportSelfMessage: ob11.reportSelfMessage || false,
              reportOfflineMessage: oldConfig.receiveOfflineMsg || false,
              debug: oldConfig.debug || false
            },
            {
              type: "ws-reverse",
              enable: ob11.enableWsReverse || false,
              url: ob11.wsReverseUrls && ob11.wsReverseUrls[0] || "",
              heartInterval: oldConfig.heartInterval || 3e4,
              token: ob11.token || "",
              messageFormat: ob11.messagePostFormat || "array",
              reportSelfMessage: ob11.reportSelfMessage || false,
              reportOfflineMessage: oldConfig.receiveOfflineMsg || false,
              debug: oldConfig.debug || false
            },
            {
              type: "http",
              enable: ob11.enableHttp || false,
              port: ob11.httpPort || 3e3,
              token: ob11.token || "",
              messageFormat: ob11.messagePostFormat || "array",
              reportSelfMessage: ob11.reportSelfMessage || false,
              reportOfflineMessage: oldConfig.receiveOfflineMsg || false,
              debug: oldConfig.debug || false
            },
            {
              type: "http-post",
              enable: ob11.enableHttpPost || false,
              url: ob11.httpPostUrls && ob11.httpPostUrls[0] || "",
              enableHeart: ob11.enableHttpHeart || false,
              heartInterval: oldConfig.heartInterval || 3e4,
              token: ob11.httpSecret || "",
              messageFormat: ob11.messagePostFormat || "array",
              reportSelfMessage: ob11.reportSelfMessage || false,
              reportOfflineMessage: oldConfig.receiveOfflineMsg || false,
              debug: oldConfig.debug || false
            }
          ]
        }
      };
    }
    return migratedConfig;
  }
  migrateWebUIToken(oldWebuiConfig) {
    if (oldWebuiConfig.token && !webuiTokenUtil.getToken()) {
      webuiTokenUtil.setToken(oldWebuiConfig.token);
      delete oldWebuiConfig["token"];
    }
    return oldWebuiConfig;
  }
}
let globalConfigUtil = null;
function getConfigUtil(force = false) {
  const configFilePath = selfInfo.uin ? path__default.join(DATA_DIR, `config_${selfInfo.uin}.json`) : void 0;
  if (!globalConfigUtil || force) {
    globalConfigUtil = new ConfigUtil(configFilePath);
  }
  return globalConfigUtil;
}
class WebUITokenUtil {
  constructor(tokenPath) {
    this.tokenPath = tokenPath;
    this.tokenPath = tokenPath;
  }
  token = "";
  getToken() {
    if (!this.token) {
      if (fs__default.existsSync(this.tokenPath)) {
        this.token = fs__default.readFileSync(this.tokenPath, "utf-8").trim();
      }
    }
    return this.token;
  }
  setToken(token2) {
    this.token = token2.trim();
    fs__default.writeFileSync(this.tokenPath, token2, "utf-8");
  }
}
const webuiTokenUtil = new WebUITokenUtil(path__default.join(DATA_DIR, "webui_token.txt"));
var ReceiveCmdS = /* @__PURE__ */ ((ReceiveCmdS2) => {
  ReceiveCmdS2["INIT"] = "nodeIQQNTWrapperSessionListener/onSessionInitComplete";
  ReceiveCmdS2["LOGIN_QR_CODE"] = "nodeIKernelLoginListener/onQRCodeGetPicture";
  ReceiveCmdS2["RECENT_CONTACT"] = "nodeIKernelRecentContactListener/onRecentContactListChangedVer2";
  ReceiveCmdS2["UPDATE_MSG"] = "nodeIKernelMsgListener/onMsgInfoListUpdate";
  ReceiveCmdS2["UPDATE_ACTIVE_MSG"] = "nodeIKernelMsgListener/onActiveMsgInfoUpdate";
  ReceiveCmdS2["NEW_MSG"] = "nodeIKernelMsgListener/onRecvMsg";
  ReceiveCmdS2["DELETE_MSG"] = "nodeIKernelMsgListener/onMsgDelete";
  ReceiveCmdS2["NEW_ACTIVE_MSG"] = "nodeIKernelMsgListener/onRecvActiveMsg";
  ReceiveCmdS2["SELF_SEND_MSG"] = "nodeIKernelMsgListener/onAddSendMsg";
  ReceiveCmdS2["USER_INFO"] = "nodeIKernelProfileListener/onProfileSimpleChanged";
  ReceiveCmdS2["USER_DETAIL_INFO"] = "nodeIKernelProfileListener/onProfileDetailInfoChanged";
  ReceiveCmdS2["GROUPS"] = "nodeIKernelGroupListener/onGroupListUpdate";
  ReceiveCmdS2["GROUPS_STORE"] = "onGroupListUpdate";
  ReceiveCmdS2["GROUP_MEMBER_INFO_UPDATE"] = "nodeIKernelGroupListener/onMemberInfoChange";
  ReceiveCmdS2["GROUP_DETAIL_INFO_UPDATE"] = "nodeIKernelGroupListener/onGroupDetailInfoChange";
  ReceiveCmdS2["FRIENDS"] = "nodeIKernelBuddyListener/onBuddyListChange";
  ReceiveCmdS2["MEDIA_DOWNLOAD_COMPLETE"] = "nodeIKernelMsgListener/onRichMediaDownloadComplete";
  ReceiveCmdS2["UNREAD_GROUP_NOTIFY"] = "nodeIKernelGroupListener/onGroupNotifiesUnreadCountUpdated";
  ReceiveCmdS2["GROUP_NOTIFY"] = "nodeIKernelGroupListener/onGroupSingleScreenNotifies";
  ReceiveCmdS2["FRIEND_REQUEST"] = "nodeIKernelBuddyListener/onBuddyReqChange";
  ReceiveCmdS2["SELF_STATUS"] = "nodeIKernelProfileListener/onSelfStatusChanged";
  ReceiveCmdS2["CACHE_SCAN_FINISH"] = "nodeIKernelStorageCleanListener/onFinishScan";
  ReceiveCmdS2["MEDIA_UPLOAD_COMPLETE"] = "nodeIKernelMsgListener/onRichMediaUploadComplete";
  ReceiveCmdS2["FLASH_FILE_DOWNLOAD_STATUS"] = "nodeIKernelFlashTransferListener/onFileSetDownloadTaskStatusChange";
  ReceiveCmdS2["FLASH_FILE_DOWNLOADING"] = "nodeIKernelFlashTransferListener/onFileSetDownloadTaskProgressChanged";
  ReceiveCmdS2["FLASH_FILE_UPLOAD_STATUS"] = "nodeIKernelFlashTransferListener/onFileSetUploadStatusChanged";
  ReceiveCmdS2["FLASH_FILE_UPLOADING"] = "nodeIKernelFlashTransferListener/onFileSetUploadProgressChanged";
  return ReceiveCmdS2;
})(ReceiveCmdS || {});
const receiveHooks = /* @__PURE__ */ new Map();
const NT_RECV_PMHQ_TYPE_TO_NT_METHOD = {
  "on_message": "nodeIKernelMsgListener",
  "on_group": "nodeIKernelGroupListener",
  "on_buddy": "nodeIKernelBuddyListener",
  "on_profile": "nodeIKernelProfileListener",
  "on_flash_file": "nodeIKernelFlashTransferListener"
};
const msgPBMap = /* @__PURE__ */ new Map();
function startHook() {
  pmhq.addResListener((data) => {
    let listenerName = data.type;
    if (data.data && "sub_type" in data.data) {
      const sub_type = data.data.sub_type;
      const convertedListenerName = NT_RECV_PMHQ_TYPE_TO_NT_METHOD[listenerName] || listenerName;
      const ntCmd = convertedListenerName + "/" + sub_type;
      for (const hook of receiveHooks.values()) {
        if (hook.method.includes(ntCmd)) {
          Promise.resolve(hook.hookFunc(data.data.data));
        }
      }
    } else if (data.type === "recv" && data.data.cmd === "trpc.msg.olpush.OlPushService.MsgPush") {
      if (getConfigUtil().getConfig().rawMsgPB) {
        const msg = parseProtobufFromHex(data.data.pb);
        try {
          const peerId = msg[1][1][8][1];
          const msgRand = msg[1][2][4];
          const msgSeq = msg[1][2][5];
          const uniqueId = `${peerId}_${msgRand}_${msgSeq}`;
          if (msgPBMap.size > 1e3) {
            const firstKey = msgPBMap.keys().next().value;
            msgPBMap.delete(firstKey);
          }
          msgPBMap.set(uniqueId, data.data.pb);
        } catch (e) {
        }
      }
    }
  });
}
function registerReceiveHook(method, hookFunc) {
  const id2 = randomUUID();
  if (!Array.isArray(method)) {
    method = [method];
  }
  receiveHooks.set(id2, {
    method,
    hookFunc
  });
  return id2;
}
function removeReceiveHook(id2) {
  receiveHooks.delete(id2);
}
var Sex = /* @__PURE__ */ ((Sex2) => {
  Sex2[Sex2["Unknown"] = 0] = "Unknown";
  Sex2[Sex2["Male"] = 1] = "Male";
  Sex2[Sex2["Female"] = 2] = "Female";
  Sex2[Sex2["Hidden"] = 255] = "Hidden";
  return Sex2;
})(Sex || {});
var UserDetailSource = /* @__PURE__ */ ((UserDetailSource2) => {
  UserDetailSource2[UserDetailSource2["KDB"] = 0] = "KDB";
  UserDetailSource2[UserDetailSource2["KSERVER"] = 1] = "KSERVER";
  return UserDetailSource2;
})(UserDetailSource || {});
var ProfileBizType = /* @__PURE__ */ ((ProfileBizType2) => {
  ProfileBizType2[ProfileBizType2["KALL"] = 0] = "KALL";
  ProfileBizType2[ProfileBizType2["KBASEEXTEND"] = 1] = "KBASEEXTEND";
  ProfileBizType2[ProfileBizType2["KVAS"] = 2] = "KVAS";
  ProfileBizType2[ProfileBizType2["KQZONE"] = 3] = "KQZONE";
  ProfileBizType2[ProfileBizType2["KOTHER"] = 4] = "KOTHER";
  return ProfileBizType2;
})(ProfileBizType || {});
var GroupMemberRole = /* @__PURE__ */ ((GroupMemberRole2) => {
  GroupMemberRole2[GroupMemberRole2["Normal"] = 2] = "Normal";
  GroupMemberRole2[GroupMemberRole2["Admin"] = 3] = "Admin";
  GroupMemberRole2[GroupMemberRole2["Owner"] = 4] = "Owner";
  return GroupMemberRole2;
})(GroupMemberRole || {});
var GroupNotifyType = /* @__PURE__ */ ((GroupNotifyType2) => {
  GroupNotifyType2[GroupNotifyType2["InvitedByMember"] = 1] = "InvitedByMember";
  GroupNotifyType2[GroupNotifyType2["RefuseInvited"] = 2] = "RefuseInvited";
  GroupNotifyType2[GroupNotifyType2["RefusedByAdminiStrator"] = 3] = "RefusedByAdminiStrator";
  GroupNotifyType2[GroupNotifyType2["AgreedTojoinDirect"] = 4] = "AgreedTojoinDirect";
  GroupNotifyType2[GroupNotifyType2["InvitedNeedAdminiStratorPass"] = 5] = "InvitedNeedAdminiStratorPass";
  GroupNotifyType2[GroupNotifyType2["AgreedToJoinByAdminiStrator"] = 6] = "AgreedToJoinByAdminiStrator";
  GroupNotifyType2[GroupNotifyType2["RequestJoinNeedAdminiStratorPass"] = 7] = "RequestJoinNeedAdminiStratorPass";
  GroupNotifyType2[GroupNotifyType2["SetAdmin"] = 8] = "SetAdmin";
  GroupNotifyType2[GroupNotifyType2["KickMemberNotifyAdmin"] = 9] = "KickMemberNotifyAdmin";
  GroupNotifyType2[GroupNotifyType2["KickMemberNotifyKicked"] = 10] = "KickMemberNotifyKicked";
  GroupNotifyType2[GroupNotifyType2["MemberLeaveNotifyAdmin"] = 11] = "MemberLeaveNotifyAdmin";
  GroupNotifyType2[GroupNotifyType2["CancelAdminNotifyCanceled"] = 12] = "CancelAdminNotifyCanceled";
  GroupNotifyType2[GroupNotifyType2["CancelAdminNotifyAdmin"] = 13] = "CancelAdminNotifyAdmin";
  GroupNotifyType2[GroupNotifyType2["TransferGroupNotifyOldowner"] = 14] = "TransferGroupNotifyOldowner";
  GroupNotifyType2[GroupNotifyType2["TransferGroupNotifyAdmin"] = 15] = "TransferGroupNotifyAdmin";
  return GroupNotifyType2;
})(GroupNotifyType || {});
var GroupNotifyStatus = /* @__PURE__ */ ((GroupNotifyStatus2) => {
  GroupNotifyStatus2[GroupNotifyStatus2["Init"] = 0] = "Init";
  GroupNotifyStatus2[GroupNotifyStatus2["Unhandle"] = 1] = "Unhandle";
  GroupNotifyStatus2[GroupNotifyStatus2["Agreed"] = 2] = "Agreed";
  GroupNotifyStatus2[GroupNotifyStatus2["Refused"] = 3] = "Refused";
  GroupNotifyStatus2[GroupNotifyStatus2["Ignored"] = 4] = "Ignored";
  return GroupNotifyStatus2;
})(GroupNotifyStatus || {});
var GroupRequestOperateTypes = /* @__PURE__ */ ((GroupRequestOperateTypes2) => {
  GroupRequestOperateTypes2[GroupRequestOperateTypes2["Approve"] = 1] = "Approve";
  GroupRequestOperateTypes2[GroupRequestOperateTypes2["Reject"] = 2] = "Reject";
  return GroupRequestOperateTypes2;
})(GroupRequestOperateTypes || {});
var BuddyReqType = /* @__PURE__ */ ((BuddyReqType2) => {
  BuddyReqType2[BuddyReqType2["MeInitiator"] = 0] = "MeInitiator";
  BuddyReqType2[BuddyReqType2["PeerInitiator"] = 1] = "PeerInitiator";
  BuddyReqType2[BuddyReqType2["MeAgreed"] = 2] = "MeAgreed";
  BuddyReqType2[BuddyReqType2["MeAgreedAndAdded"] = 3] = "MeAgreedAndAdded";
  BuddyReqType2[BuddyReqType2["PeerAgreed"] = 4] = "PeerAgreed";
  BuddyReqType2[BuddyReqType2["PeerAgreedAndAdded"] = 5] = "PeerAgreedAndAdded";
  BuddyReqType2[BuddyReqType2["PeerRefused"] = 6] = "PeerRefused";
  BuddyReqType2[BuddyReqType2["MeRefused"] = 7] = "MeRefused";
  BuddyReqType2[BuddyReqType2["MeIgnored"] = 8] = "MeIgnored";
  BuddyReqType2[BuddyReqType2["MeAgreeAnyone"] = 9] = "MeAgreeAnyone";
  BuddyReqType2[BuddyReqType2["MeSetQuestion"] = 10] = "MeSetQuestion";
  BuddyReqType2[BuddyReqType2["MeAgreeAndAddFailed"] = 11] = "MeAgreeAndAddFailed";
  BuddyReqType2[BuddyReqType2["MsgInfo"] = 12] = "MsgInfo";
  BuddyReqType2[BuddyReqType2["MeInitiatorWaitPeerConfirm"] = 13] = "MeInitiatorWaitPeerConfirm";
  return BuddyReqType2;
})(BuddyReqType || {});
var FlashFileDownloadStatus = /* @__PURE__ */ ((FlashFileDownloadStatus2) => {
  FlashFileDownloadStatus2[FlashFileDownloadStatus2["DOWNLOADING"] = 1] = "DOWNLOADING";
  FlashFileDownloadStatus2[FlashFileDownloadStatus2["DOWNLOADED"] = 2] = "DOWNLOADED";
  return FlashFileDownloadStatus2;
})(FlashFileDownloadStatus || {});
var FlashFileUploadStatus = /* @__PURE__ */ ((FlashFileUploadStatus2) => {
  FlashFileUploadStatus2[FlashFileUploadStatus2["UPLOADED"] = 4] = "UPLOADED";
  return FlashFileUploadStatus2;
})(FlashFileUploadStatus || {});
async function logSummaryMessage(ctx, message) {
  const direction = message.senderUid == selfInfo.uid ? "" : "";
  let sender = message.sendMemberName || message.sendRemarkName || message.sendNickName;
  const senderUin = message.senderUin;
  let summary = "";
  for (const msgEle of message.elements) {
    switch (msgEle.elementType) {
      case ElementType.Text:
        {
          summary += `${msgEle.textElement?.content}`;
        }
        break;
      case ElementType.Pic:
        {
          summary += `[]${msgEle.picElement?.fileName}
`;
        }
        break;
      case ElementType.Face:
        {
          summary += `[]${msgEle.faceElement?.faceText || ""}
`;
        }
        break;
      case ElementType.Ptt:
        {
          summary += `[](${msgEle.pttElement?.fileName})`;
        }
        break;
      case ElementType.Video:
        {
          summary += `[]${msgEle.videoElement?.fileName}`;
        }
        break;
      case ElementType.File:
        {
          summary += `[]${msgEle.fileElement?.fileName}
`;
        }
        break;
      case ElementType.Ark:
        {
          summary += `[]
`;
        }
        break;
      case ElementType.MultiForward: {
        summary += `[]
`;
      }
    }
  }
  if (!summary) {
    return;
  }
  new Date(parseInt(message.msgTime) * 1e3);
  let peerName = "";
  if (message.chatType == ChatType.Group) {
    peerName = `] ${message.peerName}(${message.peerUid}) ${sender}(${senderUin})`;
  } else if (message.chatType == ChatType.C2C) {
    try {
      const userUid = message.peerUid;
      const userInfo = (await ctx.ntUserApi.getUserDetailInfoWithBizInfo(userUid)).simpleInfo.coreInfo;
      sender = userInfo.remark || userInfo.nick;
      peerName = `] ${sender}(${userInfo.uin})`;
    } catch (e) {
      return;
    }
  } else if (message.chatType == ChatType.TempC2CFromGroup) {
    peerName = `] ${message.peerName}(${message.peerUin})`;
  }
  const logMsg = `[${direction}-${peerName}
${summary}`;
  ctx.logger.info(logMsg);
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var utils$4 = { exports: {} };
var windows;
var hasRequiredWindows;
function requireWindows() {
  if (hasRequiredWindows) return windows;
  hasRequiredWindows = 1;
  windows = isexe;
  isexe.sync = sync;
  var fs2 = require$$0$4;
  function checkPathExt(path2, options) {
    var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path2.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat2, path2, options) {
    if (!stat2.isSymbolicLink() && !stat2.isFile()) {
      return false;
    }
    return checkPathExt(path2, options);
  }
  function isexe(path2, options, cb) {
    fs2.stat(path2, function(er, stat2) {
      cb(er, er ? false : checkStat(stat2, path2, options));
    });
  }
  function sync(path2, options) {
    return checkStat(fs2.statSync(path2), path2, options);
  }
  return windows;
}
var mode;
var hasRequiredMode;
function requireMode() {
  if (hasRequiredMode) return mode;
  hasRequiredMode = 1;
  mode = isexe;
  isexe.sync = sync;
  var fs2 = require$$0$4;
  function isexe(path2, options, cb) {
    fs2.stat(path2, function(er, stat2) {
      cb(er, er ? false : checkStat(stat2, options));
    });
  }
  function sync(path2, options) {
    return checkStat(fs2.statSync(path2), options);
  }
  function checkStat(stat2, options) {
    return stat2.isFile() && checkMode(stat2, options);
  }
  function checkMode(stat2, options) {
    var mod = stat2.mode;
    var uid = stat2.uid;
    var gid = stat2.gid;
    var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
  return mode;
}
var isexe_1;
var hasRequiredIsexe;
function requireIsexe() {
  if (hasRequiredIsexe) return isexe_1;
  hasRequiredIsexe = 1;
  var core;
  if (process.platform === "win32" || commonjsGlobal.TESTING_WINDOWS) {
    core = requireWindows();
  } else {
    core = requireMode();
  }
  isexe_1 = isexe;
  isexe.sync = sync;
  function isexe(path2, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve2, reject) {
        isexe(path2, options || {}, function(er, is2) {
          if (er) {
            reject(er);
          } else {
            resolve2(is2);
          }
        });
      });
    }
    core(path2, options || {}, function(er, is2) {
      if (er) {
        if (er.code === "EACCES" || options && options.ignoreErrors) {
          er = null;
          is2 = false;
        }
      }
      cb(er, is2);
    });
  }
  function sync(path2, options) {
    try {
      return core.sync(path2, options || {});
    } catch (er) {
      if (options && options.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
  return isexe_1;
}
var which_1;
var hasRequiredWhich;
function requireWhich() {
  if (hasRequiredWhich) return which_1;
  hasRequiredWhich = 1;
  which_1 = which;
  which.sync = whichSync;
  var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path2 = path$1;
  var COLON = isWindows ? ";" : ":";
  var isexe = requireIsexe();
  function getNotFoundError(cmd) {
    var er = new Error("not found: " + cmd);
    er.code = "ENOENT";
    return er;
  }
  function getPathInfo(cmd, opt) {
    var colon = opt.colon || COLON;
    var pathEnv = opt.path || process.env.PATH || "";
    var pathExt = [""];
    pathEnv = pathEnv.split(colon);
    var pathExtExe = "";
    if (isWindows) {
      pathEnv.unshift(process.cwd());
      pathExtExe = opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM";
      pathExt = pathExtExe.split(colon);
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    if (cmd.match(/\//) || isWindows && cmd.match(/\\/))
      pathEnv = [""];
    return {
      env: pathEnv,
      ext: pathExt,
      extExe: pathExtExe
    };
  }
  function which(cmd, opt, cb) {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    var info = getPathInfo(cmd, opt);
    var pathEnv = info.env;
    var pathExt = info.ext;
    var pathExtExe = info.extExe;
    var found = [];
    (function F(i, l) {
      if (i === l) {
        if (opt.all && found.length)
          return cb(null, found);
        else
          return cb(getNotFoundError(cmd));
      }
      var pathPart = pathEnv[i];
      if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
        pathPart = pathPart.slice(1, -1);
      var p = path2.join(pathPart, cmd);
      if (!pathPart && /^\.[\\\/]/.test(cmd)) {
        p = cmd.slice(0, 2) + p;
      }
      (function E(ii, ll) {
        if (ii === ll) return F(i + 1, l);
        var ext = pathExt[ii];
        isexe(p + ext, { pathExt: pathExtExe }, function(er, is2) {
          if (!er && is2) {
            if (opt.all)
              found.push(p + ext);
            else
              return cb(null, p + ext);
          }
          return E(ii + 1, ll);
        });
      })(0, pathExt.length);
    })(0, pathEnv.length);
  }
  function whichSync(cmd, opt) {
    opt = opt || {};
    var info = getPathInfo(cmd, opt);
    var pathEnv = info.env;
    var pathExt = info.ext;
    var pathExtExe = info.extExe;
    var found = [];
    for (var i = 0, l = pathEnv.length; i < l; i++) {
      var pathPart = pathEnv[i];
      if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
        pathPart = pathPart.slice(1, -1);
      var p = path2.join(pathPart, cmd);
      if (!pathPart && /^\.[\\\/]/.test(cmd)) {
        p = cmd.slice(0, 2) + p;
      }
      for (var j = 0, ll = pathExt.length; j < ll; j++) {
        var cur = p + pathExt[j];
        var is2;
        try {
          is2 = isexe.sync(cur, { pathExt: pathExtExe });
          if (is2) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {
        }
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  }
  return which_1;
}
var hasRequiredUtils$4;
function requireUtils$4() {
  if (hasRequiredUtils$4) return utils$4.exports;
  hasRequiredUtils$4 = 1;
  require$$0$5.exec;
  var isWindows = require$$1$1.platform().match(/win(32|64)/);
  var which = requireWhich();
  var nlRegexp = /\r\n|\r|\n/g;
  var streamRegexp = /^\[?(.*?)\]?$/;
  var filterEscapeRegexp = /[,]/;
  var whichCache = {};
  function parseProgressLine(line2) {
    var progress = {};
    line2 = line2.replace(/=\s+/g, "=").trim();
    var progressParts = line2.split(" ");
    for (var i = 0; i < progressParts.length; i++) {
      var progressSplit = progressParts[i].split("=", 2);
      var key2 = progressSplit[0];
      var value = progressSplit[1];
      if (typeof value === "undefined")
        return null;
      progress[key2] = value;
    }
    return progress;
  }
  var utils2 = utils$4.exports = {
    isWindows,
    streamRegexp,
    /**
     * Copy an object keys into another one
     *
     * @param {Object} source source object
     * @param {Object} dest destination object
     * @private
     */
    copy: function(source2, dest) {
      Object.keys(source2).forEach(function(key2) {
        dest[key2] = source2[key2];
      });
    },
    /**
     * Create an argument list
     *
     * Returns a function that adds new arguments to the list.
     * It also has the following methods:
     * - clear() empties the argument list
     * - get() returns the argument list
     * - find(arg, count) finds 'arg' in the list and return the following 'count' items, or undefined if not found
     * - remove(arg, count) remove 'arg' in the list as well as the following 'count' items
     *
     * @private
     */
    args: function() {
      var list = [];
      var argfunc = function() {
        if (arguments.length === 1 && Array.isArray(arguments[0])) {
          list = list.concat(arguments[0]);
        } else {
          list = list.concat([].slice.call(arguments));
        }
      };
      argfunc.clear = function() {
        list = [];
      };
      argfunc.get = function() {
        return list;
      };
      argfunc.find = function(arg, count) {
        var index2 = list.indexOf(arg);
        if (index2 !== -1) {
          return list.slice(index2 + 1, index2 + 1 + (count || 0));
        }
      };
      argfunc.remove = function(arg, count) {
        var index2 = list.indexOf(arg);
        if (index2 !== -1) {
          list.splice(index2, (count || 0) + 1);
        }
      };
      argfunc.clone = function() {
        var cloned = utils2.args();
        cloned(list);
        return cloned;
      };
      return argfunc;
    },
    /**
     * Generate filter strings
     *
     * @param {String[]|Object[]} filters filter specifications. When using objects,
     *   each must have the following properties:
     * @param {String} filters.filter filter name
     * @param {String|Array} [filters.inputs] (array of) input stream specifier(s) for the filter,
     *   defaults to ffmpeg automatically choosing the first unused matching streams
     * @param {String|Array} [filters.outputs] (array of) output stream specifier(s) for the filter,
     *   defaults to ffmpeg automatically assigning the output to the output file
     * @param {Object|String|Array} [filters.options] filter options, can be omitted to not set any options
     * @return String[]
     * @private
     */
    makeFilterStrings: function(filters) {
      return filters.map(function(filterSpec) {
        if (typeof filterSpec === "string") {
          return filterSpec;
        }
        var filterString = "";
        if (Array.isArray(filterSpec.inputs)) {
          filterString += filterSpec.inputs.map(function(streamSpec) {
            return streamSpec.replace(streamRegexp, "[$1]");
          }).join("");
        } else if (typeof filterSpec.inputs === "string") {
          filterString += filterSpec.inputs.replace(streamRegexp, "[$1]");
        }
        filterString += filterSpec.filter;
        if (filterSpec.options) {
          if (typeof filterSpec.options === "string" || typeof filterSpec.options === "number") {
            filterString += "=" + filterSpec.options;
          } else if (Array.isArray(filterSpec.options)) {
            filterString += "=" + filterSpec.options.map(function(option) {
              if (typeof option === "string" && option.match(filterEscapeRegexp)) {
                return "'" + option + "'";
              } else {
                return option;
              }
            }).join(":");
          } else if (Object.keys(filterSpec.options).length) {
            filterString += "=" + Object.keys(filterSpec.options).map(function(option) {
              var value = filterSpec.options[option];
              if (typeof value === "string" && value.match(filterEscapeRegexp)) {
                value = "'" + value + "'";
              }
              return option + "=" + value;
            }).join(":");
          }
        }
        if (Array.isArray(filterSpec.outputs)) {
          filterString += filterSpec.outputs.map(function(streamSpec) {
            return streamSpec.replace(streamRegexp, "[$1]");
          }).join("");
        } else if (typeof filterSpec.outputs === "string") {
          filterString += filterSpec.outputs.replace(streamRegexp, "[$1]");
        }
        return filterString;
      });
    },
    /**
     * Search for an executable
     *
     * Uses 'which' or 'where' depending on platform
     *
     * @param {String} name executable name
     * @param {Function} callback callback with signature (err, path)
     * @private
     */
    which: function(name, callback) {
      if (name in whichCache) {
        return callback(null, whichCache[name]);
      }
      which(name, function(err, result) {
        if (err) {
          return callback(null, whichCache[name] = "");
        }
        callback(null, whichCache[name] = result);
      });
    },
    /**
     * Convert a [[hh:]mm:]ss[.xxx] timemark into seconds
     *
     * @param {String} timemark timemark string
     * @return Number
     * @private
     */
    timemarkToSeconds: function(timemark) {
      if (typeof timemark === "number") {
        return timemark;
      }
      if (timemark.indexOf(":") === -1 && timemark.indexOf(".") >= 0) {
        return Number(timemark);
      }
      var parts = timemark.split(":");
      var secs = Number(parts.pop());
      if (parts.length) {
        secs += Number(parts.pop()) * 60;
      }
      if (parts.length) {
        secs += Number(parts.pop()) * 3600;
      }
      return secs;
    },
    /**
     * Extract codec data from ffmpeg stderr and emit 'codecData' event if appropriate
     * Call it with an initially empty codec object once with each line of stderr output until it returns true
     *
     * @param {FfmpegCommand} command event emitter
     * @param {String} stderrLine ffmpeg stderr output line
     * @param {Object} codecObject object used to accumulate codec data between calls
     * @return {Boolean} true if codec data is complete (and event was emitted), false otherwise
     * @private
     */
    extractCodecData: function(command, stderrLine, codecsObject) {
      var inputPattern = /Input #[0-9]+, ([^ ]+),/;
      var durPattern = /Duration\: ([^,]+)/;
      var audioPattern = /Audio\: (.*)/;
      var videoPattern = /Video\: (.*)/;
      if (!("inputStack" in codecsObject)) {
        codecsObject.inputStack = [];
        codecsObject.inputIndex = -1;
        codecsObject.inInput = false;
      }
      var inputStack = codecsObject.inputStack;
      var inputIndex = codecsObject.inputIndex;
      var inInput = codecsObject.inInput;
      var format, dur, audio2, video2;
      if (format = stderrLine.match(inputPattern)) {
        inInput = codecsObject.inInput = true;
        inputIndex = codecsObject.inputIndex = codecsObject.inputIndex + 1;
        inputStack[inputIndex] = { format: format[1], audio: "", video: "", duration: "" };
      } else if (inInput && (dur = stderrLine.match(durPattern))) {
        inputStack[inputIndex].duration = dur[1];
      } else if (inInput && (audio2 = stderrLine.match(audioPattern))) {
        audio2 = audio2[1].split(", ");
        inputStack[inputIndex].audio = audio2[0];
        inputStack[inputIndex].audio_details = audio2;
      } else if (inInput && (video2 = stderrLine.match(videoPattern))) {
        video2 = video2[1].split(", ");
        inputStack[inputIndex].video = video2[0];
        inputStack[inputIndex].video_details = video2;
      } else if (/Output #\d+/.test(stderrLine)) {
        inInput = codecsObject.inInput = false;
      } else if (/Stream mapping:|Press (\[q\]|ctrl-c) to stop/.test(stderrLine)) {
        command.emit.apply(command, ["codecData"].concat(inputStack));
        return true;
      }
      return false;
    },
    /**
     * Extract progress data from ffmpeg stderr and emit 'progress' event if appropriate
     *
     * @param {FfmpegCommand} command event emitter
     * @param {String} stderrLine ffmpeg stderr data
     * @private
     */
    extractProgress: function(command, stderrLine) {
      var progress = parseProgressLine(stderrLine);
      if (progress) {
        var ret = {
          frames: parseInt(progress.frame, 10),
          currentFps: parseInt(progress.fps, 10),
          currentKbps: progress.bitrate ? parseFloat(progress.bitrate.replace("kbits/s", "")) : 0,
          targetSize: parseInt(progress.size || progress.Lsize, 10),
          timemark: progress.time
        };
        if (command._ffprobeData && command._ffprobeData.format && command._ffprobeData.format.duration) {
          var duration2 = Number(command._ffprobeData.format.duration);
          if (!isNaN(duration2))
            ret.percent = utils2.timemarkToSeconds(ret.timemark) / duration2 * 100;
        }
        command.emit("progress", ret);
      }
    },
    /**
     * Extract error message(s) from ffmpeg stderr
     *
     * @param {String} stderr ffmpeg stderr data
     * @return {String}
     * @private
     */
    extractError: function(stderr) {
      return stderr.split(nlRegexp).reduce(function(messages, message) {
        if (message.charAt(0) === " " || message.charAt(0) === "[") {
          return [];
        } else {
          messages.push(message);
          return messages;
        }
      }, []).join("\n");
    },
    /**
     * Creates a line ring buffer object with the following methods:
     * - append(str) : appends a string or buffer
     * - get() : returns the whole string
     * - close() : prevents further append() calls and does a last call to callbacks
     * - callback(cb) : calls cb for each line (incl. those already in the ring)
     *
     * @param {Number} maxLines maximum number of lines to store (<= 0 for unlimited)
     */
    linesRing: function(maxLines) {
      var cbs = [];
      var lines = [];
      var current = null;
      var closed = false;
      var max2 = maxLines - 1;
      function emit(line2) {
        cbs.forEach(function(cb) {
          cb(line2);
        });
      }
      return {
        callback: function(cb) {
          lines.forEach(function(l) {
            cb(l);
          });
          cbs.push(cb);
        },
        append: function(str) {
          if (closed) return;
          if (str instanceof Buffer) str = "" + str;
          if (!str || str.length === 0) return;
          var newLines = str.split(nlRegexp);
          if (newLines.length === 1) {
            if (current !== null) {
              current = current + newLines.shift();
            } else {
              current = newLines.shift();
            }
          } else {
            if (current !== null) {
              current = current + newLines.shift();
              emit(current);
              lines.push(current);
            }
            current = newLines.pop();
            newLines.forEach(function(l) {
              emit(l);
              lines.push(l);
            });
            if (max2 > -1 && lines.length > max2) {
              lines.splice(0, lines.length - max2);
            }
          }
        },
        get: function() {
          if (current !== null) {
            return lines.concat([current]).join("\n");
          } else {
            return lines.join("\n");
          }
        },
        close: function() {
          if (closed) return;
          if (current !== null) {
            emit(current);
            lines.push(current);
            if (max2 > -1 && lines.length > max2) {
              lines.shift();
            }
            current = null;
          }
          closed = true;
        }
      };
    }
  };
  return utils$4.exports;
}
var inputs;
var hasRequiredInputs;
function requireInputs() {
  if (hasRequiredInputs) return inputs;
  hasRequiredInputs = 1;
  var utils2 = requireUtils$4();
  inputs = function(proto) {
    proto.mergeAdd = proto.addInput = proto.input = function(source2) {
      var isFile = false;
      var isStream = false;
      if (typeof source2 !== "string") {
        if (!("readable" in source2) || !source2.readable) {
          throw new Error("Invalid input");
        }
        var hasInputStream = this._inputs.some(function(input) {
          return input.isStream;
        });
        if (hasInputStream) {
          throw new Error("Only one input stream is supported");
        }
        isStream = true;
        source2.pause();
      } else {
        var protocol = source2.match(/^([a-z]{2,}):/i);
        isFile = !protocol || protocol[0] === "file";
      }
      this._inputs.push(this._currentInput = {
        source: source2,
        isFile,
        isStream,
        options: utils2.args()
      });
      return this;
    };
    proto.withInputFormat = proto.inputFormat = proto.fromFormat = function(format) {
      if (!this._currentInput) {
        throw new Error("No input specified");
      }
      this._currentInput.options("-f", format);
      return this;
    };
    proto.withInputFps = proto.withInputFPS = proto.withFpsInput = proto.withFPSInput = proto.inputFPS = proto.inputFps = proto.fpsInput = proto.FPSInput = function(fps) {
      if (!this._currentInput) {
        throw new Error("No input specified");
      }
      this._currentInput.options("-r", fps);
      return this;
    };
    proto.nativeFramerate = proto.withNativeFramerate = proto.native = function() {
      if (!this._currentInput) {
        throw new Error("No input specified");
      }
      this._currentInput.options("-re");
      return this;
    };
    proto.setStartTime = proto.seekInput = function(seek) {
      if (!this._currentInput) {
        throw new Error("No input specified");
      }
      this._currentInput.options("-ss", seek);
      return this;
    };
    proto.loop = function(duration2) {
      if (!this._currentInput) {
        throw new Error("No input specified");
      }
      this._currentInput.options("-loop", "1");
      if (typeof duration2 !== "undefined") {
        this.duration(duration2);
      }
      return this;
    };
  };
  return inputs;
}
var audio$1;
var hasRequiredAudio;
function requireAudio() {
  if (hasRequiredAudio) return audio$1;
  hasRequiredAudio = 1;
  var utils2 = requireUtils$4();
  audio$1 = function(proto) {
    proto.withNoAudio = proto.noAudio = function() {
      this._currentOutput.audio.clear();
      this._currentOutput.audioFilters.clear();
      this._currentOutput.audio("-an");
      return this;
    };
    proto.withAudioCodec = proto.audioCodec = function(codec2) {
      this._currentOutput.audio("-acodec", codec2);
      return this;
    };
    proto.withAudioBitrate = proto.audioBitrate = function(bitrate) {
      this._currentOutput.audio("-b:a", ("" + bitrate).replace(/k?$/, "k"));
      return this;
    };
    proto.withAudioChannels = proto.audioChannels = function(channels) {
      this._currentOutput.audio("-ac", channels);
      return this;
    };
    proto.withAudioFrequency = proto.audioFrequency = function(freq) {
      this._currentOutput.audio("-ar", freq);
      return this;
    };
    proto.withAudioQuality = proto.audioQuality = function(quality) {
      this._currentOutput.audio("-aq", quality);
      return this;
    };
    proto.withAudioFilter = proto.withAudioFilters = proto.audioFilter = proto.audioFilters = function(filters) {
      if (arguments.length > 1) {
        filters = [].slice.call(arguments);
      }
      if (!Array.isArray(filters)) {
        filters = [filters];
      }
      this._currentOutput.audioFilters(utils2.makeFilterStrings(filters));
      return this;
    };
  };
  return audio$1;
}
var video;
var hasRequiredVideo;
function requireVideo() {
  if (hasRequiredVideo) return video;
  hasRequiredVideo = 1;
  var utils2 = requireUtils$4();
  video = function(proto) {
    proto.withNoVideo = proto.noVideo = function() {
      this._currentOutput.video.clear();
      this._currentOutput.videoFilters.clear();
      this._currentOutput.video("-vn");
      return this;
    };
    proto.withVideoCodec = proto.videoCodec = function(codec2) {
      this._currentOutput.video("-vcodec", codec2);
      return this;
    };
    proto.withVideoBitrate = proto.videoBitrate = function(bitrate, constant) {
      bitrate = ("" + bitrate).replace(/k?$/, "k");
      this._currentOutput.video("-b:v", bitrate);
      if (constant) {
        this._currentOutput.video(
          "-maxrate",
          bitrate,
          "-minrate",
          bitrate,
          "-bufsize",
          "3M"
        );
      }
      return this;
    };
    proto.withVideoFilter = proto.withVideoFilters = proto.videoFilter = proto.videoFilters = function(filters) {
      if (arguments.length > 1) {
        filters = [].slice.call(arguments);
      }
      if (!Array.isArray(filters)) {
        filters = [filters];
      }
      this._currentOutput.videoFilters(utils2.makeFilterStrings(filters));
      return this;
    };
    proto.withOutputFps = proto.withOutputFPS = proto.withFpsOutput = proto.withFPSOutput = proto.withFps = proto.withFPS = proto.outputFPS = proto.outputFps = proto.fpsOutput = proto.FPSOutput = proto.fps = proto.FPS = function(fps) {
      this._currentOutput.video("-r", fps);
      return this;
    };
    proto.takeFrames = proto.withFrames = proto.frames = function(frames) {
      this._currentOutput.video("-vframes", frames);
      return this;
    };
  };
  return video;
}
var videosize;
var hasRequiredVideosize;
function requireVideosize() {
  if (hasRequiredVideosize) return videosize;
  hasRequiredVideosize = 1;
  function getScalePadFilters(width, height, aspect, color) {
    return [
      /*
        In both cases, we first have to scale the input to match the requested size.
        When using computed width/height, we truncate them to multiples of 2
       */
      {
        filter: "scale",
        options: {
          w: "if(gt(a," + aspect + ")," + width + ",trunc(" + height + "*a/2)*2)",
          h: "if(lt(a," + aspect + ")," + height + ",trunc(" + width + "/a/2)*2)"
        }
      },
      /*
        Then we pad the scaled input to match the target size
        (here iw and ih refer to the padding input, i.e the scaled output)
       */
      {
        filter: "pad",
        options: {
          w: width,
          h: height,
          x: "if(gt(a," + aspect + "),0,(" + width + "-iw)/2)",
          y: "if(lt(a," + aspect + "),0,(" + height + "-ih)/2)",
          color
        }
      }
    ];
  }
  function createSizeFilters(output2, key2, value) {
    var data = output2.sizeData = output2.sizeData || {};
    data[key2] = value;
    if (!("size" in data)) {
      return [];
    }
    var fixedSize = data.size.match(/([0-9]+)x([0-9]+)/);
    var fixedWidth = data.size.match(/([0-9]+)x\?/);
    var fixedHeight = data.size.match(/\?x([0-9]+)/);
    var percentRatio = data.size.match(/\b([0-9]{1,3})%/);
    var width, height, aspect;
    if (percentRatio) {
      var ratio = Number(percentRatio[1]) / 100;
      return [{
        filter: "scale",
        options: {
          w: "trunc(iw*" + ratio + "/2)*2",
          h: "trunc(ih*" + ratio + "/2)*2"
        }
      }];
    } else if (fixedSize) {
      width = Math.round(Number(fixedSize[1]) / 2) * 2;
      height = Math.round(Number(fixedSize[2]) / 2) * 2;
      aspect = width / height;
      if (data.pad) {
        return getScalePadFilters(width, height, aspect, data.pad);
      } else {
        return [{ filter: "scale", options: { w: width, h: height } }];
      }
    } else if (fixedWidth || fixedHeight) {
      if ("aspect" in data) {
        width = fixedWidth ? fixedWidth[1] : Math.round(Number(fixedHeight[1]) * data.aspect);
        height = fixedHeight ? fixedHeight[1] : Math.round(Number(fixedWidth[1]) / data.aspect);
        width = Math.round(width / 2) * 2;
        height = Math.round(height / 2) * 2;
        if (data.pad) {
          return getScalePadFilters(width, height, data.aspect, data.pad);
        } else {
          return [{ filter: "scale", options: { w: width, h: height } }];
        }
      } else {
        if (fixedWidth) {
          return [{
            filter: "scale",
            options: {
              w: Math.round(Number(fixedWidth[1]) / 2) * 2,
              h: "trunc(ow/a/2)*2"
            }
          }];
        } else {
          return [{
            filter: "scale",
            options: {
              w: "trunc(oh*a/2)*2",
              h: Math.round(Number(fixedHeight[1]) / 2) * 2
            }
          }];
        }
      }
    } else {
      throw new Error("Invalid size specified: " + data.size);
    }
  }
  videosize = function(proto) {
    proto.keepPixelAspect = // Only for compatibility, this is not about keeping _pixel_ aspect ratio
    proto.keepDisplayAspect = proto.keepDisplayAspectRatio = proto.keepDAR = function() {
      return this.videoFilters([
        {
          filter: "scale",
          options: {
            w: "if(gt(sar,1),iw*sar,iw)",
            h: "if(lt(sar,1),ih/sar,ih)"
          }
        },
        {
          filter: "setsar",
          options: "1"
        }
      ]);
    };
    proto.withSize = proto.setSize = proto.size = function(size) {
      var filters = createSizeFilters(this._currentOutput, "size", size);
      this._currentOutput.sizeFilters.clear();
      this._currentOutput.sizeFilters(filters);
      return this;
    };
    proto.withAspect = proto.withAspectRatio = proto.setAspect = proto.setAspectRatio = proto.aspect = proto.aspectRatio = function(aspect) {
      var a = Number(aspect);
      if (isNaN(a)) {
        var match = aspect.match(/^(\d+):(\d+)$/);
        if (match) {
          a = Number(match[1]) / Number(match[2]);
        } else {
          throw new Error("Invalid aspect ratio: " + aspect);
        }
      }
      var filters = createSizeFilters(this._currentOutput, "aspect", a);
      this._currentOutput.sizeFilters.clear();
      this._currentOutput.sizeFilters(filters);
      return this;
    };
    proto.applyAutopadding = proto.applyAutoPadding = proto.applyAutopad = proto.applyAutoPad = proto.withAutopadding = proto.withAutoPadding = proto.withAutopad = proto.withAutoPad = proto.autoPad = proto.autopad = function(pad, color) {
      if (typeof pad === "string") {
        color = pad;
        pad = true;
      }
      if (typeof pad === "undefined") {
        pad = true;
      }
      var filters = createSizeFilters(this._currentOutput, "pad", pad ? color || "black" : false);
      this._currentOutput.sizeFilters.clear();
      this._currentOutput.sizeFilters(filters);
      return this;
    };
  };
  return videosize;
}
var output;
var hasRequiredOutput;
function requireOutput() {
  if (hasRequiredOutput) return output;
  hasRequiredOutput = 1;
  var utils2 = requireUtils$4();
  output = function(proto) {
    proto.addOutput = proto.output = function(target, pipeopts) {
      var isFile = false;
      if (!target && this._currentOutput) {
        throw new Error("Invalid output");
      }
      if (target && typeof target !== "string") {
        if (!("writable" in target) || !target.writable) {
          throw new Error("Invalid output");
        }
      } else if (typeof target === "string") {
        var protocol = target.match(/^([a-z]{2,}):/i);
        isFile = !protocol || protocol[0] === "file";
      }
      if (target && !("target" in this._currentOutput)) {
        this._currentOutput.target = target;
        this._currentOutput.isFile = isFile;
        this._currentOutput.pipeopts = pipeopts || {};
      } else {
        if (target && typeof target !== "string") {
          var hasOutputStream = this._outputs.some(function(output2) {
            return typeof output2.target !== "string";
          });
          if (hasOutputStream) {
            throw new Error("Only one output stream is supported");
          }
        }
        this._outputs.push(this._currentOutput = {
          target,
          isFile,
          flags: {},
          pipeopts: pipeopts || {}
        });
        var self2 = this;
        ["audio", "audioFilters", "video", "videoFilters", "sizeFilters", "options"].forEach(function(key2) {
          self2._currentOutput[key2] = utils2.args();
        });
        if (!target) {
          delete this._currentOutput.target;
        }
      }
      return this;
    };
    proto.seekOutput = proto.seek = function(seek) {
      this._currentOutput.options("-ss", seek);
      return this;
    };
    proto.withDuration = proto.setDuration = proto.duration = function(duration2) {
      this._currentOutput.options("-t", duration2);
      return this;
    };
    proto.toFormat = proto.withOutputFormat = proto.outputFormat = proto.format = function(format) {
      this._currentOutput.options("-f", format);
      return this;
    };
    proto.map = function(spec) {
      this._currentOutput.options("-map", spec.replace(utils2.streamRegexp, "[$1]"));
      return this;
    };
    proto.updateFlvMetadata = proto.flvmeta = function() {
      this._currentOutput.flags.flvmeta = true;
      return this;
    };
  };
  return output;
}
var custom$1;
var hasRequiredCustom;
function requireCustom() {
  if (hasRequiredCustom) return custom$1;
  hasRequiredCustom = 1;
  var utils2 = requireUtils$4();
  custom$1 = function(proto) {
    proto.addInputOption = proto.addInputOptions = proto.withInputOption = proto.withInputOptions = proto.inputOption = proto.inputOptions = function(options) {
      if (!this._currentInput) {
        throw new Error("No input specified");
      }
      var doSplit = true;
      if (arguments.length > 1) {
        options = [].slice.call(arguments);
        doSplit = false;
      }
      if (!Array.isArray(options)) {
        options = [options];
      }
      this._currentInput.options(options.reduce(function(options2, option) {
        var split = String(option).split(" ");
        if (doSplit && split.length === 2) {
          options2.push(split[0], split[1]);
        } else {
          options2.push(option);
        }
        return options2;
      }, []));
      return this;
    };
    proto.addOutputOption = proto.addOutputOptions = proto.addOption = proto.addOptions = proto.withOutputOption = proto.withOutputOptions = proto.withOption = proto.withOptions = proto.outputOption = proto.outputOptions = function(options) {
      var doSplit = true;
      if (arguments.length > 1) {
        options = [].slice.call(arguments);
        doSplit = false;
      }
      if (!Array.isArray(options)) {
        options = [options];
      }
      this._currentOutput.options(options.reduce(function(options2, option) {
        var split = String(option).split(" ");
        if (doSplit && split.length === 2) {
          options2.push(split[0], split[1]);
        } else {
          options2.push(option);
        }
        return options2;
      }, []));
      return this;
    };
    proto.filterGraph = proto.complexFilter = function(spec, map2) {
      this._complexFilters.clear();
      if (!Array.isArray(spec)) {
        spec = [spec];
      }
      this._complexFilters("-filter_complex", utils2.makeFilterStrings(spec).join(";"));
      if (Array.isArray(map2)) {
        var self2 = this;
        map2.forEach(function(streamSpec) {
          self2._complexFilters("-map", streamSpec.replace(utils2.streamRegexp, "[$1]"));
        });
      } else if (typeof map2 === "string") {
        this._complexFilters("-map", map2.replace(utils2.streamRegexp, "[$1]"));
      }
      return this;
    };
  };
  return custom$1;
}
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var misc;
var hasRequiredMisc;
function requireMisc() {
  if (hasRequiredMisc) return misc;
  hasRequiredMisc = 1;
  var path2 = path$1;
  misc = function(proto) {
    proto.usingPreset = proto.preset = function(preset) {
      if (typeof preset === "function") {
        preset(this);
      } else {
        try {
          var modulePath = path2.join(this.options.presets, preset);
          var module = commonjsRequire(modulePath);
          if (typeof module.load === "function") {
            module.load(this);
          } else {
            throw new Error("preset " + modulePath + " has no load() function");
          }
        } catch (err) {
          throw new Error("preset " + modulePath + " could not be loaded: " + err.message);
        }
      }
      return this;
    };
  };
  return misc;
}
var async = { exports: {} };
var hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async.exports;
  hasRequiredAsync = 1;
  (function(module) {
    (function() {
      var async2 = {};
      var root2, previous_async;
      root2 = this;
      if (root2 != null) {
        previous_async = root2.async;
      }
      async2.noConflict = function() {
        root2.async = previous_async;
        return async2;
      };
      function only_once(fn) {
        var called = false;
        return function() {
          if (called) throw new Error("Callback was already called.");
          called = true;
          fn.apply(root2, arguments);
        };
      }
      var _each = function(arr, iterator) {
        if (arr.forEach) {
          return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
          iterator(arr[i], i, arr);
        }
      };
      var _map2 = function(arr, iterator) {
        if (arr.map) {
          return arr.map(iterator);
        }
        var results = [];
        _each(arr, function(x, i, a) {
          results.push(iterator(x, i, a));
        });
        return results;
      };
      var _reduce = function(arr, iterator, memo) {
        if (arr.reduce) {
          return arr.reduce(iterator, memo);
        }
        _each(arr, function(x, i, a) {
          memo = iterator(memo, x, i, a);
        });
        return memo;
      };
      var _keys = function(obj) {
        if (Object.keys) {
          return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
          if (obj.hasOwnProperty(k)) {
            keys.push(k);
          }
        }
        return keys;
      };
      if (typeof process === "undefined" || !process.nextTick) {
        if (typeof setImmediate === "function") {
          async2.nextTick = function(fn) {
            setImmediate(fn);
          };
          async2.setImmediate = async2.nextTick;
        } else {
          async2.nextTick = function(fn) {
            setTimeout(fn, 0);
          };
          async2.setImmediate = async2.nextTick;
        }
      } else {
        async2.nextTick = process.nextTick;
        if (typeof setImmediate !== "undefined") {
          async2.setImmediate = function(fn) {
            setImmediate(fn);
          };
        } else {
          async2.setImmediate = async2.nextTick;
        }
      }
      async2.each = function(arr, iterator, callback) {
        callback = callback || function() {
        };
        if (!arr.length) {
          return callback();
        }
        var completed = 0;
        _each(arr, function(x) {
          iterator(x, only_once(function(err) {
            if (err) {
              callback(err);
              callback = function() {
              };
            } else {
              completed += 1;
              if (completed >= arr.length) {
                callback(null);
              }
            }
          }));
        });
      };
      async2.forEach = async2.each;
      async2.eachSeries = function(arr, iterator, callback) {
        callback = callback || function() {
        };
        if (!arr.length) {
          return callback();
        }
        var completed = 0;
        var iterate = function() {
          iterator(arr[completed], function(err) {
            if (err) {
              callback(err);
              callback = function() {
              };
            } else {
              completed += 1;
              if (completed >= arr.length) {
                callback(null);
              } else {
                iterate();
              }
            }
          });
        };
        iterate();
      };
      async2.forEachSeries = async2.eachSeries;
      async2.eachLimit = function(arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
      };
      async2.forEachLimit = async2.eachLimit;
      var _eachLimit = function(limit) {
        return function(arr, iterator, callback) {
          callback = callback || function() {
          };
          if (!arr.length || limit <= 0) {
            return callback();
          }
          var completed = 0;
          var started = 0;
          var running = 0;
          (function replenish() {
            if (completed >= arr.length) {
              return callback();
            }
            while (running < limit && started < arr.length) {
              started += 1;
              running += 1;
              iterator(arr[started - 1], function(err) {
                if (err) {
                  callback(err);
                  callback = function() {
                  };
                } else {
                  completed += 1;
                  running -= 1;
                  if (completed >= arr.length) {
                    callback();
                  } else {
                    replenish();
                  }
                }
              });
            }
          })();
        };
      };
      var doParallel = function(fn) {
        return function() {
          var args = Array.prototype.slice.call(arguments);
          return fn.apply(null, [async2.each].concat(args));
        };
      };
      var doParallelLimit = function(limit, fn) {
        return function() {
          var args = Array.prototype.slice.call(arguments);
          return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
      };
      var doSeries = function(fn) {
        return function() {
          var args = Array.prototype.slice.call(arguments);
          return fn.apply(null, [async2.eachSeries].concat(args));
        };
      };
      var _asyncMap = function(eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map2(arr, function(x, i) {
          return { index: i, value: x };
        });
        eachfn(arr, function(x, callback2) {
          iterator(x.value, function(err, v) {
            results[x.index] = v;
            callback2(err);
          });
        }, function(err) {
          callback(err, results);
        });
      };
      async2.map = doParallel(_asyncMap);
      async2.mapSeries = doSeries(_asyncMap);
      async2.mapLimit = function(arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
      };
      var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
      };
      async2.reduce = function(arr, memo, iterator, callback) {
        async2.eachSeries(arr, function(x, callback2) {
          iterator(memo, x, function(err, v) {
            memo = v;
            callback2(err);
          });
        }, function(err) {
          callback(err, memo);
        });
      };
      async2.inject = async2.reduce;
      async2.foldl = async2.reduce;
      async2.reduceRight = function(arr, memo, iterator, callback) {
        var reversed = _map2(arr, function(x) {
          return x;
        }).reverse();
        async2.reduce(reversed, memo, iterator, callback);
      };
      async2.foldr = async2.reduceRight;
      var _filter = function(eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map2(arr, function(x, i) {
          return { index: i, value: x };
        });
        eachfn(arr, function(x, callback2) {
          iterator(x.value, function(v) {
            if (v) {
              results.push(x);
            }
            callback2();
          });
        }, function(err) {
          callback(_map2(results.sort(function(a, b) {
            return a.index - b.index;
          }), function(x) {
            return x.value;
          }));
        });
      };
      async2.filter = doParallel(_filter);
      async2.filterSeries = doSeries(_filter);
      async2.select = async2.filter;
      async2.selectSeries = async2.filterSeries;
      var _reject = function(eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map2(arr, function(x, i) {
          return { index: i, value: x };
        });
        eachfn(arr, function(x, callback2) {
          iterator(x.value, function(v) {
            if (!v) {
              results.push(x);
            }
            callback2();
          });
        }, function(err) {
          callback(_map2(results.sort(function(a, b) {
            return a.index - b.index;
          }), function(x) {
            return x.value;
          }));
        });
      };
      async2.reject = doParallel(_reject);
      async2.rejectSeries = doSeries(_reject);
      var _detect = function(eachfn, arr, iterator, main_callback) {
        eachfn(arr, function(x, callback) {
          iterator(x, function(result) {
            if (result) {
              main_callback(x);
              main_callback = function() {
              };
            } else {
              callback();
            }
          });
        }, function(err) {
          main_callback();
        });
      };
      async2.detect = doParallel(_detect);
      async2.detectSeries = doSeries(_detect);
      async2.some = function(arr, iterator, main_callback) {
        async2.each(arr, function(x, callback) {
          iterator(x, function(v) {
            if (v) {
              main_callback(true);
              main_callback = function() {
              };
            }
            callback();
          });
        }, function(err) {
          main_callback(false);
        });
      };
      async2.any = async2.some;
      async2.every = function(arr, iterator, main_callback) {
        async2.each(arr, function(x, callback) {
          iterator(x, function(v) {
            if (!v) {
              main_callback(false);
              main_callback = function() {
              };
            }
            callback();
          });
        }, function(err) {
          main_callback(true);
        });
      };
      async2.all = async2.every;
      async2.sortBy = function(arr, iterator, callback) {
        async2.map(arr, function(x, callback2) {
          iterator(x, function(err, criteria) {
            if (err) {
              callback2(err);
            } else {
              callback2(null, { value: x, criteria });
            }
          });
        }, function(err, results) {
          if (err) {
            return callback(err);
          } else {
            var fn = function(left, right) {
              var a = left.criteria, b = right.criteria;
              return a < b ? -1 : a > b ? 1 : 0;
            };
            callback(null, _map2(results.sort(fn), function(x) {
              return x.value;
            }));
          }
        });
      };
      async2.auto = function(tasks, callback) {
        callback = callback || function() {
        };
        var keys = _keys(tasks);
        if (!keys.length) {
          return callback(null);
        }
        var results = {};
        var listeners = [];
        var addListener = function(fn) {
          listeners.unshift(fn);
        };
        var removeListener = function(fn) {
          for (var i = 0; i < listeners.length; i += 1) {
            if (listeners[i] === fn) {
              listeners.splice(i, 1);
              return;
            }
          }
        };
        var taskComplete = function() {
          _each(listeners.slice(0), function(fn) {
            fn();
          });
        };
        addListener(function() {
          if (_keys(results).length === keys.length) {
            callback(null, results);
            callback = function() {
            };
          }
        });
        _each(keys, function(k) {
          var task = tasks[k] instanceof Function ? [tasks[k]] : tasks[k];
          var taskCallback = function(err) {
            var args = Array.prototype.slice.call(arguments, 1);
            if (args.length <= 1) {
              args = args[0];
            }
            if (err) {
              var safeResults = {};
              _each(_keys(results), function(rkey) {
                safeResults[rkey] = results[rkey];
              });
              safeResults[k] = args;
              callback(err, safeResults);
              callback = function() {
              };
            } else {
              results[k] = args;
              async2.setImmediate(taskComplete);
            }
          };
          var requires = task.slice(0, Math.abs(task.length - 1)) || [];
          var ready = function() {
            return _reduce(requires, function(a, x) {
              return a && results.hasOwnProperty(x);
            }, true) && !results.hasOwnProperty(k);
          };
          if (ready()) {
            task[task.length - 1](taskCallback, results);
          } else {
            var listener = function() {
              if (ready()) {
                removeListener(listener);
                task[task.length - 1](taskCallback, results);
              }
            };
            addListener(listener);
          }
        });
      };
      async2.waterfall = function(tasks, callback) {
        callback = callback || function() {
        };
        if (tasks.constructor !== Array) {
          var err = new Error("First argument to waterfall must be an array of functions");
          return callback(err);
        }
        if (!tasks.length) {
          return callback();
        }
        var wrapIterator = function(iterator) {
          return function(err2) {
            if (err2) {
              callback.apply(null, arguments);
              callback = function() {
              };
            } else {
              var args = Array.prototype.slice.call(arguments, 1);
              var next = iterator.next();
              if (next) {
                args.push(wrapIterator(next));
              } else {
                args.push(callback);
              }
              async2.setImmediate(function() {
                iterator.apply(null, args);
              });
            }
          };
        };
        wrapIterator(async2.iterator(tasks))();
      };
      var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function() {
        };
        if (tasks.constructor === Array) {
          eachfn.map(tasks, function(fn, callback2) {
            if (fn) {
              fn(function(err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                  args = args[0];
                }
                callback2.call(null, err, args);
              });
            }
          }, callback);
        } else {
          var results = {};
          eachfn.each(_keys(tasks), function(k, callback2) {
            tasks[k](function(err) {
              var args = Array.prototype.slice.call(arguments, 1);
              if (args.length <= 1) {
                args = args[0];
              }
              results[k] = args;
              callback2(err);
            });
          }, function(err) {
            callback(err, results);
          });
        }
      };
      async2.parallel = function(tasks, callback) {
        _parallel({ map: async2.map, each: async2.each }, tasks, callback);
      };
      async2.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
      };
      async2.series = function(tasks, callback) {
        callback = callback || function() {
        };
        if (tasks.constructor === Array) {
          async2.mapSeries(tasks, function(fn, callback2) {
            if (fn) {
              fn(function(err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                  args = args[0];
                }
                callback2.call(null, err, args);
              });
            }
          }, callback);
        } else {
          var results = {};
          async2.eachSeries(_keys(tasks), function(k, callback2) {
            tasks[k](function(err) {
              var args = Array.prototype.slice.call(arguments, 1);
              if (args.length <= 1) {
                args = args[0];
              }
              results[k] = args;
              callback2(err);
            });
          }, function(err) {
            callback(err, results);
          });
        }
      };
      async2.iterator = function(tasks) {
        var makeCallback = function(index2) {
          var fn = function() {
            if (tasks.length) {
              tasks[index2].apply(null, arguments);
            }
            return fn.next();
          };
          fn.next = function() {
            return index2 < tasks.length - 1 ? makeCallback(index2 + 1) : null;
          };
          return fn;
        };
        return makeCallback(0);
      };
      async2.apply = function(fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function() {
          return fn.apply(
            null,
            args.concat(Array.prototype.slice.call(arguments))
          );
        };
      };
      var _concat = function(eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function(x, cb) {
          fn(x, function(err, y) {
            r = r.concat(y || []);
            cb(err);
          });
        }, function(err) {
          callback(err, r);
        });
      };
      async2.concat = doParallel(_concat);
      async2.concatSeries = doSeries(_concat);
      async2.whilst = function(test, iterator, callback) {
        if (test()) {
          iterator(function(err) {
            if (err) {
              return callback(err);
            }
            async2.whilst(test, iterator, callback);
          });
        } else {
          callback();
        }
      };
      async2.doWhilst = function(iterator, test, callback) {
        iterator(function(err) {
          if (err) {
            return callback(err);
          }
          if (test()) {
            async2.doWhilst(iterator, test, callback);
          } else {
            callback();
          }
        });
      };
      async2.until = function(test, iterator, callback) {
        if (!test()) {
          iterator(function(err) {
            if (err) {
              return callback(err);
            }
            async2.until(test, iterator, callback);
          });
        } else {
          callback();
        }
      };
      async2.doUntil = function(iterator, test, callback) {
        iterator(function(err) {
          if (err) {
            return callback(err);
          }
          if (!test()) {
            async2.doUntil(iterator, test, callback);
          } else {
            callback();
          }
        });
      };
      async2.queue = function(worker, concurrency2) {
        if (concurrency2 === void 0) {
          concurrency2 = 1;
        }
        function _insert(q2, data, pos2, callback) {
          if (data.constructor !== Array) {
            data = [data];
          }
          _each(data, function(task) {
            var item = {
              data: task,
              callback: typeof callback === "function" ? callback : null
            };
            if (pos2) {
              q2.tasks.unshift(item);
            } else {
              q2.tasks.push(item);
            }
            if (q2.saturated && q2.tasks.length === concurrency2) {
              q2.saturated();
            }
            async2.setImmediate(q2.process);
          });
        }
        var workers = 0;
        var q = {
          tasks: [],
          concurrency: concurrency2,
          saturated: null,
          empty: null,
          drain: null,
          push: function(data, callback) {
            _insert(q, data, false, callback);
          },
          unshift: function(data, callback) {
            _insert(q, data, true, callback);
          },
          process: function() {
            if (workers < q.concurrency && q.tasks.length) {
              var task = q.tasks.shift();
              if (q.empty && q.tasks.length === 0) {
                q.empty();
              }
              workers += 1;
              var next = function() {
                workers -= 1;
                if (task.callback) {
                  task.callback.apply(task, arguments);
                }
                if (q.drain && q.tasks.length + workers === 0) {
                  q.drain();
                }
                q.process();
              };
              var cb = only_once(next);
              worker(task.data, cb);
            }
          },
          length: function() {
            return q.tasks.length;
          },
          running: function() {
            return workers;
          }
        };
        return q;
      };
      async2.cargo = function(worker, payload) {
        var working = false, tasks = [];
        var cargo = {
          tasks,
          payload,
          saturated: null,
          empty: null,
          drain: null,
          push: function(data, callback) {
            if (data.constructor !== Array) {
              data = [data];
            }
            _each(data, function(task) {
              tasks.push({
                data: task,
                callback: typeof callback === "function" ? callback : null
              });
              if (cargo.saturated && tasks.length === payload) {
                cargo.saturated();
              }
            });
            async2.setImmediate(cargo.process);
          },
          process: function process2() {
            if (working) return;
            if (tasks.length === 0) {
              if (cargo.drain) cargo.drain();
              return;
            }
            var ts = typeof payload === "number" ? tasks.splice(0, payload) : tasks.splice(0);
            var ds = _map2(ts, function(task) {
              return task.data;
            });
            if (cargo.empty) cargo.empty();
            working = true;
            worker(ds, function() {
              working = false;
              var args = arguments;
              _each(ts, function(data) {
                if (data.callback) {
                  data.callback.apply(null, args);
                }
              });
              process2();
            });
          },
          length: function() {
            return tasks.length;
          },
          running: function() {
            return working;
          }
        };
        return cargo;
      };
      var _console_fn = function(name) {
        return function(fn) {
          var args = Array.prototype.slice.call(arguments, 1);
          fn.apply(null, args.concat([function(err) {
            var args2 = Array.prototype.slice.call(arguments, 1);
            if (typeof console !== "undefined") {
              if (err) {
                if (console.error) {
                  console.error(err);
                }
              } else if (console[name]) {
                _each(args2, function(x) {
                  console[name](x);
                });
              }
            }
          }]));
        };
      };
      async2.log = _console_fn("log");
      async2.dir = _console_fn("dir");
      async2.memoize = function(fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function(x) {
          return x;
        };
        var memoized = function() {
          var args = Array.prototype.slice.call(arguments);
          var callback = args.pop();
          var key2 = hasher.apply(null, args);
          if (key2 in memo) {
            callback.apply(null, memo[key2]);
          } else if (key2 in queues) {
            queues[key2].push(callback);
          } else {
            queues[key2] = [callback];
            fn.apply(null, args.concat([function() {
              memo[key2] = arguments;
              var q = queues[key2];
              delete queues[key2];
              for (var i = 0, l = q.length; i < l; i++) {
                q[i].apply(null, arguments);
              }
            }]));
          }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
      };
      async2.unmemoize = function(fn) {
        return function() {
          return (fn.unmemoized || fn).apply(null, arguments);
        };
      };
      async2.times = function(count, iterator, callback) {
        var counter2 = [];
        for (var i = 0; i < count; i++) {
          counter2.push(i);
        }
        return async2.map(counter2, iterator, callback);
      };
      async2.timesSeries = function(count, iterator, callback) {
        var counter2 = [];
        for (var i = 0; i < count; i++) {
          counter2.push(i);
        }
        return async2.mapSeries(counter2, iterator, callback);
      };
      async2.compose = function() {
        var fns = Array.prototype.reverse.call(arguments);
        return function() {
          var that = this;
          var args = Array.prototype.slice.call(arguments);
          var callback = args.pop();
          async2.reduce(
            fns,
            args,
            function(newargs, fn, cb) {
              fn.apply(that, newargs.concat([function() {
                var err = arguments[0];
                var nextargs = Array.prototype.slice.call(arguments, 1);
                cb(err, nextargs);
              }]));
            },
            function(err, results) {
              callback.apply(that, [err].concat(results));
            }
          );
        };
      };
      var _applyEach = function(eachfn, fns) {
        var go = function() {
          var that = this;
          var args2 = Array.prototype.slice.call(arguments);
          var callback = args2.pop();
          return eachfn(
            fns,
            function(fn, cb) {
              fn.apply(that, args2.concat([cb]));
            },
            callback
          );
        };
        if (arguments.length > 2) {
          var args = Array.prototype.slice.call(arguments, 2);
          return go.apply(this, args);
        } else {
          return go;
        }
      };
      async2.applyEach = doParallel(_applyEach);
      async2.applyEachSeries = doSeries(_applyEach);
      async2.forever = function(fn, callback) {
        function next(err) {
          if (err) {
            if (callback) {
              return callback(err);
            }
            throw err;
          }
          fn(next);
        }
        next();
      };
      if (module.exports) {
        module.exports = async2;
      } else {
        root2.async = async2;
      }
    })();
  })(async);
  return async.exports;
}
var processor;
var hasRequiredProcessor;
function requireProcessor() {
  if (hasRequiredProcessor) return processor;
  hasRequiredProcessor = 1;
  var spawn = require$$0$5.spawn;
  var async2 = requireAsync();
  var utils2 = requireUtils$4();
  function runFfprobe(command) {
    const inputProbeIndex = 0;
    if (command._inputs[inputProbeIndex].isStream) {
      return;
    }
    command.ffprobe(inputProbeIndex, function(err, data) {
      command._ffprobeData = data;
    });
  }
  processor = function(proto) {
    proto._spawnFfmpeg = function(args, options, processCB, endCB) {
      if (typeof options === "function") {
        endCB = processCB;
        processCB = options;
        options = {};
      }
      if (typeof endCB === "undefined") {
        endCB = processCB;
        processCB = function() {
        };
      }
      var maxLines = "stdoutLines" in options ? options.stdoutLines : this.options.stdoutLines;
      this._getFfmpegPath(function(err, command) {
        if (err) {
          return endCB(err);
        } else if (!command || command.length === 0) {
          return endCB(new Error("Cannot find ffmpeg"));
        }
        if (options.niceness && options.niceness !== 0 && !utils2.isWindows) {
          args.unshift("-n", options.niceness, command);
          command = "nice";
        }
        var stdoutRing = utils2.linesRing(maxLines);
        var stdoutClosed = false;
        var stderrRing = utils2.linesRing(maxLines);
        var stderrClosed = false;
        var ffmpegProc = spawn(command, args, options);
        if (ffmpegProc.stderr) {
          ffmpegProc.stderr.setEncoding("utf8");
        }
        ffmpegProc.on("error", function(err2) {
          endCB(err2);
        });
        var exitError = null;
        function handleExit(err2) {
          if (err2) {
            exitError = err2;
          }
          if (processExited && (stdoutClosed || !options.captureStdout) && stderrClosed) {
            endCB(exitError, stdoutRing, stderrRing);
          }
        }
        var processExited = false;
        ffmpegProc.on("exit", function(code, signal) {
          processExited = true;
          if (signal) {
            handleExit(new Error("ffmpeg was killed with signal " + signal));
          } else if (code) {
            handleExit(new Error("ffmpeg exited with code " + code));
          } else {
            handleExit();
          }
        });
        if (options.captureStdout) {
          ffmpegProc.stdout.on("data", function(data) {
            stdoutRing.append(data);
          });
          ffmpegProc.stdout.on("close", function() {
            stdoutRing.close();
            stdoutClosed = true;
            handleExit();
          });
        }
        ffmpegProc.stderr.on("data", function(data) {
          stderrRing.append(data);
        });
        ffmpegProc.stderr.on("close", function() {
          stderrRing.close();
          stderrClosed = true;
          handleExit();
        });
        processCB(ffmpegProc, stdoutRing, stderrRing);
      });
    };
    proto._getArguments = function() {
      var complexFilters = this._complexFilters.get();
      var fileOutput = this._outputs.some(function(output2) {
        return output2.isFile;
      });
      return [].concat(
        // Inputs and input options
        this._inputs.reduce(function(args, input) {
          var source2 = typeof input.source === "string" ? input.source : "pipe:0";
          return args.concat(
            input.options.get(),
            ["-i", source2]
          );
        }, []),
        // Global options
        this._global.get(),
        // Overwrite if we have file outputs
        fileOutput ? ["-y"] : [],
        // Complex filters
        complexFilters,
        // Outputs, filters and output options
        this._outputs.reduce(function(args, output2) {
          var sizeFilters = utils2.makeFilterStrings(output2.sizeFilters.get());
          var audioFilters = output2.audioFilters.get();
          var videoFilters = output2.videoFilters.get().concat(sizeFilters);
          var outputArg;
          if (!output2.target) {
            outputArg = [];
          } else if (typeof output2.target === "string") {
            outputArg = [output2.target];
          } else {
            outputArg = ["pipe:1"];
          }
          return args.concat(
            output2.audio.get(),
            audioFilters.length ? ["-filter:a", audioFilters.join(",")] : [],
            output2.video.get(),
            videoFilters.length ? ["-filter:v", videoFilters.join(",")] : [],
            output2.options.get(),
            outputArg
          );
        }, [])
      );
    };
    proto._prepare = function(callback, readMetadata) {
      var self2 = this;
      async2.waterfall([
        // Check codecs and formats
        function(cb) {
          self2._checkCapabilities(cb);
        },
        // Read metadata if required
        function(cb) {
          if (!readMetadata) {
            return cb();
          }
          self2.ffprobe(0, function(err, data) {
            if (!err) {
              self2._ffprobeData = data;
            }
            cb();
          });
        },
        // Check for flvtool2/flvmeta if necessary
        function(cb) {
          var flvmeta = self2._outputs.some(function(output2) {
            if (output2.flags.flvmeta && !output2.isFile) {
              self2.logger.warn("Updating flv metadata is only supported for files");
              output2.flags.flvmeta = false;
            }
            return output2.flags.flvmeta;
          });
          if (flvmeta) {
            self2._getFlvtoolPath(function(err) {
              cb(err);
            });
          } else {
            cb();
          }
        },
        // Build argument list
        function(cb) {
          var args;
          try {
            args = self2._getArguments();
          } catch (e) {
            return cb(e);
          }
          cb(null, args);
        },
        // Add "-strict experimental" option where needed
        function(args, cb) {
          self2.availableEncoders(function(err, encoders) {
            for (var i = 0; i < args.length; i++) {
              if (args[i] === "-acodec" || args[i] === "-vcodec") {
                i++;
                if (args[i] in encoders && encoders[args[i]].experimental) {
                  args.splice(i + 1, 0, "-strict", "experimental");
                  i += 2;
                }
              }
            }
            cb(null, args);
          });
        }
      ], callback);
      if (!readMetadata) {
        if (this.listeners("progress").length > 0) {
          runFfprobe(this);
        } else {
          this.once("newListener", function(event) {
            if (event === "progress") {
              runFfprobe(this);
            }
          });
        }
      }
    };
    proto.exec = proto.execute = proto.run = function() {
      var self2 = this;
      var outputPresent = this._outputs.some(function(output2) {
        return "target" in output2;
      });
      if (!outputPresent) {
        throw new Error("No output specified");
      }
      var outputStream = this._outputs.filter(function(output2) {
        return typeof output2.target !== "string";
      })[0];
      var inputStream = this._inputs.filter(function(input) {
        return typeof input.source !== "string";
      })[0];
      var ended = false;
      function emitEnd(err, stdout, stderr) {
        if (!ended) {
          ended = true;
          if (err) {
            self2.emit("error", err, stdout, stderr);
          } else {
            self2.emit("end", stdout, stderr);
          }
        }
      }
      self2._prepare(function(err, args) {
        if (err) {
          return emitEnd(err);
        }
        self2._spawnFfmpeg(
          args,
          {
            captureStdout: !outputStream,
            niceness: self2.options.niceness,
            cwd: self2.options.cwd,
            windowsHide: true
          },
          function processCB(ffmpegProc, stdoutRing, stderrRing) {
            self2.ffmpegProc = ffmpegProc;
            self2.emit("start", "ffmpeg " + args.join(" "));
            if (inputStream) {
              inputStream.source.on("error", function(err2) {
                var reportingErr = new Error("Input stream error: " + err2.message);
                reportingErr.inputStreamError = err2;
                emitEnd(reportingErr);
                ffmpegProc.kill();
              });
              inputStream.source.resume();
              inputStream.source.pipe(ffmpegProc.stdin);
              ffmpegProc.stdin.on("error", function() {
              });
            }
            if (self2.options.timeout) {
              self2.processTimer = setTimeout(function() {
                var msg = "process ran into a timeout (" + self2.options.timeout + "s)";
                emitEnd(new Error(msg), stdoutRing.get(), stderrRing.get());
                ffmpegProc.kill();
              }, self2.options.timeout * 1e3);
            }
            if (outputStream) {
              ffmpegProc.stdout.pipe(outputStream.target, outputStream.pipeopts);
              outputStream.target.on("close", function() {
                self2.logger.debug("Output stream closed, scheduling kill for ffmpeg process");
                setTimeout(function() {
                  emitEnd(new Error("Output stream closed"));
                  ffmpegProc.kill();
                }, 20);
              });
              outputStream.target.on("error", function(err2) {
                self2.logger.debug("Output stream error, killing ffmpeg process");
                var reportingErr = new Error("Output stream error: " + err2.message);
                reportingErr.outputStreamError = err2;
                emitEnd(reportingErr, stdoutRing.get(), stderrRing.get());
                ffmpegProc.kill("SIGKILL");
              });
            }
            if (stderrRing) {
              if (self2.listeners("stderr").length) {
                stderrRing.callback(function(line2) {
                  self2.emit("stderr", line2);
                });
              }
              if (self2.listeners("codecData").length) {
                var codecDataSent = false;
                var codecObject = {};
                stderrRing.callback(function(line2) {
                  if (!codecDataSent)
                    codecDataSent = utils2.extractCodecData(self2, line2, codecObject);
                });
              }
              if (self2.listeners("progress").length) {
                stderrRing.callback(function(line2) {
                  utils2.extractProgress(self2, line2);
                });
              }
            }
          },
          function endCB(err2, stdoutRing, stderrRing) {
            clearTimeout(self2.processTimer);
            delete self2.ffmpegProc;
            if (err2) {
              if (err2.message.match(/ffmpeg exited with code/)) {
                err2.message += ": " + utils2.extractError(stderrRing.get());
              }
              emitEnd(err2, stdoutRing.get(), stderrRing.get());
            } else {
              var flvmeta = self2._outputs.filter(function(output2) {
                return output2.flags.flvmeta;
              });
              if (flvmeta.length) {
                self2._getFlvtoolPath(function(err3, flvtool) {
                  if (err3) {
                    return emitEnd(err3);
                  }
                  async2.each(
                    flvmeta,
                    function(output2, cb) {
                      spawn(flvtool, ["-U", output2.target], { windowsHide: true }).on("error", function(err4) {
                        cb(new Error("Error running " + flvtool + " on " + output2.target + ": " + err4.message));
                      }).on("exit", function(code, signal) {
                        if (code !== 0 || signal) {
                          cb(
                            new Error(flvtool + " " + (signal ? "received signal " + signal : "exited with code " + code)) + " when running on " + output2.target
                          );
                        } else {
                          cb();
                        }
                      });
                    },
                    function(err4) {
                      if (err4) {
                        emitEnd(err4);
                      } else {
                        emitEnd(null, stdoutRing.get(), stderrRing.get());
                      }
                    }
                  );
                });
              } else {
                emitEnd(null, stdoutRing.get(), stderrRing.get());
              }
            }
          }
        );
      });
      return this;
    };
    proto.renice = function(niceness) {
      if (!utils2.isWindows) {
        niceness = niceness || 0;
        if (niceness < -20 || niceness > 20) {
          this.logger.warn("Invalid niceness value: " + niceness + ", must be between -20 and 20");
        }
        niceness = Math.min(20, Math.max(-20, niceness));
        this.options.niceness = niceness;
        if (this.ffmpegProc) {
          var logger = this.logger;
          var pid = this.ffmpegProc.pid;
          var renice = spawn("renice", [niceness, "-p", pid], { windowsHide: true });
          renice.on("error", function(err) {
            logger.warn("could not renice process " + pid + ": " + err.message);
          });
          renice.on("exit", function(code, signal) {
            if (signal) {
              logger.warn("could not renice process " + pid + ": renice was killed by signal " + signal);
            } else if (code) {
              logger.warn("could not renice process " + pid + ": renice exited with " + code);
            } else {
              logger.info("successfully reniced process " + pid + " to " + niceness + " niceness");
            }
          });
        }
      }
      return this;
    };
    proto.kill = function(signal) {
      if (!this.ffmpegProc) {
        this.logger.warn("No running ffmpeg process, cannot send signal");
      } else {
        this.ffmpegProc.kill(signal || "SIGKILL");
      }
      return this;
    };
  };
  return processor;
}
var capabilities;
var hasRequiredCapabilities;
function requireCapabilities() {
  if (hasRequiredCapabilities) return capabilities;
  hasRequiredCapabilities = 1;
  var fs2 = require$$0$4;
  var path2 = path$1;
  var async2 = requireAsync();
  var utils2 = requireUtils$4();
  var avCodecRegexp = /^\s*([D ])([E ])([VAS])([S ])([D ])([T ]) ([^ ]+) +(.*)$/;
  var ffCodecRegexp = /^\s*([D\.])([E\.])([VAS])([I\.])([L\.])([S\.]) ([^ ]+) +(.*)$/;
  var ffEncodersRegexp = /\(encoders:([^\)]+)\)/;
  var ffDecodersRegexp = /\(decoders:([^\)]+)\)/;
  var encodersRegexp = /^\s*([VAS\.])([F\.])([S\.])([X\.])([B\.])([D\.]) ([^ ]+) +(.*)$/;
  var formatRegexp = /^\s*([D ])([E ])\s+([^ ]+)\s+(.*)$/;
  var lineBreakRegexp = /\r\n|\r|\n/;
  var filterRegexp = /^(?: [T\.][S\.][C\.] )?([^ ]+) +(AA?|VV?|\|)->(AA?|VV?|\|) +(.*)$/;
  var cache = {};
  capabilities = function(proto) {
    proto.setFfmpegPath = function(ffmpegPath) {
      cache.ffmpegPath = ffmpegPath;
      return this;
    };
    proto.setFfprobePath = function(ffprobePath) {
      cache.ffprobePath = ffprobePath;
      return this;
    };
    proto.setFlvtoolPath = function(flvtool) {
      cache.flvtoolPath = flvtool;
      return this;
    };
    proto._forgetPaths = function() {
      delete cache.ffmpegPath;
      delete cache.ffprobePath;
      delete cache.flvtoolPath;
    };
    proto._getFfmpegPath = function(callback) {
      if ("ffmpegPath" in cache) {
        return callback(null, cache.ffmpegPath);
      }
      async2.waterfall([
        // Try FFMPEG_PATH
        function(cb) {
          if (process.env.FFMPEG_PATH) {
            fs2.exists(process.env.FFMPEG_PATH, function(exists) {
              if (exists) {
                cb(null, process.env.FFMPEG_PATH);
              } else {
                cb(null, "");
              }
            });
          } else {
            cb(null, "");
          }
        },
        // Search in the PATH
        function(ffmpeg2, cb) {
          if (ffmpeg2.length) {
            return cb(null, ffmpeg2);
          }
          utils2.which("ffmpeg", function(err, ffmpeg22) {
            cb(err, ffmpeg22);
          });
        }
      ], function(err, ffmpeg2) {
        if (err) {
          callback(err);
        } else {
          callback(null, cache.ffmpegPath = ffmpeg2 || "");
        }
      });
    };
    proto._getFfprobePath = function(callback) {
      var self2 = this;
      if ("ffprobePath" in cache) {
        return callback(null, cache.ffprobePath);
      }
      async2.waterfall([
        // Try FFPROBE_PATH
        function(cb) {
          if (process.env.FFPROBE_PATH) {
            fs2.exists(process.env.FFPROBE_PATH, function(exists) {
              cb(null, exists ? process.env.FFPROBE_PATH : "");
            });
          } else {
            cb(null, "");
          }
        },
        // Search in the PATH
        function(ffprobe2, cb) {
          if (ffprobe2.length) {
            return cb(null, ffprobe2);
          }
          utils2.which("ffprobe", function(err, ffprobe22) {
            cb(err, ffprobe22);
          });
        },
        // Search in the same directory as ffmpeg
        function(ffprobe2, cb) {
          if (ffprobe2.length) {
            return cb(null, ffprobe2);
          }
          self2._getFfmpegPath(function(err, ffmpeg2) {
            if (err) {
              cb(err);
            } else if (ffmpeg2.length) {
              var name = utils2.isWindows ? "ffprobe.exe" : "ffprobe";
              var ffprobe22 = path2.join(path2.dirname(ffmpeg2), name);
              fs2.exists(ffprobe22, function(exists) {
                cb(null, exists ? ffprobe22 : "");
              });
            } else {
              cb(null, "");
            }
          });
        }
      ], function(err, ffprobe2) {
        if (err) {
          callback(err);
        } else {
          callback(null, cache.ffprobePath = ffprobe2 || "");
        }
      });
    };
    proto._getFlvtoolPath = function(callback) {
      if ("flvtoolPath" in cache) {
        return callback(null, cache.flvtoolPath);
      }
      async2.waterfall([
        // Try FLVMETA_PATH
        function(cb) {
          if (process.env.FLVMETA_PATH) {
            fs2.exists(process.env.FLVMETA_PATH, function(exists) {
              cb(null, exists ? process.env.FLVMETA_PATH : "");
            });
          } else {
            cb(null, "");
          }
        },
        // Try FLVTOOL2_PATH
        function(flvtool, cb) {
          if (flvtool.length) {
            return cb(null, flvtool);
          }
          if (process.env.FLVTOOL2_PATH) {
            fs2.exists(process.env.FLVTOOL2_PATH, function(exists) {
              cb(null, exists ? process.env.FLVTOOL2_PATH : "");
            });
          } else {
            cb(null, "");
          }
        },
        // Search for flvmeta in the PATH
        function(flvtool, cb) {
          if (flvtool.length) {
            return cb(null, flvtool);
          }
          utils2.which("flvmeta", function(err, flvmeta) {
            cb(err, flvmeta);
          });
        },
        // Search for flvtool2 in the PATH
        function(flvtool, cb) {
          if (flvtool.length) {
            return cb(null, flvtool);
          }
          utils2.which("flvtool2", function(err, flvtool2) {
            cb(err, flvtool2);
          });
        }
      ], function(err, flvtool) {
        if (err) {
          callback(err);
        } else {
          callback(null, cache.flvtoolPath = flvtool || "");
        }
      });
    };
    proto.availableFilters = proto.getAvailableFilters = function(callback) {
      if ("filters" in cache) {
        return callback(null, cache.filters);
      }
      this._spawnFfmpeg(["-filters"], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {
        if (err) {
          return callback(err);
        }
        var stdout = stdoutRing.get();
        var lines = stdout.split("\n");
        var data = {};
        var types2 = { A: "audio", V: "video", "|": "none" };
        lines.forEach(function(line2) {
          var match = line2.match(filterRegexp);
          if (match) {
            data[match[1]] = {
              description: match[4],
              input: types2[match[2].charAt(0)],
              multipleInputs: match[2].length > 1,
              output: types2[match[3].charAt(0)],
              multipleOutputs: match[3].length > 1
            };
          }
        });
        callback(null, cache.filters = data);
      });
    };
    proto.availableCodecs = proto.getAvailableCodecs = function(callback) {
      if ("codecs" in cache) {
        return callback(null, cache.codecs);
      }
      this._spawnFfmpeg(["-codecs"], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {
        if (err) {
          return callback(err);
        }
        var stdout = stdoutRing.get();
        var lines = stdout.split(lineBreakRegexp);
        var data = {};
        lines.forEach(function(line2) {
          var match = line2.match(avCodecRegexp);
          if (match && match[7] !== "=") {
            data[match[7]] = {
              type: { "V": "video", "A": "audio", "S": "subtitle" }[match[3]],
              description: match[8],
              canDecode: match[1] === "D",
              canEncode: match[2] === "E",
              drawHorizBand: match[4] === "S",
              directRendering: match[5] === "D",
              weirdFrameTruncation: match[6] === "T"
            };
          }
          match = line2.match(ffCodecRegexp);
          if (match && match[7] !== "=") {
            var codecData = data[match[7]] = {
              type: { "V": "video", "A": "audio", "S": "subtitle" }[match[3]],
              description: match[8],
              canDecode: match[1] === "D",
              canEncode: match[2] === "E",
              intraFrameOnly: match[4] === "I",
              isLossy: match[5] === "L",
              isLossless: match[6] === "S"
            };
            var encoders = codecData.description.match(ffEncodersRegexp);
            encoders = encoders ? encoders[1].trim().split(" ") : [];
            var decoders = codecData.description.match(ffDecodersRegexp);
            decoders = decoders ? decoders[1].trim().split(" ") : [];
            if (encoders.length || decoders.length) {
              var coderData = {};
              utils2.copy(codecData, coderData);
              delete coderData.canEncode;
              delete coderData.canDecode;
              encoders.forEach(function(name) {
                data[name] = {};
                utils2.copy(coderData, data[name]);
                data[name].canEncode = true;
              });
              decoders.forEach(function(name) {
                if (name in data) {
                  data[name].canDecode = true;
                } else {
                  data[name] = {};
                  utils2.copy(coderData, data[name]);
                  data[name].canDecode = true;
                }
              });
            }
          }
        });
        callback(null, cache.codecs = data);
      });
    };
    proto.availableEncoders = proto.getAvailableEncoders = function(callback) {
      if ("encoders" in cache) {
        return callback(null, cache.encoders);
      }
      this._spawnFfmpeg(["-encoders"], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {
        if (err) {
          return callback(err);
        }
        var stdout = stdoutRing.get();
        var lines = stdout.split(lineBreakRegexp);
        var data = {};
        lines.forEach(function(line2) {
          var match = line2.match(encodersRegexp);
          if (match && match[7] !== "=") {
            data[match[7]] = {
              type: { "V": "video", "A": "audio", "S": "subtitle" }[match[1]],
              description: match[8],
              frameMT: match[2] === "F",
              sliceMT: match[3] === "S",
              experimental: match[4] === "X",
              drawHorizBand: match[5] === "B",
              directRendering: match[6] === "D"
            };
          }
        });
        callback(null, cache.encoders = data);
      });
    };
    proto.availableFormats = proto.getAvailableFormats = function(callback) {
      if ("formats" in cache) {
        return callback(null, cache.formats);
      }
      this._spawnFfmpeg(["-formats"], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {
        if (err) {
          return callback(err);
        }
        var stdout = stdoutRing.get();
        var lines = stdout.split(lineBreakRegexp);
        var data = {};
        lines.forEach(function(line2) {
          var match = line2.match(formatRegexp);
          if (match) {
            match[3].split(",").forEach(function(format) {
              if (!(format in data)) {
                data[format] = {
                  description: match[4],
                  canDemux: false,
                  canMux: false
                };
              }
              if (match[1] === "D") {
                data[format].canDemux = true;
              }
              if (match[2] === "E") {
                data[format].canMux = true;
              }
            });
          }
        });
        callback(null, cache.formats = data);
      });
    };
    proto._checkCapabilities = function(callback) {
      var self2 = this;
      async2.waterfall([
        // Get available formats
        function(cb) {
          self2.availableFormats(cb);
        },
        // Check whether specified formats are available
        function(formats2, cb) {
          var unavailable;
          unavailable = self2._outputs.reduce(function(fmts, output2) {
            var format = output2.options.find("-f", 1);
            if (format) {
              if (!(format[0] in formats2) || !formats2[format[0]].canMux) {
                fmts.push(format);
              }
            }
            return fmts;
          }, []);
          if (unavailable.length === 1) {
            return cb(new Error("Output format " + unavailable[0] + " is not available"));
          } else if (unavailable.length > 1) {
            return cb(new Error("Output formats " + unavailable.join(", ") + " are not available"));
          }
          unavailable = self2._inputs.reduce(function(fmts, input) {
            var format = input.options.find("-f", 1);
            if (format) {
              if (!(format[0] in formats2) || !formats2[format[0]].canDemux) {
                fmts.push(format[0]);
              }
            }
            return fmts;
          }, []);
          if (unavailable.length === 1) {
            return cb(new Error("Input format " + unavailable[0] + " is not available"));
          } else if (unavailable.length > 1) {
            return cb(new Error("Input formats " + unavailable.join(", ") + " are not available"));
          }
          cb();
        },
        // Get available codecs
        function(cb) {
          self2.availableEncoders(cb);
        },
        // Check whether specified codecs are available and add strict experimental options if needed
        function(encoders, cb) {
          var unavailable;
          unavailable = self2._outputs.reduce(function(cdcs, output2) {
            var acodec = output2.audio.find("-acodec", 1);
            if (acodec && acodec[0] !== "copy") {
              if (!(acodec[0] in encoders) || encoders[acodec[0]].type !== "audio") {
                cdcs.push(acodec[0]);
              }
            }
            return cdcs;
          }, []);
          if (unavailable.length === 1) {
            return cb(new Error("Audio codec " + unavailable[0] + " is not available"));
          } else if (unavailable.length > 1) {
            return cb(new Error("Audio codecs " + unavailable.join(", ") + " are not available"));
          }
          unavailable = self2._outputs.reduce(function(cdcs, output2) {
            var vcodec = output2.video.find("-vcodec", 1);
            if (vcodec && vcodec[0] !== "copy") {
              if (!(vcodec[0] in encoders) || encoders[vcodec[0]].type !== "video") {
                cdcs.push(vcodec[0]);
              }
            }
            return cdcs;
          }, []);
          if (unavailable.length === 1) {
            return cb(new Error("Video codec " + unavailable[0] + " is not available"));
          } else if (unavailable.length > 1) {
            return cb(new Error("Video codecs " + unavailable.join(", ") + " are not available"));
          }
          cb();
        }
      ], callback);
    };
  };
  return capabilities;
}
var ffprobe;
var hasRequiredFfprobe;
function requireFfprobe() {
  if (hasRequiredFfprobe) return ffprobe;
  hasRequiredFfprobe = 1;
  var spawn = require$$0$5.spawn;
  function legacyTag(key2) {
    return key2.match(/^TAG:/);
  }
  function legacyDisposition(key2) {
    return key2.match(/^DISPOSITION:/);
  }
  function parseFfprobeOutput(out) {
    var lines = out.split(/\r\n|\r|\n/);
    lines = lines.filter(function(line3) {
      return line3.length > 0;
    });
    var data = {
      streams: [],
      format: {},
      chapters: []
    };
    function parseBlock(name) {
      var data2 = {};
      var line3 = lines.shift();
      while (typeof line3 !== "undefined") {
        if (line3.toLowerCase() == "[/" + name + "]") {
          return data2;
        } else if (line3.match(/^\[/)) {
          line3 = lines.shift();
          continue;
        }
        var kv = line3.match(/^([^=]+)=(.*)$/);
        if (kv) {
          if (!kv[1].match(/^TAG:/) && kv[2].match(/^[0-9]+(\.[0-9]+)?$/)) {
            data2[kv[1]] = Number(kv[2]);
          } else {
            data2[kv[1]] = kv[2];
          }
        }
        line3 = lines.shift();
      }
      return data2;
    }
    var line2 = lines.shift();
    while (typeof line2 !== "undefined") {
      if (line2.match(/^\[stream/i)) {
        var stream = parseBlock("stream");
        data.streams.push(stream);
      } else if (line2.match(/^\[chapter/i)) {
        var chapter = parseBlock("chapter");
        data.chapters.push(chapter);
      } else if (line2.toLowerCase() === "[format]") {
        data.format = parseBlock("format");
      }
      line2 = lines.shift();
    }
    return data;
  }
  ffprobe = function(proto) {
    proto.ffprobe = function() {
      var input, index2 = null, options = [], callback;
      var callback = arguments[arguments.length - 1];
      var ended = false;
      function handleCallback(err, data) {
        if (!ended) {
          ended = true;
          callback(err, data);
        }
      }
      switch (arguments.length) {
        case 3:
          index2 = arguments[0];
          options = arguments[1];
          break;
        case 2:
          if (typeof arguments[0] === "number") {
            index2 = arguments[0];
          } else if (Array.isArray(arguments[0])) {
            options = arguments[0];
          }
          break;
      }
      if (index2 === null) {
        if (!this._currentInput) {
          return handleCallback(new Error("No input specified"));
        }
        input = this._currentInput;
      } else {
        input = this._inputs[index2];
        if (!input) {
          return handleCallback(new Error("Invalid input index"));
        }
      }
      this._getFfprobePath(function(err, path2) {
        if (err) {
          return handleCallback(err);
        } else if (!path2) {
          return handleCallback(new Error("Cannot find ffprobe"));
        }
        var stdout = "";
        var stdoutClosed = false;
        var stderr = "";
        var stderrClosed = false;
        var src = input.isStream ? "pipe:0" : input.source;
        var ffprobe2 = spawn(path2, ["-show_streams", "-show_format"].concat(options, src), { windowsHide: true });
        if (input.isStream) {
          ffprobe2.stdin.on("error", function(err2) {
            if (["ECONNRESET", "EPIPE", "EOF"].indexOf(err2.code) >= 0) {
              return;
            }
            handleCallback(err2);
          });
          ffprobe2.stdin.on("close", function() {
            input.source.pause();
            input.source.unpipe(ffprobe2.stdin);
          });
          input.source.pipe(ffprobe2.stdin);
        }
        ffprobe2.on("error", callback);
        var exitError = null;
        function handleExit(err2) {
          if (err2) {
            exitError = err2;
          }
          if (processExited && stdoutClosed && stderrClosed) {
            if (exitError) {
              if (stderr) {
                exitError.message += "\n" + stderr;
              }
              return handleCallback(exitError);
            }
            var data = parseFfprobeOutput(stdout);
            [data.format].concat(data.streams).forEach(function(target) {
              if (target) {
                var legacyTagKeys = Object.keys(target).filter(legacyTag);
                if (legacyTagKeys.length) {
                  target.tags = target.tags || {};
                  legacyTagKeys.forEach(function(tagKey) {
                    target.tags[tagKey.substr(4)] = target[tagKey];
                    delete target[tagKey];
                  });
                }
                var legacyDispositionKeys = Object.keys(target).filter(legacyDisposition);
                if (legacyDispositionKeys.length) {
                  target.disposition = target.disposition || {};
                  legacyDispositionKeys.forEach(function(dispositionKey) {
                    target.disposition[dispositionKey.substr(12)] = target[dispositionKey];
                    delete target[dispositionKey];
                  });
                }
              }
            });
            handleCallback(null, data);
          }
        }
        var processExited = false;
        ffprobe2.on("exit", function(code, signal) {
          processExited = true;
          if (code) {
            handleExit(new Error("ffprobe exited with code " + code));
          } else if (signal) {
            handleExit(new Error("ffprobe was killed with signal " + signal));
          } else {
            handleExit();
          }
        });
        ffprobe2.stdout.on("data", function(data) {
          stdout += data;
        });
        ffprobe2.stdout.on("close", function() {
          stdoutClosed = true;
          handleExit();
        });
        ffprobe2.stderr.on("data", function(data) {
          stderr += data;
        });
        ffprobe2.stderr.on("close", function() {
          stderrClosed = true;
          handleExit();
        });
      });
    };
  };
  return ffprobe;
}
var recipes;
var hasRequiredRecipes;
function requireRecipes() {
  if (hasRequiredRecipes) return recipes;
  hasRequiredRecipes = 1;
  var fs2 = require$$0$4;
  var path2 = path$1;
  var PassThrough = require$$0$6.PassThrough;
  var async2 = requireAsync();
  var utils2 = requireUtils$4();
  recipes = function recipes2(proto) {
    proto.saveToFile = proto.save = function(output2) {
      this.output(output2).run();
      return this;
    };
    proto.writeToStream = proto.pipe = proto.stream = function(stream, options) {
      if (stream && !("writable" in stream)) {
        options = stream;
        stream = void 0;
      }
      if (!stream) {
        if (process.version.match(/v0\.8\./)) {
          throw new Error("PassThrough stream is not supported on node v0.8");
        }
        stream = new PassThrough();
      }
      this.output(stream, options).run();
      return stream;
    };
    proto.takeScreenshots = proto.thumbnail = proto.thumbnails = proto.screenshot = proto.screenshots = function(config2, folder) {
      var self2 = this;
      var source2 = this._currentInput.source;
      config2 = config2 || { count: 1 };
      if (typeof config2 === "number") {
        config2 = {
          count: config2
        };
      }
      if (!("folder" in config2)) {
        config2.folder = folder || ".";
      }
      if ("timestamps" in config2) {
        config2.timemarks = config2.timestamps;
      }
      if (!("timemarks" in config2)) {
        if (!config2.count) {
          throw new Error("Cannot take screenshots: neither a count nor a timemark list are specified");
        }
        var interval = 100 / (1 + config2.count);
        config2.timemarks = [];
        for (var i = 0; i < config2.count; i++) {
          config2.timemarks.push(interval * (i + 1) + "%");
        }
      }
      if ("size" in config2) {
        var fixedSize = config2.size.match(/^(\d+)x(\d+)$/);
        var fixedWidth = config2.size.match(/^(\d+)x\?$/);
        var fixedHeight = config2.size.match(/^\?x(\d+)$/);
        var percentSize = config2.size.match(/^(\d+)%$/);
        if (!fixedSize && !fixedWidth && !fixedHeight && !percentSize) {
          throw new Error("Invalid size parameter: " + config2.size);
        }
      }
      var metadata;
      function getMetadata(cb) {
        if (metadata) {
          cb(null, metadata);
        } else {
          self2.ffprobe(function(err, meta2) {
            metadata = meta2;
            cb(err, meta2);
          });
        }
      }
      async2.waterfall([
        // Compute percent timemarks if any
        function computeTimemarks(next) {
          if (config2.timemarks.some(function(t) {
            return ("" + t).match(/^[\d.]+%$/);
          })) {
            if (typeof source2 !== "string") {
              return next(new Error("Cannot compute screenshot timemarks with an input stream, please specify fixed timemarks"));
            }
            getMetadata(function(err, meta2) {
              if (err) {
                next(err);
              } else {
                var vstream = meta2.streams.reduce(function(biggest, stream) {
                  if (stream.codec_type === "video" && stream.width * stream.height > biggest.width * biggest.height) {
                    return stream;
                  } else {
                    return biggest;
                  }
                }, { width: 0, height: 0 });
                if (vstream.width === 0) {
                  return next(new Error("No video stream in input, cannot take screenshots"));
                }
                var duration2 = Number(vstream.duration);
                if (isNaN(duration2)) {
                  duration2 = Number(meta2.format.duration);
                }
                if (isNaN(duration2)) {
                  return next(new Error("Could not get input duration, please specify fixed timemarks"));
                }
                config2.timemarks = config2.timemarks.map(function(mark) {
                  if (("" + mark).match(/^([\d.]+)%$/)) {
                    return duration2 * parseFloat(mark) / 100;
                  } else {
                    return mark;
                  }
                });
                next();
              }
            });
          } else {
            next();
          }
        },
        // Turn all timemarks into numbers and sort them
        function normalizeTimemarks(next) {
          config2.timemarks = config2.timemarks.map(function(mark) {
            return utils2.timemarkToSeconds(mark);
          }).sort(function(a, b) {
            return a - b;
          });
          next();
        },
        // Add '_%i' to pattern when requesting multiple screenshots and no variable token is present
        function fixPattern(next) {
          var pattern2 = config2.filename || "tn.png";
          if (pattern2.indexOf(".") === -1) {
            pattern2 += ".png";
          }
          if (config2.timemarks.length > 1 && !pattern2.match(/%(s|0*i)/)) {
            var ext = path2.extname(pattern2);
            pattern2 = path2.join(path2.dirname(pattern2), path2.basename(pattern2, ext) + "_%i" + ext);
          }
          next(null, pattern2);
        },
        // Replace filename tokens (%f, %b) in pattern
        function replaceFilenameTokens(pattern2, next) {
          if (pattern2.match(/%[bf]/)) {
            if (typeof source2 !== "string") {
              return next(new Error("Cannot replace %f or %b when using an input stream"));
            }
            pattern2 = pattern2.replace(/%f/g, path2.basename(source2)).replace(/%b/g, path2.basename(source2, path2.extname(source2)));
          }
          next(null, pattern2);
        },
        // Compute size if needed
        function getSize(pattern2, next) {
          if (pattern2.match(/%[whr]/)) {
            if (fixedSize) {
              return next(null, pattern2, fixedSize[1], fixedSize[2]);
            }
            getMetadata(function(err, meta2) {
              if (err) {
                return next(new Error("Could not determine video resolution to replace %w, %h or %r"));
              }
              var vstream = meta2.streams.reduce(function(biggest, stream) {
                if (stream.codec_type === "video" && stream.width * stream.height > biggest.width * biggest.height) {
                  return stream;
                } else {
                  return biggest;
                }
              }, { width: 0, height: 0 });
              if (vstream.width === 0) {
                return next(new Error("No video stream in input, cannot replace %w, %h or %r"));
              }
              var width = vstream.width;
              var height = vstream.height;
              if (fixedWidth) {
                height = height * Number(fixedWidth[1]) / width;
                width = Number(fixedWidth[1]);
              } else if (fixedHeight) {
                width = width * Number(fixedHeight[1]) / height;
                height = Number(fixedHeight[1]);
              } else if (percentSize) {
                width = width * Number(percentSize[1]) / 100;
                height = height * Number(percentSize[1]) / 100;
              }
              next(null, pattern2, Math.round(width / 2) * 2, Math.round(height / 2) * 2);
            });
          } else {
            next(null, pattern2, -1, -1);
          }
        },
        // Replace size tokens (%w, %h, %r) in pattern
        function replaceSizeTokens(pattern2, width, height, next) {
          pattern2 = pattern2.replace(/%r/g, "%wx%h").replace(/%w/g, width).replace(/%h/g, height);
          next(null, pattern2);
        },
        // Replace variable tokens in pattern (%s, %i) and generate filename list
        function replaceVariableTokens(pattern2, next) {
          var filenames = config2.timemarks.map(function(t, i2) {
            return pattern2.replace(/%s/g, utils2.timemarkToSeconds(t)).replace(/%(0*)i/g, function(match, padding) {
              var idx = "" + (i2 + 1);
              return padding.substr(0, Math.max(0, padding.length + 1 - idx.length)) + idx;
            });
          });
          self2.emit("filenames", filenames);
          next(null, filenames);
        },
        // Create output directory
        function createDirectory(filenames, next) {
          fs2.exists(config2.folder, function(exists) {
            if (!exists) {
              fs2.mkdir(config2.folder, function(err) {
                if (err) {
                  next(err);
                } else {
                  next(null, filenames);
                }
              });
            } else {
              next(null, filenames);
            }
          });
        }
      ], function runCommand(err, filenames) {
        if (err) {
          return self2.emit("error", err);
        }
        var count = config2.timemarks.length;
        var split;
        var filters = [split = {
          filter: "split",
          options: count,
          outputs: []
        }];
        if ("size" in config2) {
          self2.size(config2.size);
          var sizeFilters = self2._currentOutput.sizeFilters.get().map(function(f, i3) {
            if (i3 > 0) {
              f.inputs = "size" + (i3 - 1);
            }
            f.outputs = "size" + i3;
            return f;
          });
          split.inputs = "size" + (sizeFilters.length - 1);
          filters = sizeFilters.concat(filters);
          self2._currentOutput.sizeFilters.clear();
        }
        var first = 0;
        for (var i2 = 0; i2 < count; i2++) {
          var stream = "screen" + i2;
          split.outputs.push(stream);
          if (i2 === 0) {
            first = config2.timemarks[i2];
            self2.seekInput(first);
          }
          self2.output(path2.join(config2.folder, filenames[i2])).frames(1).map(stream);
          if (i2 > 0) {
            self2.seek(config2.timemarks[i2] - first);
          }
        }
        self2.complexFilter(filters);
        self2.run();
      });
      return this;
    };
    proto.mergeToFile = proto.concatenate = proto.concat = function(target, options) {
      var fileInput = this._inputs.filter(function(input) {
        return !input.isStream;
      })[0];
      var self2 = this;
      this.ffprobe(this._inputs.indexOf(fileInput), function(err, data) {
        if (err) {
          return self2.emit("error", err);
        }
        var hasAudioStreams = data.streams.some(function(stream) {
          return stream.codec_type === "audio";
        });
        var hasVideoStreams = data.streams.some(function(stream) {
          return stream.codec_type === "video";
        });
        self2.output(target, options).complexFilter({
          filter: "concat",
          options: {
            n: self2._inputs.length,
            v: hasVideoStreams ? 1 : 0,
            a: hasAudioStreams ? 1 : 0
          }
        }).run();
      });
      return this;
    };
  };
  return recipes;
}
var fluentFfmpeg$1;
var hasRequiredFluentFfmpeg$1;
function requireFluentFfmpeg$1() {
  if (hasRequiredFluentFfmpeg$1) return fluentFfmpeg$1;
  hasRequiredFluentFfmpeg$1 = 1;
  var path2 = path$1;
  var util2 = require$$1$2;
  var EventEmitter = require$$0$7.EventEmitter;
  var utils2 = requireUtils$4();
  function FfmpegCommand(input, options) {
    if (!(this instanceof FfmpegCommand)) {
      return new FfmpegCommand(input, options);
    }
    EventEmitter.call(this);
    if (typeof input === "object" && !("readable" in input)) {
      options = input;
    } else {
      options = options || {};
      options.source = input;
    }
    this._inputs = [];
    if (options.source) {
      this.input(options.source);
    }
    this._outputs = [];
    this.output();
    var self2 = this;
    ["_global", "_complexFilters"].forEach(function(prop) {
      self2[prop] = utils2.args();
    });
    options.stdoutLines = "stdoutLines" in options ? options.stdoutLines : 100;
    options.presets = options.presets || options.preset || path2.join(__dirname, "presets");
    options.niceness = options.niceness || options.priority || 0;
    this.options = options;
    this.logger = options.logger || {
      debug: function() {
      },
      info: function() {
      },
      warn: function() {
      },
      error: function() {
      }
    };
  }
  util2.inherits(FfmpegCommand, EventEmitter);
  fluentFfmpeg$1 = FfmpegCommand;
  FfmpegCommand.prototype.clone = function() {
    var clone2 = new FfmpegCommand();
    var self2 = this;
    clone2.options = this.options;
    clone2.logger = this.logger;
    clone2._inputs = this._inputs.map(function(input) {
      return {
        source: input.source,
        options: input.options.clone()
      };
    });
    if ("target" in this._outputs[0]) {
      clone2._outputs = [];
      clone2.output();
    } else {
      clone2._outputs = [
        clone2._currentOutput = {
          flags: {}
        }
      ];
      ["audio", "audioFilters", "video", "videoFilters", "sizeFilters", "options"].forEach(function(key2) {
        clone2._currentOutput[key2] = self2._currentOutput[key2].clone();
      });
      if (this._currentOutput.sizeData) {
        clone2._currentOutput.sizeData = {};
        utils2.copy(this._currentOutput.sizeData, clone2._currentOutput.sizeData);
      }
      utils2.copy(this._currentOutput.flags, clone2._currentOutput.flags);
    }
    ["_global", "_complexFilters"].forEach(function(prop) {
      clone2[prop] = self2[prop].clone();
    });
    return clone2;
  };
  requireInputs()(FfmpegCommand.prototype);
  requireAudio()(FfmpegCommand.prototype);
  requireVideo()(FfmpegCommand.prototype);
  requireVideosize()(FfmpegCommand.prototype);
  requireOutput()(FfmpegCommand.prototype);
  requireCustom()(FfmpegCommand.prototype);
  requireMisc()(FfmpegCommand.prototype);
  requireProcessor()(FfmpegCommand.prototype);
  requireCapabilities()(FfmpegCommand.prototype);
  FfmpegCommand.setFfmpegPath = function(path3) {
    new FfmpegCommand().setFfmpegPath(path3);
  };
  FfmpegCommand.setFfprobePath = function(path3) {
    new FfmpegCommand().setFfprobePath(path3);
  };
  FfmpegCommand.setFlvtoolPath = function(path3) {
    new FfmpegCommand().setFlvtoolPath(path3);
  };
  FfmpegCommand.availableFilters = FfmpegCommand.getAvailableFilters = function(callback) {
    new FfmpegCommand().availableFilters(callback);
  };
  FfmpegCommand.availableCodecs = FfmpegCommand.getAvailableCodecs = function(callback) {
    new FfmpegCommand().availableCodecs(callback);
  };
  FfmpegCommand.availableFormats = FfmpegCommand.getAvailableFormats = function(callback) {
    new FfmpegCommand().availableFormats(callback);
  };
  FfmpegCommand.availableEncoders = FfmpegCommand.getAvailableEncoders = function(callback) {
    new FfmpegCommand().availableEncoders(callback);
  };
  requireFfprobe()(FfmpegCommand.prototype);
  FfmpegCommand.ffprobe = function(file2) {
    var instance = new FfmpegCommand(file2);
    instance.ffprobe.apply(instance, Array.prototype.slice.call(arguments, 1));
  };
  requireRecipes()(FfmpegCommand.prototype);
  return fluentFfmpeg$1;
}
var fluentFfmpeg;
var hasRequiredFluentFfmpeg;
function requireFluentFfmpeg() {
  if (hasRequiredFluentFfmpeg) return fluentFfmpeg;
  hasRequiredFluentFfmpeg = 1;
  fluentFfmpeg = requireFluentFfmpeg$1();
  return fluentFfmpeg;
}
var fluentFfmpegExports = requireFluentFfmpeg();
const ffmpeg = /* @__PURE__ */ getDefaultExportFromCjs(fluentFfmpegExports);
function setFFMpegPath(ffmpegPath) {
  os.platform();
  const paths = [
    ffmpegPath,
    path__default.join(path__default.dirname(fileURLToPath(import.meta.url)), "ffmpeg.exe"),
    process.env["FFMPEG_PATH"] || ""
    // ...envPaths,
  ];
  for (const p of paths) {
    if (fs__default.existsSync(p)) {
      ffmpeg.setFfmpegPath(p);
      console.log("set ffmpeg successfully", p);
      break;
    }
  }
}
var LocalExitGroupReason = /* @__PURE__ */ ((LocalExitGroupReason2) => {
  LocalExitGroupReason2[LocalExitGroupReason2["NO_QUIT"] = 0] = "NO_QUIT";
  LocalExitGroupReason2[LocalExitGroupReason2["KICKED"] = 1] = "KICKED";
  LocalExitGroupReason2[LocalExitGroupReason2["DISMISS"] = 2] = "DISMISS";
  LocalExitGroupReason2[LocalExitGroupReason2["SELF_QUIT"] = 3] = "SELF_QUIT";
  return LocalExitGroupReason2;
})(LocalExitGroupReason || {});
class Core extends Service2 {
  constructor(ctx, config2) {
    super(ctx, "app", true);
    this.ctx = ctx;
    this.config = config2;
    this.pmhq = pmhq;
  }
  static inject = ["ntMsgApi", "ntFriendApi", "ntGroupApi", "store", "ntUserApi", "ntFileApi"];
  startupTime = 0;
  messageReceivedCount = 0;
  messageSentCount = 0;
  lastMessageTime = 0;
  pmhq;
  start() {
    this.startupTime = Math.trunc(Date.now() / 1e3);
    this.registerListener();
    setFFMpegPath("");
    this.ctx.on("llob/config-updated", (input) => {
      Object.assign(this.config, input);
      setFFMpegPath(input.ffmpeg || "");
    });
  }
  async sendMessage(ctx, peer, sendElements, deleteAfterSentFiles) {
    if (peer.chatType === ChatType.Group) {
      const info = await ctx.ntGroupApi.getGroupAllInfo(peer.peerUid).catch(() => void 0);
      const shutUpMeTimestamp = info?.shutUpMeTimestamp;
      if (shutUpMeTimestamp && shutUpMeTimestamp * 1e3 > Date.now()) {
        throw new Error("");
      }
    }
    if (!sendElements.length) {
      throw new Error("");
    }
    let totalSize = 0;
    for (const fileElement of sendElements) {
      try {
        if (fileElement.elementType === ElementType.Ptt) {
          totalSize += statSync(fileElement.pttElement.filePath).size;
        } else if (fileElement.elementType === ElementType.File) {
          totalSize += statSync(fileElement.fileElement.filePath).size;
        } else if (fileElement.elementType === ElementType.Video) {
          totalSize += statSync(fileElement.videoElement.filePath).size;
        } else if (fileElement.elementType === ElementType.Pic) {
          totalSize += statSync(fileElement.picElement.sourcePath).size;
        }
      } catch (e) {
        ctx.logger.warn("", e, fileElement);
      }
    }
    const timeout2 = 1e4 + totalSize / 1024 / 256 * 1e3;
    const returnMsg = await ctx.ntMsgApi.sendMsg(peer, sendElements, timeout2);
    this.messageSentCount++;
    ctx.logger.info("", peer);
    deleteAfterSentFiles.forEach((path2) => {
      unlink(path2).catch((e) => {
      });
    });
    return returnMsg;
  }
  async handleMessage(msgList) {
    for (const message of msgList) {
      const msgTime = parseInt(message.msgTime);
      if (msgTime < this.startupTime) {
        const existing = await this.ctx.store.checkMsgExist(message);
        if (!existing) {
          this.ctx.parallel("nt/offline-message-created", message);
        }
        continue;
      }
      if (message.senderUin && message.senderUin !== "0") {
        this.ctx.store.addMsgCache(message);
      }
      this.lastMessageTime = msgTime;
      this.messageReceivedCount++;
      logSummaryMessage(this.ctx, message).then();
      this.ctx.parallel("nt/message-created", message);
    }
    if (!this.config.autoDeleteFile) {
      return;
    }
    const allPaths = [];
    for (const message of msgList) {
      for (const msgElement of message.elements) {
        const picPath = msgElement.picElement?.sourcePath;
        const picThumbPath = [...(msgElement.picElement?.thumbPath ?? []).values()];
        const pttPath = msgElement.pttElement?.filePath;
        const filePath = msgElement.fileElement?.filePath;
        const videoPath = msgElement.videoElement?.filePath;
        const videoThumbPath = [...(msgElement.videoElement?.thumbPath ?? []).values()];
        const pathList = [picPath, ...picThumbPath, pttPath, filePath, videoPath, ...videoThumbPath];
        if (msgElement.picElement) {
          pathList.push(...Object.values(msgElement.picElement.thumbPath));
        }
        allPaths.push(...pathList.filter((path2) => path2 !== void 0 && path2 !== null));
      }
    }
    if (allPaths.length > 0) {
      setTimeout(() => {
        for (const path2 of allPaths) {
          if (path2) {
            unlink(path2).then(() => this.ctx.logger.info("", path2)).catch((e) => {
            });
          }
        }
      }, this.config.autoDeleteFileSecond * 1e3);
    }
  }
  registerListener() {
    registerReceiveHook(ReceiveCmdS.LOGIN_QR_CODE, (data) => {
      this.ctx.parallel("nt/login-qrcode", data);
    });
    registerReceiveHook(ReceiveCmdS.SELF_STATUS, (info) => {
      Object.assign(selfInfo, { online: info.status !== 20 });
    });
    registerReceiveHook(ReceiveCmdS.NEW_MSG, (payload) => {
      this.handleMessage(payload);
    });
    const sentMsgIds = /* @__PURE__ */ new Map();
    const recallMsgIds = [];
    registerReceiveHook([ReceiveCmdS.UPDATE_MSG], (payload) => {
      for (const msg of payload) {
        if (msg.recallTime !== "0" && msg.msgType === 5 && msg.subMsgType === 4 && msg.elements[0]?.grayTipElement?.subElementType === GrayTipElementSubType.Revoke && !recallMsgIds.includes(msg.msgId)) {
          recallMsgIds.push(msg.msgId);
          this.ctx.parallel("nt/message-deleted", msg);
        } else if (sentMsgIds.get(msg.msgId)) {
          if (msg.sendStatus === 2) {
            sentMsgIds.delete(msg.msgId);
            logSummaryMessage(this.ctx, msg).then();
            this.ctx.parallel("nt/message-sent", msg);
          }
        }
      }
      if (recallMsgIds.length > 1e3) {
        recallMsgIds.shift();
      }
      if (sentMsgIds.size > 1e3) {
        const firstKey = sentMsgIds.keys().next().value;
        if (firstKey) {
          sentMsgIds.delete(firstKey);
        }
      }
    });
    registerReceiveHook(ReceiveCmdS.DELETE_MSG, (payload) => {
      const [peer, msgIds] = payload;
      for (const msgId of msgIds) {
        const msg = this.ctx.store.getMsgCache(msgId);
        if (!msg) {
          this.ctx.ntMsgApi.getMsgsByMsgId(peer, [msgId]).then((r) => {
            for (const _msg of r.msgList) {
              this.ctx.parallel("nt/message-deleted", _msg);
            }
          }).catch((e) => {
            this.ctx.logger.error("", e, { peer, msgId });
          });
        } else {
          this.ctx.parallel("nt/message-deleted", msg);
        }
      }
    });
    registerReceiveHook(ReceiveCmdS.SELF_SEND_MSG, (payload) => {
      sentMsgIds.set(payload.msgId, true);
    });
    const groupNotifyIgnore = [];
    registerReceiveHook(ReceiveCmdS.UNREAD_GROUP_NOTIFY, async (payload) => {
      const [doubt, oldestUnreadSeq, unreadCount] = payload;
      if (unreadCount) {
        let notifies;
        try {
          notifies = (await this.ctx.ntGroupApi.getSingleScreenNotifies(doubt, unreadCount)).notifies;
        } catch (e) {
          return;
        }
        for (const notify of notifies) {
          const notifyTime = Math.trunc(+notify.seq / 1e3 / 1e3);
          if (groupNotifyIgnore.includes(notify.seq) || notifyTime < this.startupTime) {
            continue;
          }
          groupNotifyIgnore.push(notify.seq);
          if (groupNotifyIgnore.length > 1e3) {
            groupNotifyIgnore.shift();
          }
          this.ctx.parallel("nt/group-notify", { notify, doubt });
        }
      }
    });
    registerReceiveHook(ReceiveCmdS.FRIEND_REQUEST, (payload) => {
      this.ctx.ntFriendApi.clearBuddyReqUnreadCnt().catch((e) => this.ctx.logger.error(``, e));
      for (const req of payload.buddyReqs) {
        if (!req.isUnread || req.isInitiator || req.isDecide && req.reqType !== BuddyReqType.MeInitiatorWaitPeerConfirm) {
          continue;
        }
        if (+req.reqTime < this.startupTime) {
          continue;
        }
        this.ctx.parallel("nt/friend-request", req);
      }
    });
    registerReceiveHook("nodeIKernelMsgListener/onRecvSysMsg", (payload) => {
      this.ctx.parallel("nt/system-message-created", Buffer.from(payload));
    });
    registerReceiveHook(ReceiveCmdS.FLASH_FILE_DOWNLOAD_STATUS, (payload) => {
      const [status, errCodeOrFileSetId, fileSetIdOrFileInfo] = payload;
      let fileSetId;
      if (typeof fileSetIdOrFileInfo !== "string") {
        fileSetId = errCodeOrFileSetId;
      } else {
        fileSetId = fileSetIdOrFileInfo;
      }
      this.ctx.ntFileApi.getFlashFileInfo(fileSetId).then((info) => {
        this.ctx.parallel("nt/flash-file-download-status", {
          status,
          info
        });
      }).catch((err) => {
        this.ctx.logger.error(err, { fileSetId });
      });
    });
    registerReceiveHook(ReceiveCmdS.FLASH_FILE_UPLOAD_STATUS, (payload) => {
      this.ctx.parallel("nt/flash-file-upload-status", payload);
    });
    registerReceiveHook(ReceiveCmdS.FLASH_FILE_DOWNLOADING, (payload) => {
      const [fileSetId, info] = payload;
      this.ctx.parallel("nt/flash-file-downloading", [fileSetId, info]);
    });
    registerReceiveHook(ReceiveCmdS.FLASH_FILE_UPLOADING, (payload) => {
      this.ctx.parallel("nt/flash-file-uploading", payload);
    });
    const group_dismiss_codes = [];
    registerReceiveHook(ReceiveCmdS.GROUP_DETAIL_INFO_UPDATE, async (data) => {
      if (data.localExitGroupReason === LocalExitGroupReason.DISMISS && !group_dismiss_codes.includes(data.groupCode) && data.cmdUinJoinTime > this.startupTime) {
        group_dismiss_codes.push(data.groupCode);
        if (group_dismiss_codes.length > 1e3) {
          group_dismiss_codes.shift();
        }
        this.ctx.parallel("nt/group-dismiss", data);
      } else if (data.localExitGroupReason === LocalExitGroupReason.SELF_QUIT) {
        this.ctx.parallel("nt/group-quit", data);
      }
    });
    registerReceiveHook("nodeIKernelMsgListener/onKickedOffLine", (info) => {
      this.ctx.parallel("nt/kicked-offLine", info);
    });
  }
}
var OB11UserSex = /* @__PURE__ */ ((OB11UserSex2) => {
  OB11UserSex2["Male"] = "male";
  OB11UserSex2["Female"] = "female";
  OB11UserSex2["Unknown"] = "unknown";
  return OB11UserSex2;
})(OB11UserSex || {});
var OB11GroupMemberRole = /* @__PURE__ */ ((OB11GroupMemberRole2) => {
  OB11GroupMemberRole2["Owner"] = "owner";
  OB11GroupMemberRole2["Admin"] = "admin";
  OB11GroupMemberRole2["Member"] = "member";
  return OB11GroupMemberRole2;
})(OB11GroupMemberRole || {});
var OB11MessageDataType = /* @__PURE__ */ ((OB11MessageDataType2) => {
  OB11MessageDataType2["Text"] = "text";
  OB11MessageDataType2["Image"] = "image";
  OB11MessageDataType2["Music"] = "music";
  OB11MessageDataType2["Video"] = "video";
  OB11MessageDataType2["Record"] = "record";
  OB11MessageDataType2["File"] = "file";
  OB11MessageDataType2["FlashFile"] = "flash_file";
  OB11MessageDataType2["At"] = "at";
  OB11MessageDataType2["Reply"] = "reply";
  OB11MessageDataType2["Json"] = "json";
  OB11MessageDataType2["Face"] = "face";
  OB11MessageDataType2["Mface"] = "mface";
  OB11MessageDataType2["Markdown"] = "markdown";
  OB11MessageDataType2["Node"] = "node";
  OB11MessageDataType2["Forward"] = "forward";
  OB11MessageDataType2["Xml"] = "xml";
  OB11MessageDataType2["Poke"] = "poke";
  OB11MessageDataType2["Dice"] = "dice";
  OB11MessageDataType2["Rps"] = "rps";
  OB11MessageDataType2["Contact"] = "contact";
  OB11MessageDataType2["Shake"] = "shake";
  OB11MessageDataType2["Keyboard"] = "keyboard";
  return OB11MessageDataType2;
})(OB11MessageDataType || {});
var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2["META"] = "meta_event";
  EventType2["REQUEST"] = "request";
  EventType2["NOTICE"] = "notice";
  EventType2["MESSAGE"] = "message";
  EventType2["MESSAGE_SENT"] = "message_sent";
  return EventType2;
})(EventType || {});
class OB11BaseEvent {
  time = Math.floor(Date.now() / 1e3);
  self_id = parseInt(selfInfo.uin);
  getSummaryEventName() {
    return this.post_type + "." + this[(this.post_type === "message_sent" ? "message" : this.post_type) + "_type"];
  }
}
const pattern = /\[CQ:(\w+)((,\w+=[^,\]]*)*)\]/;
function unescape$1(source2) {
  return String(source2).replace(/&#91;/g, "[").replace(/&#93;/g, "]").replace(/&#44;/g, ",").replace(/&amp;/g, "&");
}
function from(source2) {
  const capture = pattern.exec(source2);
  if (!capture) return null;
  const [, type2, attrs] = capture;
  const data = {};
  if (attrs) {
    attrs.slice(1).split(",").forEach((str) => {
      const index2 = str.indexOf("=");
      data[str.slice(0, index2)] = unescape$1(str.slice(index2 + 1));
    });
  }
  return { type: type2, data, capture };
}
function h$1(type2, data) {
  return {
    type: type2,
    data
  };
}
function decodeCQCode(source2) {
  const elements = [];
  let result;
  while (result = from(source2)) {
    const { type: type2, data, capture } = result;
    if (capture.index) {
      elements.push(h$1("text", { text: unescape$1(source2.slice(0, capture.index)) }));
    }
    elements.push(h$1(type2, data));
    source2 = source2.slice(capture.index + capture[0].length);
  }
  if (source2) elements.push(h$1("text", { text: unescape$1(source2) }));
  return elements;
}
function encodeCQCode(input) {
  const CQCodeEscapeText = (text) => {
    return text.replace(/\&/g, "&amp;").replace(/\[/g, "&#91;").replace(/\]/g, "&#93;");
  };
  const CQCodeEscape = (text) => {
    return text.replace(/\&/g, "&amp;").replace(/\[/g, "&#91;").replace(/\]/g, "&#93;").replace(/,/g, "&#44;");
  };
  if (input.type === "text") {
    return CQCodeEscapeText(input.data.text);
  }
  let result = "[CQ:" + input.type;
  for (const [key2, value] of Object.entries(input.data)) {
    if (value === void 0) {
      continue;
    }
    try {
      const text = value.toString();
      result += `,${key2}=${CQCodeEscape(text)}`;
    } catch (error2) {
    }
  }
  result += "]";
  return result;
}
class OB11BaseNoticeEvent extends OB11BaseEvent {
  post_type = EventType.NOTICE;
}
class OB11GroupNoticeEvent extends OB11BaseNoticeEvent {
}
class OB11GroupIncreaseEvent extends OB11GroupNoticeEvent {
  notice_type = "group_increase";
  operator_id;
  sub_type;
  group_id;
  user_id;
  constructor(groupId, userId, operatorId, subType = "approve") {
    super();
    this.group_id = groupId;
    this.operator_id = operatorId;
    this.user_id = userId;
    this.sub_type = subType;
  }
}
class OB11GroupUploadNoticeEvent extends OB11GroupNoticeEvent {
  notice_type = "group_upload";
  file;
  group_id;
  user_id;
  constructor(groupId, userId, file2) {
    super();
    this.group_id = groupId;
    this.user_id = userId;
    this.file = file2;
  }
}
class OB11GroupTitleEvent extends OB11GroupNoticeEvent {
  notice_type = "notify";
  sub_type = "title";
  title;
  group_id;
  user_id;
  constructor(groupId, userId, title) {
    super();
    this.group_id = groupId;
    this.user_id = userId;
    this.title = title;
  }
}
class OB11GroupDecreaseEvent extends OB11GroupNoticeEvent {
  notice_type = "group_decrease";
  sub_type = "leave";
  operator_id;
  group_id;
  user_id;
  constructor(groupId, userId, operatorId, subType = "leave") {
    super();
    this.group_id = groupId;
    this.operator_id = operatorId;
    this.user_id = userId;
    this.sub_type = subType;
  }
}
class OB11FriendAddNoticeEvent extends OB11BaseNoticeEvent {
  notice_type = "friend_add";
  user_id;
  constructor(userId) {
    super();
    this.user_id = userId;
  }
}
class OB11FriendRecallNoticeEvent extends OB11BaseNoticeEvent {
  notice_type = "friend_recall";
  user_id;
  message_id;
  constructor(userId, messageId) {
    super();
    this.user_id = userId;
    this.message_id = messageId;
  }
}
class OB11GroupRecallNoticeEvent extends OB11GroupNoticeEvent {
  notice_type = "group_recall";
  operator_id;
  message_id;
  group_id;
  user_id;
  constructor(groupId, userId, operatorId, messageId) {
    super();
    this.group_id = groupId;
    this.user_id = userId;
    this.operator_id = operatorId;
    this.message_id = messageId;
  }
}
class OB11PokeEvent extends OB11BaseNoticeEvent {
  notice_type = "notify";
  sub_type = "poke";
  target_id = 0;
}
class OB11FriendPokeEvent extends OB11PokeEvent {
  user_id;
  raw_info;
  constructor(user_id, target_id, raw_message) {
    super();
    this.target_id = target_id;
    this.user_id = user_id;
    this.raw_info = raw_message;
  }
}
class OB11GroupPokeEvent extends OB11PokeEvent {
  user_id;
  group_id;
  raw_info;
  constructor(group_id, user_id, target_id, raw_message) {
    super();
    this.group_id = group_id;
    this.target_id = target_id;
    this.user_id = user_id;
    this.raw_info = raw_message;
  }
}
class OB11FriendPokeRecallEvent extends OB11FriendPokeEvent {
  sub_type = "poke_recall";
}
class OB11GroupPokeRecallEvent extends OB11GroupPokeEvent {
  sub_type = "poke_recall";
}
class GroupBanEvent extends OB11GroupNoticeEvent {
  notice_type = "group_ban";
  operator_id;
  duration;
  sub_type;
  group_id;
  user_id;
  constructor(groupId, userId, operatorId, duration2, sub_type) {
    super();
    this.group_id = groupId;
    this.operator_id = operatorId;
    this.user_id = userId;
    this.duration = duration2;
    this.sub_type = sub_type;
  }
  static async parse(ctx, groupElement, groupCode) {
    const memberUid = groupElement.shutUp?.member.uid;
    const adminUid = groupElement.shutUp?.admin.uid;
    let memberUin = "";
    let duration2 = Number(groupElement.shutUp?.duration);
    if (memberUid) {
      memberUin = await ctx.ntUserApi.getUinByUid(memberUid);
    } else {
      memberUin = "0";
      if (duration2 > 0) {
        duration2 = -1;
      }
    }
    const adminUin = await ctx.ntUserApi.getUinByUid(adminUid);
    const subType = duration2 > 0 ? "ban" : "lift_ban";
    return new GroupBanEvent(+groupCode, +memberUin, +adminUin, duration2, subType);
  }
}
class OB11GroupRequestAddEvent extends OB11BaseNoticeEvent {
  post_type = EventType.REQUEST;
  request_type = "group";
  sub_type;
  comment;
  flag;
  group_id;
  //  invitor_id 
  invitor_id;
  // https://github.com/Mrs4s/go-cqhttp/blob/master/coolq/event.go#L566
  constructor(groupId, userId, flag, comment, invitor_id = 0) {
    super();
    this.group_id = groupId;
    this.user_id = userId;
    this.comment = comment;
    this.flag = flag;
    this.sub_type = "add";
    this.invitor_id = invitor_id;
  }
}
class OB11GroupRequestInviteBotEvent extends OB11BaseNoticeEvent {
  post_type = EventType.REQUEST;
  request_type = "group";
  sub_type;
  // invite  bot 
  comment;
  flag;
  group_id;
  user_id;
  //  sub_type  invite  user_id  QQ 
  constructor(groupId, userId, flag, comment) {
    super();
    this.group_id = groupId;
    this.user_id = userId;
    this.comment = comment;
    this.flag = flag;
    this.sub_type = "invite";
  }
}
var OB11Entities;
((OB11Entities2) => {
  async function message(ctx, msg, rootMsgID, peer, config2) {
    if (!msg.senderUin || msg.senderUin === "0" || msg.msgType === 1) return;
    const selfUin = selfInfo.uin;
    const msgShortId = ctx.store.createMsgShortId(msg);
    const resMsg = {
      self_id: Number(selfUin),
      user_id: Number(msg.senderUin),
      time: Number(msg.msgTime),
      message_id: msgShortId,
      message_seq: Number(msg.msgSeq),
      message_type: msg.chatType === ChatType.Group ? "group" : "private",
      sender: {
        user_id: Number(msg.senderUin),
        nickname: msg.sendNickName,
        card: msg.sendMemberName ?? ""
      },
      raw_message: "",
      font: 14,
      sub_type: "friend",
      message: [],
      message_format: "array",
      post_type: selfUin === msg.senderUin ? EventType.MESSAGE_SENT : EventType.MESSAGE,
      getSummaryEventName() {
        return this.post_type + "." + this.message_type;
      }
    };
    if (!config2 || config2.debug) {
      resMsg.raw = msg;
      resMsg.raw_pb = "";
      const uniqueId = `${msg.peerUin}_${msg.msgRandom}_${msg.msgSeq}`;
      const msgPB = msgPBMap.get(uniqueId);
      if (msgPB) {
        resMsg.raw_pb = msgPB;
      }
    }
    if (msg.chatType === ChatType.Group) {
      resMsg.sub_type = "normal";
      resMsg.group_id = parseInt(msg.peerUin);
      resMsg.group_name = msg.peerName;
      if (msg.peerUin !== "284840486") {
        try {
          const member = await ctx.ntGroupApi.getGroupMember(msg.peerUin, msg.senderUid);
          resMsg.sender.role = groupMemberRole(member.role);
          resMsg.sender.nickname = member.nick;
          resMsg.sender.title = member.memberSpecialTitle ?? "";
        } catch {
          resMsg.sender.role = OB11GroupMemberRole.Member;
          resMsg.sender.title = "";
        }
      }
    } else if (msg.chatType === ChatType.C2C) {
      resMsg.sub_type = "friend";
      if (msg.senderUin === "1094950020") {
        resMsg.sender.nickname = "QQ";
      } else {
        resMsg.sender.nickname = (await ctx.ntUserApi.getCoreAndBaseInfo([msg.senderUid])).get(msg.senderUid).coreInfo.nick;
      }
    } else if (msg.chatType === ChatType.TempC2CFromGroup) {
      resMsg.sub_type = "group";
      resMsg.temp_source = 0;
      if (msg.senderUin === "1094950020") {
        resMsg.sender.nickname = "QQ";
      } else {
        resMsg.sender.nickname = (await ctx.ntUserApi.getCoreAndBaseInfo([msg.senderUid])).get(msg.senderUid).coreInfo.nick;
      }
      const ret = await ctx.ntMsgApi.getTempChatInfo(ChatType.TempC2CFromGroup, msg.peerUid);
      if (ret?.result === 0) {
        resMsg.sender.group_id = Number(ret.tmpChatInfo?.groupCode);
      } else {
        resMsg.sender.group_id = 284840486;
      }
    }
    for (const element of msg.elements) {
      let messageSegment;
      if (element.textElement && element.textElement?.atType !== AtType.Unknown) {
        let qq;
        let name;
        if (element.textElement.atType === AtType.All) {
          qq = "all";
        } else {
          const { atNtUid, atUid, content } = element.textElement;
          if (atUid && atUid !== "0") {
            qq = atUid;
          } else {
            qq = await ctx.ntUserApi.getUinByUid(atNtUid);
          }
          name = content.replace("@", "");
        }
        messageSegment = {
          type: OB11MessageDataType.At,
          data: {
            qq,
            name
          }
        };
      } else if (element.textElement) {
        const text = element.textElement.content;
        if (!text) {
          continue;
        }
        messageSegment = {
          type: OB11MessageDataType.Text,
          data: {
            text
          }
        };
      } else if (element.replyElement) {
        const { replyElement } = element;
        const peer2 = {
          chatType: msg.chatType,
          peerUid: msg.peerUid,
          guildId: ""
        };
        try {
          const { replayMsgSeq: replyMsgSeq, replyMsgTime } = replyElement;
          const record2 = msg.records.find((msgRecord) => msgRecord.msgId === replyElement.sourceMsgIdInRecords);
          const { msgList } = await ctx.ntMsgApi.getMsgsBySeqAndCount(peer2, replyMsgSeq, 1, true, true);
          if (!replyMsgTime) {
            ctx.logger.error("", replyElement);
            continue;
          }
          let replyMsg;
          if (record2 && record2.msgRandom !== "0") {
            replyMsg = msgList.find((msg2) => msg2.msgRandom === record2.msgRandom);
          } else {
            if (msgList.length > 0) {
              replyMsg = msgList.find((msg2) => msg2.msgTime === replyMsgTime);
            } else if (record2) {
              if (record2.senderUin && record2.senderUin !== "0") {
                peer2.chatType = record2.chatType;
                peer2.peerUid = record2.peerUid;
                ctx.store.addMsgCache(record2);
              }
              ctx.logger.info("msgList is empty, use record", replyElement, record2);
              replyMsg = record2;
            }
          }
          if (!replyMsg) {
            ctx.logger.error("", replyElement, record2);
            continue;
          }
          messageSegment = {
            type: OB11MessageDataType.Reply,
            data: {
              id: ctx.store.createMsgShortId(replyMsg).toString()
            }
          };
        } catch (e) {
          ctx.logger.error("", e, replyElement, e.stack);
          continue;
        }
      } else if (element.picElement) {
        const { picElement } = element;
        const fileSize = picElement.fileSize ?? "0";
        messageSegment = {
          type: OB11MessageDataType.Image,
          data: {
            file: picElement.fileName,
            subType: picElement.picSubType,
            url: await ctx.ntFileApi.getImageUrl(picElement),
            file_size: fileSize
          }
        };
        ctx.store.addFileCache({
          peerUid: msg.peerUid,
          msgId: msg.msgId,
          msgTime: +msg.msgTime,
          chatType: msg.chatType,
          elementId: element.elementId,
          elementType: element.elementType,
          fileName: picElement.fileName,
          fileUuid: picElement.fileUuid,
          fileSize
        }).then();
      } else if (element.videoElement) {
        const { videoElement } = element;
        const videoUrl = await ctx.ntFileApi.getVideoUrl(
          peer ?? {
            chatType: msg.chatType,
            peerUid: msg.peerUid,
            guildId: ""
          },
          rootMsgID ?? msg.msgId,
          element.elementId
        );
        const fileSize = videoElement.fileSize ?? "0";
        messageSegment = {
          type: OB11MessageDataType.Video,
          data: {
            file: videoElement.fileName,
            url: videoUrl || pathToFileURL(videoElement.filePath).href,
            path: videoElement.filePath,
            file_size: fileSize
          }
        };
        ctx.store.addFileCache({
          peerUid: msg.peerUid,
          msgId: msg.msgId,
          msgTime: +msg.msgTime,
          chatType: msg.chatType,
          elementId: element.elementId,
          elementType: element.elementType,
          fileName: videoElement.fileName,
          fileUuid: videoElement.fileUuid,
          fileSize
        }).then();
      } else if (element.fileElement) {
        const { fileElement } = element;
        const fileSize = fileElement.fileSize ?? "0";
        messageSegment = {
          type: OB11MessageDataType.File,
          data: {
            file: fileElement.fileName,
            url: fileElement.filePath ? pathToFileURL(fileElement.filePath).href : "",
            file_id: fileElement.fileUuid,
            path: fileElement.filePath,
            file_size: fileSize
          }
        };
        ctx.store.addFileCache({
          peerUid: msg.peerUid,
          msgId: msg.msgId,
          msgTime: +msg.msgTime,
          chatType: msg.chatType,
          elementId: element.elementId,
          elementType: element.elementType,
          fileName: fileElement.fileName,
          fileUuid: fileElement.fileUuid,
          fileSize
        }).then();
      } else if (element.pttElement) {
        const { pttElement } = element;
        const fileSize = pttElement.fileSize ?? "0";
        messageSegment = {
          type: OB11MessageDataType.Record,
          data: {
            file: pttElement.fileName,
            url: await ctx.ntFileApi.getPttUrl(pttElement.fileUuid, msg.chatType === ChatType.Group),
            path: pttElement.filePath,
            file_size: fileSize
          }
        };
        ctx.store.addFileCache({
          peerUid: msg.peerUid,
          msgId: msg.msgId,
          msgTime: +msg.msgTime,
          chatType: msg.chatType,
          elementId: element.elementId,
          elementType: element.elementType,
          fileName: pttElement.fileName,
          fileUuid: pttElement.fileUuid,
          fileSize
        }).then();
      } else if (element.arkElement) {
        const { arkElement } = element;
        try {
          const data = JSON.parse(arkElement.bytesData);
          if (data.app === "com.tencent.multimsg") {
            messageSegment = {
              type: OB11MessageDataType.Forward,
              data: {
                id: msg.msgId
              }
            };
          } else {
            messageSegment = {
              type: OB11MessageDataType.Json,
              data: {
                data: arkElement.bytesData
              }
            };
          }
        } catch {
        }
      } else if (element.faceElement) {
        const { faceElement } = element;
        const { faceIndex, faceType } = faceElement;
        if (faceType === FaceType.Poke && faceIndex === 1) {
          messageSegment = {
            type: OB11MessageDataType.Shake,
            data: {}
          };
        } else {
          if (faceIndex === FaceIndex.Dice) {
            messageSegment = {
              type: OB11MessageDataType.Dice,
              data: {
                result: faceElement.resultId
              }
            };
          } else if (faceIndex === FaceIndex.RPS) {
            messageSegment = {
              type: OB11MessageDataType.Rps,
              data: {
                result: faceElement.resultId
              }
            };
          } else {
            messageSegment = {
              type: OB11MessageDataType.Face,
              data: {
                id: faceIndex.toString(),
                sub_type: faceType
              }
            };
          }
        }
      } else if (element.marketFaceElement) {
        const { marketFaceElement } = element;
        const { emojiId } = marketFaceElement;
        const dir = emojiId.substring(0, 2);
        const url2 = `https://gxh.vip.qq.com/club/item/parcel/item/${dir}/${emojiId}/raw300.gif`;
        messageSegment = {
          type: OB11MessageDataType.Mface,
          data: {
            summary: marketFaceElement.faceName,
            url: url2,
            emoji_id: emojiId,
            emoji_package_id: marketFaceElement.emojiPackageId,
            key: marketFaceElement.key
          }
        };
      } else if (element.markdownElement) {
        const { markdownElement } = element;
        if (markdownElement?.content.startsWith("[](")) {
          const mqqapiUrl = markdownElement?.content.substring(5, markdownElement?.content.length - 1);
          const urlJson = new URL(mqqapiUrl).searchParams.get("json");
          if (urlJson) {
            const jsonData = JSON.parse(urlJson);
            const busId = jsonData?.busId;
            if (busId === "FlashTransfer") {
              const attributes = jsonData?.attributes?.attributes || [];
              const fileAttribute = attributes.find((a) => a.viewId === "file");
              if (fileAttribute) {
                const urlParams = new URL(fileAttribute.schema).searchParams;
                const fileSetId = urlParams.get("fileset_id") || "";
                const sceneType = urlParams.get("scene_type") || "";
                const fileSubAttributes = fileAttribute?.attributes || [];
                const titleAttribute = fileSubAttributes.find((a) => a.viewId === "title");
                const title = titleAttribute?.text;
                messageSegment = {
                  type: OB11MessageDataType.FlashFile,
                  data: {
                    title,
                    file_set_id: fileSetId,
                    scene_type: parseInt(sceneType)
                  }
                };
              }
            }
          }
        } else {
          messageSegment = {
            type: OB11MessageDataType.Markdown,
            data: {
              content: markdownElement.content
            }
          };
        }
      } else if (element.multiForwardMsgElement) {
        messageSegment = {
          type: OB11MessageDataType.Forward,
          data: {
            id: msg.msgId
          }
        };
      } else if (element.inlineKeyboardElement) {
        messageSegment = {
          type: OB11MessageDataType.Keyboard,
          data: {
            rows: element.inlineKeyboardElement.rows.map((row) => ({
              buttons: row.buttons.map((button) => ({
                id: button.id,
                render_data: {
                  label: button.label,
                  visited_label: button.visitedLabel,
                  style: button.style
                },
                action: {
                  type: button.type,
                  permission: {
                    type: button.permissionType,
                    specify_role_ids: button.specifyRoleIds,
                    specify_user_ids: button.specifyTinyids
                  },
                  unsupport_tips: button.unsupportTips,
                  data: button.data,
                  reply: button.isReply,
                  enter: button.enter
                }
              }))
            }))
          }
        };
      }
      if (messageSegment) {
        const cqCode = encodeCQCode(messageSegment);
        if (typeof resMsg.message === "object") {
          resMsg.message.push(messageSegment);
        }
        resMsg.raw_message += cqCode;
      }
    }
    if (config2?.messageFormat === "string") {
      resMsg.message = resMsg.raw_message;
      resMsg.message_format = "string";
    }
    return resMsg;
  }
  OB11Entities2.message = message;
  async function privateEvent(ctx, msg) {
    if (msg.chatType !== ChatType.C2C) {
      return;
    }
    if (msg.msgType !== 5 && msg.msgType !== 11) {
      return;
    }
    for (const element of msg.elements) {
      if (element.grayTipElement) {
        const { grayTipElement } = element;
        if (grayTipElement.jsonGrayTipElement?.busiId === "1061") {
          const json2 = JSON.parse(grayTipElement.jsonGrayTipElement.jsonStr);
          const param = grayTipElement.jsonGrayTipElement.xmlToJsonParam;
          if (param) {
            return new OB11FriendPokeEvent(
              Number(param.templParam.get("uin_str1")),
              Number(param.templParam.get("uin_str2")),
              json2.items
            );
          }
          const pokedetail = json2.items;
          const poke_uid = pokedetail.filter((item) => item.uid);
          if (poke_uid.length === 2) {
            return new OB11FriendPokeEvent(
              Number(await ctx.ntUserApi.getUinByUid(poke_uid[0].uid)),
              Number(await ctx.ntUserApi.getUinByUid(poke_uid[1].uid)),
              pokedetail
            );
          }
        }
        if (grayTipElement.xmlElement?.templId === "10229" || grayTipElement.jsonGrayTipElement?.busiId === JsonGrayTipBusId.AddedFriend) {
          ctx.logger.info("", msg.peerUid);
          const uin = +msg.peerUin || +await ctx.ntUserApi.getUinByUid(msg.peerUid);
          return new OB11FriendAddNoticeEvent(uin);
        }
      } else if (element.arkElement) {
        const data = JSON.parse(element.arkElement.bytesData);
        if (data.app === "com.tencent.qun.invite" || data.app === "com.tencent.tuwen.lua" && data.bizsrc === "qun.invite") {
          const params = new URLSearchParams(data.meta.news.jumpUrl);
          const receiverUin = params.get("receiveruin");
          const senderUin = params.get("senderuin");
          if (receiverUin !== selfInfo.uin || senderUin !== msg.senderUin) {
            return;
          }
          ctx.logger.info("", JSON.stringify(data));
          const groupCode = params.get("groupcode");
          const seq = params.get("msgseq");
          const flag = `${groupCode}|${seq}|1|0`;
          return new OB11GroupRequestInviteBotEvent(
            Number(groupCode),
            Number(senderUin),
            flag,
            data.meta.news.desc
          );
        }
      }
    }
  }
  OB11Entities2.privateEvent = privateEvent;
  async function groupEvent(ctx, msg) {
    if (msg.chatType !== ChatType.Group) {
      return;
    }
    if (msg.msgType !== 5 && msg.msgType !== 3) {
      return;
    }
    for (const element of msg.elements) {
      if (element.fileElement) {
        return new OB11GroupUploadNoticeEvent(+msg.peerUid, +msg.senderUin, {
          id: element.fileElement.fileUuid,
          name: element.fileElement.fileName,
          size: parseInt(element.fileElement.fileSize),
          busid: element.fileElement.fileBizId || 0
        });
      } else if (element.grayTipElement) {
        const grayTipElement = element.grayTipElement;
        if (grayTipElement.subElementType === GrayTipElementSubType.JSON) {
          const json2 = JSON.parse(grayTipElement.jsonGrayTipElement.jsonStr);
          if (grayTipElement.jsonGrayTipElement?.busiId === "1061") {
            const param = grayTipElement.jsonGrayTipElement.xmlToJsonParam;
            return new OB11GroupPokeEvent(
              Number(msg.peerUid),
              Number(param.templParam.get("uin_str1")),
              Number(param.templParam.get("uin_str2")),
              json2.items
            );
          } else if (grayTipElement.jsonGrayTipElement?.busiId === JsonGrayTipBusId.GroupMemberTitleChanged) {
            ctx.logger.info("", json2);
            const memberUin = json2.items[1].param[0];
            const title = json2.items[3].txt;
            return new OB11GroupTitleEvent(parseInt(msg.peerUid), parseInt(memberUin), title);
          } else if (grayTipElement.jsonGrayTipElement?.busiId === JsonGrayTipBusId.GroupNewMemberInvited) {
            ctx.logger.info("", grayTipElement);
            const userId = new URL(json2.items[2].jp).searchParams.get("robot_uin");
            const operatorId = new URL(json2.items[0].jp).searchParams.get("uin");
            return new OB11GroupIncreaseEvent(Number(msg.peerUid), Number(userId), Number(operatorId), "invite");
          }
        } else if (grayTipElement.subElementType === GrayTipElementSubType.Group) {
          const groupElement = grayTipElement.groupElement;
          if (groupElement.type === TipGroupElementType.ShutUp) {
            ctx.logger.info("", groupElement);
            return await GroupBanEvent.parse(ctx, groupElement, msg.peerUid);
          } else if (groupElement.type === TipGroupElementType.Quitted) {
            ctx.logger.info(`, ${msg.peerUid}`, groupElement);
            const { adminUid } = groupElement;
            return new OB11GroupDecreaseEvent(
              Number(msg.peerUid),
              Number(selfInfo.uin),
              adminUid ? Number(await ctx.ntUserApi.getUinByUid(adminUid)) : 0,
              adminUid ? "kick_me" : "leave"
            );
          } else if (groupElement.type === TipGroupElementType.MemberAdd) {
            const { memberUid, adminUid } = groupElement;
            if (memberUid !== selfInfo.uid) return;
            ctx.logger.info("", groupElement);
            const adminUin = adminUid ? await ctx.ntUserApi.getUinByUid(adminUid) : selfInfo.uin;
            return new OB11GroupIncreaseEvent(+msg.peerUid, +selfInfo.uin, +adminUin);
          }
        } else if (grayTipElement.subElementType === GrayTipElementSubType.XmlMsg) {
          const xmlElement = grayTipElement.xmlElement;
          if (xmlElement.templId === "10179" || xmlElement.templId === "10180") {
            ctx.logger.info("", xmlElement);
            const invitor = xmlElement.templParam.get("invitor");
            const invitee = xmlElement.templParam.get("invitee");
            if (invitor && invitee) {
              return new OB11GroupIncreaseEvent(+msg.peerUid, +invitee, +invitor, "invite");
            }
          } else if (xmlElement.templId === "10485") {
            ctx.logger.info("", xmlElement);
            const invitor = xmlElement.templParam.get("invitor");
            const invitees = xmlElement.templParam.get("invitees_dynamic")?.matchAll(/jp="([^"]+)"/g);
            if (invitor && invitees) {
              return invitees.map((e) => new OB11GroupIncreaseEvent(+msg.peerUid, +e[1], +invitor, "invite")).toArray();
            }
          }
        }
      }
    }
  }
  OB11Entities2.groupEvent = groupEvent;
  async function recallEvent(ctx, msg, shortId) {
    const revokeElement = msg.elements[0].grayTipElement?.revokeElement;
    if (msg.chatType === ChatType.Group) {
      const operator = await ctx.ntGroupApi.getGroupMember(msg.peerUid, revokeElement.operatorUid);
      let uin = msg.senderUin;
      if (uin === "0" || !uin) {
        uin = await ctx.ntUserApi.getUinByUid(revokeElement.origMsgSenderUid);
      }
      return new OB11GroupRecallNoticeEvent(
        parseInt(msg.peerUid),
        parseInt(uin),
        parseInt(operator.uin || msg.senderUin),
        shortId
      );
    } else {
      return new OB11FriendRecallNoticeEvent(parseInt(msg.senderUin), shortId);
    }
  }
  OB11Entities2.recallEvent = recallEvent;
  function friend(raw) {
    return {
      user_id: parseInt(raw.coreInfo.uin),
      nickname: raw.coreInfo.nick,
      remark: raw.coreInfo.remark || raw.coreInfo.nick,
      sex: sex(raw.baseInfo.sex),
      birthday_year: raw.baseInfo.birthday_year,
      birthday_month: raw.baseInfo.birthday_month,
      birthday_day: raw.baseInfo.birthday_day,
      age: raw.baseInfo.age,
      qid: raw.baseInfo.qid,
      long_nick: raw.baseInfo.longNick
    };
  }
  OB11Entities2.friend = friend;
  function friends(raw) {
    return raw.map(friend);
  }
  OB11Entities2.friends = friends;
  function groupMemberRole(role) {
    return {
      4: OB11GroupMemberRole.Owner,
      3: OB11GroupMemberRole.Admin,
      2: OB11GroupMemberRole.Member
    }[role] ?? OB11GroupMemberRole.Member;
  }
  OB11Entities2.groupMemberRole = groupMemberRole;
  function sex(sex2) {
    const sexMap = {
      [Sex.Unknown]: OB11UserSex.Unknown,
      [Sex.Male]: OB11UserSex.Male,
      [Sex.Female]: OB11UserSex.Female,
      [Sex.Hidden]: OB11UserSex.Unknown
    };
    return sexMap[sex2] ?? OB11UserSex.Unknown;
  }
  OB11Entities2.sex = sex;
  function groupMember(groupId, member) {
    return {
      group_id: groupId,
      user_id: parseInt(member.uin),
      nickname: member.nick,
      card: member.cardName || "",
      card_or_nickname: member.cardName || member.nick,
      sex: OB11UserSex.Unknown,
      age: 0,
      area: "",
      level: String(member.memberRealLevel ?? 0),
      qq_level: 0,
      join_time: member.joinTime,
      last_sent_time: member.lastSpeakTime,
      title_expire_time: 0,
      unfriendly: false,
      card_changeable: true,
      is_robot: member.isRobot,
      shut_up_timestamp: member.shutUpTime,
      role: groupMemberRole(member.role),
      title: member.memberSpecialTitle
    };
  }
  OB11Entities2.groupMember = groupMember;
  function group(group2) {
    return {
      group_id: parseInt(group2.groupCode),
      group_name: group2.groupName,
      group_memo: "",
      group_create_time: +group2.createTime,
      member_count: group2.memberCount,
      max_member_count: group2.maxMember,
      remark_name: group2.remarkName
    };
  }
  OB11Entities2.group = group;
  function groups(groups2) {
    return groups2.map(group);
  }
  OB11Entities2.groups = groups;
})(OB11Entities || (OB11Entities = {}));
class OB11FriendRequestEvent extends OB11BaseNoticeEvent {
  post_type = EventType.REQUEST;
  user_id;
  request_type;
  comment;
  flag;
  constructor(userId, comment, flag, requestType = "friend") {
    super();
    this.user_id = userId;
    this.comment = comment;
    this.flag = flag;
    this.request_type = requestType;
  }
}
class OB11Response {
  static res(data, status, retcode, message = "") {
    return {
      status,
      retcode,
      data,
      message,
      wording: message,
      echo: void 0
    };
  }
  static ok(data, echo) {
    const res = OB11Response.res(data, "ok", 0);
    if (!isNullable(echo)) {
      res.echo = echo;
    }
    return res;
  }
  static error(err, retcode, echo) {
    const res = OB11Response.res(null, "failed", retcode, err);
    if (!isNullable(echo)) {
      res.echo = echo;
    }
    return res;
  }
}
class OB11BaseMetaEvent extends OB11BaseEvent {
  post_type = EventType.META;
}
var LifeCycleSubType = /* @__PURE__ */ ((LifeCycleSubType2) => {
  LifeCycleSubType2["ENABLE"] = "enable";
  LifeCycleSubType2["DISABLE"] = "disable";
  LifeCycleSubType2["CONNECT"] = "connect";
  return LifeCycleSubType2;
})(LifeCycleSubType || {});
class OB11LifeCycleEvent extends OB11BaseMetaEvent {
  meta_event_type = "lifecycle";
  sub_type;
  constructor(subType) {
    super();
    this.sub_type = subType;
  }
}
class OB11HeartbeatEvent extends OB11BaseMetaEvent {
  meta_event_type = "heartbeat";
  status;
  interval;
  constructor(isOnline, isGood, interval) {
    super();
    this.interval = interval;
    this.status = {
      online: isOnline,
      good: isGood
    };
  }
}
const version$2 = "7.4.0";
class OB11WebSocket {
  constructor(ctx, config2) {
    this.ctx = ctx;
    this.config = config2;
  }
  wsServer;
  wsClients = [];
  activated = false;
  start() {
    if (this.wsServer || !this.config.enable) {
      return;
    }
    const host = this.config.onlyLocalhost ? "127.0.0.1" : "";
    this.ctx.logger.info(`OneBot V11 WebSocket server started ${host}:${this.config.port}`);
    this.wsServer = new WebSocketServer({
      host,
      port: this.config.port,
      maxPayload: 1024 * 1024 * 1024
    });
    this.wsServer.on("error", (err) => {
      this.ctx.logger.error("OneBot V11  WS ", err);
    });
    this.wsServer?.on("connection", (socket, req) => {
      this.authorize(socket, req);
      this.connect(socket, req);
    });
    this.activated = true;
  }
  stop() {
    return new Promise((resolve2) => {
      this.ctx.logger.info("OneBot V11 WebSocket Server closing...");
      this.wsClients.forEach(({ socket }) => {
        try {
          socket.close();
        } catch (e) {
          this.ctx.logger.error(" OneBot V11 WebSocket ", e);
        }
      });
      this.wsClients = [];
      if (this.wsServer) {
        this.wsServer.close((err) => {
          if (err) {
            this.ctx.logger.error(`OneBot V11 WebSocket Server closing ${err}`);
            return resolve2(false);
          }
          this.ctx.logger.info("OneBot V11 WebSocket Server closed");
          resolve2(true);
        });
        this.wsServer = void 0;
      } else {
        resolve2(true);
      }
      this.activated = false;
    });
  }
  async emitEvent(event) {
    if (!this.activated) return;
    this.wsClients.forEach(({ socket, emitEvent }) => {
      if (emitEvent && socket.readyState === WebSocket$2.OPEN) {
        socket.send(JSON.stringify(event));
        const eventName = event.getSummaryEventName();
        this.ctx.logger.info("WebSocket ", socket.url ?? "", eventName);
      }
    });
  }
  async emitMessageLikeEvent(event, self2, offline) {
    if (self2 && !this.config.reportSelfMessage) {
      return;
    }
    if (offline && !this.config.reportOfflineMessage) {
      return;
    }
    if (event.post_type === "message" || event.post_type === "message_sent") {
      const msg = event;
      if (!this.config.debug && msg.message.length === 0) {
        return;
      }
      if (!this.config.debug) {
        delete msg.raw;
      }
      if (this.config.messageFormat === "string") {
        msg.message = msg.raw_message;
        msg.message_format = "string";
      }
    }
    await this.emitEvent(event);
  }
  updateConfig(config2) {
    Object.assign(this.config, config2);
  }
  reply(socket, data) {
    if (socket.readyState !== WebSocket$2.OPEN) {
      return;
    }
    socket.send(JSON.stringify(data));
    if ("post_type" in data) {
      this.ctx.logger.info("WebSocket ", socket.url ?? "", data.post_type);
    }
  }
  authorize(socket, req) {
    const url2 = req.url?.split("?").shift();
    this.ctx.logger.info("ws connect", url2);
    let clientToken = "";
    const authHeader = req.headers["authorization"];
    if (authHeader) {
      clientToken = authHeader.split("Bearer ").pop();
      this.ctx.logger.info("receive ws header token", clientToken);
    } else {
      const { searchParams } = new URL(`http://localhost${req.url}`);
      const urlToken = searchParams.get("access_token");
      if (urlToken) {
        if (Array.isArray(urlToken)) {
          clientToken = urlToken[0];
        } else {
          clientToken = urlToken;
        }
        this.ctx.logger.info("receive ws url token", clientToken);
      }
    }
    if (this.config.token && clientToken !== this.config.token) {
      this.reply(socket, OB11Response.res(null, "failed", 1403, "token"));
      return socket.close();
    }
  }
  async handleAction(socket, data) {
    let receive = { action: null, params: {} };
    try {
      receive = JSON.parse(data.toString());
      this.ctx.logger.info(" Websocket ", receive);
    } catch (e) {
      return this.reply(socket, OB11Response.error(`JSON : ${e.message}`, 1400));
    }
    const action = this.config.actionMap.get(receive.action);
    if (!action) {
      return this.reply(socket, OB11Response.error(`${receive.action} API `, 1404, receive.echo));
    }
    const handleResult = await action.websocketHandle(receive.params, receive.echo, {
      messageFormat: this.config.messageFormat,
      debug: this.config.debug
    });
    this.reply(socket, handleResult);
  }
  connect(socket, req) {
    const url2 = req.url?.split("?").shift();
    if (["/api", "/api/", "/", void 0].includes(url2)) {
      socket.on("message", (data) => {
        this.handleAction(socket, data);
      });
    }
    if (["/event", "/event/", "/", void 0].includes(url2)) {
      try {
        this.reply(socket, new OB11LifeCycleEvent(LifeCycleSubType.CONNECT));
      } catch (e) {
        this.ctx.logger.error("", e);
      }
      const disposeHeartBeat = this.ctx.setInterval(() => {
        this.reply(socket, new OB11HeartbeatEvent(selfInfo.online, true, this.config.heartInterval));
      }, this.config.heartInterval);
      socket.on("close", () => {
        disposeHeartBeat();
        this.ctx.logger.info(" Websocket ");
      });
    }
    socket.on("error", (err) => this.ctx.logger.error(err.message));
    socket.on("ping", () => {
      socket.pong();
    });
    this.wsClients.push({
      socket,
      emitEvent: ["/event", "/event/", "/", void 0].includes(url2)
    });
  }
}
class OB11WebSocketReverse {
  constructor(ctx, config2) {
    this.ctx = ctx;
    this.config = config2;
  }
  activated = false;
  wsClient;
  start() {
    if (!this.config.enable) {
      return;
    }
    if (!this.activated) {
      this.activated = true;
      this.tryConnect();
    }
  }
  stop() {
    this.activated = false;
    this.wsClient?.close();
  }
  async emitEvent(event) {
    if (!this.activated) return;
    if (this.wsClient && this.wsClient.readyState === WebSocket$2.OPEN) {
      this.wsClient.send(JSON.stringify(event));
      const eventName = event.getSummaryEventName();
      this.ctx.logger.info("WebSocket ", this.wsClient.url ?? "", eventName);
    }
  }
  async emitMessageLikeEvent(event, self2, offline) {
    if (self2 && !this.config.reportSelfMessage) {
      return;
    }
    if (offline && !this.config.reportOfflineMessage) {
      return;
    }
    if (event.post_type === "message" || event.post_type === "message_sent") {
      const msg = event;
      if (!this.config.debug && msg.message.length === 0) {
        return;
      }
      if (!this.config.debug) {
        delete msg.raw;
      }
      if (this.config.messageFormat === "string") {
        msg.message = msg.raw_message;
        msg.message_format = "string";
      }
    }
    await this.emitEvent(event);
  }
  updateConfig(config2) {
    Object.assign(this.config, config2);
  }
  reply(socket, data) {
    if (socket.readyState !== WebSocket$2.OPEN) {
      return;
    }
    socket.send(JSON.stringify(data));
    if ("post_type" in data) {
      this.ctx.logger.info("WebSocket ", socket.url ?? "", data.post_type);
    }
  }
  async handleAction(data) {
    let receive = { action: null, params: {} };
    try {
      receive = JSON.parse(data.toString());
      this.ctx.logger.info(" Websocket ", receive);
    } catch (e) {
      return this.reply(this.wsClient, OB11Response.error(`JSON : ${e.message}`, 1400, receive.echo));
    }
    const action = this.config.actionMap.get(receive.action);
    if (!action) {
      return this.reply(this.wsClient, OB11Response.error(`${receive.action} API `, 1404, receive.echo));
    }
    const handleResult = await action.websocketHandle(receive.params, receive.echo, {
      messageFormat: this.config.messageFormat,
      debug: this.config.debug
    });
    this.reply(this.wsClient, handleResult);
  }
  tryConnect() {
    if (this.wsClient && !this.activated) {
      return;
    }
    this.wsClient = new WebSocket$2(this.config.url, {
      maxPayload: 1024 * 1024 * 1024,
      handshakeTimeout: 2e3,
      perMessageDeflate: false,
      headers: {
        "X-Self-ID": selfInfo.uin,
        "Authorization": `Bearer ${this.config.token}`,
        "x-client-role": "Universal",
        // koishi-adapter-onebot 
        "User-Agent": `LLOneBot/${version$2}`
      }
    });
    this.ctx.logger.info("Trying to connect to the websocket server: " + this.config.url);
    this.wsClient.on("open", () => {
      this.ctx.logger.info("Connected to the websocket server: " + this.config.url);
      try {
        this.reply(this.wsClient, new OB11LifeCycleEvent(LifeCycleSubType.CONNECT));
      } catch (e) {
        this.ctx.logger.error("", e);
      }
    });
    this.wsClient.on("error", (err) => this.ctx.logger.error(err));
    this.wsClient.on("message", (data) => {
      this.handleAction(data);
    });
    this.wsClient.on("ping", () => {
      this.wsClient?.pong();
    });
    const disposeHeartBeat = this.ctx.setInterval(() => {
      if (this.wsClient) {
        this.reply(this.wsClient, new OB11HeartbeatEvent(selfInfo.online, true, this.config.heartInterval));
      }
    }, this.config.heartInterval);
    this.wsClient.on("close", (code, reason) => {
      disposeHeartBeat();
      this.ctx.logger.info(`The websocket connection: ${this.config.url} closed, code ${code}${this.activated ? ", trying reconnecting..." : ""}`);
      if (this.activated) {
        this.ctx.setTimeout(() => this.tryConnect(), 3e3);
      }
    });
  }
}
var lib$4 = { exports: {} };
var objectAssign;
var hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign) return objectAssign;
  hasRequiredObjectAssign = 1;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i = 0; i < 10; i++) {
        test2["_" + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  objectAssign = shouldUseNative() ? Object.assign : function(target, source2) {
    var from2;
    var to = toObject(target);
    var symbols2;
    for (var s = 1; s < arguments.length; s++) {
      from2 = Object(arguments[s]);
      for (var key2 in from2) {
        if (hasOwnProperty.call(from2, key2)) {
          to[key2] = from2[key2];
        }
      }
      if (getOwnPropertySymbols) {
        symbols2 = getOwnPropertySymbols(from2);
        for (var i = 0; i < symbols2.length; i++) {
          if (propIsEnumerable.call(from2, symbols2[i])) {
            to[symbols2[i]] = from2[symbols2[i]];
          }
        }
      }
    }
    return to;
  };
  return objectAssign;
}
var vary = { exports: {} };
var hasRequiredVary;
function requireVary() {
  if (hasRequiredVary) return vary.exports;
  hasRequiredVary = 1;
  vary.exports = vary$1;
  vary.exports.append = append;
  var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
  function append(header, field) {
    if (typeof header !== "string") {
      throw new TypeError("header argument is required");
    }
    if (!field) {
      throw new TypeError("field argument is required");
    }
    var fields = !Array.isArray(field) ? parse3(String(field)) : field;
    for (var j = 0; j < fields.length; j++) {
      if (!FIELD_NAME_REGEXP.test(fields[j])) {
        throw new TypeError("field argument contains an invalid header name");
      }
    }
    if (header === "*") {
      return header;
    }
    var val = header;
    var vals = parse3(header.toLowerCase());
    if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
      return "*";
    }
    for (var i = 0; i < fields.length; i++) {
      var fld = fields[i].toLowerCase();
      if (vals.indexOf(fld) === -1) {
        vals.push(fld);
        val = val ? val + ", " + fields[i] : fields[i];
      }
    }
    return val;
  }
  function parse3(header) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = header.length; i < len; i++) {
      switch (header.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          list.push(header.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    list.push(header.substring(start, end));
    return list;
  }
  function vary$1(res, field) {
    if (!res || !res.getHeader || !res.setHeader) {
      throw new TypeError("res argument is required");
    }
    var val = res.getHeader("Vary") || "";
    var header = Array.isArray(val) ? val.join(", ") : String(val);
    if (val = append(header, field)) {
      res.setHeader("Vary", val);
    }
  }
  return vary.exports;
}
var hasRequiredLib$4;
function requireLib$4() {
  if (hasRequiredLib$4) return lib$4.exports;
  hasRequiredLib$4 = 1;
  (function() {
    var assign = requireObjectAssign();
    var vary2 = requireVary();
    var defaults = {
      origin: "*",
      methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
      preflightContinue: false,
      optionsSuccessStatus: 204
    };
    function isString(s) {
      return typeof s === "string" || s instanceof String;
    }
    function isOriginAllowed(origin, allowedOrigin) {
      if (Array.isArray(allowedOrigin)) {
        for (var i = 0; i < allowedOrigin.length; ++i) {
          if (isOriginAllowed(origin, allowedOrigin[i])) {
            return true;
          }
        }
        return false;
      } else if (isString(allowedOrigin)) {
        return origin === allowedOrigin;
      } else if (allowedOrigin instanceof RegExp) {
        return allowedOrigin.test(origin);
      } else {
        return !!allowedOrigin;
      }
    }
    function configureOrigin(options, req) {
      var requestOrigin = req.headers.origin, headers = [], isAllowed;
      if (!options.origin || options.origin === "*") {
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: "*"
        }]);
      } else if (isString(options.origin)) {
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: options.origin
        }]);
        headers.push([{
          key: "Vary",
          value: "Origin"
        }]);
      } else {
        isAllowed = isOriginAllowed(requestOrigin, options.origin);
        headers.push([{
          key: "Access-Control-Allow-Origin",
          value: isAllowed ? requestOrigin : false
        }]);
        headers.push([{
          key: "Vary",
          value: "Origin"
        }]);
      }
      return headers;
    }
    function configureMethods(options) {
      var methods2 = options.methods;
      if (methods2.join) {
        methods2 = options.methods.join(",");
      }
      return {
        key: "Access-Control-Allow-Methods",
        value: methods2
      };
    }
    function configureCredentials(options) {
      if (options.credentials === true) {
        return {
          key: "Access-Control-Allow-Credentials",
          value: "true"
        };
      }
      return null;
    }
    function configureAllowedHeaders(options, req) {
      var allowedHeaders = options.allowedHeaders || options.headers;
      var headers = [];
      if (!allowedHeaders) {
        allowedHeaders = req.headers["access-control-request-headers"];
        headers.push([{
          key: "Vary",
          value: "Access-Control-Request-Headers"
        }]);
      } else if (allowedHeaders.join) {
        allowedHeaders = allowedHeaders.join(",");
      }
      if (allowedHeaders && allowedHeaders.length) {
        headers.push([{
          key: "Access-Control-Allow-Headers",
          value: allowedHeaders
        }]);
      }
      return headers;
    }
    function configureExposedHeaders(options) {
      var headers = options.exposedHeaders;
      if (!headers) {
        return null;
      } else if (headers.join) {
        headers = headers.join(",");
      }
      if (headers && headers.length) {
        return {
          key: "Access-Control-Expose-Headers",
          value: headers
        };
      }
      return null;
    }
    function configureMaxAge(options) {
      var maxAge = (typeof options.maxAge === "number" || options.maxAge) && options.maxAge.toString();
      if (maxAge && maxAge.length) {
        return {
          key: "Access-Control-Max-Age",
          value: maxAge
        };
      }
      return null;
    }
    function applyHeaders(headers, res) {
      for (var i = 0, n = headers.length; i < n; i++) {
        var header = headers[i];
        if (header) {
          if (Array.isArray(header)) {
            applyHeaders(header, res);
          } else if (header.key === "Vary" && header.value) {
            vary2(res, header.value);
          } else if (header.value) {
            res.setHeader(header.key, header.value);
          }
        }
      }
    }
    function cors2(options, req, res, next) {
      var headers = [], method = req.method && req.method.toUpperCase && req.method.toUpperCase();
      if (method === "OPTIONS") {
        headers.push(configureOrigin(options, req));
        headers.push(configureCredentials(options));
        headers.push(configureMethods(options));
        headers.push(configureAllowedHeaders(options, req));
        headers.push(configureMaxAge(options));
        headers.push(configureExposedHeaders(options));
        applyHeaders(headers, res);
        if (options.preflightContinue) {
          next();
        } else {
          res.statusCode = options.optionsSuccessStatus;
          res.setHeader("Content-Length", "0");
          res.end();
        }
      } else {
        headers.push(configureOrigin(options, req));
        headers.push(configureCredentials(options));
        headers.push(configureExposedHeaders(options));
        applyHeaders(headers, res);
        next();
      }
    }
    function middlewareWrapper(o) {
      var optionsCallback = null;
      if (typeof o === "function") {
        optionsCallback = o;
      } else {
        optionsCallback = function(req, cb) {
          cb(null, o);
        };
      }
      return function corsMiddleware(req, res, next) {
        optionsCallback(req, function(err, options) {
          if (err) {
            next(err);
          } else {
            var corsOptions = assign({}, defaults, options);
            var originCallback = null;
            if (corsOptions.origin && typeof corsOptions.origin === "function") {
              originCallback = corsOptions.origin;
            } else if (corsOptions.origin) {
              originCallback = function(origin, cb) {
                cb(null, corsOptions.origin);
              };
            }
            if (originCallback) {
              originCallback(req.headers.origin, function(err2, origin) {
                if (err2 || !origin) {
                  next(err2);
                } else {
                  corsOptions.origin = origin;
                  cors2(corsOptions, req, res, next);
                }
              });
            } else {
              next();
            }
          }
        });
      };
    }
    lib$4.exports = middlewareWrapper;
  })();
  return lib$4.exports;
}
var libExports$1 = requireLib$4();
const cors = /* @__PURE__ */ getDefaultExportFromCjs(libExports$1);
var express$2 = { exports: {} };
var bodyParser = { exports: {} };
var httpErrors = { exports: {} };
var browser$1;
var hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$1;
  hasRequiredBrowser$1 = 1;
  browser$1 = depd;
  function depd(namespace) {
    if (!namespace) {
      throw new TypeError("argument namespace is required");
    }
    function deprecate(message) {
    }
    deprecate._file = void 0;
    deprecate._ignored = true;
    deprecate._namespace = namespace;
    deprecate._traced = false;
    deprecate._warned = /* @__PURE__ */ Object.create(null);
    deprecate.function = wrapfunction;
    deprecate.property = wrapproperty;
    return deprecate;
  }
  function wrapfunction(fn, message) {
    if (typeof fn !== "function") {
      throw new TypeError("argument fn must be a function");
    }
    return fn;
  }
  function wrapproperty(obj, prop, message) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new TypeError("argument obj must be object");
    }
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    if (!descriptor) {
      throw new TypeError("must call property on owner object");
    }
    if (!descriptor.configurable) {
      throw new TypeError("property must be configurable");
    }
  }
  return browser$1;
}
var setprototypeof;
var hasRequiredSetprototypeof;
function requireSetprototypeof() {
  if (hasRequiredSetprototypeof) return setprototypeof;
  hasRequiredSetprototypeof = 1;
  setprototypeof = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
  function setProtoOf(obj, proto) {
    obj.__proto__ = proto;
    return obj;
  }
  function mixinProperties(obj, proto) {
    for (var prop in proto) {
      if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
        obj[prop] = proto[prop];
      }
    }
    return obj;
  }
  return setprototypeof;
}
const require$$0$3 = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a Teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Too Early",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
var statuses;
var hasRequiredStatuses;
function requireStatuses() {
  if (hasRequiredStatuses) return statuses;
  hasRequiredStatuses = 1;
  var codes = require$$0$3;
  statuses = status;
  status.message = codes;
  status.code = createMessageToStatusCodeMap(codes);
  status.codes = createStatusCodeList(codes);
  status.redirect = {
    300: true,
    301: true,
    302: true,
    303: true,
    305: true,
    307: true,
    308: true
  };
  status.empty = {
    204: true,
    205: true,
    304: true
  };
  status.retry = {
    502: true,
    503: true,
    504: true
  };
  function createMessageToStatusCodeMap(codes2) {
    var map2 = {};
    Object.keys(codes2).forEach(function forEachCode(code) {
      var message = codes2[code];
      var status2 = Number(code);
      map2[message.toLowerCase()] = status2;
    });
    return map2;
  }
  function createStatusCodeList(codes2) {
    return Object.keys(codes2).map(function mapCode(code) {
      return Number(code);
    });
  }
  function getStatusCode(message) {
    var msg = message.toLowerCase();
    if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
      throw new Error('invalid status message: "' + message + '"');
    }
    return status.code[msg];
  }
  function getStatusMessage(code) {
    if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
      throw new Error("invalid status code: " + code);
    }
    return status.message[code];
  }
  function status(code) {
    if (typeof code === "number") {
      return getStatusMessage(code);
    }
    if (typeof code !== "string") {
      throw new TypeError("code must be a number or string");
    }
    var n = parseInt(code, 10);
    if (!isNaN(n)) {
      return getStatusMessage(n);
    }
    return getStatusCode(code);
  }
  return statuses;
}
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
var toidentifier;
var hasRequiredToidentifier;
function requireToidentifier() {
  if (hasRequiredToidentifier) return toidentifier;
  hasRequiredToidentifier = 1;
  toidentifier = toIdentifier;
  function toIdentifier(str) {
    return str.split(" ").map(function(token2) {
      return token2.slice(0, 1).toUpperCase() + token2.slice(1);
    }).join("").replace(/[^ _0-9a-z]/gi, "");
  }
  return toidentifier;
}
var hasRequiredHttpErrors;
function requireHttpErrors() {
  if (hasRequiredHttpErrors) return httpErrors.exports;
  hasRequiredHttpErrors = 1;
  (function(module) {
    var deprecate = requireBrowser$1()("http-errors");
    var setPrototypeOf = requireSetprototypeof();
    var statuses2 = requireStatuses();
    var inherits = requireInherits_browser();
    var toIdentifier = requireToidentifier();
    module.exports = createError;
    module.exports.HttpError = createHttpErrorConstructor();
    module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
    populateConstructorExports(module.exports, statuses2.codes, module.exports.HttpError);
    function codeClass(status) {
      return Number(String(status).charAt(0) + "00");
    }
    function createError() {
      var err;
      var msg;
      var status = 500;
      var props = {};
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        var type2 = typeof arg;
        if (type2 === "object" && arg instanceof Error) {
          err = arg;
          status = err.status || err.statusCode || status;
        } else if (type2 === "number" && i === 0) {
          status = arg;
        } else if (type2 === "string") {
          msg = arg;
        } else if (type2 === "object") {
          props = arg;
        } else {
          throw new TypeError("argument #" + (i + 1) + " unsupported type " + type2);
        }
      }
      if (typeof status === "number" && (status < 400 || status >= 600)) {
        deprecate("non-error status code; use only 4xx or 5xx status codes");
      }
      if (typeof status !== "number" || !statuses2.message[status] && (status < 400 || status >= 600)) {
        status = 500;
      }
      var HttpError = createError[status] || createError[codeClass(status)];
      if (!err) {
        err = HttpError ? new HttpError(msg) : new Error(msg || statuses2.message[status]);
        Error.captureStackTrace(err, createError);
      }
      if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
        err.expose = status < 500;
        err.status = err.statusCode = status;
      }
      for (var key2 in props) {
        if (key2 !== "status" && key2 !== "statusCode") {
          err[key2] = props[key2];
        }
      }
      return err;
    }
    function createHttpErrorConstructor() {
      function HttpError() {
        throw new TypeError("cannot construct abstract class");
      }
      inherits(HttpError, Error);
      return HttpError;
    }
    function createClientErrorConstructor(HttpError, name, code) {
      var className = toClassName(name);
      function ClientError(message) {
        var msg = message != null ? message : statuses2.message[code];
        var err = new Error(msg);
        Error.captureStackTrace(err, ClientError);
        setPrototypeOf(err, ClientError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits(ClientError, HttpError);
      nameFunc(ClientError, className);
      ClientError.prototype.status = code;
      ClientError.prototype.statusCode = code;
      ClientError.prototype.expose = true;
      return ClientError;
    }
    function createIsHttpErrorFunction(HttpError) {
      return function isHttpError(val) {
        if (!val || typeof val !== "object") {
          return false;
        }
        if (val instanceof HttpError) {
          return true;
        }
        return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
      };
    }
    function createServerErrorConstructor(HttpError, name, code) {
      var className = toClassName(name);
      function ServerError(message) {
        var msg = message != null ? message : statuses2.message[code];
        var err = new Error(msg);
        Error.captureStackTrace(err, ServerError);
        setPrototypeOf(err, ServerError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits(ServerError, HttpError);
      nameFunc(ServerError, className);
      ServerError.prototype.status = code;
      ServerError.prototype.statusCode = code;
      ServerError.prototype.expose = false;
      return ServerError;
    }
    function nameFunc(func, name) {
      var desc = Object.getOwnPropertyDescriptor(func, "name");
      if (desc && desc.configurable) {
        desc.value = name;
        Object.defineProperty(func, "name", desc);
      }
    }
    function populateConstructorExports(exports$1, codes, HttpError) {
      codes.forEach(function forEachCode(code) {
        var CodeError;
        var name = toIdentifier(statuses2.message[code]);
        switch (codeClass(code)) {
          case 400:
            CodeError = createClientErrorConstructor(HttpError, name, code);
            break;
          case 500:
            CodeError = createServerErrorConstructor(HttpError, name, code);
            break;
        }
        if (CodeError) {
          exports$1[code] = CodeError;
          exports$1[name] = CodeError;
        }
      });
    }
    function toClassName(name) {
      return name.slice(-5) === "Error" ? name : name + "Error";
    }
  })(httpErrors);
  return httpErrors.exports;
}
var bytes = { exports: {} };
var hasRequiredBytes;
function requireBytes() {
  if (hasRequiredBytes) return bytes.exports;
  hasRequiredBytes = 1;
  bytes.exports = bytes$1;
  bytes.exports.format = format;
  bytes.exports.parse = parse3;
  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
  var map2 = {
    b: 1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5)
  };
  var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
  function bytes$1(value, options) {
    if (typeof value === "string") {
      return parse3(value);
    }
    if (typeof value === "number") {
      return format(value, options);
    }
    return null;
  }
  function format(value, options) {
    if (!Number.isFinite(value)) {
      return null;
    }
    var mag = Math.abs(value);
    var thousandsSeparator = options && options.thousandsSeparator || "";
    var unitSeparator = options && options.unitSeparator || "";
    var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
    var fixedDecimals = Boolean(options && options.fixedDecimals);
    var unit = options && options.unit || "";
    if (!unit || !map2[unit.toLowerCase()]) {
      if (mag >= map2.pb) {
        unit = "PB";
      } else if (mag >= map2.tb) {
        unit = "TB";
      } else if (mag >= map2.gb) {
        unit = "GB";
      } else if (mag >= map2.mb) {
        unit = "MB";
      } else if (mag >= map2.kb) {
        unit = "KB";
      } else {
        unit = "B";
      }
    }
    var val = value / map2[unit.toLowerCase()];
    var str = val.toFixed(decimalPlaces);
    if (!fixedDecimals) {
      str = str.replace(formatDecimalsRegExp, "$1");
    }
    if (thousandsSeparator) {
      str = str.split(".").map(function(s, i) {
        return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
      }).join(".");
    }
    return str + unitSeparator + unit;
  }
  function parse3(val) {
    if (typeof val === "number" && !isNaN(val)) {
      return val;
    }
    if (typeof val !== "string") {
      return null;
    }
    var results = parseRegExp.exec(val);
    var floatValue;
    var unit = "b";
    if (!results) {
      floatValue = parseInt(val, 10);
      unit = "b";
    } else {
      floatValue = parseFloat(results[1]);
      unit = results[4].toLowerCase();
    }
    if (isNaN(floatValue)) {
      return null;
    }
    return Math.floor(map2[unit] * floatValue);
  }
  return bytes.exports;
}
var lib$3 = { exports: {} };
var safer_1;
var hasRequiredSafer;
function requireSafer() {
  if (hasRequiredSafer) return safer_1;
  hasRequiredSafer = 1;
  var buffer2 = require$$0$8;
  var Buffer2 = buffer2.Buffer;
  var safer = {};
  var key2;
  for (key2 in buffer2) {
    if (!buffer2.hasOwnProperty(key2)) continue;
    if (key2 === "SlowBuffer" || key2 === "Buffer") continue;
    safer[key2] = buffer2[key2];
  }
  var Safer = safer.Buffer = {};
  for (key2 in Buffer2) {
    if (!Buffer2.hasOwnProperty(key2)) continue;
    if (key2 === "allocUnsafe" || key2 === "allocUnsafeSlow") continue;
    Safer[key2] = Buffer2[key2];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding2) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding2 === "string") {
        buf.fill(fill, encoding2);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {
    }
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  safer_1 = safer;
  return safer_1;
}
var bomHandling = {};
var hasRequiredBomHandling;
function requireBomHandling() {
  if (hasRequiredBomHandling) return bomHandling;
  hasRequiredBomHandling = 1;
  var BOMChar = "\uFEFF";
  bomHandling.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
      str = BOMChar + str;
      this.addBOM = false;
    }
    return this.encoder.write(str);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  bomHandling.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder2, options) {
    this.decoder = decoder2;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res) {
      return res;
    }
    if (res[0] === BOMChar) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === "function") {
        this.options.stripBOM();
      }
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
  return bomHandling;
}
var mergeExports;
var hasRequiredMergeExports;
function requireMergeExports() {
  if (hasRequiredMergeExports) return mergeExports;
  hasRequiredMergeExports = 1;
  var hasOwn = typeof Object.hasOwn === "undefined" ? Function.call.bind(Object.prototype.hasOwnProperty) : Object.hasOwn;
  function mergeModules(target, module) {
    for (var key2 in module) {
      if (hasOwn(module, key2)) {
        target[key2] = module[key2];
      }
    }
  }
  mergeExports = mergeModules;
  return mergeExports;
}
var encodings = {};
var internal;
var hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal) return internal;
  hasRequiredInternal = 1;
  var Buffer2 = requireSafer().Buffer;
  internal = {
    // Encodings
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64") {
      this.encoder = InternalEncoderBase64;
    } else if (this.enc === "utf8") {
      this.encoder = InternalEncoderUtf8;
    } else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = require$$1$3.StringDecoder;
  function InternalDecoder(options, codec2) {
    this.decoder = new StringDecoder(codec2.enc);
  }
  InternalDecoder.prototype.write = function(buf) {
    if (!Buffer2.isBuffer(buf)) {
      buf = Buffer2.from(buf);
    }
    return this.decoder.write(buf);
  };
  InternalDecoder.prototype.end = function() {
    return this.decoder.end();
  };
  function InternalEncoder(options, codec2) {
    this.enc = codec2.enc;
  }
  InternalEncoder.prototype.write = function(str) {
    return Buffer2.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options, codec2) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer2.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec2) {
  }
  InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length * 3);
    var bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
      var charCode = str.charCodeAt(i);
      if (charCode < 128) {
        buf[bufIdx++] = charCode;
      } else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options, codec2) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec2.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc;
    var contBytes = this.contBytes;
    var accBytes = this.accBytes;
    var res = "";
    for (var i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0) {
              res += this.defaultCharUnicode;
            } else if (accBytes === 3 && acc < 2048) {
              res += this.defaultCharUnicode;
            } else {
              res += String.fromCharCode(acc);
            }
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0) {
      res += this.defaultCharUnicode;
    }
    return res;
  };
  function InternalEncoderUtf8(options, codec2) {
    this.highSurrogate = "";
  }
  InternalEncoderUtf8.prototype.write = function(str) {
    if (this.highSurrogate) {
      str = this.highSurrogate + str;
      this.highSurrogate = "";
    }
    if (str.length > 0) {
      var charCode = str.charCodeAt(str.length - 1);
      if (charCode >= 55296 && charCode < 56320) {
        this.highSurrogate = str[str.length - 1];
        str = str.slice(0, str.length - 1);
      }
    }
    return Buffer2.from(str, this.enc);
  };
  InternalEncoderUtf8.prototype.end = function() {
    if (this.highSurrogate) {
      var str = this.highSurrogate;
      this.highSurrogate = "";
      return Buffer2.from(str, this.enc);
    }
  };
  return internal;
}
var utf32 = {};
var hasRequiredUtf32;
function requireUtf32() {
  if (hasRequiredUtf32) return utf32;
  hasRequiredUtf32 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf32._utf32 = Utf32Codec;
  function Utf32Codec(codecOptions, iconv) {
    this.iconv = iconv;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
  }
  utf32.utf32le = { type: "_utf32", isLE: true };
  utf32.utf32be = { type: "_utf32", isLE: false };
  utf32.ucs4le = "utf32le";
  utf32.ucs4be = "utf32be";
  Utf32Codec.prototype.encoder = Utf32Encoder;
  Utf32Codec.prototype.decoder = Utf32Decoder;
  function Utf32Encoder(options, codec2) {
    this.isLE = codec2.isLE;
    this.highSurrogate = 0;
  }
  Utf32Encoder.prototype.write = function(str) {
    var src = Buffer2.from(str, "ucs2");
    var dst = Buffer2.alloc(src.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;
    for (var i = 0; i < src.length; i += 2) {
      var code = src.readUInt16LE(i);
      var isHighSurrogate = code >= 55296 && code < 56320;
      var isLowSurrogate = code >= 56320 && code < 57344;
      if (this.highSurrogate) {
        if (isHighSurrogate || !isLowSurrogate) {
          write32.call(dst, this.highSurrogate, offset);
          offset += 4;
        } else {
          var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
          write32.call(dst, codepoint, offset);
          offset += 4;
          this.highSurrogate = 0;
          continue;
        }
      }
      if (isHighSurrogate) {
        this.highSurrogate = code;
      } else {
        write32.call(dst, code, offset);
        offset += 4;
        this.highSurrogate = 0;
      }
    }
    if (offset < dst.length) {
      dst = dst.slice(0, offset);
    }
    return dst;
  };
  Utf32Encoder.prototype.end = function() {
    if (!this.highSurrogate) {
      return;
    }
    var buf = Buffer2.alloc(4);
    if (this.isLE) {
      buf.writeUInt32LE(this.highSurrogate, 0);
    } else {
      buf.writeUInt32BE(this.highSurrogate, 0);
    }
    this.highSurrogate = 0;
    return buf;
  };
  function Utf32Decoder(options, codec2) {
    this.isLE = codec2.isLE;
    this.badChar = codec2.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = [];
  }
  Utf32Decoder.prototype.write = function(src) {
    if (src.length === 0) {
      return "";
    }
    var i = 0;
    var codepoint = 0;
    var dst = Buffer2.alloc(src.length + 4);
    var offset = 0;
    var isLE = this.isLE;
    var overflow = this.overflow;
    var badChar = this.badChar;
    if (overflow.length > 0) {
      for (; i < src.length && overflow.length < 4; i++) {
        overflow.push(src[i]);
      }
      if (overflow.length === 4) {
        if (isLE) {
          codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
        } else {
          codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
        }
        overflow.length = 0;
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
    }
    for (; i < src.length - 3; i += 4) {
      if (isLE) {
        codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;
      } else {
        codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
      }
      offset = _writeCodepoint(dst, offset, codepoint, badChar);
    }
    for (; i < src.length; i++) {
      overflow.push(src[i]);
    }
    return dst.slice(0, offset).toString("ucs2");
  };
  function _writeCodepoint(dst, offset, codepoint, badChar) {
    if (codepoint < 0 || codepoint > 1114111) {
      codepoint = badChar;
    }
    if (codepoint >= 65536) {
      codepoint -= 65536;
      var high = 55296 | codepoint >> 10;
      dst[offset++] = high & 255;
      dst[offset++] = high >> 8;
      var codepoint = 56320 | codepoint & 1023;
    }
    dst[offset++] = codepoint & 255;
    dst[offset++] = codepoint >> 8;
    return offset;
  }
  Utf32Decoder.prototype.end = function() {
    this.overflow.length = 0;
  };
  utf32.utf32 = Utf32AutoCodec;
  utf32.ucs4 = "utf32";
  function Utf32AutoCodec(options, iconv) {
    this.iconv = iconv;
  }
  Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
  Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
  function Utf32AutoEncoder(options, codec2) {
    options = options || {};
    if (options.addBOM === void 0) {
      options.addBOM = true;
    }
    this.encoder = codec2.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
  }
  Utf32AutoEncoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf32AutoEncoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf32AutoDecoder(options, codec2) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec2.iconv;
  }
  Utf32AutoDecoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 32) {
        return "";
      }
      var encoding2 = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding2, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++) {
        resStr += this.decoder.write(this.initialBufs[i]);
      }
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf32AutoDecoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding2 = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding2, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++) {
        resStr += this.decoder.write(this.initialBufs[i]);
      }
      var trail = this.decoder.end();
      if (trail) {
        resStr += trail;
      }
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var invalidLE = 0;
    var invalidBE = 0;
    var bmpCharsLE = 0;
    var bmpCharsBE = 0;
    outerLoop:
      for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 4) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                return "utf-32le";
              }
              if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                return "utf-32be";
              }
            }
            if (b[0] !== 0 || b[1] > 16) invalidBE++;
            if (b[3] !== 0 || b[2] > 16) invalidLE++;
            if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
            if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outerLoop;
            }
          }
        }
      }
    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
    return defaultEncoding || "utf-32le";
  }
  return utf32;
}
var utf16 = {};
var hasRequiredUtf16;
function requireUtf16() {
  if (hasRequiredUtf16) return utf16;
  hasRequiredUtf16 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf16.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer2.from(str, "ucs2");
    for (var i = 0; i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0) {
      return "";
    }
    var buf2 = Buffer2.alloc(buf.length + 1);
    var i = 0;
    var j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (; i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
    this.overflowByte = -1;
  };
  utf16.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec2) {
    options = options || {};
    if (options.addBOM === void 0) {
      options.addBOM = true;
    }
    this.encoder = codec2.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec2) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec2.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 16) {
        return "";
      }
      var encoding2 = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding2, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++) {
        resStr += this.decoder.write(this.initialBufs[i]);
      }
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding2 = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding2, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++) {
        resStr += this.decoder.write(this.initialBufs[i]);
      }
      var trail = this.decoder.end();
      if (trail) {
        resStr += trail;
      }
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var asciiCharsLE = 0;
    var asciiCharsBE = 0;
    outerLoop:
      for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 2) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254) return "utf-16le";
              if (b[0] === 254 && b[1] === 255) return "utf-16be";
            }
            if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
            if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outerLoop;
            }
          }
        }
      }
    if (asciiCharsBE > asciiCharsLE) return "utf-16be";
    if (asciiCharsBE < asciiCharsLE) return "utf-16le";
    return defaultEncoding || "utf-16le";
  }
  return utf16;
}
var utf7 = {};
var hasRequiredUtf7;
function requireUtf7() {
  if (hasRequiredUtf7) return utf7;
  hasRequiredUtf7 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf7.utf7 = Utf7Codec;
  utf7.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec2) {
    this.iconv = codec2.iconv;
  }
  Utf7Encoder.prototype.write = function(str) {
    return Buffer2.from(str.replace(nonDirectChars, function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }.bind(this)));
  };
  Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options, codec2) {
    this.iconv = codec2.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i = 0; i < 256; i++) {
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  }
  var plusChar = "+".charCodeAt(0);
  var minusChar = "-".charCodeAt(0);
  var andChar = "&".charCodeAt(0);
  Utf7Decoder.prototype.write = function(buf) {
    var res = "";
    var lastI = 0;
    var inBase64 = this.inBase64;
    var base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar) {
            i2--;
          }
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0) {
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    }
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  utf7.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec2) {
    this.iconv = codec2.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64;
    var base64Accum = this.base64Accum;
    var base64AccumIdx = this.base64AccumIdx;
    var buf = Buffer2.alloc(str.length * 5 + 10);
    var bufIdx = 0;
    for (var i2 = 0; i2 < str.length; i2++) {
      var uChar = str.charCodeAt(i2);
      if (uChar >= 32 && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar) {
            buf[bufIdx++] = minusChar;
          }
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10);
    var bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec2) {
    this.iconv = codec2.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[",".charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "";
    var lastI = 0;
    var inBase64 = this.inBase64;
    var base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar) {
            i2--;
          }
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0) {
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    }
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  return utf7;
}
var sbcsCodec = {};
var hasRequiredSbcsCodec;
function requireSbcsCodec() {
  if (hasRequiredSbcsCodec) return sbcsCodec;
  hasRequiredSbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  sbcsCodec._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions) {
      throw new Error("SBCS codec is called without the data.");
    }
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) {
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    }
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0; i < 128; i++) {
        asciiString += String.fromCharCode(i);
      }
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0; i < codecOptions.chars.length; i++) {
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    }
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec2) {
    this.encodeBuf = codec2.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length);
    for (var i = 0; i < str.length; i++) {
      buf[i] = this.encodeBuf[str.charCodeAt(i)];
    }
    return buf;
  };
  SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options, codec2) {
    this.decodeBuf = codec2.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0;
    var idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
  return sbcsCodec;
}
var sbcsData;
var hasRequiredSbcsData;
function requireSbcsData() {
  if (hasRequiredSbcsData) return sbcsData;
  hasRequiredSbcsData = 1;
  sbcsData = {
    // Not supported by iconv, not sure why.
    10029: "maccenteuro",
    maccenteuro: {
      type: "_sbcs",
      chars: ""
    },
    808: "cp808",
    ibm808: "cp808",
    cp808: {
      type: "_sbcs",
      chars: ""
    },
    mik: {
      type: "_sbcs",
      chars: ""
    },
    cp720: {
      type: "_sbcs",
      chars: ""
    },
    // Aliases of generated encodings.
    ascii8bit: "ascii",
    usascii: "ascii",
    ansix34: "ascii",
    ansix341968: "ascii",
    ansix341986: "ascii",
    csascii: "ascii",
    cp367: "ascii",
    ibm367: "ascii",
    isoir6: "ascii",
    iso646us: "ascii",
    iso646irv: "ascii",
    us: "ascii",
    latin1: "iso88591",
    latin2: "iso88592",
    latin3: "iso88593",
    latin4: "iso88594",
    latin5: "iso88599",
    latin6: "iso885910",
    latin7: "iso885913",
    latin8: "iso885914",
    latin9: "iso885915",
    latin10: "iso885916",
    csisolatin1: "iso88591",
    csisolatin2: "iso88592",
    csisolatin3: "iso88593",
    csisolatin4: "iso88594",
    csisolatincyrillic: "iso88595",
    csisolatinarabic: "iso88596",
    csisolatingreek: "iso88597",
    csisolatinhebrew: "iso88598",
    csisolatin5: "iso88599",
    csisolatin6: "iso885910",
    l1: "iso88591",
    l2: "iso88592",
    l3: "iso88593",
    l4: "iso88594",
    l5: "iso88599",
    l6: "iso885910",
    l7: "iso885913",
    l8: "iso885914",
    l9: "iso885915",
    l10: "iso885916",
    isoir14: "iso646jp",
    isoir57: "iso646cn",
    isoir100: "iso88591",
    isoir101: "iso88592",
    isoir109: "iso88593",
    isoir110: "iso88594",
    isoir144: "iso88595",
    isoir127: "iso88596",
    isoir126: "iso88597",
    isoir138: "iso88598",
    isoir148: "iso88599",
    isoir157: "iso885910",
    isoir166: "tis620",
    isoir179: "iso885913",
    isoir199: "iso885914",
    isoir203: "iso885915",
    isoir226: "iso885916",
    cp819: "iso88591",
    ibm819: "iso88591",
    cyrillic: "iso88595",
    arabic: "iso88596",
    arabic8: "iso88596",
    ecma114: "iso88596",
    asmo708: "iso88596",
    greek: "iso88597",
    greek8: "iso88597",
    ecma118: "iso88597",
    elot928: "iso88597",
    hebrew: "iso88598",
    hebrew8: "iso88598",
    turkish: "iso88599",
    turkish8: "iso88599",
    thai: "iso885911",
    thai8: "iso885911",
    celtic: "iso885914",
    celtic8: "iso885914",
    isoceltic: "iso885914",
    tis6200: "tis620",
    tis62025291: "tis620",
    tis62025330: "tis620",
    1e4: "macroman",
    10006: "macgreek",
    10007: "maccyrillic",
    10079: "maciceland",
    10081: "macturkish",
    cspc8codepage437: "cp437",
    cspc775baltic: "cp775",
    cspc850multilingual: "cp850",
    cspcp852: "cp852",
    cspc862latinhebrew: "cp862",
    cpgr: "cp869",
    msee: "cp1250",
    mscyrl: "cp1251",
    msansi: "cp1252",
    msgreek: "cp1253",
    msturk: "cp1254",
    mshebr: "cp1255",
    msarab: "cp1256",
    winbaltrim: "cp1257",
    cp20866: "koi8r",
    20866: "koi8r",
    ibm878: "koi8r",
    cskoi8r: "koi8r",
    cp21866: "koi8u",
    21866: "koi8u",
    ibm1168: "koi8u",
    strk10482002: "rk1048",
    tcvn5712: "tcvn",
    tcvn57121: "tcvn",
    gb198880: "iso646cn",
    cn: "iso646cn",
    csiso14jisc6220ro: "iso646jp",
    jisc62201969ro: "iso646jp",
    jp: "iso646jp",
    cshproman8: "hproman8",
    r8: "hproman8",
    roman8: "hproman8",
    xroman8: "hproman8",
    ibm1051: "hproman8",
    mac: "macintosh",
    csmacintosh: "macintosh"
  };
  return sbcsData;
}
var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;
function requireSbcsDataGenerated() {
  if (hasRequiredSbcsDataGenerated) return sbcsDataGenerated;
  hasRequiredSbcsDataGenerated = 1;
  sbcsDataGenerated = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": ""
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": ""
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": ""
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": ""
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": ""
    },
    "macroman": {
      "type": "_sbcs",
      "chars": ""
    },
    "macromania": {
      "type": "_sbcs",
      "chars": ""
    },
    "macthai": {
      "type": "_sbcs",
      "chars": "\uFEFF"
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": ""
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": ""
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": ")(.,-"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": ""
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": ""
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": ""
    },
    "pt154": {
      "type": "_sbcs",
      "chars": ""
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": ""
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": ""
    },
    "ascii": {
      "type": "_sbcs",
      "chars": ""
    },
    "tis620": {
      "type": "_sbcs",
      "chars": ""
    }
  };
  return sbcsDataGenerated;
}
var dbcsCodec = {};
var hasRequiredDbcsCodec;
function requireDbcsCodec() {
  if (hasRequiredDbcsCodec) return dbcsCodec;
  hasRequiredDbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  dbcsCodec._dbcs = DBCSCodec;
  var UNASSIGNED = -1;
  var GB18030_CODE = -2;
  var SEQ_START = -10;
  var NODE_START = -1e3;
  var UNASSIGNED_NODE = new Array(256);
  var DEF_CHAR = -1;
  for (var i = 0; i < 256; i++) {
    UNASSIGNED_NODE[i] = UNASSIGNED;
  }
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions) {
      throw new Error("DBCS codec is called without the data.");
    }
    if (!codecOptions.table) {
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    }
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0; i2 < mappingTable.length; i2++) {
      this._addDecodeChunk(mappingTable[i2]);
    }
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var commonThirdByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var commonFourthByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var firstByteNode = this.decodeTables[0];
      for (var i2 = 129; i2 <= 254; i2++) {
        var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
        for (var j = 48; j <= 57; j++) {
          if (secondByteNode[j] === UNASSIGNED) {
            secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
          } else if (secondByteNode[j] > NODE_START) {
            throw new Error("gb18030 decode tables conflict at byte 2");
          }
          var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
          for (var k = 129; k <= 254; k++) {
            if (thirdByteNode[k] === UNASSIGNED) {
              thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
            } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
              continue;
            } else if (thirdByteNode[k] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 3");
            }
            var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
            for (var l = 48; l <= 57; l++) {
              if (fourthByteNode[l] === UNASSIGNED) {
                fourthByteNode[l] = GB18030_CODE;
              }
            }
          }
        }
      }
    }
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals) {
      for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number") {
          skipEncodeChars[val] = true;
        } else {
          for (var j = val.from; j <= val.to; j++) {
            skipEncodeChars[j] = true;
          }
        }
      }
    }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd) {
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) {
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
        }
      }
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes2 = [];
    for (; addr > 0; addr >>>= 8) {
      bytes2.push(addr & 255);
    }
    if (bytes2.length == 0) {
      bytes2.push(0);
    }
    var node = this.decodeTables[0];
    for (var i2 = bytes2.length - 1; i2 > 0; i2--) {
      var val = node[bytes2[i2]];
      if (val == UNASSIGNED) {
        node[bytes2[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node = this.decodeTables[NODE_START - val];
      } else {
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
      }
    }
    return node;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0; l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (code >= 55296 && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (codeTrail >= 56320 && codeTrail < 57344) {
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            } else {
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
            }
          } else if (code > 4080 && code <= 4095) {
            var len = 4095 - code + 2;
            var seq = [];
            for (var m = 0; m < len; m++) {
              seq.push(part.charCodeAt(l++));
            }
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else {
            writeTable[curAddr++] = code;
          }
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0; l < part; l++) {
          writeTable[curAddr++] = charCode++;
        }
      } else {
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
      }
    }
    if (curAddr > 255) {
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
    }
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === void 0) {
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    }
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START) {
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    } else if (bucket[low] == UNASSIGNED) {
      bucket[low] = dbcsCode;
    }
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node;
    if (bucket[low] <= SEQ_START) {
      node = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node = {};
      if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node);
    }
    for (var j = 1; j < seq.length - 1; j++) {
      var oldVal = node[uCode];
      if (typeof oldVal === "object") {
        node = oldVal;
      } else {
        node = node[uCode] = {};
        if (oldVal !== void 0) {
          node[DEF_CHAR] = oldVal;
        }
      }
    }
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    var hasValues = false;
    var subNodeEmpty = {};
    for (var i2 = 0; i2 < 256; i2++) {
      var uCode = node[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode]) {
        continue;
      }
      if (uCode >= 0) {
        this._setEncodeChar(uCode, mbCode);
        hasValues = true;
      } else if (uCode <= NODE_START) {
        var subNodeIdx = NODE_START - uCode;
        if (!subNodeEmpty[subNodeIdx]) {
          var newPrefix = mbCode << 8 >>> 0;
          if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars)) {
            hasValues = true;
          } else {
            subNodeEmpty[subNodeIdx] = true;
          }
        }
      } else if (uCode <= SEQ_START) {
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        hasValues = true;
      }
    }
    return hasValues;
  };
  function DBCSEncoder(options, codec2) {
    this.leadSurrogate = -1;
    this.seqObj = void 0;
    this.encodeTable = codec2.encodeTable;
    this.encodeTableSeq = codec2.encodeTableSeq;
    this.defaultCharSingleByte = codec2.defCharSB;
    this.gb18030 = codec2.gb18030;
  }
  DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3));
    var leadSurrogate = this.leadSurrogate;
    var seqObj = this.seqObj;
    var nextChar = -1;
    var i2 = 0;
    var j = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str.length) break;
        var uCode = str.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (uCode >= 55296 && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode === "number") {
          dbcsCode = resCode;
        } else if (resCode == void 0) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== void 0) {
            dbcsCode = resCode;
            nextChar = uCode;
          }
        }
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0) {
          dbcsCode = subtable[uCode & 255];
        }
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED) {
        dbcsCode = this.defaultCharSingleByte;
      }
      if (dbcsCode < 256) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 255;
      } else if (dbcsCode < 16777216) {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      } else {
        newBuf[j++] = dbcsCode >>> 24;
        newBuf[j++] = dbcsCode >>> 16 & 255;
        newBuf[j++] = dbcsCode >>> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === void 0) {
      return;
    }
    var newBuf = Buffer2.alloc(10);
    var j = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== void 0) {
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = void 0;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec2) {
    this.nodeIdx = 0;
    this.prevBytes = [];
    this.decodeTables = codec2.decodeTables;
    this.decodeTableSeq = codec2.decodeTableSeq;
    this.defaultCharUnicode = codec2.defaultCharUnicode;
    this.gb18030 = codec2.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2);
    var nodeIdx = this.nodeIdx;
    var prevBytes = this.prevBytes;
    var prevOffset = this.prevBytes.length;
    var seqStart = -this.prevBytes.length;
    var uCode;
    for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) ;
      else if (uCode === UNASSIGNED) {
        uCode = this.defaultCharUnicode.charCodeAt(0);
        i2 = seqStart;
      } else if (uCode === GB18030_CODE) {
        if (i2 >= 3) {
          var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
        } else {
          var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
        }
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0; k < seq.length - 1; k++) {
          uCode = seq[k];
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else {
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      }
      if (uCode >= 65536) {
        uCode -= 65536;
        var uCodeLead = 55296 | uCode >> 10;
        newBuf[j++] = uCodeLead & 255;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 56320 | uCode & 1023;
      }
      newBuf[j++] = uCode & 255;
      newBuf[j++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
    return newBuf.slice(0, j).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBytes.length > 0) {
      ret += this.defaultCharUnicode;
      var bytesArr = this.prevBytes.slice(1);
      this.prevBytes = [];
      this.nodeIdx = 0;
      if (bytesArr.length > 0) {
        ret += this.write(bytesArr);
      }
    }
    this.prevBytes = [];
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val) {
      return -1;
    }
    var l = 0;
    var r = table.length;
    while (l < r - 1) {
      var mid = l + (r - l + 1 >> 1);
      if (table[mid] <= val) {
        l = mid;
      } else {
        r = mid;
      }
    }
    return l;
  }
  return dbcsCodec;
}
const require$$0$2 = [
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "",
    62
  ],
  [
    "8140",
    "",
    9,
    ""
  ],
  [
    "8180",
    ""
  ],
  [
    "81b8",
    ""
  ],
  [
    "81c8",
    ""
  ],
  [
    "81da",
    ""
  ],
  [
    "81f0",
    ""
  ],
  [
    "81fc",
    ""
  ],
  [
    "824f",
    "",
    9
  ],
  [
    "8260",
    "",
    25
  ],
  [
    "8281",
    "",
    25
  ],
  [
    "829f",
    "",
    82
  ],
  [
    "8340",
    "",
    62
  ],
  [
    "8380",
    "",
    22
  ],
  [
    "839f",
    "",
    16,
    "",
    6
  ],
  [
    "83bf",
    "",
    16,
    "",
    6
  ],
  [
    "8440",
    "",
    5,
    "",
    25
  ],
  [
    "8470",
    "",
    5,
    "",
    7
  ],
  [
    "8480",
    "",
    17
  ],
  [
    "849f",
    ""
  ],
  [
    "8740",
    "",
    19,
    "",
    9
  ],
  [
    "875f",
    ""
  ],
  [
    "877e",
    ""
  ],
  [
    "8780",
    "",
    4,
    ""
  ],
  [
    "889f",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8980",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a80",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b80",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8c80",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d80",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8e80",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8f80",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "9080",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "9180",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "9280",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "9380",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "9480",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "9580",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "9680",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "9780",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "989f",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "9980",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9a80",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b80",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9c80",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9d80",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9e80",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f80",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e080",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e180",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e280",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e380",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e480",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e580",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e680",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e780",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e880",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e980",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "ea80",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "ed80",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "ee80",
    ""
  ],
  [
    "eeef",
    "",
    9,
    ""
  ],
  [
    "f040",
    "",
    62
  ],
  [
    "f080",
    "",
    124
  ],
  [
    "f140",
    "",
    62
  ],
  [
    "f180",
    "",
    124
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    124
  ],
  [
    "f340",
    "",
    62
  ],
  [
    "f380",
    "",
    124
  ],
  [
    "f440",
    "",
    62
  ],
  [
    "f480",
    "",
    124
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    124
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    124
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    124
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    124
  ],
  [
    "f940",
    ""
  ],
  [
    "fa40",
    "",
    9,
    "",
    9,
    ""
  ],
  [
    "fa80",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fb80",
    ""
  ],
  [
    "fc40",
    ""
  ]
];
const require$$1 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127],["8ea1","",62],["a1a1","",9,""],["a2a1",""],["a2ba",""],["a2ca",""],["a2dc",""],["a2f2",""],["a2fe",""],["a3b0","",9],["a3c1","",25],["a3e1","",25],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a7a1","",5,"",25],["a7d1","",5,"",25],["a8a1",""],["ada1","",19,"",9],["adc0",""],["addf","",4,""],["b0a1",""],["b1a1",""],["b2a1",""],["b3a1",""],["b4a1",""],["b5a1",""],["b6a1",""],["b7a1",""],["b8a1",""],["b9a1",""],["baa1",""],["bba1",""],["bca1",""],["bda1",""],["bea1",""],["bfa1",""],["c0a1",""],["c1a1",""],["c2a1",""],["c3a1",""],["c4a1",""],["c5a1",""],["c6a1",""],["c7a1",""],["c8a1",""],["c9a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1",""],["d2a1",""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fcf1","",9,""],["8fa2af",""],["8fa2c2",""],["8fa2eb",""],["8fa6e1",""],["8fa6e7",""],["8fa6e9",""],["8fa6ec",""],["8fa6f1",""],["8fa7c2","",10,""],["8fa7f2","",10,""],["8fa9a1",""],["8fa9a4",""],["8fa9a6",""],["8fa9a8",""],["8fa9ab",""],["8fa9af",""],["8fa9c1",""],["8faaa1",""],["8faaba",""],["8faba1",""],["8fabbd",""],["8fabc5",""],["8fb0a1",""],["8fb1a1",""],["8fb2a1","",4,""],["8fb3a1",""],["8fb4a1",""],["8fb5a1",""],["8fb6a1","",5,"",4,""],["8fb7a1","",4,""],["8fb8a1",""],["8fb9a1",""],["8fbaa1","",4,""],["8fbba1",""],["8fbca1","",4,""],["8fbda1","",4,""],["8fbea1","",4,""],["8fbfa1",""],["8fc0a1",""],["8fc1a1",""],["8fc2a1",""],["8fc3a1","",4,""],["8fc4a1",""],["8fc5a1",""],["8fc6a1",""],["8fc7a1",""],["8fc8a1",""],["8fc9a1","",4,"",4,""],["8fcaa1",""],["8fcba1",""],["8fcca1","",9,""],["8fcda1","",5,""],["8fcea1","",6,""],["8fcfa1",""],["8fd0a1",""],["8fd1a1",""],["8fd2a1","",5],["8fd3a1",""],["8fd4a1","",4,""],["8fd5a1",""],["8fd6a1",""],["8fd7a1",""],["8fd8a1",""],["8fd9a1","",4,"",6,""],["8fdaa1","",4,""],["8fdba1","",6,""],["8fdca1","",4,""],["8fdda1","",4,""],["8fdea1","",4,""],["8fdfa1",""],["8fe0a1",""],["8fe1a1","",4,""],["8fe2a1",""],["8fe3a1","",5,"",4,""],["8fe4a1","",4,""],["8fe5a1","",4,""],["8fe6a1",""],["8fe7a1",""],["8fe8a1","",4,""],["8fe9a1","",4],["8feaa1","",4,""],["8feba1","",4,""],["8feca1",""],["8feda1","",4,"",4,""]]');
const require$$2 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127,""],["8140","",5,"",9,"",6,""],["8180","",6,"",4,"",4,"",5,""],["8240","",4,"",8,"",4,"",11],["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],["8340","",17,"",5,"",10,"",4,"",9,""],["8380","",5,"",13,"",28,"",4,"",4,"",5],["8440","",5,"",5,""],["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],["8540","",9,""],["8580","",4,"",6,"",4,"",4,"",7,""],["8640","",4,"",5,"",4,"",5,""],["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],["8740","",7,"",11,"",4,"",4],["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],["8840","",9,"",4,"",4,""],["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],["8940","",5,"",6,"",4,"",5,"",4,"",16,""],["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],["8a40","",4,"",12,""],["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],["8b40","",8,"",17,"",6,"",13,""],["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],["8c40","",7,""],["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],["8d40","",5,"",5,"",5,"",6,"",9,"",4],["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],["8e40","",21,"",12,"",6,"",12,""],["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],["8f40","",5,"",11,"",8,""],["8f80","",6,"",14,"",5,"",5,"",4,""],["9040","",4,"",4,"",6,""],["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],["9140","",6,"",6,"",18,"",4,""],["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],["9240","",6,"",5,""],["9280","",5,"",7,"",6,""],["9340","",6,"",4,"",4,"",5,""],["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],["9440","",24,"",7,"",7,"",4,"",8],["9480","",4,"",4,"",14,"",7,"",7,""],["9540","",4,"",4,"",6,""],["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],["9640","",5,"",4,""],["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],["9740","",7,"",8,"",7,"",9,""],["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],["9840","",4,"",5,"",9,""],["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],["9980","",114,"",6],["9a40","",11,"",7,"",13,""],["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],["9b40","",4,""],["9b80","",5,"",4,"",4,"",5,""],["9c40","",7,""],["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],["9d40","",7,"",4,"",9,"",6,""],["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],["9e40","",7,"",32,"",7,"",6,"",6],["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],["9f40","",6,"",10,"",4,"",10,"",7,""],["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],["a040","",9,"",5,"",9,"",11,"",19],["a080","",9,"",6,"",4,"",11,"",11,"",6,""],["a1a1","",7,""],["a2a1","",9],["a2b1","",19,"",19,"",9],["a2e5","",9],["a2f1","",11],["a3a1","",88,""],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a6e0",""],["a6ee",""],["a6f4",""],["a7a1","",5,"",25],["a7d1","",5,"",25],["a840","",35,"",6],["a880","",7,""],["a8a1",""],["a8bd",""],["a8c0",""],["a8c5","",36],["a940","",8,""],["a959",""],["a95c",""],["a960","",9,"",8],["a980","",4,""],["a996",""],["a9a4","",75],["aa40","",5,"",5,"",8],["aa80","",7,"",10,""],["ab40","",11,"",4,"",5,"",4],["ab80","",6,"",4],["ac40","",10,"",8,"",5,"",4,"",11],["ac80","",6,"",12,"",4,""],["ad40","",10,"",7,"",15,"",12],["ad80","",9,"",8,"",6,""],["ae40","",6,"",7,"",4,""],["ae80","",7,"",6,"",4,""],["af40","",4,""],["af80",""],["b040","",6,"",5,"",4,"",6,"",7,""],["b080","",7,"",8,"",9,""],["b140","",4,"",7,"",10,""],["b180","",4,"",7,"",7,""],["b240","",11,"",5,"",11,"",4],["b280","",12,"",8,"",4,""],["b340","",5,""],["b380","",11,"",7,"",6,""],["b440","",7,"",9],["b480","",4,"",5,"",6,""],["b540","",5,"",9,"",4,"",14,"",4,"",8,""],["b580","",6,"",4,""],["b640","",6,"",11,"",10,"",4,"",5,""],["b680","",6,"",4,""],["b740","",14,"",5,"",9,"",4,"",16],["b780","",6,""],["b840","",4,"",10,"",10,"",9,"",5,""],["b880","",4,""],["b940","",5,"",10,"",6,""],["b980","",7,""],["ba40","",4,"",4,"",7,"",5,""],["ba80","",4,"",5,"",12,"",5,""],["bb40","",9,"",36,"",5,"",9],["bb80","",6,"",4,""],["bc40","",6,"",6,"",5,"",7,"",13,"",5],["bc80","",14,"",6,""],["bd40","",54,"",7],["bd80","",32,""],["be40","",12,"",6,"",42],["be80","",32,""],["bf40","",62],["bf80","",4,"",4,"",21,""],["c040","",35,"",23,""],["c080","",6,"",9,""],["c140","",4,"",7,"",4,"",4,"",6,""],["c180","",4,"",4,"",5,""],["c240","",6,"",5,""],["c280","",13,"",5,"",11,""],["c340","",5,"",4,"",6,""],["c380","",12,"",4,""],["c440","",5,"",4,"",4,"",5,"",4,""],["c480","",7,"",5,"",6,""],["c540","",14,"",4,"",5,"",4,"",5,""],["c580","",7,"",7,""],["c640",""],["c680","",4,"",9,""],["c740","",4,"",4,"",6,"",6,"",6,""],["c780",""],["c840","",4,"",5,"",5,"",7,"",5,"",7,""],["c880","",6,"",4,"",4,""],["c940","",4,"",7,"",12,""],["c980","",4,"",4,"",10,""],["ca40","",8,"",8,"",9,"",4,"",10],["ca80","",4,"",8,""],["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],["cb80","",5,"",6,"",14,""],["cc40","",4,"",10,"",15,"",13,""],["cc80","",11,"",4,"",7,""],["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],["cd80",""],["ce40","",6,"",5,"",7,""],["ce80","",4,"",6,"",4,""],["cf40","",4,"",4,"",6,"",9],["cf80","",5,"",7,"",4,""],["d040","",13,"",5,"",5,"",5,"",6,""],["d080","",4,"",4,"",5,""],["d140","",4,"",4,"",6,"",5],["d180","",4,"",4,"",4,""],["d240","",8,"",24,"",5,"",19,""],["d280","",26,""],["d340","",30,"",6],["d380","",4,"",5,"",21,""],["d440","",31,"",8,"",21],["d480","",25,"",6,""],["d540","",7,"",7,"",46],["d580","",32,""],["d640","",34,"",27],["d680","",30,""],["d740","",31,"",4,"",25],["d780","",24,""],["d840","",8,"",7,"",5,"",6,"",6,"",6,""],["d880","",6,"",20,""],["d940","",62],["d980","",32,""],["da40","",14,"",8,"",4,"",9,""],["da80","",12,""],["db40","",6,"",7,"",4,""],["db80","",4,"",5,"",11,""],["dc40","",4,"",6,"",6,"",11,"",6,"",7],["dc80","",10,"",21,""],["dd40","",62],["dd80","",32,""],["de40","",32,""],["de80","",4,""],["df40","",5,"",4,"",4,"",5,"",4,"",6,""],["df80","",4,""],["e040","",19,""],["e080","",10,"",6,"",8,""],["e140","",4,"",6,"",5,"",5,""],["e180","",10,"",9,"",8,""],["e240","",62],["e280","",32,"",5,""],["e340","",45,"",16],["e380","",7,"",24,""],["e440","",5,"",24,"",31],["e480","",32,""],["e540","",51,"",10],["e580","",31,""],["e640","",34,"",27],["e680","",29,""],["e740","",7,"",54],["e780","",32,"",6,"",4,""],["e840","",14,"",43,""],["e880","",20,""],["e940","",7,"",42],["e980","",32,""],["ea40","",27,"",6,""],["ea80","",4,"",12,""],["eb40","",9,"",7,"",9,"",6,""],["eb80","",4,""],["ec40","",8,"",4,"",18,"",7],["ec80","",4,"",7,"",4,"",4,""],["ed40","",6,"",46],["ed80","",4,"",23,""],["ee40","",62],["ee80","",32,"",4,"",6,""],["ef40","",5,"",37,"",4],["ef80","",30,"",4,"",8,""],["f040","",4,"",28,"",26],["f080","",9,"",12,"",4,"",6,""],["f140","",10,"",47],["f180","",32,""],["f240","",62],["f280","",32,""],["f340","",17,"",6,"",4,""],["f380","",8,"",6,""],["f440","",5,"",10,"",10,"",7,"",5],["f480","",32,""],["f540","",62],["f580","",32,""],["f640","",62],["f680","",32,"",5,"",5,"",4,"",7,""],["f740","",62],["f780","",4,"",4,""],["f840","",62],["f880","",32],["f940","",62],["f980","",32],["fa40","",62],["fa80","",32],["fb40","",27,"",9,""],["fb80","",5,"",8,"",5,""],["fc40","",8,"",4,"",8,"",6],["fc80","",4,"",5,"",8,""],["fd40","",4,"",4,"",10,"",38],["fd80","",5,"",11,"",4,""],["fe40",""]]');
const require$$3 = [
  [
    "a140",
    "",
    62
  ],
  [
    "a180",
    "",
    32
  ],
  [
    "a240",
    "",
    62
  ],
  [
    "a280",
    "",
    32
  ],
  [
    "a2ab",
    "",
    5
  ],
  [
    "a2e3",
    ""
  ],
  [
    "a2ef",
    ""
  ],
  [
    "a2fd",
    ""
  ],
  [
    "a340",
    "",
    62
  ],
  [
    "a380",
    "",
    31,
    ""
  ],
  [
    "a440",
    "",
    62
  ],
  [
    "a480",
    "",
    32
  ],
  [
    "a4f4",
    "",
    10
  ],
  [
    "a540",
    "",
    62
  ],
  [
    "a580",
    "",
    32
  ],
  [
    "a5f7",
    "",
    7
  ],
  [
    "a640",
    "",
    62
  ],
  [
    "a680",
    "",
    32
  ],
  [
    "a6b9",
    "",
    7
  ],
  [
    "a6d9",
    "",
    6
  ],
  [
    "a6ec",
    ""
  ],
  [
    "a6f3",
    ""
  ],
  [
    "a6f6",
    "",
    8
  ],
  [
    "a740",
    "",
    62
  ],
  [
    "a780",
    "",
    32
  ],
  [
    "a7c2",
    "",
    14
  ],
  [
    "a7f2",
    "",
    12
  ],
  [
    "a896",
    "",
    10
  ],
  [
    "a8bc",
    ""
  ],
  [
    "a8bf",
    ""
  ],
  [
    "a8c1",
    ""
  ],
  [
    "a8ea",
    "",
    20
  ],
  [
    "a958",
    ""
  ],
  [
    "a95b",
    ""
  ],
  [
    "a95d",
    ""
  ],
  [
    "a989",
    "",
    11
  ],
  [
    "a997",
    "",
    12
  ],
  [
    "a9f0",
    "",
    14
  ],
  [
    "aaa1",
    "",
    93
  ],
  [
    "aba1",
    "",
    93
  ],
  [
    "aca1",
    "",
    93
  ],
  [
    "ada1",
    "",
    93
  ],
  [
    "aea1",
    "",
    93
  ],
  [
    "afa1",
    "",
    93
  ],
  [
    "d7fa",
    "",
    4
  ],
  [
    "f8a1",
    "",
    93
  ],
  [
    "f9a1",
    "",
    93
  ],
  [
    "faa1",
    "",
    93
  ],
  [
    "fba1",
    "",
    93
  ],
  [
    "fca1",
    "",
    93
  ],
  [
    "fda1",
    "",
    93
  ],
  [
    "fe50",
    ""
  ],
  [
    "fe80",
    "",
    6,
    "",
    93
  ],
  [
    "8135f437",
    ""
  ]
];
const uChars = [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536];
const gbChars = [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3];
const require$$4 = {
  uChars,
  gbChars
};
const require$$5 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127],["8141","",4,"",6,""],["8161","",9,"",5,""],["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],["8241","",7,"",5],["8261","",6,"",5,""],["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],["8341","",5,"",5,"",7],["8361","",18,""],["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],["8441","",5,"",8],["8461","",18],["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],["8541","",5,"",4,"",6,"",4],["8561","",5,"",5,"",6,""],["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],["8641","",6,"",5,""],["8661","",6,"",10],["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],["8741","",9,"",15],["8761","",18,""],["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],["8841","",4,"",5,"",6,"",4],["8861","",4,""],["8881","",15,"",4,"",6,"",5,"",54,""],["8941","",6,"",5,""],["8961","",10,"",5,""],["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],["8a41","",10,"",6,""],["8a61","",4,"",18,""],["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],["8b41","",5,"",4,"",6,""],["8b61","",6,"",8],["8b81","",52,"",4,"",6,"",5,"",18,"",18],["8c41","",15,"",4],["8c61","",6,"",5,"",6,"",5],["8c81","",12,"",26,"",50,"",5,"",16],["8d41","",16,"",8],["8d61","",17,""],["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],["8e41","",6,"",5,"",8],["8e61","",4,"",19],["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],["8f41","",7,"",17],["8f61","",7,"",6,"",4],["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],["9041","",6,"",5,""],["9061","",5,"",15],["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],["9141","",6,"",5],["9161","",9,"",5],["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],["9241","",7,"",4,""],["9261","",7,"",7,"",4],["9281","",21,"",18,"",6,"",7,"",6,"",35,""],["9341","",4,""],["9361","",6,"",8],["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],["9441","",5,"",5,"",8],["9461","",5,"",6,"",12],["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],["9541","",11,"",5,""],["9561","",6,"",5,""],["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],["9641","",23,""],["9661","",6,"",5,"",8],["9681","",10,"",5,"",13,"",33,"",6,"",44],["9741","",16,"",8],["9761","",17,"",7],["9781","",11,"",5,"",6,"",89,""],["9841","",16,"",5,""],["9861","",6,"",15],["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],["9941","",6,"",5,""],["9961","",6,"",5,""],["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],["9a41","",16],["9a61","",6,"",6,""],["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],["9b41","",6,"",8],["9b61","",17,"",7],["9b81","",25,"",4,"",5,"",50,"",22,""],["9c41","",4,"",5,"",5],["9c61","",8,"",6,"",9],["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],["9d41","",13,"",8],["9d61","",25],["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],["9e41","",7,"",9,""],["9e61","",4,"",6,""],["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],["9f41","",5,"",4,"",5,""],["9f61","",6,"",5,""],["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],["a041","",5,"",6,""],["a061","",5,"",13],["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],["a141","",18,""],["a161","",6,"",5,""],["a181","",14,"",5,"",4,"",9,""],["a241","",5,"",18],["a261","",6,"",18],["a281","",7,"",6,"",7,""],["a341","",6,"",10,""],["a361","",6,"",16],["a381","",16,"",4,"",58,"",32,""],["a441","",5,""],["a461","",5,"",12],["a481","",28,"",93],["a541","",4,"",6,"",5,""],["a561","",17,"",5,""],["a581","",16,"",14,"",9],["a5b0","",9],["a5c1","",16,"",6],["a5e1","",16,"",6],["a641","",19,""],["a661","",5,"",5,"",6],["a681","",6,"",18,"",7],["a741","",4,"",6,"",7],["a761","",22,""],["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],["a841","",10,"",14],["a861","",18,"",6],["a881","",19,"",11,""],["a8a6",""],["a8a8",""],["a8b1","",27,"",25,"",14,""],["a941","",14,"",10],["a961","",18],["a981","",14,"",6,"",27,"",25,"",14,""],["aa41","",6,"",4,""],["aa61","",4,"",5,"",6,""],["aa81","",29,"",82],["ab41","",6,"",5,""],["ab61","",6,"",5,"",5],["ab81","",8,"",6,"",12,"",85],["ac41","",5,"",6,""],["ac61","",11,"",4],["ac81","",28,"",5,"",25],["acd1","",5,"",25],["ad41","",6,"",5,"",7],["ad61","",6,"",10,""],["ad81","",5,"",18,""],["ae41","",5,"",16],["ae61","",5,"",6,"",4],["ae81","",6,"",5,""],["af41","",19],["af61","",13,"",5,""],["af81","",5,"",6,"",5,""],["b041","",5,"",5,"",12],["b061","",5,"",19],["b081","",13,"",6,"",5,"",7,"",4,""],["b141","",6,"",5,""],["b161","",6,"",5,"",11],["b181","",14,"",6,""],["b241","",6,"",5,""],["b261","",18,"",5,""],["b281","",5,"",18,"",6,""],["b341","",19,""],["b361","",5,"",5,"",5],["b381","",5,"",5,"",19,"",4,""],["b441","",5,"",6,"",5],["b461","",6,"",10,""],["b481","",6,"",18,"",4,"",4,""],["b541","",14,"",5],["b561","",5,"",5,"",4],["b581","",6,"",5,"",11,""],["b641","",7,"",17],["b661","",15,""],["b681","",5,"",6,"",5,""],["b741","",13,"",6,""],["b761","",20,""],["b781","",6,"",14,""],["b841","",7,"",17],["b861","",8,"",13],["b881","",5,"",24,"",4,""],["b941","",6,"",5,""],["b961","",14,"",6,""],["b981","",22,"",4,"",4,""],["ba41","",5,"",6,""],["ba61","",5,"",4,"",5],["ba81","",6,"",9,""],["bb41","",4,"",5,"",4,""],["bb61","",6,"",5,""],["bb81","",31,""],["bc41","",17,""],["bc61","",5,"",6,""],["bc81","",4,"",6,"",5,"",5,"",4,""],["bd41","",7,"",7,""],["bd61","",5,"",13],["bd81","",5,"",25,""],["be41","",7,"",14],["be61","",7,"",7,""],["be81","",4,"",4,"",5,"",8,"",6,""],["bf41","",10,"",14],["bf61","",18,""],["bf81","",5,"",7,"",6,"",5,""],["c041","",5,"",6,"",5],["c061","",25],["c081","",6,"",5,"",7,""],["c141","",5,"",6,""],["c161","",19,""],["c181","",31,""],["c241","",4,"",5,""],["c261","",4,"",5,"",6,""],["c281","",5,"",7,"",9,""],["c341","",4],["c361","",4,"",5,"",11],["c381","",5,"",7,"",5,""],["c441","",7,"",7,""],["c461","",5,"",4],["c481","",5,"",11,""],["c541","",6,"",5,""],["c561","",6,"",5,"",4],["c581","",6,"",5,""],["c641","",6,"",5],["c6a1",""],["c7a1",""],["c8a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1","",5,"",4,""],["d2a1","",4,"",5,"",10,"",7,"",5,""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f5a1",""],["f6a1",""],["f7a1",""],["f8a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fda1",""]]');
const require$$6 = /* @__PURE__ */ JSON.parse('[["0","\\u0000",127],["a140",""],["a1a1","",4,""],["a240","",7,""],["a2a1","",9,"",9,"",8,"",25,"",21],["a340","",16,"",6,"",16,"",6,"",10],["a3a1","",25,""],["a3e1",""],["a440",""],["a4a1",""],["a540",""],["a5a1",""],["a640",""],["a6a1",""],["a740",""],["a7a1",""],["a840",""],["a8a1",""],["a940",""],["a9a1",""],["aa40",""],["aaa1",""],["ab40",""],["aba1",""],["ac40",""],["aca1",""],["ad40",""],["ada1",""],["ae40",""],["aea1",""],["af40",""],["afa1",""],["b040",""],["b0a1",""],["b140",""],["b1a1",""],["b240",""],["b2a1",""],["b340",""],["b3a1",""],["b440",""],["b4a1",""],["b540",""],["b5a1",""],["b640",""],["b6a1",""],["b740",""],["b7a1",""],["b840",""],["b8a1",""],["b940",""],["b9a1",""],["ba40",""],["baa1",""],["bb40",""],["bba1",""],["bc40",""],["bca1",""],["bd40",""],["bda1",""],["be40",""],["bea1",""],["bf40",""],["bfa1",""],["c040",""],["c0a1",""],["c140",""],["c1a1",""],["c240",""],["c2a1",""],["c340",""],["c3a1",""],["c440",""],["c4a1",""],["c540",""],["c5a1",""],["c640",""],["c940",""],["c9a1",""],["ca40",""],["caa1",""],["cb40",""],["cba1",""],["cc40",""],["cca1",""],["cd40",""],["cda1",""],["ce40",""],["cea1",""],["cf40",""],["cfa1",""],["d040",""],["d0a1",""],["d140",""],["d1a1",""],["d240",""],["d2a1",""],["d340",""],["d3a1",""],["d440",""],["d4a1",""],["d540",""],["d5a1",""],["d640",""],["d6a1",""],["d740",""],["d7a1",""],["d840",""],["d8a1",""],["d940",""],["d9a1",""],["da40",""],["daa1",""],["db40",""],["dba1",""],["dc40",""],["dca1",""],["dd40",""],["dda1",""],["de40",""],["dea1",""],["df40",""],["dfa1",""],["e040",""],["e0a1",""],["e140",""],["e1a1",""],["e240",""],["e2a1",""],["e340",""],["e3a1",""],["e440",""],["e4a1",""],["e540",""],["e5a1",""],["e640",""],["e6a1",""],["e740",""],["e7a1",""],["e840",""],["e8a1",""],["e940",""],["e9a1",""],["ea40",""],["eaa1",""],["eb40",""],["eba1",""],["ec40",""],["eca1",""],["ed40",""],["eda1",""],["ee40",""],["eea1",""],["ef40",""],["efa1",""],["f040",""],["f0a1",""],["f140",""],["f1a1",""],["f240",""],["f2a1",""],["f340",""],["f3a1",""],["f440",""],["f4a1",""],["f540",""],["f5a1",""],["f640",""],["f6a1",""],["f740",""],["f7a1",""],["f840",""],["f8a1",""],["f940",""],["f9a1",""]]');
const require$$7 = [
  [
    "8740",
    ""
  ],
  [
    "8767",
    ""
  ],
  [
    "87a1",
    ""
  ],
  [
    "8840",
    "",
    4,
    ""
  ],
  [
    "88a1",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8943",
    ""
  ],
  [
    "8946",
    ""
  ],
  [
    "894c",
    ""
  ],
  [
    "89a1",
    ""
  ],
  [
    "89ab",
    ""
  ],
  [
    "89b0",
    ""
  ],
  [
    "89b5",
    ""
  ],
  [
    "89c1",
    ""
  ],
  [
    "89c5",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a43",
    ""
  ],
  [
    "8a64",
    ""
  ],
  [
    "8a76",
    ""
  ],
  [
    "8aa1",
    ""
  ],
  [
    "8aac",
    ""
  ],
  [
    "8ab2",
    ""
  ],
  [
    "8abb",
    ""
  ],
  [
    "8ac9",
    ""
  ],
  [
    "8ace",
    ""
  ],
  [
    "8adf",
    ""
  ],
  [
    "8af6",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b55",
    ""
  ],
  [
    "8ba1",
    ""
  ],
  [
    "8bde",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8ca1",
    ""
  ],
  [
    "8ca7",
    ""
  ],
  [
    "8cc9",
    ""
  ],
  [
    "8cce",
    ""
  ],
  [
    "8ce6",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d42",
    ""
  ],
  [
    "8da1",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8ea1",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8fa1",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "90a1",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "91a1",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "92a1",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "93a1",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "94a1",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "95a1",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "96a1",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "97a1",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "98a1",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "99a1",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9aa1",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b62",
    ""
  ],
  [
    "9ba1",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9ca1",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9da1",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9ea1",
    ""
  ],
  [
    "9ead",
    ""
  ],
  [
    "9ec5",
    ""
  ],
  [
    "9ef5",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f4f",
    ""
  ],
  [
    "9fa1",
    ""
  ],
  [
    "9fae",
    ""
  ],
  [
    "9fb2",
    ""
  ],
  [
    "9fc1",
    ""
  ],
  [
    "9fc9",
    ""
  ],
  [
    "9fdb",
    ""
  ],
  [
    "9fe7",
    ""
  ],
  [
    "9feb",
    ""
  ],
  [
    "9ff0",
    ""
  ],
  [
    "a040",
    ""
  ],
  [
    "a055",
    ""
  ],
  [
    "a058",
    ""
  ],
  [
    "a05b",
    ""
  ],
  [
    "a063",
    ""
  ],
  [
    "a073",
    ""
  ],
  [
    "a0a1",
    ""
  ],
  [
    "a0a6",
    ""
  ],
  [
    "a0ae",
    ""
  ],
  [
    "a0b0",
    ""
  ],
  [
    "a0d4",
    ""
  ],
  [
    "a0e2",
    ""
  ],
  [
    "a3c0",
    "",
    31,
    ""
  ],
  [
    "c6a1",
    "",
    9,
    "",
    9,
    "",
    9,
    "",
    23
  ],
  [
    "c740",
    "",
    58,
    ""
  ],
  [
    "c7a1",
    "",
    81,
    "",
    5,
    "",
    4
  ],
  [
    "c840",
    "",
    26,
    "",
    25,
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c8cd",
    ""
  ],
  [
    "c8f5",
    ""
  ],
  [
    "f9fe",
    ""
  ],
  [
    "fa40",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fc40",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fd40",
    ""
  ],
  [
    "fda1",
    ""
  ],
  [
    "fe40",
    ""
  ],
  [
    "fea1",
    ""
  ]
];
var dbcsData;
var hasRequiredDbcsData;
function requireDbcsData() {
  if (hasRequiredDbcsData) return dbcsData;
  hasRequiredDbcsData = 1;
  dbcsData = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes.
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII,
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    shiftjis: {
      type: "_dbcs",
      table: function() {
        return require$$0$2;
      },
      encodeAdd: { "": 92, "": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    csshiftjis: "shiftjis",
    mskanji: "shiftjis",
    sjis: "shiftjis",
    windows31j: "shiftjis",
    ms31j: "shiftjis",
    xsjis: "shiftjis",
    windows932: "shiftjis",
    ms932: "shiftjis",
    932: "shiftjis",
    cp932: "shiftjis",
    eucjp: {
      type: "_dbcs",
      table: function() {
        return require$$1;
      },
      encodeAdd: { "": 92, "": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    gb2312: "cp936",
    gb231280: "cp936",
    gb23121980: "cp936",
    csgb2312: "cp936",
    csiso58gb231280: "cp936",
    euccn: "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    windows936: "cp936",
    ms936: "cp936",
    936: "cp936",
    cp936: {
      type: "_dbcs",
      table: function() {
        return require$$2;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    gbk: {
      type: "_dbcs",
      table: function() {
        return require$$2.concat(require$$3);
      }
    },
    xgbk: "gbk",
    isoir58: "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    gb18030: {
      type: "_dbcs",
      table: function() {
        return require$$2.concat(require$$3);
      },
      gb18030: function() {
        return require$$4;
      },
      encodeSkipVals: [128],
      encodeAdd: { "": 41699 }
    },
    chinese: "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    windows949: "cp949",
    ms949: "cp949",
    949: "cp949",
    cp949: {
      type: "_dbcs",
      table: function() {
        return require$$5;
      }
    },
    cseuckr: "cp949",
    csksc56011987: "cp949",
    euckr: "cp949",
    isoir149: "cp949",
    korean: "cp949",
    ksc56011987: "cp949",
    ksc56011989: "cp949",
    ksc5601: "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard.
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    //
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    windows950: "cp950",
    ms950: "cp950",
    950: "cp950",
    cp950: {
      type: "_dbcs",
      table: function() {
        return require$$6;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    big5: "big5hkscs",
    big5hkscs: {
      type: "_dbcs",
      table: function() {
        return require$$6.concat(require$$7);
      },
      encodeSkipVals: [
        // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
        // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
        // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
        36457,
        36463,
        36478,
        36523,
        36532,
        36557,
        36560,
        36695,
        36713,
        36718,
        36811,
        36862,
        36973,
        36986,
        37060,
        37084,
        37105,
        37311,
        37551,
        37552,
        37553,
        37554,
        37585,
        37959,
        38090,
        38361,
        38652,
        39285,
        39798,
        39800,
        39803,
        39878,
        39902,
        39916,
        39926,
        40002,
        40019,
        40034,
        40040,
        40043,
        40055,
        40124,
        40125,
        40144,
        40279,
        40282,
        40388,
        40431,
        40443,
        40617,
        40687,
        40701,
        40800,
        40907,
        41079,
        41180,
        41183,
        36812,
        37576,
        38468,
        38637,
        // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
        41636,
        41637,
        41639,
        41638,
        41676,
        41678
      ]
    },
    cnbig5: "big5hkscs",
    csbig5: "big5hkscs",
    xxbig5: "big5hkscs"
  };
  return dbcsData;
}
var hasRequiredEncodings;
function requireEncodings() {
  if (hasRequiredEncodings) return encodings;
  hasRequiredEncodings = 1;
  (function(exports$1) {
    var mergeModules = requireMergeExports();
    var modules = [
      requireInternal(),
      requireUtf32(),
      requireUtf16(),
      requireUtf7(),
      requireSbcsCodec(),
      requireSbcsData(),
      requireSbcsDataGenerated(),
      requireDbcsCodec(),
      requireDbcsData()
    ];
    for (var i = 0; i < modules.length; i++) {
      var module = modules[i];
      mergeModules(exports$1, module);
    }
  })(encodings);
  return encodings;
}
var streams;
var hasRequiredStreams;
function requireStreams() {
  if (hasRequiredStreams) return streams;
  hasRequiredStreams = 1;
  var Buffer2 = requireSafer().Buffer;
  streams = function(streamModule) {
    var Transform = streamModule.Transform;
    function IconvLiteEncoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.decodeStrings = false;
      Transform.call(this, options);
    }
    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteEncoderStream }
    });
    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding2, done) {
      if (typeof chunk !== "string") {
        return done(new Error("Iconv encoding stream needs strings as its input."));
      }
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype.collect = function(cb) {
      var chunks = [];
      this.on("error", cb);
      this.on("data", function(chunk) {
        chunks.push(chunk);
      });
      this.on("end", function() {
        cb(null, Buffer2.concat(chunks));
      });
      return this;
    };
    function IconvLiteDecoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.encoding = this.encoding = "utf8";
      Transform.call(this, options);
    }
    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
      constructor: { value: IconvLiteDecoderStream }
    });
    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding2, done) {
      if (!Buffer2.isBuffer(chunk) && !(chunk instanceof Uint8Array)) {
        return done(new Error("Iconv decoding stream needs buffers as its input."));
      }
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype.collect = function(cb) {
      var res = "";
      this.on("error", cb);
      this.on("data", function(chunk) {
        res += chunk;
      });
      this.on("end", function() {
        cb(null, res);
      });
      return this;
    };
    return {
      IconvLiteEncoderStream,
      IconvLiteDecoderStream
    };
  };
  return streams;
}
var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib$3.exports;
  hasRequiredLib$3 = 1;
  (function(module) {
    var Buffer2 = requireSafer().Buffer;
    var bomHandling2 = requireBomHandling();
    var mergeModules = requireMergeExports();
    var iconv = module.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = "";
    iconv.defaultCharSingleByte = "?";
    iconv.encode = function encode2(str, encoding2, options) {
      str = "" + (str || "");
      var encoder = iconv.getEncoder(encoding2, options);
      var res = encoder.write(str);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
    };
    iconv.decode = function decode2(buf, encoding2, options) {
      if (typeof buf === "string") {
        if (!iconv.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder2 = iconv.getDecoder(encoding2, options);
      var res = decoder2.write(buf);
      var trail = decoder2.end();
      return trail ? res + trail : res;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = { __proto__: null };
    iconv.getCodec = function getCodec(encoding2) {
      if (!iconv.encodings) {
        var raw = requireEncodings();
        iconv.encodings = { __proto__: null };
        mergeModules(iconv.encodings, raw);
      }
      var enc = iconv._canonicalizeEncoding(encoding2);
      var codecOptions = {};
      while (true) {
        var codec2 = iconv._codecDataCache[enc];
        if (codec2) {
          return codec2;
        }
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key2 in codecDef) {
              codecOptions[key2] = codecDef[key2];
            }
            if (!codecOptions.encodingName) {
              codecOptions.encodingName = enc;
            }
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName) {
              codecOptions.encodingName = enc;
            }
            codec2 = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec2;
            return codec2;
          default:
            throw new Error("Encoding not recognized: '" + encoding2 + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function(encoding2) {
      return ("" + encoding2).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding2, options) {
      var codec2 = iconv.getCodec(encoding2);
      var encoder = new codec2.encoder(options, codec2);
      if (codec2.bomAware && options && options.addBOM) {
        encoder = new bomHandling2.PrependBOM(encoder, options);
      }
      return encoder;
    };
    iconv.getDecoder = function getDecoder(encoding2, options) {
      var codec2 = iconv.getCodec(encoding2);
      var decoder2 = new codec2.decoder(options, codec2);
      if (codec2.bomAware && !(options && options.stripBOM === false)) {
        decoder2 = new bomHandling2.StripBOM(decoder2, options);
      }
      return decoder2;
    };
    iconv.enableStreamingAPI = function enableStreamingAPI(streamModule2) {
      if (iconv.supportsStreams) {
        return;
      }
      var streams2 = requireStreams()(streamModule2);
      iconv.IconvLiteEncoderStream = streams2.IconvLiteEncoderStream;
      iconv.IconvLiteDecoderStream = streams2.IconvLiteDecoderStream;
      iconv.encodeStream = function encodeStream(encoding2, options) {
        return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding2, options), options);
      };
      iconv.decodeStream = function decodeStream(encoding2, options) {
        return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding2, options), options);
      };
      iconv.supportsStreams = true;
    };
    var streamModule;
    try {
      streamModule = require("stream");
    } catch (e) {
    }
    if (streamModule && streamModule.Transform) {
      iconv.enableStreamingAPI(streamModule);
    } else {
      iconv.encodeStream = iconv.decodeStream = function() {
        throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
      };
    }
  })(lib$3);
  return lib$3.exports;
}
var unpipe_1;
var hasRequiredUnpipe;
function requireUnpipe() {
  if (hasRequiredUnpipe) return unpipe_1;
  hasRequiredUnpipe = 1;
  unpipe_1 = unpipe;
  function hasPipeDataListeners(stream) {
    var listeners = stream.listeners("data");
    for (var i = 0; i < listeners.length; i++) {
      if (listeners[i].name === "ondata") {
        return true;
      }
    }
    return false;
  }
  function unpipe(stream) {
    if (!stream) {
      throw new TypeError("argument stream is required");
    }
    if (typeof stream.unpipe === "function") {
      stream.unpipe();
      return;
    }
    if (!hasPipeDataListeners(stream)) {
      return;
    }
    var listener;
    var listeners = stream.listeners("close");
    for (var i = 0; i < listeners.length; i++) {
      listener = listeners[i];
      if (listener.name !== "cleanup" && listener.name !== "onclose") {
        continue;
      }
      listener.call(stream);
    }
  }
  return unpipe_1;
}
var rawBody;
var hasRequiredRawBody;
function requireRawBody() {
  if (hasRequiredRawBody) return rawBody;
  hasRequiredRawBody = 1;
  var asyncHooks = tryRequireAsyncHooks();
  var bytes2 = requireBytes();
  var createError = requireHttpErrors();
  var iconv = requireLib$3();
  var unpipe = requireUnpipe();
  rawBody = getRawBody;
  var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
  function getDecoder(encoding2) {
    if (!encoding2) return null;
    try {
      return iconv.getDecoder(encoding2);
    } catch (e) {
      if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;
      throw createError(415, "specified encoding unsupported", {
        encoding: encoding2,
        type: "encoding.unsupported"
      });
    }
  }
  function getRawBody(stream, options, callback) {
    var done = callback;
    var opts = options || {};
    if (stream === void 0) {
      throw new TypeError("argument stream is required");
    } else if (typeof stream !== "object" || stream === null || typeof stream.on !== "function") {
      throw new TypeError("argument stream must be a stream");
    }
    if (options === true || typeof options === "string") {
      opts = {
        encoding: options
      };
    }
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    if (done !== void 0 && typeof done !== "function") {
      throw new TypeError("argument callback must be a function");
    }
    if (!done && !commonjsGlobal.Promise) {
      throw new TypeError("argument callback is required");
    }
    var encoding2 = opts.encoding !== true ? opts.encoding : "utf-8";
    var limit = bytes2.parse(opts.limit);
    var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
    if (done) {
      return readStream(stream, encoding2, length, limit, wrap(done));
    }
    return new Promise(function executor(resolve2, reject) {
      readStream(stream, encoding2, length, limit, function onRead(err, buf) {
        if (err) return reject(err);
        resolve2(buf);
      });
    });
  }
  function halt(stream) {
    unpipe(stream);
    if (typeof stream.pause === "function") {
      stream.pause();
    }
  }
  function readStream(stream, encoding2, length, limit, callback) {
    var complete = false;
    var sync = true;
    if (limit !== null && length !== null && length > limit) {
      return done(createError(413, "request entity too large", {
        expected: length,
        length,
        limit,
        type: "entity.too.large"
      }));
    }
    var state2 = stream._readableState;
    if (stream._decoder || state2 && (state2.encoding || state2.decoder)) {
      return done(createError(500, "stream encoding should not be set", {
        type: "stream.encoding.set"
      }));
    }
    if (typeof stream.readable !== "undefined" && !stream.readable) {
      return done(createError(500, "stream is not readable", {
        type: "stream.not.readable"
      }));
    }
    var received = 0;
    var decoder2;
    try {
      decoder2 = getDecoder(encoding2);
    } catch (err) {
      return done(err);
    }
    var buffer2 = decoder2 ? "" : [];
    stream.on("aborted", onAborted);
    stream.on("close", cleanup);
    stream.on("data", onData);
    stream.on("end", onEnd);
    stream.on("error", onEnd);
    sync = false;
    function done() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      complete = true;
      if (sync) {
        process.nextTick(invokeCallback);
      } else {
        invokeCallback();
      }
      function invokeCallback() {
        cleanup();
        if (args[0]) {
          halt(stream);
        }
        callback.apply(null, args);
      }
    }
    function onAborted() {
      if (complete) return;
      done(createError(400, "request aborted", {
        code: "ECONNABORTED",
        expected: length,
        length,
        received,
        type: "request.aborted"
      }));
    }
    function onData(chunk) {
      if (complete) return;
      received += chunk.length;
      if (limit !== null && received > limit) {
        done(createError(413, "request entity too large", {
          limit,
          received,
          type: "entity.too.large"
        }));
      } else if (decoder2) {
        buffer2 += decoder2.write(chunk);
      } else {
        buffer2.push(chunk);
      }
    }
    function onEnd(err) {
      if (complete) return;
      if (err) return done(err);
      if (length !== null && received !== length) {
        done(createError(400, "request size did not match content length", {
          expected: length,
          length,
          received,
          type: "request.size.invalid"
        }));
      } else {
        var string2 = decoder2 ? buffer2 + (decoder2.end() || "") : Buffer.concat(buffer2);
        done(null, string2);
      }
    }
    function cleanup() {
      buffer2 = null;
      stream.removeListener("aborted", onAborted);
      stream.removeListener("data", onData);
      stream.removeListener("end", onEnd);
      stream.removeListener("error", onEnd);
      stream.removeListener("close", cleanup);
    }
  }
  function tryRequireAsyncHooks() {
    try {
      return require("async_hooks");
    } catch (e) {
      return {};
    }
  }
  function wrap(fn) {
    var res;
    if (asyncHooks.AsyncResource) {
      res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
    }
    if (!res || !res.runInAsyncScope) {
      return fn;
    }
    return res.runInAsyncScope.bind(res, fn, null);
  }
  return rawBody;
}
var onFinished = { exports: {} };
var eeFirst;
var hasRequiredEeFirst;
function requireEeFirst() {
  if (hasRequiredEeFirst) return eeFirst;
  hasRequiredEeFirst = 1;
  eeFirst = first;
  function first(stuff, done) {
    if (!Array.isArray(stuff))
      throw new TypeError("arg must be an array of [ee, events...] arrays");
    var cleanups = [];
    for (var i = 0; i < stuff.length; i++) {
      var arr = stuff[i];
      if (!Array.isArray(arr) || arr.length < 2)
        throw new TypeError("each array member must be [ee, events...]");
      var ee = arr[0];
      for (var j = 1; j < arr.length; j++) {
        var event = arr[j];
        var fn = listener(event, callback);
        ee.on(event, fn);
        cleanups.push({
          ee,
          event,
          fn
        });
      }
    }
    function callback() {
      cleanup();
      done.apply(null, arguments);
    }
    function cleanup() {
      var x;
      for (var i2 = 0; i2 < cleanups.length; i2++) {
        x = cleanups[i2];
        x.ee.removeListener(x.event, x.fn);
      }
    }
    function thunk(fn2) {
      done = fn2;
    }
    thunk.cancel = cleanup;
    return thunk;
  }
  function listener(event, done) {
    return function onevent(arg1) {
      var args = new Array(arguments.length);
      var ee = this;
      var err = event === "error" ? arg1 : null;
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      done(err, ee, event, args);
    };
  }
  return eeFirst;
}
var hasRequiredOnFinished;
function requireOnFinished() {
  if (hasRequiredOnFinished) return onFinished.exports;
  hasRequiredOnFinished = 1;
  onFinished.exports = onFinished$1;
  onFinished.exports.isFinished = isFinished;
  var asyncHooks = tryRequireAsyncHooks();
  var first = requireEeFirst();
  var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
    process.nextTick(fn.bind.apply(fn, arguments));
  };
  function onFinished$1(msg, listener) {
    if (isFinished(msg) !== false) {
      defer(listener, null, msg);
      return msg;
    }
    attachListener(msg, wrap(listener));
    return msg;
  }
  function isFinished(msg) {
    var socket = msg.socket;
    if (typeof msg.finished === "boolean") {
      return Boolean(msg.finished || socket && !socket.writable);
    }
    if (typeof msg.complete === "boolean") {
      return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
    }
    return void 0;
  }
  function attachFinishedListener(msg, callback) {
    var eeMsg;
    var eeSocket;
    var finished = false;
    function onFinish(error2) {
      eeMsg.cancel();
      eeSocket.cancel();
      finished = true;
      callback(error2);
    }
    eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
    function onSocket(socket) {
      msg.removeListener("socket", onSocket);
      if (finished) return;
      if (eeMsg !== eeSocket) return;
      eeSocket = first([[socket, "error", "close"]], onFinish);
    }
    if (msg.socket) {
      onSocket(msg.socket);
      return;
    }
    msg.on("socket", onSocket);
    if (msg.socket === void 0) {
      patchAssignSocket(msg, onSocket);
    }
  }
  function attachListener(msg, listener) {
    var attached = msg.__onFinished;
    if (!attached || !attached.queue) {
      attached = msg.__onFinished = createListener(msg);
      attachFinishedListener(msg, attached);
    }
    attached.queue.push(listener);
  }
  function createListener(msg) {
    function listener(err) {
      if (msg.__onFinished === listener) msg.__onFinished = null;
      if (!listener.queue) return;
      var queue2 = listener.queue;
      listener.queue = null;
      for (var i = 0; i < queue2.length; i++) {
        queue2[i](err, msg);
      }
    }
    listener.queue = [];
    return listener;
  }
  function patchAssignSocket(res, callback) {
    var assignSocket = res.assignSocket;
    if (typeof assignSocket !== "function") return;
    res.assignSocket = function _assignSocket(socket) {
      assignSocket.call(this, socket);
      callback(socket);
    };
  }
  function tryRequireAsyncHooks() {
    try {
      return require("async_hooks");
    } catch (e) {
      return {};
    }
  }
  function wrap(fn) {
    var res;
    if (asyncHooks.AsyncResource) {
      res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
    }
    if (!res || !res.runInAsyncScope) {
      return fn;
    }
    return res.runInAsyncScope.bind(res, fn, null);
  }
  return onFinished.exports;
}
var typeIs$1 = { exports: {} };
var contentType = {};
var hasRequiredContentType;
function requireContentType() {
  if (hasRequiredContentType) return contentType;
  hasRequiredContentType = 1;
  var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
  var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
  var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
  var QUOTE_REGEXP = /([\\"])/g;
  var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  contentType.format = format;
  contentType.parse = parse3;
  function format(obj) {
    if (!obj || typeof obj !== "object") {
      throw new TypeError("argument obj is required");
    }
    var parameters = obj.parameters;
    var type2 = obj.type;
    if (!type2 || !TYPE_REGEXP.test(type2)) {
      throw new TypeError("invalid type");
    }
    var string2 = type2;
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0; i < params.length; i++) {
        param = params[i];
        if (!TOKEN_REGEXP.test(param)) {
          throw new TypeError("invalid parameter name");
        }
        string2 += "; " + param + "=" + qstring(parameters[param]);
      }
    }
    return string2;
  }
  function parse3(string2) {
    if (!string2) {
      throw new TypeError("argument string is required");
    }
    var header = typeof string2 === "object" ? getcontenttype(string2) : string2;
    if (typeof header !== "string") {
      throw new TypeError("argument string is required to be a string");
    }
    var index2 = header.indexOf(";");
    var type2 = index2 !== -1 ? header.slice(0, index2).trim() : header.trim();
    if (!TYPE_REGEXP.test(type2)) {
      throw new TypeError("invalid media type");
    }
    var obj = new ContentType(type2.toLowerCase());
    if (index2 !== -1) {
      var key2;
      var match;
      var value;
      PARAM_REGEXP.lastIndex = index2;
      while (match = PARAM_REGEXP.exec(header)) {
        if (match.index !== index2) {
          throw new TypeError("invalid parameter format");
        }
        index2 += match[0].length;
        key2 = match[1].toLowerCase();
        value = match[2];
        if (value.charCodeAt(0) === 34) {
          value = value.slice(1, -1);
          if (value.indexOf("\\") !== -1) {
            value = value.replace(QESC_REGEXP, "$1");
          }
        }
        obj.parameters[key2] = value;
      }
      if (index2 !== header.length) {
        throw new TypeError("invalid parameter format");
      }
    }
    return obj;
  }
  function getcontenttype(obj) {
    var header;
    if (typeof obj.getHeader === "function") {
      header = obj.getHeader("content-type");
    } else if (typeof obj.headers === "object") {
      header = obj.headers && obj.headers["content-type"];
    }
    if (typeof header !== "string") {
      throw new TypeError("content-type header is missing from object");
    }
    return header;
  }
  function qstring(val) {
    var str = String(val);
    if (TOKEN_REGEXP.test(str)) {
      return str;
    }
    if (str.length > 0 && !TEXT_REGEXP.test(str)) {
      throw new TypeError("invalid parameter value");
    }
    return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
  }
  function ContentType(type2) {
    this.parameters = /* @__PURE__ */ Object.create(null);
    this.type = type2;
  }
  return contentType;
}
var mimeTypes$1 = {};
const require$$0$1 = {
  "application/1d-interleaved-parityfec": { "source": "iana" },
  "application/3gpdash-qoe-report+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/3gpp-ims+xml": { "source": "iana", "compressible": true },
  "application/3gpphal+json": { "source": "iana", "compressible": true },
  "application/3gpphalforms+json": { "source": "iana", "compressible": true },
  "application/a2l": { "source": "iana" },
  "application/ace+cbor": { "source": "iana" },
  "application/ace+json": { "source": "iana", "compressible": true },
  "application/ace-groupcomm+cbor": { "source": "iana" },
  "application/ace-trl+cbor": { "source": "iana" },
  "application/activemessage": { "source": "iana" },
  "application/activity+json": { "source": "iana", "compressible": true },
  "application/aif+cbor": { "source": "iana" },
  "application/aif+json": { "source": "iana", "compressible": true },
  "application/alto-cdni+json": { "source": "iana", "compressible": true },
  "application/alto-cdnifilter+json": { "source": "iana", "compressible": true },
  "application/alto-costmap+json": { "source": "iana", "compressible": true },
  "application/alto-costmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-directory+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcost+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcostparams+json": { "source": "iana", "compressible": true },
  "application/alto-endpointprop+json": { "source": "iana", "compressible": true },
  "application/alto-endpointpropparams+json": { "source": "iana", "compressible": true },
  "application/alto-error+json": { "source": "iana", "compressible": true },
  "application/alto-networkmap+json": { "source": "iana", "compressible": true },
  "application/alto-networkmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-propmap+json": { "source": "iana", "compressible": true },
  "application/alto-propmapparams+json": { "source": "iana", "compressible": true },
  "application/alto-tips+json": { "source": "iana", "compressible": true },
  "application/alto-tipsparams+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamcontrol+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamparams+json": { "source": "iana", "compressible": true },
  "application/aml": { "source": "iana" },
  "application/andrew-inset": { "source": "iana", "extensions": ["ez"] },
  "application/appinstaller": { "compressible": false, "extensions": ["appinstaller"] },
  "application/applefile": { "source": "iana" },
  "application/applixware": { "source": "apache", "extensions": ["aw"] },
  "application/appx": { "compressible": false, "extensions": ["appx"] },
  "application/appxbundle": { "compressible": false, "extensions": ["appxbundle"] },
  "application/at+jwt": { "source": "iana" },
  "application/atf": { "source": "iana" },
  "application/atfx": { "source": "iana" },
  "application/atom+xml": { "source": "iana", "compressible": true, "extensions": ["atom"] },
  "application/atomcat+xml": { "source": "iana", "compressible": true, "extensions": ["atomcat"] },
  "application/atomdeleted+xml": { "source": "iana", "compressible": true, "extensions": ["atomdeleted"] },
  "application/atomicmail": { "source": "iana" },
  "application/atomsvc+xml": { "source": "iana", "compressible": true, "extensions": ["atomsvc"] },
  "application/atsc-dwd+xml": { "source": "iana", "compressible": true, "extensions": ["dwd"] },
  "application/atsc-dynamic-event-message": { "source": "iana" },
  "application/atsc-held+xml": { "source": "iana", "compressible": true, "extensions": ["held"] },
  "application/atsc-rdt+json": { "source": "iana", "compressible": true },
  "application/atsc-rsat+xml": { "source": "iana", "compressible": true, "extensions": ["rsat"] },
  "application/atxml": { "source": "iana" },
  "application/auth-policy+xml": { "source": "iana", "compressible": true },
  "application/automationml-aml+xml": { "source": "iana", "compressible": true, "extensions": ["aml"] },
  "application/automationml-amlx+zip": { "source": "iana", "compressible": false, "extensions": ["amlx"] },
  "application/bacnet-xdd+zip": { "source": "iana", "compressible": false },
  "application/batch-smtp": { "source": "iana" },
  "application/bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/beep+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/bufr": { "source": "iana" },
  "application/c2pa": { "source": "iana" },
  "application/calendar+json": { "source": "iana", "compressible": true },
  "application/calendar+xml": { "source": "iana", "compressible": true, "extensions": ["xcs"] },
  "application/call-completion": { "source": "iana" },
  "application/cals-1840": { "source": "iana" },
  "application/captive+json": { "source": "iana", "compressible": true },
  "application/cbor": { "source": "iana" },
  "application/cbor-seq": { "source": "iana" },
  "application/cccex": { "source": "iana" },
  "application/ccmp+xml": { "source": "iana", "compressible": true },
  "application/ccxml+xml": { "source": "iana", "compressible": true, "extensions": ["ccxml"] },
  "application/cda+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/cdfx+xml": { "source": "iana", "compressible": true, "extensions": ["cdfx"] },
  "application/cdmi-capability": { "source": "iana", "extensions": ["cdmia"] },
  "application/cdmi-container": { "source": "iana", "extensions": ["cdmic"] },
  "application/cdmi-domain": { "source": "iana", "extensions": ["cdmid"] },
  "application/cdmi-object": { "source": "iana", "extensions": ["cdmio"] },
  "application/cdmi-queue": { "source": "iana", "extensions": ["cdmiq"] },
  "application/cdni": { "source": "iana" },
  "application/ce+cbor": { "source": "iana" },
  "application/cea": { "source": "iana" },
  "application/cea-2018+xml": { "source": "iana", "compressible": true },
  "application/cellml+xml": { "source": "iana", "compressible": true },
  "application/cfw": { "source": "iana" },
  "application/cid-edhoc+cbor-seq": { "source": "iana" },
  "application/city+json": { "source": "iana", "compressible": true },
  "application/city+json-seq": { "source": "iana" },
  "application/clr": { "source": "iana" },
  "application/clue+xml": { "source": "iana", "compressible": true },
  "application/clue_info+xml": { "source": "iana", "compressible": true },
  "application/cms": { "source": "iana" },
  "application/cnrp+xml": { "source": "iana", "compressible": true },
  "application/coap-eap": { "source": "iana" },
  "application/coap-group+json": { "source": "iana", "compressible": true },
  "application/coap-payload": { "source": "iana" },
  "application/commonground": { "source": "iana" },
  "application/concise-problem-details+cbor": { "source": "iana" },
  "application/conference-info+xml": { "source": "iana", "compressible": true },
  "application/cose": { "source": "iana" },
  "application/cose-key": { "source": "iana" },
  "application/cose-key-set": { "source": "iana" },
  "application/cose-x509": { "source": "iana" },
  "application/cpl+xml": { "source": "iana", "compressible": true, "extensions": ["cpl"] },
  "application/csrattrs": { "source": "iana" },
  "application/csta+xml": { "source": "iana", "compressible": true },
  "application/cstadata+xml": { "source": "iana", "compressible": true },
  "application/csvm+json": { "source": "iana", "compressible": true },
  "application/cu-seeme": { "source": "apache", "extensions": ["cu"] },
  "application/cwl": { "source": "iana", "extensions": ["cwl"] },
  "application/cwl+json": { "source": "iana", "compressible": true },
  "application/cwl+yaml": { "source": "iana" },
  "application/cwt": { "source": "iana" },
  "application/cybercash": { "source": "iana" },
  "application/dart": { "compressible": true },
  "application/dash+xml": { "source": "iana", "compressible": true, "extensions": ["mpd"] },
  "application/dash-patch+xml": { "source": "iana", "compressible": true, "extensions": ["mpp"] },
  "application/dashdelta": { "source": "iana" },
  "application/davmount+xml": { "source": "iana", "compressible": true, "extensions": ["davmount"] },
  "application/dca-rft": { "source": "iana" },
  "application/dcd": { "source": "iana" },
  "application/dec-dx": { "source": "iana" },
  "application/dialog-info+xml": { "source": "iana", "compressible": true },
  "application/dicom": { "source": "iana", "extensions": ["dcm"] },
  "application/dicom+json": { "source": "iana", "compressible": true },
  "application/dicom+xml": { "source": "iana", "compressible": true },
  "application/dii": { "source": "iana" },
  "application/dit": { "source": "iana" },
  "application/dns": { "source": "iana" },
  "application/dns+json": { "source": "iana", "compressible": true },
  "application/dns-message": { "source": "iana" },
  "application/docbook+xml": { "source": "apache", "compressible": true, "extensions": ["dbk"] },
  "application/dots+cbor": { "source": "iana" },
  "application/dpop+jwt": { "source": "iana" },
  "application/dskpp+xml": { "source": "iana", "compressible": true },
  "application/dssc+der": { "source": "iana", "extensions": ["dssc"] },
  "application/dssc+xml": { "source": "iana", "compressible": true, "extensions": ["xdssc"] },
  "application/dvcs": { "source": "iana" },
  "application/eat+cwt": { "source": "iana" },
  "application/eat+jwt": { "source": "iana" },
  "application/eat-bun+cbor": { "source": "iana" },
  "application/eat-bun+json": { "source": "iana", "compressible": true },
  "application/eat-ucs+cbor": { "source": "iana" },
  "application/eat-ucs+json": { "source": "iana", "compressible": true },
  "application/ecmascript": { "source": "apache", "compressible": true, "extensions": ["ecma"] },
  "application/edhoc+cbor-seq": { "source": "iana" },
  "application/edi-consent": { "source": "iana" },
  "application/edi-x12": { "source": "iana", "compressible": false },
  "application/edifact": { "source": "iana", "compressible": false },
  "application/efi": { "source": "iana" },
  "application/elm+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/elm+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.cap+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/emergencycalldata.comment+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.control+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.deviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.ecall.msd": { "source": "iana" },
  "application/emergencycalldata.legacyesn+json": { "source": "iana", "compressible": true },
  "application/emergencycalldata.providerinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.serviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.subscriberinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.veds+xml": { "source": "iana", "compressible": true },
  "application/emma+xml": { "source": "iana", "compressible": true, "extensions": ["emma"] },
  "application/emotionml+xml": { "source": "iana", "compressible": true, "extensions": ["emotionml"] },
  "application/encaprtp": { "source": "iana" },
  "application/entity-statement+jwt": { "source": "iana" },
  "application/epp+xml": { "source": "iana", "compressible": true },
  "application/epub+zip": { "source": "iana", "compressible": false, "extensions": ["epub"] },
  "application/eshop": { "source": "iana" },
  "application/exi": { "source": "iana", "extensions": ["exi"] },
  "application/expect-ct-report+json": { "source": "iana", "compressible": true },
  "application/express": { "source": "iana", "extensions": ["exp"] },
  "application/fastinfoset": { "source": "iana" },
  "application/fastsoap": { "source": "iana" },
  "application/fdf": { "source": "iana", "extensions": ["fdf"] },
  "application/fdt+xml": { "source": "iana", "compressible": true, "extensions": ["fdt"] },
  "application/fhir+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fhir+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fido.trusted-apps+json": { "compressible": true },
  "application/fits": { "source": "iana" },
  "application/flexfec": { "source": "iana" },
  "application/font-sfnt": { "source": "iana" },
  "application/font-tdpfr": { "source": "iana", "extensions": ["pfr"] },
  "application/font-woff": { "source": "iana", "compressible": false },
  "application/framework-attributes+xml": { "source": "iana", "compressible": true },
  "application/geo+json": { "source": "iana", "compressible": true, "extensions": ["geojson"] },
  "application/geo+json-seq": { "source": "iana" },
  "application/geopackage+sqlite3": { "source": "iana" },
  "application/geopose+json": { "source": "iana", "compressible": true },
  "application/geoxacml+json": { "source": "iana", "compressible": true },
  "application/geoxacml+xml": { "source": "iana", "compressible": true },
  "application/gltf-buffer": { "source": "iana" },
  "application/gml+xml": { "source": "iana", "compressible": true, "extensions": ["gml"] },
  "application/gnap-binding-jws": { "source": "iana" },
  "application/gnap-binding-jwsd": { "source": "iana" },
  "application/gnap-binding-rotation-jws": { "source": "iana" },
  "application/gnap-binding-rotation-jwsd": { "source": "iana" },
  "application/gpx+xml": { "source": "apache", "compressible": true, "extensions": ["gpx"] },
  "application/grib": { "source": "iana" },
  "application/gxf": { "source": "apache", "extensions": ["gxf"] },
  "application/gzip": { "source": "iana", "compressible": false, "extensions": ["gz"] },
  "application/h224": { "source": "iana" },
  "application/held+xml": { "source": "iana", "compressible": true },
  "application/hjson": { "extensions": ["hjson"] },
  "application/hl7v2+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/http": { "source": "iana" },
  "application/hyperstudio": { "source": "iana", "extensions": ["stk"] },
  "application/ibe-key-request+xml": { "source": "iana", "compressible": true },
  "application/ibe-pkg-reply+xml": { "source": "iana", "compressible": true },
  "application/ibe-pp-data": { "source": "iana" },
  "application/iges": { "source": "iana" },
  "application/im-iscomposing+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/index": { "source": "iana" },
  "application/index.cmd": { "source": "iana" },
  "application/index.obj": { "source": "iana" },
  "application/index.response": { "source": "iana" },
  "application/index.vnd": { "source": "iana" },
  "application/inkml+xml": { "source": "iana", "compressible": true, "extensions": ["ink", "inkml"] },
  "application/iotp": { "source": "iana" },
  "application/ipfix": { "source": "iana", "extensions": ["ipfix"] },
  "application/ipp": { "source": "iana" },
  "application/isup": { "source": "iana" },
  "application/its+xml": { "source": "iana", "compressible": true, "extensions": ["its"] },
  "application/java-archive": { "source": "iana", "compressible": false, "extensions": ["jar", "war", "ear"] },
  "application/java-serialized-object": { "source": "apache", "compressible": false, "extensions": ["ser"] },
  "application/java-vm": { "source": "apache", "compressible": false, "extensions": ["class"] },
  "application/javascript": { "source": "apache", "charset": "UTF-8", "compressible": true, "extensions": ["js"] },
  "application/jf2feed+json": { "source": "iana", "compressible": true },
  "application/jose": { "source": "iana" },
  "application/jose+json": { "source": "iana", "compressible": true },
  "application/jrd+json": { "source": "iana", "compressible": true },
  "application/jscalendar+json": { "source": "iana", "compressible": true },
  "application/jscontact+json": { "source": "iana", "compressible": true },
  "application/json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["json", "map"] },
  "application/json-patch+json": { "source": "iana", "compressible": true },
  "application/json-seq": { "source": "iana" },
  "application/json5": { "extensions": ["json5"] },
  "application/jsonml+json": { "source": "apache", "compressible": true, "extensions": ["jsonml"] },
  "application/jsonpath": { "source": "iana" },
  "application/jwk+json": { "source": "iana", "compressible": true },
  "application/jwk-set+json": { "source": "iana", "compressible": true },
  "application/jwk-set+jwt": { "source": "iana" },
  "application/jwt": { "source": "iana" },
  "application/kpml-request+xml": { "source": "iana", "compressible": true },
  "application/kpml-response+xml": { "source": "iana", "compressible": true },
  "application/ld+json": { "source": "iana", "compressible": true, "extensions": ["jsonld"] },
  "application/lgr+xml": { "source": "iana", "compressible": true, "extensions": ["lgr"] },
  "application/link-format": { "source": "iana" },
  "application/linkset": { "source": "iana" },
  "application/linkset+json": { "source": "iana", "compressible": true },
  "application/load-control+xml": { "source": "iana", "compressible": true },
  "application/logout+jwt": { "source": "iana" },
  "application/lost+xml": { "source": "iana", "compressible": true, "extensions": ["lostxml"] },
  "application/lostsync+xml": { "source": "iana", "compressible": true },
  "application/lpf+zip": { "source": "iana", "compressible": false },
  "application/lxf": { "source": "iana" },
  "application/mac-binhex40": { "source": "iana", "extensions": ["hqx"] },
  "application/mac-compactpro": { "source": "apache", "extensions": ["cpt"] },
  "application/macwriteii": { "source": "iana" },
  "application/mads+xml": { "source": "iana", "compressible": true, "extensions": ["mads"] },
  "application/manifest+json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["webmanifest"] },
  "application/marc": { "source": "iana", "extensions": ["mrc"] },
  "application/marcxml+xml": { "source": "iana", "compressible": true, "extensions": ["mrcx"] },
  "application/mathematica": { "source": "iana", "extensions": ["ma", "nb", "mb"] },
  "application/mathml+xml": { "source": "iana", "compressible": true, "extensions": ["mathml"] },
  "application/mathml-content+xml": { "source": "iana", "compressible": true },
  "application/mathml-presentation+xml": { "source": "iana", "compressible": true },
  "application/mbms-associated-procedure-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-deregister+xml": { "source": "iana", "compressible": true },
  "application/mbms-envelope+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-protection-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-reception-report+xml": { "source": "iana", "compressible": true },
  "application/mbms-register+xml": { "source": "iana", "compressible": true },
  "application/mbms-register-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-schedule+xml": { "source": "iana", "compressible": true },
  "application/mbms-user-service-description+xml": { "source": "iana", "compressible": true },
  "application/mbox": { "source": "iana", "extensions": ["mbox"] },
  "application/media-policy-dataset+xml": { "source": "iana", "compressible": true, "extensions": ["mpf"] },
  "application/media_control+xml": { "source": "iana", "compressible": true },
  "application/mediaservercontrol+xml": { "source": "iana", "compressible": true, "extensions": ["mscml"] },
  "application/merge-patch+json": { "source": "iana", "compressible": true },
  "application/metalink+xml": { "source": "apache", "compressible": true, "extensions": ["metalink"] },
  "application/metalink4+xml": { "source": "iana", "compressible": true, "extensions": ["meta4"] },
  "application/mets+xml": { "source": "iana", "compressible": true, "extensions": ["mets"] },
  "application/mf4": { "source": "iana" },
  "application/mikey": { "source": "iana" },
  "application/mipc": { "source": "iana" },
  "application/missing-blocks+cbor-seq": { "source": "iana" },
  "application/mmt-aei+xml": { "source": "iana", "compressible": true, "extensions": ["maei"] },
  "application/mmt-usd+xml": { "source": "iana", "compressible": true, "extensions": ["musd"] },
  "application/mods+xml": { "source": "iana", "compressible": true, "extensions": ["mods"] },
  "application/moss-keys": { "source": "iana" },
  "application/moss-signature": { "source": "iana" },
  "application/mosskey-data": { "source": "iana" },
  "application/mosskey-request": { "source": "iana" },
  "application/mp21": { "source": "iana", "extensions": ["m21", "mp21"] },
  "application/mp4": { "source": "iana", "extensions": ["mp4", "mpg4", "mp4s", "m4p"] },
  "application/mpeg4-generic": { "source": "iana" },
  "application/mpeg4-iod": { "source": "iana" },
  "application/mpeg4-iod-xmt": { "source": "iana" },
  "application/mrb-consumer+xml": { "source": "iana", "compressible": true },
  "application/mrb-publish+xml": { "source": "iana", "compressible": true },
  "application/msc-ivr+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msc-mixer+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msix": { "compressible": false, "extensions": ["msix"] },
  "application/msixbundle": { "compressible": false, "extensions": ["msixbundle"] },
  "application/msword": { "source": "iana", "compressible": false, "extensions": ["doc", "dot"] },
  "application/mud+json": { "source": "iana", "compressible": true },
  "application/multipart-core": { "source": "iana" },
  "application/mxf": { "source": "iana", "extensions": ["mxf"] },
  "application/n-quads": { "source": "iana", "extensions": ["nq"] },
  "application/n-triples": { "source": "iana", "extensions": ["nt"] },
  "application/nasdata": { "source": "iana" },
  "application/news-checkgroups": { "source": "iana", "charset": "US-ASCII" },
  "application/news-groupinfo": { "source": "iana", "charset": "US-ASCII" },
  "application/news-transmission": { "source": "iana" },
  "application/nlsml+xml": { "source": "iana", "compressible": true },
  "application/node": { "source": "iana", "extensions": ["cjs"] },
  "application/nss": { "source": "iana" },
  "application/oauth-authz-req+jwt": { "source": "iana" },
  "application/oblivious-dns-message": { "source": "iana" },
  "application/ocsp-request": { "source": "iana" },
  "application/ocsp-response": { "source": "iana" },
  "application/octet-stream": { "source": "iana", "compressible": true, "extensions": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"] },
  "application/oda": { "source": "iana", "extensions": ["oda"] },
  "application/odm+xml": { "source": "iana", "compressible": true },
  "application/odx": { "source": "iana" },
  "application/oebps-package+xml": { "source": "iana", "compressible": true, "extensions": ["opf"] },
  "application/ogg": { "source": "iana", "compressible": false, "extensions": ["ogx"] },
  "application/ohttp-keys": { "source": "iana" },
  "application/omdoc+xml": { "source": "apache", "compressible": true, "extensions": ["omdoc"] },
  "application/onenote": { "source": "apache", "extensions": ["onetoc", "onetoc2", "onetmp", "onepkg", "one", "onea"] },
  "application/opc-nodeset+xml": { "source": "iana", "compressible": true },
  "application/oscore": { "source": "iana" },
  "application/oxps": { "source": "iana", "extensions": ["oxps"] },
  "application/p21": { "source": "iana" },
  "application/p21+zip": { "source": "iana", "compressible": false },
  "application/p2p-overlay+xml": { "source": "iana", "compressible": true, "extensions": ["relo"] },
  "application/parityfec": { "source": "iana" },
  "application/passport": { "source": "iana" },
  "application/patch-ops-error+xml": { "source": "iana", "compressible": true, "extensions": ["xer"] },
  "application/pdf": { "source": "iana", "compressible": false, "extensions": ["pdf"] },
  "application/pdx": { "source": "iana" },
  "application/pem-certificate-chain": { "source": "iana" },
  "application/pgp-encrypted": { "source": "iana", "compressible": false, "extensions": ["pgp"] },
  "application/pgp-keys": { "source": "iana", "extensions": ["asc"] },
  "application/pgp-signature": { "source": "iana", "extensions": ["sig", "asc"] },
  "application/pics-rules": { "source": "apache", "extensions": ["prf"] },
  "application/pidf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pidf-diff+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pkcs10": { "source": "iana", "extensions": ["p10"] },
  "application/pkcs12": { "source": "iana" },
  "application/pkcs7-mime": { "source": "iana", "extensions": ["p7m", "p7c"] },
  "application/pkcs7-signature": { "source": "iana", "extensions": ["p7s"] },
  "application/pkcs8": { "source": "iana", "extensions": ["p8"] },
  "application/pkcs8-encrypted": { "source": "iana" },
  "application/pkix-attr-cert": { "source": "iana", "extensions": ["ac"] },
  "application/pkix-cert": { "source": "iana", "extensions": ["cer"] },
  "application/pkix-crl": { "source": "iana", "extensions": ["crl"] },
  "application/pkix-pkipath": { "source": "iana", "extensions": ["pkipath"] },
  "application/pkixcmp": { "source": "iana", "extensions": ["pki"] },
  "application/pls+xml": { "source": "iana", "compressible": true, "extensions": ["pls"] },
  "application/poc-settings+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/postscript": { "source": "iana", "compressible": true, "extensions": ["ai", "eps", "ps"] },
  "application/ppsp-tracker+json": { "source": "iana", "compressible": true },
  "application/private-token-issuer-directory": { "source": "iana" },
  "application/private-token-request": { "source": "iana" },
  "application/private-token-response": { "source": "iana" },
  "application/problem+json": { "source": "iana", "compressible": true },
  "application/problem+xml": { "source": "iana", "compressible": true },
  "application/provenance+xml": { "source": "iana", "compressible": true, "extensions": ["provx"] },
  "application/provided-claims+jwt": { "source": "iana" },
  "application/prs.alvestrand.titrax-sheet": { "source": "iana" },
  "application/prs.cww": { "source": "iana", "extensions": ["cww"] },
  "application/prs.cyn": { "source": "iana", "charset": "7-BIT" },
  "application/prs.hpub+zip": { "source": "iana", "compressible": false },
  "application/prs.implied-document+xml": { "source": "iana", "compressible": true },
  "application/prs.implied-executable": { "source": "iana" },
  "application/prs.implied-object+json": { "source": "iana", "compressible": true },
  "application/prs.implied-object+json-seq": { "source": "iana" },
  "application/prs.implied-object+yaml": { "source": "iana" },
  "application/prs.implied-structure": { "source": "iana" },
  "application/prs.mayfile": { "source": "iana" },
  "application/prs.nprend": { "source": "iana" },
  "application/prs.plucker": { "source": "iana" },
  "application/prs.rdf-xml-crypt": { "source": "iana" },
  "application/prs.vcfbzip2": { "source": "iana" },
  "application/prs.xsf+xml": { "source": "iana", "compressible": true, "extensions": ["xsf"] },
  "application/pskc+xml": { "source": "iana", "compressible": true, "extensions": ["pskcxml"] },
  "application/pvd+json": { "source": "iana", "compressible": true },
  "application/qsig": { "source": "iana" },
  "application/raml+yaml": { "compressible": true, "extensions": ["raml"] },
  "application/raptorfec": { "source": "iana" },
  "application/rdap+json": { "source": "iana", "compressible": true },
  "application/rdf+xml": { "source": "iana", "compressible": true, "extensions": ["rdf", "owl"] },
  "application/reginfo+xml": { "source": "iana", "compressible": true, "extensions": ["rif"] },
  "application/relax-ng-compact-syntax": { "source": "iana", "extensions": ["rnc"] },
  "application/remote-printing": { "source": "apache" },
  "application/reputon+json": { "source": "iana", "compressible": true },
  "application/resolve-response+jwt": { "source": "iana" },
  "application/resource-lists+xml": { "source": "iana", "compressible": true, "extensions": ["rl"] },
  "application/resource-lists-diff+xml": { "source": "iana", "compressible": true, "extensions": ["rld"] },
  "application/rfc+xml": { "source": "iana", "compressible": true },
  "application/riscos": { "source": "iana" },
  "application/rlmi+xml": { "source": "iana", "compressible": true },
  "application/rls-services+xml": { "source": "iana", "compressible": true, "extensions": ["rs"] },
  "application/route-apd+xml": { "source": "iana", "compressible": true, "extensions": ["rapd"] },
  "application/route-s-tsid+xml": { "source": "iana", "compressible": true, "extensions": ["sls"] },
  "application/route-usd+xml": { "source": "iana", "compressible": true, "extensions": ["rusd"] },
  "application/rpki-checklist": { "source": "iana" },
  "application/rpki-ghostbusters": { "source": "iana", "extensions": ["gbr"] },
  "application/rpki-manifest": { "source": "iana", "extensions": ["mft"] },
  "application/rpki-publication": { "source": "iana" },
  "application/rpki-roa": { "source": "iana", "extensions": ["roa"] },
  "application/rpki-signed-tal": { "source": "iana" },
  "application/rpki-updown": { "source": "iana" },
  "application/rsd+xml": { "source": "apache", "compressible": true, "extensions": ["rsd"] },
  "application/rss+xml": { "source": "apache", "compressible": true, "extensions": ["rss"] },
  "application/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "application/rtploopback": { "source": "iana" },
  "application/rtx": { "source": "iana" },
  "application/samlassertion+xml": { "source": "iana", "compressible": true },
  "application/samlmetadata+xml": { "source": "iana", "compressible": true },
  "application/sarif+json": { "source": "iana", "compressible": true },
  "application/sarif-external-properties+json": { "source": "iana", "compressible": true },
  "application/sbe": { "source": "iana" },
  "application/sbml+xml": { "source": "iana", "compressible": true, "extensions": ["sbml"] },
  "application/scaip+xml": { "source": "iana", "compressible": true },
  "application/scim+json": { "source": "iana", "compressible": true },
  "application/scvp-cv-request": { "source": "iana", "extensions": ["scq"] },
  "application/scvp-cv-response": { "source": "iana", "extensions": ["scs"] },
  "application/scvp-vp-request": { "source": "iana", "extensions": ["spq"] },
  "application/scvp-vp-response": { "source": "iana", "extensions": ["spp"] },
  "application/sdp": { "source": "iana", "extensions": ["sdp"] },
  "application/secevent+jwt": { "source": "iana" },
  "application/senml+cbor": { "source": "iana" },
  "application/senml+json": { "source": "iana", "compressible": true },
  "application/senml+xml": { "source": "iana", "compressible": true, "extensions": ["senmlx"] },
  "application/senml-etch+cbor": { "source": "iana" },
  "application/senml-etch+json": { "source": "iana", "compressible": true },
  "application/senml-exi": { "source": "iana" },
  "application/sensml+cbor": { "source": "iana" },
  "application/sensml+json": { "source": "iana", "compressible": true },
  "application/sensml+xml": { "source": "iana", "compressible": true, "extensions": ["sensmlx"] },
  "application/sensml-exi": { "source": "iana" },
  "application/sep+xml": { "source": "iana", "compressible": true },
  "application/sep-exi": { "source": "iana" },
  "application/session-info": { "source": "iana" },
  "application/set-payment": { "source": "iana" },
  "application/set-payment-initiation": { "source": "iana", "extensions": ["setpay"] },
  "application/set-registration": { "source": "iana" },
  "application/set-registration-initiation": { "source": "iana", "extensions": ["setreg"] },
  "application/sgml": { "source": "iana" },
  "application/sgml-open-catalog": { "source": "iana" },
  "application/shf+xml": { "source": "iana", "compressible": true, "extensions": ["shf"] },
  "application/sieve": { "source": "iana", "extensions": ["siv", "sieve"] },
  "application/simple-filter+xml": { "source": "iana", "compressible": true },
  "application/simple-message-summary": { "source": "iana" },
  "application/simplesymbolcontainer": { "source": "iana" },
  "application/sipc": { "source": "iana" },
  "application/slate": { "source": "iana" },
  "application/smil": { "source": "apache" },
  "application/smil+xml": { "source": "iana", "compressible": true, "extensions": ["smi", "smil"] },
  "application/smpte336m": { "source": "iana" },
  "application/soap+fastinfoset": { "source": "iana" },
  "application/soap+xml": { "source": "iana", "compressible": true },
  "application/sparql-query": { "source": "iana", "extensions": ["rq"] },
  "application/sparql-results+xml": { "source": "iana", "compressible": true, "extensions": ["srx"] },
  "application/spdx+json": { "source": "iana", "compressible": true },
  "application/spirits-event+xml": { "source": "iana", "compressible": true },
  "application/sql": { "source": "iana", "extensions": ["sql"] },
  "application/srgs": { "source": "iana", "extensions": ["gram"] },
  "application/srgs+xml": { "source": "iana", "compressible": true, "extensions": ["grxml"] },
  "application/sru+xml": { "source": "iana", "compressible": true, "extensions": ["sru"] },
  "application/ssdl+xml": { "source": "apache", "compressible": true, "extensions": ["ssdl"] },
  "application/sslkeylogfile": { "source": "iana" },
  "application/ssml+xml": { "source": "iana", "compressible": true, "extensions": ["ssml"] },
  "application/st2110-41": { "source": "iana" },
  "application/stix+json": { "source": "iana", "compressible": true },
  "application/stratum": { "source": "iana" },
  "application/swid+cbor": { "source": "iana" },
  "application/swid+xml": { "source": "iana", "compressible": true, "extensions": ["swidtag"] },
  "application/tamp-apex-update": { "source": "iana" },
  "application/tamp-apex-update-confirm": { "source": "iana" },
  "application/tamp-community-update": { "source": "iana" },
  "application/tamp-community-update-confirm": { "source": "iana" },
  "application/tamp-error": { "source": "iana" },
  "application/tamp-sequence-adjust": { "source": "iana" },
  "application/tamp-sequence-adjust-confirm": { "source": "iana" },
  "application/tamp-status-query": { "source": "iana" },
  "application/tamp-status-response": { "source": "iana" },
  "application/tamp-update": { "source": "iana" },
  "application/tamp-update-confirm": { "source": "iana" },
  "application/tar": { "compressible": true },
  "application/taxii+json": { "source": "iana", "compressible": true },
  "application/td+json": { "source": "iana", "compressible": true },
  "application/tei+xml": { "source": "iana", "compressible": true, "extensions": ["tei", "teicorpus"] },
  "application/tetra_isi": { "source": "iana" },
  "application/thraud+xml": { "source": "iana", "compressible": true, "extensions": ["tfi"] },
  "application/timestamp-query": { "source": "iana" },
  "application/timestamp-reply": { "source": "iana" },
  "application/timestamped-data": { "source": "iana", "extensions": ["tsd"] },
  "application/tlsrpt+gzip": { "source": "iana" },
  "application/tlsrpt+json": { "source": "iana", "compressible": true },
  "application/tm+json": { "source": "iana", "compressible": true },
  "application/tnauthlist": { "source": "iana" },
  "application/toc+cbor": { "source": "iana" },
  "application/token-introspection+jwt": { "source": "iana" },
  "application/toml": { "source": "iana", "compressible": true, "extensions": ["toml"] },
  "application/trickle-ice-sdpfrag": { "source": "iana" },
  "application/trig": { "source": "iana", "extensions": ["trig"] },
  "application/trust-chain+json": { "source": "iana", "compressible": true },
  "application/trust-mark+jwt": { "source": "iana" },
  "application/trust-mark-delegation+jwt": { "source": "iana" },
  "application/ttml+xml": { "source": "iana", "compressible": true, "extensions": ["ttml"] },
  "application/tve-trigger": { "source": "iana" },
  "application/tzif": { "source": "iana" },
  "application/tzif-leap": { "source": "iana" },
  "application/ubjson": { "compressible": false, "extensions": ["ubj"] },
  "application/uccs+cbor": { "source": "iana" },
  "application/ujcs+json": { "source": "iana", "compressible": true },
  "application/ulpfec": { "source": "iana" },
  "application/urc-grpsheet+xml": { "source": "iana", "compressible": true },
  "application/urc-ressheet+xml": { "source": "iana", "compressible": true, "extensions": ["rsheet"] },
  "application/urc-targetdesc+xml": { "source": "iana", "compressible": true, "extensions": ["td"] },
  "application/urc-uisocketdesc+xml": { "source": "iana", "compressible": true },
  "application/vc": { "source": "iana" },
  "application/vc+cose": { "source": "iana" },
  "application/vc+jwt": { "source": "iana" },
  "application/vcard+json": { "source": "iana", "compressible": true },
  "application/vcard+xml": { "source": "iana", "compressible": true },
  "application/vemmi": { "source": "iana" },
  "application/vividence.scriptfile": { "source": "apache" },
  "application/vnd.1000minds.decision-model+xml": { "source": "iana", "compressible": true, "extensions": ["1km"] },
  "application/vnd.1ob": { "source": "iana" },
  "application/vnd.3gpp-prose+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3a+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3ach+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3ch+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc8+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-v2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.5gnas": { "source": "iana" },
  "application/vnd.3gpp.5gsa2x": { "source": "iana" },
  "application/vnd.3gpp.5gsa2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.5gsv2x": { "source": "iana" },
  "application/vnd.3gpp.5gsv2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.access-transfer-events+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.bsf+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.crs+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.current-location-discovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gmop+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gtpc": { "source": "iana" },
  "application/vnd.3gpp.interworking-data": { "source": "iana" },
  "application/vnd.3gpp.lpp": { "source": "iana" },
  "application/vnd.3gpp.mc-signalling-ear": { "source": "iana" },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-msgstore-ctrl-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-payload": { "source": "iana" },
  "application/vnd.3gpp.mcdata-regroup+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-signalling": { "source": "iana" },
  "application/vnd.3gpp.mcdata-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-floor-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-regroup+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-signed+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-regroup+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mid-call+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ngap": { "source": "iana" },
  "application/vnd.3gpp.pfcp": { "source": "iana" },
  "application/vnd.3gpp.pic-bw-large": { "source": "iana", "extensions": ["plb"] },
  "application/vnd.3gpp.pic-bw-small": { "source": "iana", "extensions": ["psb"] },
  "application/vnd.3gpp.pic-bw-var": { "source": "iana", "extensions": ["pvb"] },
  "application/vnd.3gpp.pinapp-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.s1ap": { "source": "iana" },
  "application/vnd.3gpp.seal-group-doc+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-network-qos-management-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-ue-config-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-unicast-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-user-profile-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.sms": { "source": "iana" },
  "application/vnd.3gpp.sms+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-ext+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.state-and-event-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ussd+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.v2x": { "source": "iana" },
  "application/vnd.3gpp.vae-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.bcmcsinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.sms": { "source": "iana" },
  "application/vnd.3gpp2.tcap": { "source": "iana", "extensions": ["tcap"] },
  "application/vnd.3lightssoftware.imagescal": { "source": "iana" },
  "application/vnd.3m.post-it-notes": { "source": "iana", "extensions": ["pwn"] },
  "application/vnd.accpac.simply.aso": { "source": "iana", "extensions": ["aso"] },
  "application/vnd.accpac.simply.imp": { "source": "iana", "extensions": ["imp"] },
  "application/vnd.acm.addressxfer+json": { "source": "iana", "compressible": true },
  "application/vnd.acm.chatbot+json": { "source": "iana", "compressible": true },
  "application/vnd.acucobol": { "source": "iana", "extensions": ["acu"] },
  "application/vnd.acucorp": { "source": "iana", "extensions": ["atc", "acutc"] },
  "application/vnd.adobe.air-application-installer-package+zip": { "source": "apache", "compressible": false, "extensions": ["air"] },
  "application/vnd.adobe.flash.movie": { "source": "iana" },
  "application/vnd.adobe.formscentral.fcdt": { "source": "iana", "extensions": ["fcdt"] },
  "application/vnd.adobe.fxp": { "source": "iana", "extensions": ["fxp", "fxpl"] },
  "application/vnd.adobe.partial-upload": { "source": "iana" },
  "application/vnd.adobe.xdp+xml": { "source": "iana", "compressible": true, "extensions": ["xdp"] },
  "application/vnd.adobe.xfdf": { "source": "apache", "extensions": ["xfdf"] },
  "application/vnd.aether.imp": { "source": "iana" },
  "application/vnd.afpc.afplinedata": { "source": "iana" },
  "application/vnd.afpc.afplinedata-pagedef": { "source": "iana" },
  "application/vnd.afpc.cmoca-cmresource": { "source": "iana" },
  "application/vnd.afpc.foca-charset": { "source": "iana" },
  "application/vnd.afpc.foca-codedfont": { "source": "iana" },
  "application/vnd.afpc.foca-codepage": { "source": "iana" },
  "application/vnd.afpc.modca": { "source": "iana" },
  "application/vnd.afpc.modca-cmtable": { "source": "iana" },
  "application/vnd.afpc.modca-formdef": { "source": "iana" },
  "application/vnd.afpc.modca-mediummap": { "source": "iana" },
  "application/vnd.afpc.modca-objectcontainer": { "source": "iana" },
  "application/vnd.afpc.modca-overlay": { "source": "iana" },
  "application/vnd.afpc.modca-pagesegment": { "source": "iana" },
  "application/vnd.age": { "source": "iana", "extensions": ["age"] },
  "application/vnd.ah-barcode": { "source": "apache" },
  "application/vnd.ahead.space": { "source": "iana", "extensions": ["ahead"] },
  "application/vnd.airzip.filesecure.azf": { "source": "iana", "extensions": ["azf"] },
  "application/vnd.airzip.filesecure.azs": { "source": "iana", "extensions": ["azs"] },
  "application/vnd.amadeus+json": { "source": "iana", "compressible": true },
  "application/vnd.amazon.ebook": { "source": "apache", "extensions": ["azw"] },
  "application/vnd.amazon.mobi8-ebook": { "source": "iana" },
  "application/vnd.americandynamics.acc": { "source": "iana", "extensions": ["acc"] },
  "application/vnd.amiga.ami": { "source": "iana", "extensions": ["ami"] },
  "application/vnd.amundsen.maze+xml": { "source": "iana", "compressible": true },
  "application/vnd.android.ota": { "source": "iana" },
  "application/vnd.android.package-archive": { "source": "apache", "compressible": false, "extensions": ["apk"] },
  "application/vnd.anki": { "source": "iana" },
  "application/vnd.anser-web-certificate-issue-initiation": { "source": "iana", "extensions": ["cii"] },
  "application/vnd.anser-web-funds-transfer-initiation": { "source": "apache", "extensions": ["fti"] },
  "application/vnd.antix.game-component": { "source": "iana", "extensions": ["atx"] },
  "application/vnd.apache.arrow.file": { "source": "iana" },
  "application/vnd.apache.arrow.stream": { "source": "iana" },
  "application/vnd.apache.parquet": { "source": "iana" },
  "application/vnd.apache.thrift.binary": { "source": "iana" },
  "application/vnd.apache.thrift.compact": { "source": "iana" },
  "application/vnd.apache.thrift.json": { "source": "iana" },
  "application/vnd.apexlang": { "source": "iana" },
  "application/vnd.api+json": { "source": "iana", "compressible": true },
  "application/vnd.aplextor.warrp+json": { "source": "iana", "compressible": true },
  "application/vnd.apothekende.reservation+json": { "source": "iana", "compressible": true },
  "application/vnd.apple.installer+xml": { "source": "iana", "compressible": true, "extensions": ["mpkg"] },
  "application/vnd.apple.keynote": { "source": "iana", "extensions": ["key"] },
  "application/vnd.apple.mpegurl": { "source": "iana", "extensions": ["m3u8"] },
  "application/vnd.apple.numbers": { "source": "iana", "extensions": ["numbers"] },
  "application/vnd.apple.pages": { "source": "iana", "extensions": ["pages"] },
  "application/vnd.apple.pkpass": { "compressible": false, "extensions": ["pkpass"] },
  "application/vnd.arastra.swi": { "source": "apache" },
  "application/vnd.aristanetworks.swi": { "source": "iana", "extensions": ["swi"] },
  "application/vnd.artisan+json": { "source": "iana", "compressible": true },
  "application/vnd.artsquare": { "source": "iana" },
  "application/vnd.astraea-software.iota": { "source": "iana", "extensions": ["iota"] },
  "application/vnd.audiograph": { "source": "iana", "extensions": ["aep"] },
  "application/vnd.autodesk.fbx": { "extensions": ["fbx"] },
  "application/vnd.autopackage": { "source": "iana" },
  "application/vnd.avalon+json": { "source": "iana", "compressible": true },
  "application/vnd.avistar+xml": { "source": "iana", "compressible": true },
  "application/vnd.balsamiq.bmml+xml": { "source": "iana", "compressible": true, "extensions": ["bmml"] },
  "application/vnd.balsamiq.bmpr": { "source": "iana" },
  "application/vnd.banana-accounting": { "source": "iana" },
  "application/vnd.bbf.usp.error": { "source": "iana" },
  "application/vnd.bbf.usp.msg": { "source": "iana" },
  "application/vnd.bbf.usp.msg+json": { "source": "iana", "compressible": true },
  "application/vnd.bekitzur-stech+json": { "source": "iana", "compressible": true },
  "application/vnd.belightsoft.lhzd+zip": { "source": "iana", "compressible": false },
  "application/vnd.belightsoft.lhzl+zip": { "source": "iana", "compressible": false },
  "application/vnd.bint.med-content": { "source": "iana" },
  "application/vnd.biopax.rdf+xml": { "source": "iana", "compressible": true },
  "application/vnd.blink-idb-value-wrapper": { "source": "iana" },
  "application/vnd.blueice.multipass": { "source": "iana", "extensions": ["mpm"] },
  "application/vnd.bluetooth.ep.oob": { "source": "iana" },
  "application/vnd.bluetooth.le.oob": { "source": "iana" },
  "application/vnd.bmi": { "source": "iana", "extensions": ["bmi"] },
  "application/vnd.bpf": { "source": "iana" },
  "application/vnd.bpf3": { "source": "iana" },
  "application/vnd.businessobjects": { "source": "iana", "extensions": ["rep"] },
  "application/vnd.byu.uapi+json": { "source": "iana", "compressible": true },
  "application/vnd.bzip3": { "source": "iana" },
  "application/vnd.c3voc.schedule+xml": { "source": "iana", "compressible": true },
  "application/vnd.cab-jscript": { "source": "iana" },
  "application/vnd.canon-cpdl": { "source": "iana" },
  "application/vnd.canon-lips": { "source": "iana" },
  "application/vnd.capasystems-pg+json": { "source": "iana", "compressible": true },
  "application/vnd.cendio.thinlinc.clientconf": { "source": "iana" },
  "application/vnd.century-systems.tcp_stream": { "source": "iana" },
  "application/vnd.chemdraw+xml": { "source": "iana", "compressible": true, "extensions": ["cdxml"] },
  "application/vnd.chess-pgn": { "source": "iana" },
  "application/vnd.chipnuts.karaoke-mmd": { "source": "iana", "extensions": ["mmd"] },
  "application/vnd.ciedi": { "source": "iana" },
  "application/vnd.cinderella": { "source": "iana", "extensions": ["cdy"] },
  "application/vnd.cirpack.isdn-ext": { "source": "iana" },
  "application/vnd.citationstyles.style+xml": { "source": "iana", "compressible": true, "extensions": ["csl"] },
  "application/vnd.claymore": { "source": "iana", "extensions": ["cla"] },
  "application/vnd.cloanto.rp9": { "source": "iana", "extensions": ["rp9"] },
  "application/vnd.clonk.c4group": { "source": "iana", "extensions": ["c4g", "c4d", "c4f", "c4p", "c4u"] },
  "application/vnd.cluetrust.cartomobile-config": { "source": "iana", "extensions": ["c11amc"] },
  "application/vnd.cluetrust.cartomobile-config-pkg": { "source": "iana", "extensions": ["c11amz"] },
  "application/vnd.cncf.helm.chart.content.v1.tar+gzip": { "source": "iana" },
  "application/vnd.cncf.helm.chart.provenance.v1.prov": { "source": "iana" },
  "application/vnd.cncf.helm.config.v1+json": { "source": "iana", "compressible": true },
  "application/vnd.coffeescript": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet-template": { "source": "iana" },
  "application/vnd.collection+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.doc+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.next+json": { "source": "iana", "compressible": true },
  "application/vnd.comicbook+zip": { "source": "iana", "compressible": false },
  "application/vnd.comicbook-rar": { "source": "iana" },
  "application/vnd.commerce-battelle": { "source": "iana" },
  "application/vnd.commonspace": { "source": "iana", "extensions": ["csp"] },
  "application/vnd.contact.cmsg": { "source": "iana", "extensions": ["cdbcmsg"] },
  "application/vnd.coreos.ignition+json": { "source": "iana", "compressible": true },
  "application/vnd.cosmocaller": { "source": "iana", "extensions": ["cmc"] },
  "application/vnd.crick.clicker": { "source": "iana", "extensions": ["clkx"] },
  "application/vnd.crick.clicker.keyboard": { "source": "iana", "extensions": ["clkk"] },
  "application/vnd.crick.clicker.palette": { "source": "iana", "extensions": ["clkp"] },
  "application/vnd.crick.clicker.template": { "source": "iana", "extensions": ["clkt"] },
  "application/vnd.crick.clicker.wordbank": { "source": "iana", "extensions": ["clkw"] },
  "application/vnd.criticaltools.wbs+xml": { "source": "iana", "compressible": true, "extensions": ["wbs"] },
  "application/vnd.cryptii.pipe+json": { "source": "iana", "compressible": true },
  "application/vnd.crypto-shade-file": { "source": "iana" },
  "application/vnd.cryptomator.encrypted": { "source": "iana" },
  "application/vnd.cryptomator.vault": { "source": "iana" },
  "application/vnd.ctc-posml": { "source": "iana", "extensions": ["pml"] },
  "application/vnd.ctct.ws+xml": { "source": "iana", "compressible": true },
  "application/vnd.cups-pdf": { "source": "iana" },
  "application/vnd.cups-postscript": { "source": "iana" },
  "application/vnd.cups-ppd": { "source": "iana", "extensions": ["ppd"] },
  "application/vnd.cups-raster": { "source": "iana" },
  "application/vnd.cups-raw": { "source": "iana" },
  "application/vnd.curl": { "source": "iana" },
  "application/vnd.curl.car": { "source": "apache", "extensions": ["car"] },
  "application/vnd.curl.pcurl": { "source": "apache", "extensions": ["pcurl"] },
  "application/vnd.cyan.dean.root+xml": { "source": "iana", "compressible": true },
  "application/vnd.cybank": { "source": "iana" },
  "application/vnd.cyclonedx+json": { "source": "iana", "compressible": true },
  "application/vnd.cyclonedx+xml": { "source": "iana", "compressible": true },
  "application/vnd.d2l.coursepackage1p0+zip": { "source": "iana", "compressible": false },
  "application/vnd.d3m-dataset": { "source": "iana" },
  "application/vnd.d3m-problem": { "source": "iana" },
  "application/vnd.dart": { "source": "iana", "compressible": true, "extensions": ["dart"] },
  "application/vnd.data-vision.rdz": { "source": "iana", "extensions": ["rdz"] },
  "application/vnd.datalog": { "source": "iana" },
  "application/vnd.datapackage+json": { "source": "iana", "compressible": true },
  "application/vnd.dataresource+json": { "source": "iana", "compressible": true },
  "application/vnd.dbf": { "source": "iana", "extensions": ["dbf"] },
  "application/vnd.dcmp+xml": { "source": "iana", "compressible": true, "extensions": ["dcmp"] },
  "application/vnd.debian.binary-package": { "source": "iana" },
  "application/vnd.dece.data": { "source": "iana", "extensions": ["uvf", "uvvf", "uvd", "uvvd"] },
  "application/vnd.dece.ttml+xml": { "source": "iana", "compressible": true, "extensions": ["uvt", "uvvt"] },
  "application/vnd.dece.unspecified": { "source": "iana", "extensions": ["uvx", "uvvx"] },
  "application/vnd.dece.zip": { "source": "iana", "extensions": ["uvz", "uvvz"] },
  "application/vnd.denovo.fcselayout-link": { "source": "iana", "extensions": ["fe_launch"] },
  "application/vnd.desmume.movie": { "source": "iana" },
  "application/vnd.dir-bi.plate-dl-nosuffix": { "source": "iana" },
  "application/vnd.dm.delegation+xml": { "source": "iana", "compressible": true },
  "application/vnd.dna": { "source": "iana", "extensions": ["dna"] },
  "application/vnd.document+json": { "source": "iana", "compressible": true },
  "application/vnd.dolby.mlp": { "source": "apache", "extensions": ["mlp"] },
  "application/vnd.dolby.mobile.1": { "source": "iana" },
  "application/vnd.dolby.mobile.2": { "source": "iana" },
  "application/vnd.doremir.scorecloud-binary-document": { "source": "iana" },
  "application/vnd.dpgraph": { "source": "iana", "extensions": ["dpg"] },
  "application/vnd.dreamfactory": { "source": "iana", "extensions": ["dfac"] },
  "application/vnd.drive+json": { "source": "iana", "compressible": true },
  "application/vnd.ds-keypoint": { "source": "apache", "extensions": ["kpxx"] },
  "application/vnd.dtg.local": { "source": "iana" },
  "application/vnd.dtg.local.flash": { "source": "iana" },
  "application/vnd.dtg.local.html": { "source": "iana" },
  "application/vnd.dvb.ait": { "source": "iana", "extensions": ["ait"] },
  "application/vnd.dvb.dvbisl+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.dvbj": { "source": "iana" },
  "application/vnd.dvb.esgcontainer": { "source": "iana" },
  "application/vnd.dvb.ipdcdftnotifaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess2": { "source": "iana" },
  "application/vnd.dvb.ipdcesgpdd": { "source": "iana" },
  "application/vnd.dvb.ipdcroaming": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-base": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-enhancement": { "source": "iana" },
  "application/vnd.dvb.notif-aggregate-root+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-container+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-generic+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-msglist+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-response+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-init+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.pfr": { "source": "iana" },
  "application/vnd.dvb.service": { "source": "iana", "extensions": ["svc"] },
  "application/vnd.dxr": { "source": "iana" },
  "application/vnd.dynageo": { "source": "iana", "extensions": ["geo"] },
  "application/vnd.dzr": { "source": "iana" },
  "application/vnd.easykaraoke.cdgdownload": { "source": "iana" },
  "application/vnd.ecdis-update": { "source": "iana" },
  "application/vnd.ecip.rlp": { "source": "iana" },
  "application/vnd.eclipse.ditto+json": { "source": "iana", "compressible": true },
  "application/vnd.ecowin.chart": { "source": "iana", "extensions": ["mag"] },
  "application/vnd.ecowin.filerequest": { "source": "iana" },
  "application/vnd.ecowin.fileupdate": { "source": "iana" },
  "application/vnd.ecowin.series": { "source": "iana" },
  "application/vnd.ecowin.seriesrequest": { "source": "iana" },
  "application/vnd.ecowin.seriesupdate": { "source": "iana" },
  "application/vnd.efi.img": { "source": "iana" },
  "application/vnd.efi.iso": { "source": "iana" },
  "application/vnd.eln+zip": { "source": "iana", "compressible": false },
  "application/vnd.emclient.accessrequest+xml": { "source": "iana", "compressible": true },
  "application/vnd.enliven": { "source": "iana", "extensions": ["nml"] },
  "application/vnd.enphase.envoy": { "source": "iana" },
  "application/vnd.eprints.data+xml": { "source": "iana", "compressible": true },
  "application/vnd.epson.esf": { "source": "iana", "extensions": ["esf"] },
  "application/vnd.epson.msf": { "source": "iana", "extensions": ["msf"] },
  "application/vnd.epson.quickanime": { "source": "iana", "extensions": ["qam"] },
  "application/vnd.epson.salt": { "source": "iana", "extensions": ["slt"] },
  "application/vnd.epson.ssf": { "source": "iana", "extensions": ["ssf"] },
  "application/vnd.ericsson.quickcall": { "source": "iana" },
  "application/vnd.erofs": { "source": "iana" },
  "application/vnd.espass-espass+zip": { "source": "iana", "compressible": false },
  "application/vnd.eszigno3+xml": { "source": "iana", "compressible": true, "extensions": ["es3", "et3"] },
  "application/vnd.etsi.aoc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.asic-e+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.asic-s+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.cug+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvcommand+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-bc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-cod+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-npvr+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvservice+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsync+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mcid+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mheg5": { "source": "iana" },
  "application/vnd.etsi.overload-control-policy-dataset+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.pstn+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.sci+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.simservs+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.timestamp-token": { "source": "iana" },
  "application/vnd.etsi.tsl+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.tsl.der": { "source": "iana" },
  "application/vnd.eu.kasparian.car+json": { "source": "iana", "compressible": true },
  "application/vnd.eudora.data": { "source": "iana" },
  "application/vnd.evolv.ecig.profile": { "source": "iana" },
  "application/vnd.evolv.ecig.settings": { "source": "iana" },
  "application/vnd.evolv.ecig.theme": { "source": "iana" },
  "application/vnd.exstream-empower+zip": { "source": "iana", "compressible": false },
  "application/vnd.exstream-package": { "source": "iana" },
  "application/vnd.ezpix-album": { "source": "iana", "extensions": ["ez2"] },
  "application/vnd.ezpix-package": { "source": "iana", "extensions": ["ez3"] },
  "application/vnd.f-secure.mobile": { "source": "iana" },
  "application/vnd.familysearch.gedcom+zip": { "source": "iana", "compressible": false },
  "application/vnd.fastcopy-disk-image": { "source": "iana" },
  "application/vnd.fdf": { "source": "apache", "extensions": ["fdf"] },
  "application/vnd.fdsn.mseed": { "source": "iana", "extensions": ["mseed"] },
  "application/vnd.fdsn.seed": { "source": "iana", "extensions": ["seed", "dataless"] },
  "application/vnd.fdsn.stationxml+xml": { "source": "iana", "charset": "XML-BASED", "compressible": true },
  "application/vnd.ffsns": { "source": "iana" },
  "application/vnd.ficlab.flb+zip": { "source": "iana", "compressible": false },
  "application/vnd.filmit.zfc": { "source": "iana" },
  "application/vnd.fints": { "source": "iana" },
  "application/vnd.firemonkeys.cloudcell": { "source": "iana" },
  "application/vnd.flographit": { "source": "iana", "extensions": ["gph"] },
  "application/vnd.fluxtime.clip": { "source": "iana", "extensions": ["ftc"] },
  "application/vnd.font-fontforge-sfd": { "source": "iana" },
  "application/vnd.framemaker": { "source": "iana", "extensions": ["fm", "frame", "maker", "book"] },
  "application/vnd.freelog.comic": { "source": "iana" },
  "application/vnd.frogans.fnc": { "source": "apache", "extensions": ["fnc"] },
  "application/vnd.frogans.ltf": { "source": "apache", "extensions": ["ltf"] },
  "application/vnd.fsc.weblaunch": { "source": "iana", "extensions": ["fsc"] },
  "application/vnd.fujifilm.fb.docuworks": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.binder": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.container": { "source": "iana" },
  "application/vnd.fujifilm.fb.jfi+xml": { "source": "iana", "compressible": true },
  "application/vnd.fujitsu.oasys": { "source": "iana", "extensions": ["oas"] },
  "application/vnd.fujitsu.oasys2": { "source": "iana", "extensions": ["oa2"] },
  "application/vnd.fujitsu.oasys3": { "source": "iana", "extensions": ["oa3"] },
  "application/vnd.fujitsu.oasysgp": { "source": "iana", "extensions": ["fg5"] },
  "application/vnd.fujitsu.oasysprs": { "source": "iana", "extensions": ["bh2"] },
  "application/vnd.fujixerox.art-ex": { "source": "iana" },
  "application/vnd.fujixerox.art4": { "source": "iana" },
  "application/vnd.fujixerox.ddd": { "source": "iana", "extensions": ["ddd"] },
  "application/vnd.fujixerox.docuworks": { "source": "iana", "extensions": ["xdw"] },
  "application/vnd.fujixerox.docuworks.binder": { "source": "iana", "extensions": ["xbd"] },
  "application/vnd.fujixerox.docuworks.container": { "source": "iana" },
  "application/vnd.fujixerox.hbpl": { "source": "iana" },
  "application/vnd.fut-misnet": { "source": "iana" },
  "application/vnd.futoin+cbor": { "source": "iana" },
  "application/vnd.futoin+json": { "source": "iana", "compressible": true },
  "application/vnd.fuzzysheet": { "source": "iana", "extensions": ["fzs"] },
  "application/vnd.ga4gh.passport+jwt": { "source": "iana" },
  "application/vnd.genomatix.tuxedo": { "source": "iana", "extensions": ["txd"] },
  "application/vnd.genozip": { "source": "iana" },
  "application/vnd.gentics.grd+json": { "source": "iana", "compressible": true },
  "application/vnd.gentoo.catmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.gentoo.ebuild": { "source": "iana" },
  "application/vnd.gentoo.eclass": { "source": "iana" },
  "application/vnd.gentoo.gpkg": { "source": "iana" },
  "application/vnd.gentoo.manifest": { "source": "iana" },
  "application/vnd.gentoo.pkgmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.gentoo.xpak": { "source": "iana" },
  "application/vnd.geo+json": { "source": "apache", "compressible": true },
  "application/vnd.geocube+xml": { "source": "apache", "compressible": true },
  "application/vnd.geogebra.file": { "source": "iana", "extensions": ["ggb"] },
  "application/vnd.geogebra.pinboard": { "source": "iana" },
  "application/vnd.geogebra.slides": { "source": "iana", "extensions": ["ggs"] },
  "application/vnd.geogebra.tool": { "source": "iana", "extensions": ["ggt"] },
  "application/vnd.geometry-explorer": { "source": "iana", "extensions": ["gex", "gre"] },
  "application/vnd.geonext": { "source": "iana", "extensions": ["gxt"] },
  "application/vnd.geoplan": { "source": "iana", "extensions": ["g2w"] },
  "application/vnd.geospace": { "source": "iana", "extensions": ["g3w"] },
  "application/vnd.gerber": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt-response": { "source": "iana" },
  "application/vnd.gmx": { "source": "iana", "extensions": ["gmx"] },
  "application/vnd.gnu.taler.exchange+json": { "source": "iana", "compressible": true },
  "application/vnd.gnu.taler.merchant+json": { "source": "iana", "compressible": true },
  "application/vnd.google-apps.audio": {},
  "application/vnd.google-apps.document": { "compressible": false, "extensions": ["gdoc"] },
  "application/vnd.google-apps.drawing": { "compressible": false, "extensions": ["gdraw"] },
  "application/vnd.google-apps.drive-sdk": { "compressible": false },
  "application/vnd.google-apps.file": {},
  "application/vnd.google-apps.folder": { "compressible": false },
  "application/vnd.google-apps.form": { "compressible": false, "extensions": ["gform"] },
  "application/vnd.google-apps.fusiontable": {},
  "application/vnd.google-apps.jam": { "compressible": false, "extensions": ["gjam"] },
  "application/vnd.google-apps.mail-layout": {},
  "application/vnd.google-apps.map": { "compressible": false, "extensions": ["gmap"] },
  "application/vnd.google-apps.photo": {},
  "application/vnd.google-apps.presentation": { "compressible": false, "extensions": ["gslides"] },
  "application/vnd.google-apps.script": { "compressible": false, "extensions": ["gscript"] },
  "application/vnd.google-apps.shortcut": {},
  "application/vnd.google-apps.site": { "compressible": false, "extensions": ["gsite"] },
  "application/vnd.google-apps.spreadsheet": { "compressible": false, "extensions": ["gsheet"] },
  "application/vnd.google-apps.unknown": {},
  "application/vnd.google-apps.video": {},
  "application/vnd.google-earth.kml+xml": { "source": "iana", "compressible": true, "extensions": ["kml"] },
  "application/vnd.google-earth.kmz": { "source": "iana", "compressible": false, "extensions": ["kmz"] },
  "application/vnd.gov.sk.e-form+xml": { "source": "apache", "compressible": true },
  "application/vnd.gov.sk.e-form+zip": { "source": "iana", "compressible": false },
  "application/vnd.gov.sk.xmldatacontainer+xml": { "source": "iana", "compressible": true, "extensions": ["xdcf"] },
  "application/vnd.gpxsee.map+xml": { "source": "iana", "compressible": true },
  "application/vnd.grafeq": { "source": "iana", "extensions": ["gqf", "gqs"] },
  "application/vnd.gridmp": { "source": "iana" },
  "application/vnd.groove-account": { "source": "iana", "extensions": ["gac"] },
  "application/vnd.groove-help": { "source": "iana", "extensions": ["ghf"] },
  "application/vnd.groove-identity-message": { "source": "iana", "extensions": ["gim"] },
  "application/vnd.groove-injector": { "source": "iana", "extensions": ["grv"] },
  "application/vnd.groove-tool-message": { "source": "iana", "extensions": ["gtm"] },
  "application/vnd.groove-tool-template": { "source": "iana", "extensions": ["tpl"] },
  "application/vnd.groove-vcard": { "source": "iana", "extensions": ["vcg"] },
  "application/vnd.hal+json": { "source": "iana", "compressible": true },
  "application/vnd.hal+xml": { "source": "iana", "compressible": true, "extensions": ["hal"] },
  "application/vnd.handheld-entertainment+xml": { "source": "iana", "compressible": true, "extensions": ["zmm"] },
  "application/vnd.hbci": { "source": "iana", "extensions": ["hbci"] },
  "application/vnd.hc+json": { "source": "iana", "compressible": true },
  "application/vnd.hcl-bireports": { "source": "iana" },
  "application/vnd.hdt": { "source": "iana" },
  "application/vnd.heroku+json": { "source": "iana", "compressible": true },
  "application/vnd.hhe.lesson-player": { "source": "iana", "extensions": ["les"] },
  "application/vnd.hp-hpgl": { "source": "iana", "extensions": ["hpgl"] },
  "application/vnd.hp-hpid": { "source": "iana", "extensions": ["hpid"] },
  "application/vnd.hp-hps": { "source": "iana", "extensions": ["hps"] },
  "application/vnd.hp-jlyt": { "source": "iana", "extensions": ["jlt"] },
  "application/vnd.hp-pcl": { "source": "iana", "extensions": ["pcl"] },
  "application/vnd.hp-pclxl": { "source": "iana", "extensions": ["pclxl"] },
  "application/vnd.hsl": { "source": "iana" },
  "application/vnd.httphone": { "source": "iana" },
  "application/vnd.hydrostatix.sof-data": { "source": "iana", "extensions": ["sfd-hdstx"] },
  "application/vnd.hyper+json": { "source": "iana", "compressible": true },
  "application/vnd.hyper-item+json": { "source": "iana", "compressible": true },
  "application/vnd.hyperdrive+json": { "source": "iana", "compressible": true },
  "application/vnd.hzn-3d-crossword": { "source": "iana" },
  "application/vnd.ibm.afplinedata": { "source": "apache" },
  "application/vnd.ibm.electronic-media": { "source": "iana" },
  "application/vnd.ibm.minipay": { "source": "iana", "extensions": ["mpy"] },
  "application/vnd.ibm.modcap": { "source": "apache", "extensions": ["afp", "listafp", "list3820"] },
  "application/vnd.ibm.rights-management": { "source": "iana", "extensions": ["irm"] },
  "application/vnd.ibm.secure-container": { "source": "iana", "extensions": ["sc"] },
  "application/vnd.iccprofile": { "source": "iana", "extensions": ["icc", "icm"] },
  "application/vnd.ieee.1905": { "source": "iana" },
  "application/vnd.igloader": { "source": "iana", "extensions": ["igl"] },
  "application/vnd.imagemeter.folder+zip": { "source": "iana", "compressible": false },
  "application/vnd.imagemeter.image+zip": { "source": "iana", "compressible": false },
  "application/vnd.immervision-ivp": { "source": "iana", "extensions": ["ivp"] },
  "application/vnd.immervision-ivu": { "source": "iana", "extensions": ["ivu"] },
  "application/vnd.ims.imsccv1p1": { "source": "iana" },
  "application/vnd.ims.imsccv1p2": { "source": "iana" },
  "application/vnd.ims.imsccv1p3": { "source": "iana" },
  "application/vnd.ims.lis.v2.result+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy.id+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": { "source": "iana", "compressible": true },
  "application/vnd.informedcontrol.rms+xml": { "source": "iana", "compressible": true },
  "application/vnd.informix-visionary": { "source": "apache" },
  "application/vnd.infotech.project": { "source": "iana" },
  "application/vnd.infotech.project+xml": { "source": "iana", "compressible": true },
  "application/vnd.innopath.wamp.notification": { "source": "iana" },
  "application/vnd.insors.igm": { "source": "iana", "extensions": ["igm"] },
  "application/vnd.intercon.formnet": { "source": "iana", "extensions": ["xpw", "xpx"] },
  "application/vnd.intergeo": { "source": "iana", "extensions": ["i2g"] },
  "application/vnd.intertrust.digibox": { "source": "iana" },
  "application/vnd.intertrust.nncp": { "source": "iana" },
  "application/vnd.intu.qbo": { "source": "iana", "extensions": ["qbo"] },
  "application/vnd.intu.qfx": { "source": "iana", "extensions": ["qfx"] },
  "application/vnd.ipfs.ipns-record": { "source": "iana" },
  "application/vnd.ipld.car": { "source": "iana" },
  "application/vnd.ipld.dag-cbor": { "source": "iana" },
  "application/vnd.ipld.dag-json": { "source": "iana" },
  "application/vnd.ipld.raw": { "source": "iana" },
  "application/vnd.iptc.g2.catalogitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.conceptitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.knowledgeitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.packageitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.planningitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.ipunplugged.rcprofile": { "source": "iana", "extensions": ["rcprofile"] },
  "application/vnd.irepository.package+xml": { "source": "iana", "compressible": true, "extensions": ["irp"] },
  "application/vnd.is-xpr": { "source": "iana", "extensions": ["xpr"] },
  "application/vnd.isac.fcs": { "source": "iana", "extensions": ["fcs"] },
  "application/vnd.iso11783-10+zip": { "source": "iana", "compressible": false },
  "application/vnd.jam": { "source": "iana", "extensions": ["jam"] },
  "application/vnd.japannet-directory-service": { "source": "iana" },
  "application/vnd.japannet-jpnstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-payment-wakeup": { "source": "iana" },
  "application/vnd.japannet-registration": { "source": "iana" },
  "application/vnd.japannet-registration-wakeup": { "source": "iana" },
  "application/vnd.japannet-setstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-verification": { "source": "iana" },
  "application/vnd.japannet-verification-wakeup": { "source": "iana" },
  "application/vnd.jcp.javame.midlet-rms": { "source": "iana", "extensions": ["rms"] },
  "application/vnd.jisp": { "source": "iana", "extensions": ["jisp"] },
  "application/vnd.joost.joda-archive": { "source": "iana", "extensions": ["joda"] },
  "application/vnd.jsk.isdn-ngn": { "source": "iana" },
  "application/vnd.kahootz": { "source": "iana", "extensions": ["ktz", "ktr"] },
  "application/vnd.kde.karbon": { "source": "iana", "extensions": ["karbon"] },
  "application/vnd.kde.kchart": { "source": "iana", "extensions": ["chrt"] },
  "application/vnd.kde.kformula": { "source": "iana", "extensions": ["kfo"] },
  "application/vnd.kde.kivio": { "source": "iana", "extensions": ["flw"] },
  "application/vnd.kde.kontour": { "source": "iana", "extensions": ["kon"] },
  "application/vnd.kde.kpresenter": { "source": "iana", "extensions": ["kpr", "kpt"] },
  "application/vnd.kde.kspread": { "source": "iana", "extensions": ["ksp"] },
  "application/vnd.kde.kword": { "source": "iana", "extensions": ["kwd", "kwt"] },
  "application/vnd.kdl": { "source": "iana" },
  "application/vnd.kenameaapp": { "source": "iana", "extensions": ["htke"] },
  "application/vnd.keyman.kmp+zip": { "source": "iana", "compressible": false },
  "application/vnd.keyman.kmx": { "source": "iana" },
  "application/vnd.kidspiration": { "source": "iana", "extensions": ["kia"] },
  "application/vnd.kinar": { "source": "iana", "extensions": ["kne", "knp"] },
  "application/vnd.koan": { "source": "iana", "extensions": ["skp", "skd", "skt", "skm"] },
  "application/vnd.kodak-descriptor": { "source": "iana", "extensions": ["sse"] },
  "application/vnd.las": { "source": "iana" },
  "application/vnd.las.las+json": { "source": "iana", "compressible": true },
  "application/vnd.las.las+xml": { "source": "iana", "compressible": true, "extensions": ["lasxml"] },
  "application/vnd.laszip": { "source": "iana" },
  "application/vnd.ldev.productlicensing": { "source": "iana" },
  "application/vnd.leap+json": { "source": "iana", "compressible": true },
  "application/vnd.liberty-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.llamagraphics.life-balance.desktop": { "source": "iana", "extensions": ["lbd"] },
  "application/vnd.llamagraphics.life-balance.exchange+xml": { "source": "iana", "compressible": true, "extensions": ["lbe"] },
  "application/vnd.logipipe.circuit+zip": { "source": "iana", "compressible": false },
  "application/vnd.loom": { "source": "iana" },
  "application/vnd.lotus-1-2-3": { "source": "iana", "extensions": ["123"] },
  "application/vnd.lotus-approach": { "source": "iana", "extensions": ["apr"] },
  "application/vnd.lotus-freelance": { "source": "iana", "extensions": ["pre"] },
  "application/vnd.lotus-notes": { "source": "iana", "extensions": ["nsf"] },
  "application/vnd.lotus-organizer": { "source": "iana", "extensions": ["org"] },
  "application/vnd.lotus-screencam": { "source": "iana", "extensions": ["scm"] },
  "application/vnd.lotus-wordpro": { "source": "iana", "extensions": ["lwp"] },
  "application/vnd.macports.portpkg": { "source": "iana", "extensions": ["portpkg"] },
  "application/vnd.mapbox-vector-tile": { "source": "iana", "extensions": ["mvt"] },
  "application/vnd.marlin.drm.actiontoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.conftoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.license+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.mdcf": { "source": "iana" },
  "application/vnd.mason+json": { "source": "iana", "compressible": true },
  "application/vnd.maxar.archive.3tz+zip": { "source": "iana", "compressible": false },
  "application/vnd.maxmind.maxmind-db": { "source": "iana" },
  "application/vnd.mcd": { "source": "iana", "extensions": ["mcd"] },
  "application/vnd.mdl": { "source": "iana" },
  "application/vnd.mdl-mbsdf": { "source": "iana" },
  "application/vnd.medcalcdata": { "source": "iana", "extensions": ["mc1"] },
  "application/vnd.mediastation.cdkey": { "source": "iana", "extensions": ["cdkey"] },
  "application/vnd.medicalholodeck.recordxr": { "source": "iana" },
  "application/vnd.meridian-slingshot": { "source": "iana" },
  "application/vnd.mermaid": { "source": "iana" },
  "application/vnd.mfer": { "source": "iana", "extensions": ["mwf"] },
  "application/vnd.mfmp": { "source": "iana", "extensions": ["mfm"] },
  "application/vnd.micro+json": { "source": "iana", "compressible": true },
  "application/vnd.micrografx.flo": { "source": "iana", "extensions": ["flo"] },
  "application/vnd.micrografx.igx": { "source": "iana", "extensions": ["igx"] },
  "application/vnd.microsoft.portable-executable": { "source": "iana" },
  "application/vnd.microsoft.windows.thumbnail-cache": { "source": "iana" },
  "application/vnd.miele+json": { "source": "iana", "compressible": true },
  "application/vnd.mif": { "source": "iana", "extensions": ["mif"] },
  "application/vnd.minisoft-hp3000-save": { "source": "iana" },
  "application/vnd.mitsubishi.misty-guard.trustweb": { "source": "iana" },
  "application/vnd.mobius.daf": { "source": "iana", "extensions": ["daf"] },
  "application/vnd.mobius.dis": { "source": "iana", "extensions": ["dis"] },
  "application/vnd.mobius.mbk": { "source": "iana", "extensions": ["mbk"] },
  "application/vnd.mobius.mqy": { "source": "iana", "extensions": ["mqy"] },
  "application/vnd.mobius.msl": { "source": "iana", "extensions": ["msl"] },
  "application/vnd.mobius.plc": { "source": "iana", "extensions": ["plc"] },
  "application/vnd.mobius.txf": { "source": "iana", "extensions": ["txf"] },
  "application/vnd.modl": { "source": "iana" },
  "application/vnd.mophun.application": { "source": "iana", "extensions": ["mpn"] },
  "application/vnd.mophun.certificate": { "source": "iana", "extensions": ["mpc"] },
  "application/vnd.motorola.flexsuite": { "source": "iana" },
  "application/vnd.motorola.flexsuite.adsi": { "source": "iana" },
  "application/vnd.motorola.flexsuite.fis": { "source": "iana" },
  "application/vnd.motorola.flexsuite.gotap": { "source": "iana" },
  "application/vnd.motorola.flexsuite.kmr": { "source": "iana" },
  "application/vnd.motorola.flexsuite.ttc": { "source": "iana" },
  "application/vnd.motorola.flexsuite.wem": { "source": "iana" },
  "application/vnd.motorola.iprm": { "source": "iana" },
  "application/vnd.mozilla.xul+xml": { "source": "iana", "compressible": true, "extensions": ["xul"] },
  "application/vnd.ms-3mfdocument": { "source": "iana" },
  "application/vnd.ms-artgalry": { "source": "iana", "extensions": ["cil"] },
  "application/vnd.ms-asf": { "source": "iana" },
  "application/vnd.ms-cab-compressed": { "source": "iana", "extensions": ["cab"] },
  "application/vnd.ms-color.iccprofile": { "source": "apache" },
  "application/vnd.ms-excel": { "source": "iana", "compressible": false, "extensions": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"] },
  "application/vnd.ms-excel.addin.macroenabled.12": { "source": "iana", "extensions": ["xlam"] },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": { "source": "iana", "extensions": ["xlsb"] },
  "application/vnd.ms-excel.sheet.macroenabled.12": { "source": "iana", "extensions": ["xlsm"] },
  "application/vnd.ms-excel.template.macroenabled.12": { "source": "iana", "extensions": ["xltm"] },
  "application/vnd.ms-fontobject": { "source": "iana", "compressible": true, "extensions": ["eot"] },
  "application/vnd.ms-htmlhelp": { "source": "iana", "extensions": ["chm"] },
  "application/vnd.ms-ims": { "source": "iana", "extensions": ["ims"] },
  "application/vnd.ms-lrm": { "source": "iana", "extensions": ["lrm"] },
  "application/vnd.ms-office.activex+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-officetheme": { "source": "iana", "extensions": ["thmx"] },
  "application/vnd.ms-opentype": { "source": "apache", "compressible": true },
  "application/vnd.ms-outlook": { "compressible": false, "extensions": ["msg"] },
  "application/vnd.ms-package.obfuscated-opentype": { "source": "apache" },
  "application/vnd.ms-pki.seccat": { "source": "apache", "extensions": ["cat"] },
  "application/vnd.ms-pki.stl": { "source": "apache", "extensions": ["stl"] },
  "application/vnd.ms-playready.initiator+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-powerpoint": { "source": "iana", "compressible": false, "extensions": ["ppt", "pps", "pot"] },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": { "source": "iana", "extensions": ["ppam"] },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": { "source": "iana", "extensions": ["pptm"] },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": { "source": "iana", "extensions": ["sldm"] },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": { "source": "iana", "extensions": ["ppsm"] },
  "application/vnd.ms-powerpoint.template.macroenabled.12": { "source": "iana", "extensions": ["potm"] },
  "application/vnd.ms-printdevicecapabilities+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-printing.printticket+xml": { "source": "apache", "compressible": true },
  "application/vnd.ms-printschematicket+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-project": { "source": "iana", "extensions": ["mpp", "mpt"] },
  "application/vnd.ms-tnef": { "source": "iana" },
  "application/vnd.ms-visio.viewer": { "extensions": ["vdx"] },
  "application/vnd.ms-windows.devicepairing": { "source": "iana" },
  "application/vnd.ms-windows.nwprinting.oob": { "source": "iana" },
  "application/vnd.ms-windows.printerpairing": { "source": "iana" },
  "application/vnd.ms-windows.wsd.oob": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-resp": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-resp": { "source": "iana" },
  "application/vnd.ms-word.document.macroenabled.12": { "source": "iana", "extensions": ["docm"] },
  "application/vnd.ms-word.template.macroenabled.12": { "source": "iana", "extensions": ["dotm"] },
  "application/vnd.ms-works": { "source": "iana", "extensions": ["wps", "wks", "wcm", "wdb"] },
  "application/vnd.ms-wpl": { "source": "iana", "extensions": ["wpl"] },
  "application/vnd.ms-xpsdocument": { "source": "iana", "compressible": false, "extensions": ["xps"] },
  "application/vnd.msa-disk-image": { "source": "iana" },
  "application/vnd.mseq": { "source": "iana", "extensions": ["mseq"] },
  "application/vnd.msgpack": { "source": "iana" },
  "application/vnd.msign": { "source": "iana" },
  "application/vnd.multiad.creator": { "source": "iana" },
  "application/vnd.multiad.creator.cif": { "source": "iana" },
  "application/vnd.music-niff": { "source": "iana" },
  "application/vnd.musician": { "source": "iana", "extensions": ["mus"] },
  "application/vnd.muvee.style": { "source": "iana", "extensions": ["msty"] },
  "application/vnd.mynfc": { "source": "iana", "extensions": ["taglet"] },
  "application/vnd.nacamar.ybrid+json": { "source": "iana", "compressible": true },
  "application/vnd.nato.bindingdataobject+cbor": { "source": "iana" },
  "application/vnd.nato.bindingdataobject+json": { "source": "iana", "compressible": true },
  "application/vnd.nato.bindingdataobject+xml": { "source": "iana", "compressible": true, "extensions": ["bdo"] },
  "application/vnd.nato.openxmlformats-package.iepd+zip": { "source": "iana", "compressible": false },
  "application/vnd.ncd.control": { "source": "iana" },
  "application/vnd.ncd.reference": { "source": "iana" },
  "application/vnd.nearst.inv+json": { "source": "iana", "compressible": true },
  "application/vnd.nebumind.line": { "source": "iana" },
  "application/vnd.nervana": { "source": "iana" },
  "application/vnd.netfpx": { "source": "iana" },
  "application/vnd.neurolanguage.nlu": { "source": "iana", "extensions": ["nlu"] },
  "application/vnd.nimn": { "source": "iana" },
  "application/vnd.nintendo.nitro.rom": { "source": "iana" },
  "application/vnd.nintendo.snes.rom": { "source": "iana" },
  "application/vnd.nitf": { "source": "iana", "extensions": ["ntf", "nitf"] },
  "application/vnd.noblenet-directory": { "source": "iana", "extensions": ["nnd"] },
  "application/vnd.noblenet-sealer": { "source": "iana", "extensions": ["nns"] },
  "application/vnd.noblenet-web": { "source": "iana", "extensions": ["nnw"] },
  "application/vnd.nokia.catalogs": { "source": "iana" },
  "application/vnd.nokia.conml+wbxml": { "source": "iana" },
  "application/vnd.nokia.conml+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.iptv.config+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.isds-radio-presets": { "source": "iana" },
  "application/vnd.nokia.landmark+wbxml": { "source": "iana" },
  "application/vnd.nokia.landmark+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.landmarkcollection+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.n-gage.ac+xml": { "source": "iana", "compressible": true, "extensions": ["ac"] },
  "application/vnd.nokia.n-gage.data": { "source": "iana", "extensions": ["ngdat"] },
  "application/vnd.nokia.n-gage.symbian.install": { "source": "apache", "extensions": ["n-gage"] },
  "application/vnd.nokia.ncd": { "source": "iana" },
  "application/vnd.nokia.pcd+wbxml": { "source": "iana" },
  "application/vnd.nokia.pcd+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.radio-preset": { "source": "iana", "extensions": ["rpst"] },
  "application/vnd.nokia.radio-presets": { "source": "iana", "extensions": ["rpss"] },
  "application/vnd.novadigm.edm": { "source": "iana", "extensions": ["edm"] },
  "application/vnd.novadigm.edx": { "source": "iana", "extensions": ["edx"] },
  "application/vnd.novadigm.ext": { "source": "iana", "extensions": ["ext"] },
  "application/vnd.ntt-local.content-share": { "source": "iana" },
  "application/vnd.ntt-local.file-transfer": { "source": "iana" },
  "application/vnd.ntt-local.ogw_remote-access": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_remote": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_tcp_stream": { "source": "iana" },
  "application/vnd.oai.workflows": { "source": "iana" },
  "application/vnd.oai.workflows+json": { "source": "iana", "compressible": true },
  "application/vnd.oai.workflows+yaml": { "source": "iana" },
  "application/vnd.oasis.opendocument.base": { "source": "iana" },
  "application/vnd.oasis.opendocument.chart": { "source": "iana", "extensions": ["odc"] },
  "application/vnd.oasis.opendocument.chart-template": { "source": "iana", "extensions": ["otc"] },
  "application/vnd.oasis.opendocument.database": { "source": "apache", "extensions": ["odb"] },
  "application/vnd.oasis.opendocument.formula": { "source": "iana", "extensions": ["odf"] },
  "application/vnd.oasis.opendocument.formula-template": { "source": "iana", "extensions": ["odft"] },
  "application/vnd.oasis.opendocument.graphics": { "source": "iana", "compressible": false, "extensions": ["odg"] },
  "application/vnd.oasis.opendocument.graphics-template": { "source": "iana", "extensions": ["otg"] },
  "application/vnd.oasis.opendocument.image": { "source": "iana", "extensions": ["odi"] },
  "application/vnd.oasis.opendocument.image-template": { "source": "iana", "extensions": ["oti"] },
  "application/vnd.oasis.opendocument.presentation": { "source": "iana", "compressible": false, "extensions": ["odp"] },
  "application/vnd.oasis.opendocument.presentation-template": { "source": "iana", "extensions": ["otp"] },
  "application/vnd.oasis.opendocument.spreadsheet": { "source": "iana", "compressible": false, "extensions": ["ods"] },
  "application/vnd.oasis.opendocument.spreadsheet-template": { "source": "iana", "extensions": ["ots"] },
  "application/vnd.oasis.opendocument.text": { "source": "iana", "compressible": false, "extensions": ["odt"] },
  "application/vnd.oasis.opendocument.text-master": { "source": "iana", "extensions": ["odm"] },
  "application/vnd.oasis.opendocument.text-master-template": { "source": "iana" },
  "application/vnd.oasis.opendocument.text-template": { "source": "iana", "extensions": ["ott"] },
  "application/vnd.oasis.opendocument.text-web": { "source": "iana", "extensions": ["oth"] },
  "application/vnd.obn": { "source": "iana" },
  "application/vnd.ocf+cbor": { "source": "iana" },
  "application/vnd.oci.image.manifest.v1+json": { "source": "iana", "compressible": true },
  "application/vnd.oftn.l10n+json": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessdownload+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessstreaming+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.cspg-hexbinary": { "source": "iana" },
  "application/vnd.oipf.dae.svg+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.dae.xhtml+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.mippvcontrolmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.pae.gem": { "source": "iana" },
  "application/vnd.oipf.spdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.spdlist+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.ueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.userprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.olpc-sugar": { "source": "iana", "extensions": ["xo"] },
  "application/vnd.oma-scws-config": { "source": "iana" },
  "application/vnd.oma-scws-http-request": { "source": "iana" },
  "application/vnd.oma-scws-http-response": { "source": "iana" },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.drm-trigger+xml": { "source": "apache", "compressible": true },
  "application/vnd.oma.bcast.imd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.ltkm": { "source": "iana" },
  "application/vnd.oma.bcast.notification+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.provisioningtrigger": { "source": "iana" },
  "application/vnd.oma.bcast.sgboot": { "source": "iana" },
  "application/vnd.oma.bcast.sgdd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.sgdu": { "source": "iana" },
  "application/vnd.oma.bcast.simple-symbol-container": { "source": "iana" },
  "application/vnd.oma.bcast.smartcard-trigger+xml": { "source": "apache", "compressible": true },
  "application/vnd.oma.bcast.sprov+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.stkm": { "source": "iana" },
  "application/vnd.oma.cab-address-book+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-feature-handler+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-pcc+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-subs-invite+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-user-prefs+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.dcd": { "source": "iana" },
  "application/vnd.oma.dcdc": { "source": "iana" },
  "application/vnd.oma.dd2+xml": { "source": "iana", "compressible": true, "extensions": ["dd2"] },
  "application/vnd.oma.drm.risd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.group-usage-list+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+cbor": { "source": "iana" },
  "application/vnd.oma.lwm2m+json": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+tlv": { "source": "iana" },
  "application/vnd.oma.pal+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.detailed-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.final-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.groups+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.invocation-descriptor+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.optimized-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.push": { "source": "iana" },
  "application/vnd.oma.scidm.messages+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.xcap-directory+xml": { "source": "iana", "compressible": true },
  "application/vnd.omads-email+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-file+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-folder+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omaloc-supl-init": { "source": "iana" },
  "application/vnd.onepager": { "source": "iana" },
  "application/vnd.onepagertamp": { "source": "iana" },
  "application/vnd.onepagertamx": { "source": "iana" },
  "application/vnd.onepagertat": { "source": "iana" },
  "application/vnd.onepagertatp": { "source": "iana" },
  "application/vnd.onepagertatx": { "source": "iana" },
  "application/vnd.onvif.metadata": { "source": "iana" },
  "application/vnd.openblox.game+xml": { "source": "iana", "compressible": true, "extensions": ["obgx"] },
  "application/vnd.openblox.game-binary": { "source": "iana" },
  "application/vnd.openeye.oeb": { "source": "iana" },
  "application/vnd.openofficeorg.extension": { "source": "apache", "extensions": ["oxt"] },
  "application/vnd.openstreetmap.data+xml": { "source": "iana", "compressible": true, "extensions": ["osm"] },
  "application/vnd.opentimestamps.ots": { "source": "iana" },
  "application/vnd.openvpi.dspx+json": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawing+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": { "source": "iana", "compressible": false, "extensions": ["pptx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": { "source": "iana", "extensions": ["sldx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": { "source": "iana", "extensions": ["ppsx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.template": { "source": "iana", "extensions": ["potx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": { "source": "iana", "compressible": false, "extensions": ["xlsx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": { "source": "iana", "extensions": ["xltx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.theme+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.vmldrawing": { "source": "iana" },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": { "source": "iana", "compressible": false, "extensions": ["docx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": { "source": "iana", "extensions": ["dotx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.core-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.relationships+xml": { "source": "iana", "compressible": true },
  "application/vnd.oracle.resource+json": { "source": "iana", "compressible": true },
  "application/vnd.orange.indata": { "source": "iana" },
  "application/vnd.osa.netdeploy": { "source": "iana" },
  "application/vnd.osgeo.mapguide.package": { "source": "iana", "extensions": ["mgp"] },
  "application/vnd.osgi.bundle": { "source": "iana" },
  "application/vnd.osgi.dp": { "source": "iana", "extensions": ["dp"] },
  "application/vnd.osgi.subsystem": { "source": "iana", "extensions": ["esa"] },
  "application/vnd.otps.ct-kip+xml": { "source": "iana", "compressible": true },
  "application/vnd.oxli.countgraph": { "source": "iana" },
  "application/vnd.pagerduty+json": { "source": "iana", "compressible": true },
  "application/vnd.palm": { "source": "iana", "extensions": ["pdb", "pqa", "oprc"] },
  "application/vnd.panoply": { "source": "iana" },
  "application/vnd.paos.xml": { "source": "iana" },
  "application/vnd.patentdive": { "source": "iana" },
  "application/vnd.patientecommsdoc": { "source": "iana" },
  "application/vnd.pawaafile": { "source": "iana", "extensions": ["paw"] },
  "application/vnd.pcos": { "source": "iana" },
  "application/vnd.pg.format": { "source": "iana", "extensions": ["str"] },
  "application/vnd.pg.osasli": { "source": "iana", "extensions": ["ei6"] },
  "application/vnd.piaccess.application-licence": { "source": "iana" },
  "application/vnd.picsel": { "source": "iana", "extensions": ["efif"] },
  "application/vnd.pmi.widget": { "source": "iana", "extensions": ["wg"] },
  "application/vnd.poc.group-advertisement+xml": { "source": "iana", "compressible": true },
  "application/vnd.pocketlearn": { "source": "iana", "extensions": ["plf"] },
  "application/vnd.powerbuilder6": { "source": "iana", "extensions": ["pbd"] },
  "application/vnd.powerbuilder6-s": { "source": "iana" },
  "application/vnd.powerbuilder7": { "source": "iana" },
  "application/vnd.powerbuilder7-s": { "source": "iana" },
  "application/vnd.powerbuilder75": { "source": "iana" },
  "application/vnd.powerbuilder75-s": { "source": "iana" },
  "application/vnd.preminet": { "source": "iana" },
  "application/vnd.previewsystems.box": { "source": "iana", "extensions": ["box"] },
  "application/vnd.procrate.brushset": { "extensions": ["brushset"] },
  "application/vnd.procreate.brush": { "extensions": ["brush"] },
  "application/vnd.procreate.dream": { "extensions": ["drm"] },
  "application/vnd.proteus.magazine": { "source": "iana", "extensions": ["mgz"] },
  "application/vnd.psfs": { "source": "iana" },
  "application/vnd.pt.mundusmundi": { "source": "iana" },
  "application/vnd.publishare-delta-tree": { "source": "iana", "extensions": ["qps"] },
  "application/vnd.pvi.ptid1": { "source": "iana", "extensions": ["ptid"] },
  "application/vnd.pwg-multiplexed": { "source": "iana" },
  "application/vnd.pwg-xhtml-print+xml": { "source": "iana", "compressible": true, "extensions": ["xhtm"] },
  "application/vnd.qualcomm.brew-app-res": { "source": "iana" },
  "application/vnd.quarantainenet": { "source": "iana" },
  "application/vnd.quark.quarkxpress": { "source": "iana", "extensions": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"] },
  "application/vnd.quobject-quoxdocument": { "source": "iana" },
  "application/vnd.radisys.moml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conn+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-stream+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-base+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-group+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-speech+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-transform+xml": { "source": "iana", "compressible": true },
  "application/vnd.rainstor.data": { "source": "iana" },
  "application/vnd.rapid": { "source": "iana" },
  "application/vnd.rar": { "source": "iana", "extensions": ["rar"] },
  "application/vnd.realvnc.bed": { "source": "iana", "extensions": ["bed"] },
  "application/vnd.recordare.musicxml": { "source": "iana", "extensions": ["mxl"] },
  "application/vnd.recordare.musicxml+xml": { "source": "iana", "compressible": true, "extensions": ["musicxml"] },
  "application/vnd.relpipe": { "source": "iana" },
  "application/vnd.renlearn.rlprint": { "source": "iana" },
  "application/vnd.resilient.logic": { "source": "iana" },
  "application/vnd.restful+json": { "source": "iana", "compressible": true },
  "application/vnd.rig.cryptonote": { "source": "iana", "extensions": ["cryptonote"] },
  "application/vnd.rim.cod": { "source": "apache", "extensions": ["cod"] },
  "application/vnd.rn-realmedia": { "source": "apache", "extensions": ["rm"] },
  "application/vnd.rn-realmedia-vbr": { "source": "apache", "extensions": ["rmvb"] },
  "application/vnd.route66.link66+xml": { "source": "iana", "compressible": true, "extensions": ["link66"] },
  "application/vnd.rs-274x": { "source": "iana" },
  "application/vnd.ruckus.download": { "source": "iana" },
  "application/vnd.s3sms": { "source": "iana" },
  "application/vnd.sailingtracker.track": { "source": "iana", "extensions": ["st"] },
  "application/vnd.sar": { "source": "iana" },
  "application/vnd.sbm.cid": { "source": "iana" },
  "application/vnd.sbm.mid2": { "source": "iana" },
  "application/vnd.scribus": { "source": "iana" },
  "application/vnd.sealed.3df": { "source": "iana" },
  "application/vnd.sealed.csf": { "source": "iana" },
  "application/vnd.sealed.doc": { "source": "iana" },
  "application/vnd.sealed.eml": { "source": "iana" },
  "application/vnd.sealed.mht": { "source": "iana" },
  "application/vnd.sealed.net": { "source": "iana" },
  "application/vnd.sealed.ppt": { "source": "iana" },
  "application/vnd.sealed.tiff": { "source": "iana" },
  "application/vnd.sealed.xls": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.html": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.pdf": { "source": "iana" },
  "application/vnd.seemail": { "source": "iana", "extensions": ["see"] },
  "application/vnd.seis+json": { "source": "iana", "compressible": true },
  "application/vnd.sema": { "source": "iana", "extensions": ["sema"] },
  "application/vnd.semd": { "source": "iana", "extensions": ["semd"] },
  "application/vnd.semf": { "source": "iana", "extensions": ["semf"] },
  "application/vnd.shade-save-file": { "source": "iana" },
  "application/vnd.shana.informed.formdata": { "source": "iana", "extensions": ["ifm"] },
  "application/vnd.shana.informed.formtemplate": { "source": "iana", "extensions": ["itp"] },
  "application/vnd.shana.informed.interchange": { "source": "iana", "extensions": ["iif"] },
  "application/vnd.shana.informed.package": { "source": "iana", "extensions": ["ipk"] },
  "application/vnd.shootproof+json": { "source": "iana", "compressible": true },
  "application/vnd.shopkick+json": { "source": "iana", "compressible": true },
  "application/vnd.shp": { "source": "iana" },
  "application/vnd.shx": { "source": "iana" },
  "application/vnd.sigrok.session": { "source": "iana" },
  "application/vnd.simtech-mindmapper": { "source": "iana", "extensions": ["twd", "twds"] },
  "application/vnd.siren+json": { "source": "iana", "compressible": true },
  "application/vnd.sketchometry": { "source": "iana" },
  "application/vnd.smaf": { "source": "iana", "extensions": ["mmf"] },
  "application/vnd.smart.notebook": { "source": "iana" },
  "application/vnd.smart.teacher": { "source": "iana", "extensions": ["teacher"] },
  "application/vnd.smintio.portals.archive": { "source": "iana" },
  "application/vnd.snesdev-page-table": { "source": "iana" },
  "application/vnd.software602.filler.form+xml": { "source": "iana", "compressible": true, "extensions": ["fo"] },
  "application/vnd.software602.filler.form-xml-zip": { "source": "iana" },
  "application/vnd.solent.sdkm+xml": { "source": "iana", "compressible": true, "extensions": ["sdkm", "sdkd"] },
  "application/vnd.spotfire.dxp": { "source": "iana", "extensions": ["dxp"] },
  "application/vnd.spotfire.sfs": { "source": "iana", "extensions": ["sfs"] },
  "application/vnd.sqlite3": { "source": "iana" },
  "application/vnd.sss-cod": { "source": "iana" },
  "application/vnd.sss-dtf": { "source": "iana" },
  "application/vnd.sss-ntf": { "source": "iana" },
  "application/vnd.stardivision.calc": { "source": "apache", "extensions": ["sdc"] },
  "application/vnd.stardivision.draw": { "source": "apache", "extensions": ["sda"] },
  "application/vnd.stardivision.impress": { "source": "apache", "extensions": ["sdd"] },
  "application/vnd.stardivision.math": { "source": "apache", "extensions": ["smf"] },
  "application/vnd.stardivision.writer": { "source": "apache", "extensions": ["sdw", "vor"] },
  "application/vnd.stardivision.writer-global": { "source": "apache", "extensions": ["sgl"] },
  "application/vnd.stepmania.package": { "source": "iana", "extensions": ["smzip"] },
  "application/vnd.stepmania.stepchart": { "source": "iana", "extensions": ["sm"] },
  "application/vnd.street-stream": { "source": "iana" },
  "application/vnd.sun.wadl+xml": { "source": "iana", "compressible": true, "extensions": ["wadl"] },
  "application/vnd.sun.xml.calc": { "source": "apache", "extensions": ["sxc"] },
  "application/vnd.sun.xml.calc.template": { "source": "apache", "extensions": ["stc"] },
  "application/vnd.sun.xml.draw": { "source": "apache", "extensions": ["sxd"] },
  "application/vnd.sun.xml.draw.template": { "source": "apache", "extensions": ["std"] },
  "application/vnd.sun.xml.impress": { "source": "apache", "extensions": ["sxi"] },
  "application/vnd.sun.xml.impress.template": { "source": "apache", "extensions": ["sti"] },
  "application/vnd.sun.xml.math": { "source": "apache", "extensions": ["sxm"] },
  "application/vnd.sun.xml.writer": { "source": "apache", "extensions": ["sxw"] },
  "application/vnd.sun.xml.writer.global": { "source": "apache", "extensions": ["sxg"] },
  "application/vnd.sun.xml.writer.template": { "source": "apache", "extensions": ["stw"] },
  "application/vnd.sus-calendar": { "source": "iana", "extensions": ["sus", "susp"] },
  "application/vnd.svd": { "source": "iana", "extensions": ["svd"] },
  "application/vnd.swiftview-ics": { "source": "iana" },
  "application/vnd.sybyl.mol2": { "source": "iana" },
  "application/vnd.sycle+xml": { "source": "iana", "compressible": true },
  "application/vnd.syft+json": { "source": "iana", "compressible": true },
  "application/vnd.symbian.install": { "source": "apache", "extensions": ["sis", "sisx"] },
  "application/vnd.syncml+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xsm"] },
  "application/vnd.syncml.dm+wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["bdm"] },
  "application/vnd.syncml.dm+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xdm"] },
  "application/vnd.syncml.dm.notification": { "source": "iana" },
  "application/vnd.syncml.dmddf+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmddf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["ddf"] },
  "application/vnd.syncml.dmtnds+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmtnds+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.syncml.ds.notification": { "source": "iana" },
  "application/vnd.tableschema+json": { "source": "iana", "compressible": true },
  "application/vnd.tao.intent-module-archive": { "source": "iana", "extensions": ["tao"] },
  "application/vnd.tcpdump.pcap": { "source": "iana", "extensions": ["pcap", "cap", "dmp"] },
  "application/vnd.think-cell.ppttc+json": { "source": "iana", "compressible": true },
  "application/vnd.tmd.mediaflex.api+xml": { "source": "iana", "compressible": true },
  "application/vnd.tml": { "source": "iana" },
  "application/vnd.tmobile-livetv": { "source": "iana", "extensions": ["tmo"] },
  "application/vnd.tri.onesource": { "source": "iana" },
  "application/vnd.trid.tpt": { "source": "iana", "extensions": ["tpt"] },
  "application/vnd.triscape.mxs": { "source": "iana", "extensions": ["mxs"] },
  "application/vnd.trueapp": { "source": "iana", "extensions": ["tra"] },
  "application/vnd.truedoc": { "source": "iana" },
  "application/vnd.ubisoft.webplayer": { "source": "iana" },
  "application/vnd.ufdl": { "source": "iana", "extensions": ["ufd", "ufdl"] },
  "application/vnd.uic.osdm+json": { "source": "iana", "compressible": true },
  "application/vnd.uiq.theme": { "source": "iana", "extensions": ["utz"] },
  "application/vnd.umajin": { "source": "iana", "extensions": ["umj"] },
  "application/vnd.unity": { "source": "iana", "extensions": ["unityweb"] },
  "application/vnd.uoml+xml": { "source": "iana", "compressible": true, "extensions": ["uoml", "uo"] },
  "application/vnd.uplanet.alert": { "source": "iana" },
  "application/vnd.uplanet.alert-wbxml": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice-wbxml": { "source": "iana" },
  "application/vnd.uplanet.cacheop": { "source": "iana" },
  "application/vnd.uplanet.cacheop-wbxml": { "source": "iana" },
  "application/vnd.uplanet.channel": { "source": "iana" },
  "application/vnd.uplanet.channel-wbxml": { "source": "iana" },
  "application/vnd.uplanet.list": { "source": "iana" },
  "application/vnd.uplanet.list-wbxml": { "source": "iana" },
  "application/vnd.uplanet.listcmd": { "source": "iana" },
  "application/vnd.uplanet.listcmd-wbxml": { "source": "iana" },
  "application/vnd.uplanet.signal": { "source": "iana" },
  "application/vnd.uri-map": { "source": "iana" },
  "application/vnd.valve.source.material": { "source": "iana" },
  "application/vnd.vcx": { "source": "iana", "extensions": ["vcx"] },
  "application/vnd.vd-study": { "source": "iana" },
  "application/vnd.vectorworks": { "source": "iana" },
  "application/vnd.vel+json": { "source": "iana", "compressible": true },
  "application/vnd.veraison.tsm-report+cbor": { "source": "iana" },
  "application/vnd.veraison.tsm-report+json": { "source": "iana", "compressible": true },
  "application/vnd.verimatrix.vcas": { "source": "iana" },
  "application/vnd.veritone.aion+json": { "source": "iana", "compressible": true },
  "application/vnd.veryant.thin": { "source": "iana" },
  "application/vnd.ves.encrypted": { "source": "iana" },
  "application/vnd.vidsoft.vidconference": { "source": "iana" },
  "application/vnd.visio": { "source": "iana", "extensions": ["vsd", "vst", "vss", "vsw", "vsdx", "vtx"] },
  "application/vnd.visionary": { "source": "iana", "extensions": ["vis"] },
  "application/vnd.vividence.scriptfile": { "source": "iana" },
  "application/vnd.vocalshaper.vsp4": { "source": "iana" },
  "application/vnd.vsf": { "source": "iana", "extensions": ["vsf"] },
  "application/vnd.wap.sic": { "source": "iana" },
  "application/vnd.wap.slc": { "source": "iana" },
  "application/vnd.wap.wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["wbxml"] },
  "application/vnd.wap.wmlc": { "source": "iana", "extensions": ["wmlc"] },
  "application/vnd.wap.wmlscriptc": { "source": "iana", "extensions": ["wmlsc"] },
  "application/vnd.wasmflow.wafl": { "source": "iana" },
  "application/vnd.webturbo": { "source": "iana", "extensions": ["wtb"] },
  "application/vnd.wfa.dpp": { "source": "iana" },
  "application/vnd.wfa.p2p": { "source": "iana" },
  "application/vnd.wfa.wsc": { "source": "iana" },
  "application/vnd.windows.devicepairing": { "source": "iana" },
  "application/vnd.wmc": { "source": "iana" },
  "application/vnd.wmf.bootstrap": { "source": "iana" },
  "application/vnd.wolfram.mathematica": { "source": "iana" },
  "application/vnd.wolfram.mathematica.package": { "source": "iana" },
  "application/vnd.wolfram.player": { "source": "iana", "extensions": ["nbp"] },
  "application/vnd.wordlift": { "source": "iana" },
  "application/vnd.wordperfect": { "source": "iana", "extensions": ["wpd"] },
  "application/vnd.wqd": { "source": "iana", "extensions": ["wqd"] },
  "application/vnd.wrq-hp3000-labelled": { "source": "iana" },
  "application/vnd.wt.stf": { "source": "iana", "extensions": ["stf"] },
  "application/vnd.wv.csp+wbxml": { "source": "iana" },
  "application/vnd.wv.csp+xml": { "source": "iana", "compressible": true },
  "application/vnd.wv.ssp+xml": { "source": "iana", "compressible": true },
  "application/vnd.xacml+json": { "source": "iana", "compressible": true },
  "application/vnd.xara": { "source": "iana", "extensions": ["xar"] },
  "application/vnd.xarin.cpj": { "source": "iana" },
  "application/vnd.xecrets-encrypted": { "source": "iana" },
  "application/vnd.xfdl": { "source": "iana", "extensions": ["xfdl"] },
  "application/vnd.xfdl.webform": { "source": "iana" },
  "application/vnd.xmi+xml": { "source": "iana", "compressible": true },
  "application/vnd.xmpie.cpkg": { "source": "iana" },
  "application/vnd.xmpie.dpkg": { "source": "iana" },
  "application/vnd.xmpie.plan": { "source": "iana" },
  "application/vnd.xmpie.ppkg": { "source": "iana" },
  "application/vnd.xmpie.xlim": { "source": "iana" },
  "application/vnd.yamaha.hv-dic": { "source": "iana", "extensions": ["hvd"] },
  "application/vnd.yamaha.hv-script": { "source": "iana", "extensions": ["hvs"] },
  "application/vnd.yamaha.hv-voice": { "source": "iana", "extensions": ["hvp"] },
  "application/vnd.yamaha.openscoreformat": { "source": "iana", "extensions": ["osf"] },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": { "source": "iana", "compressible": true, "extensions": ["osfpvg"] },
  "application/vnd.yamaha.remote-setup": { "source": "iana" },
  "application/vnd.yamaha.smaf-audio": { "source": "iana", "extensions": ["saf"] },
  "application/vnd.yamaha.smaf-phrase": { "source": "iana", "extensions": ["spf"] },
  "application/vnd.yamaha.through-ngn": { "source": "iana" },
  "application/vnd.yamaha.tunnel-udpencap": { "source": "iana" },
  "application/vnd.yaoweme": { "source": "iana" },
  "application/vnd.yellowriver-custom-menu": { "source": "iana", "extensions": ["cmp"] },
  "application/vnd.zul": { "source": "iana", "extensions": ["zir", "zirz"] },
  "application/vnd.zzazz.deck+xml": { "source": "iana", "compressible": true, "extensions": ["zaz"] },
  "application/voicexml+xml": { "source": "iana", "compressible": true, "extensions": ["vxml"] },
  "application/voucher-cms+json": { "source": "iana", "compressible": true },
  "application/voucher-jws+json": { "source": "iana", "compressible": true },
  "application/vp": { "source": "iana" },
  "application/vp+cose": { "source": "iana" },
  "application/vp+jwt": { "source": "iana" },
  "application/vq-rtcpxr": { "source": "iana" },
  "application/wasm": { "source": "iana", "compressible": true, "extensions": ["wasm"] },
  "application/watcherinfo+xml": { "source": "iana", "compressible": true, "extensions": ["wif"] },
  "application/webpush-options+json": { "source": "iana", "compressible": true },
  "application/whoispp-query": { "source": "iana" },
  "application/whoispp-response": { "source": "iana" },
  "application/widget": { "source": "iana", "extensions": ["wgt"] },
  "application/winhlp": { "source": "apache", "extensions": ["hlp"] },
  "application/wita": { "source": "iana" },
  "application/wordperfect5.1": { "source": "iana" },
  "application/wsdl+xml": { "source": "iana", "compressible": true, "extensions": ["wsdl"] },
  "application/wspolicy+xml": { "source": "iana", "compressible": true, "extensions": ["wspolicy"] },
  "application/x-7z-compressed": { "source": "apache", "compressible": false, "extensions": ["7z"] },
  "application/x-abiword": { "source": "apache", "extensions": ["abw"] },
  "application/x-ace-compressed": { "source": "apache", "extensions": ["ace"] },
  "application/x-amf": { "source": "apache" },
  "application/x-apple-diskimage": { "source": "apache", "extensions": ["dmg"] },
  "application/x-arj": { "compressible": false, "extensions": ["arj"] },
  "application/x-authorware-bin": { "source": "apache", "extensions": ["aab", "x32", "u32", "vox"] },
  "application/x-authorware-map": { "source": "apache", "extensions": ["aam"] },
  "application/x-authorware-seg": { "source": "apache", "extensions": ["aas"] },
  "application/x-bcpio": { "source": "apache", "extensions": ["bcpio"] },
  "application/x-bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/x-bittorrent": { "source": "apache", "extensions": ["torrent"] },
  "application/x-blender": { "extensions": ["blend"] },
  "application/x-blorb": { "source": "apache", "extensions": ["blb", "blorb"] },
  "application/x-bzip": { "source": "apache", "compressible": false, "extensions": ["bz"] },
  "application/x-bzip2": { "source": "apache", "compressible": false, "extensions": ["bz2", "boz"] },
  "application/x-cbr": { "source": "apache", "extensions": ["cbr", "cba", "cbt", "cbz", "cb7"] },
  "application/x-cdlink": { "source": "apache", "extensions": ["vcd"] },
  "application/x-cfs-compressed": { "source": "apache", "extensions": ["cfs"] },
  "application/x-chat": { "source": "apache", "extensions": ["chat"] },
  "application/x-chess-pgn": { "source": "apache", "extensions": ["pgn"] },
  "application/x-chrome-extension": { "extensions": ["crx"] },
  "application/x-cocoa": { "source": "nginx", "extensions": ["cco"] },
  "application/x-compress": { "source": "apache" },
  "application/x-compressed": { "extensions": ["rar"] },
  "application/x-conference": { "source": "apache", "extensions": ["nsc"] },
  "application/x-cpio": { "source": "apache", "extensions": ["cpio"] },
  "application/x-csh": { "source": "apache", "extensions": ["csh"] },
  "application/x-deb": { "compressible": false },
  "application/x-debian-package": { "source": "apache", "extensions": ["deb", "udeb"] },
  "application/x-dgc-compressed": { "source": "apache", "extensions": ["dgc"] },
  "application/x-director": { "source": "apache", "extensions": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"] },
  "application/x-doom": { "source": "apache", "extensions": ["wad"] },
  "application/x-dtbncx+xml": { "source": "apache", "compressible": true, "extensions": ["ncx"] },
  "application/x-dtbook+xml": { "source": "apache", "compressible": true, "extensions": ["dtb"] },
  "application/x-dtbresource+xml": { "source": "apache", "compressible": true, "extensions": ["res"] },
  "application/x-dvi": { "source": "apache", "compressible": false, "extensions": ["dvi"] },
  "application/x-envoy": { "source": "apache", "extensions": ["evy"] },
  "application/x-eva": { "source": "apache", "extensions": ["eva"] },
  "application/x-font-bdf": { "source": "apache", "extensions": ["bdf"] },
  "application/x-font-dos": { "source": "apache" },
  "application/x-font-framemaker": { "source": "apache" },
  "application/x-font-ghostscript": { "source": "apache", "extensions": ["gsf"] },
  "application/x-font-libgrx": { "source": "apache" },
  "application/x-font-linux-psf": { "source": "apache", "extensions": ["psf"] },
  "application/x-font-pcf": { "source": "apache", "extensions": ["pcf"] },
  "application/x-font-snf": { "source": "apache", "extensions": ["snf"] },
  "application/x-font-speedo": { "source": "apache" },
  "application/x-font-sunos-news": { "source": "apache" },
  "application/x-font-type1": { "source": "apache", "extensions": ["pfa", "pfb", "pfm", "afm"] },
  "application/x-font-vfont": { "source": "apache" },
  "application/x-freearc": { "source": "apache", "extensions": ["arc"] },
  "application/x-futuresplash": { "source": "apache", "extensions": ["spl"] },
  "application/x-gca-compressed": { "source": "apache", "extensions": ["gca"] },
  "application/x-glulx": { "source": "apache", "extensions": ["ulx"] },
  "application/x-gnumeric": { "source": "apache", "extensions": ["gnumeric"] },
  "application/x-gramps-xml": { "source": "apache", "extensions": ["gramps"] },
  "application/x-gtar": { "source": "apache", "extensions": ["gtar"] },
  "application/x-gzip": { "source": "apache" },
  "application/x-hdf": { "source": "apache", "extensions": ["hdf"] },
  "application/x-httpd-php": { "compressible": true, "extensions": ["php"] },
  "application/x-install-instructions": { "source": "apache", "extensions": ["install"] },
  "application/x-ipynb+json": { "compressible": true, "extensions": ["ipynb"] },
  "application/x-iso9660-image": { "source": "apache", "extensions": ["iso"] },
  "application/x-iwork-keynote-sffkey": { "extensions": ["key"] },
  "application/x-iwork-numbers-sffnumbers": { "extensions": ["numbers"] },
  "application/x-iwork-pages-sffpages": { "extensions": ["pages"] },
  "application/x-java-archive-diff": { "source": "nginx", "extensions": ["jardiff"] },
  "application/x-java-jnlp-file": { "source": "apache", "compressible": false, "extensions": ["jnlp"] },
  "application/x-javascript": { "compressible": true },
  "application/x-keepass2": { "extensions": ["kdbx"] },
  "application/x-latex": { "source": "apache", "compressible": false, "extensions": ["latex"] },
  "application/x-lua-bytecode": { "extensions": ["luac"] },
  "application/x-lzh-compressed": { "source": "apache", "extensions": ["lzh", "lha"] },
  "application/x-makeself": { "source": "nginx", "extensions": ["run"] },
  "application/x-mie": { "source": "apache", "extensions": ["mie"] },
  "application/x-mobipocket-ebook": { "source": "apache", "extensions": ["prc", "mobi"] },
  "application/x-mpegurl": { "compressible": false },
  "application/x-ms-application": { "source": "apache", "extensions": ["application"] },
  "application/x-ms-shortcut": { "source": "apache", "extensions": ["lnk"] },
  "application/x-ms-wmd": { "source": "apache", "extensions": ["wmd"] },
  "application/x-ms-wmz": { "source": "apache", "extensions": ["wmz"] },
  "application/x-ms-xbap": { "source": "apache", "extensions": ["xbap"] },
  "application/x-msaccess": { "source": "apache", "extensions": ["mdb"] },
  "application/x-msbinder": { "source": "apache", "extensions": ["obd"] },
  "application/x-mscardfile": { "source": "apache", "extensions": ["crd"] },
  "application/x-msclip": { "source": "apache", "extensions": ["clp"] },
  "application/x-msdos-program": { "extensions": ["exe"] },
  "application/x-msdownload": { "source": "apache", "extensions": ["exe", "dll", "com", "bat", "msi"] },
  "application/x-msmediaview": { "source": "apache", "extensions": ["mvb", "m13", "m14"] },
  "application/x-msmetafile": { "source": "apache", "extensions": ["wmf", "wmz", "emf", "emz"] },
  "application/x-msmoney": { "source": "apache", "extensions": ["mny"] },
  "application/x-mspublisher": { "source": "apache", "extensions": ["pub"] },
  "application/x-msschedule": { "source": "apache", "extensions": ["scd"] },
  "application/x-msterminal": { "source": "apache", "extensions": ["trm"] },
  "application/x-mswrite": { "source": "apache", "extensions": ["wri"] },
  "application/x-netcdf": { "source": "apache", "extensions": ["nc", "cdf"] },
  "application/x-ns-proxy-autoconfig": { "compressible": true, "extensions": ["pac"] },
  "application/x-nzb": { "source": "apache", "extensions": ["nzb"] },
  "application/x-perl": { "source": "nginx", "extensions": ["pl", "pm"] },
  "application/x-pilot": { "source": "nginx", "extensions": ["prc", "pdb"] },
  "application/x-pkcs12": { "source": "apache", "compressible": false, "extensions": ["p12", "pfx"] },
  "application/x-pkcs7-certificates": { "source": "apache", "extensions": ["p7b", "spc"] },
  "application/x-pkcs7-certreqresp": { "source": "apache", "extensions": ["p7r"] },
  "application/x-pki-message": { "source": "iana" },
  "application/x-rar-compressed": { "source": "apache", "compressible": false, "extensions": ["rar"] },
  "application/x-redhat-package-manager": { "source": "nginx", "extensions": ["rpm"] },
  "application/x-research-info-systems": { "source": "apache", "extensions": ["ris"] },
  "application/x-sea": { "source": "nginx", "extensions": ["sea"] },
  "application/x-sh": { "source": "apache", "compressible": true, "extensions": ["sh"] },
  "application/x-shar": { "source": "apache", "extensions": ["shar"] },
  "application/x-shockwave-flash": { "source": "apache", "compressible": false, "extensions": ["swf"] },
  "application/x-silverlight-app": { "source": "apache", "extensions": ["xap"] },
  "application/x-sql": { "source": "apache", "extensions": ["sql"] },
  "application/x-stuffit": { "source": "apache", "compressible": false, "extensions": ["sit"] },
  "application/x-stuffitx": { "source": "apache", "extensions": ["sitx"] },
  "application/x-subrip": { "source": "apache", "extensions": ["srt"] },
  "application/x-sv4cpio": { "source": "apache", "extensions": ["sv4cpio"] },
  "application/x-sv4crc": { "source": "apache", "extensions": ["sv4crc"] },
  "application/x-t3vm-image": { "source": "apache", "extensions": ["t3"] },
  "application/x-tads": { "source": "apache", "extensions": ["gam"] },
  "application/x-tar": { "source": "apache", "compressible": true, "extensions": ["tar"] },
  "application/x-tcl": { "source": "apache", "extensions": ["tcl", "tk"] },
  "application/x-tex": { "source": "apache", "extensions": ["tex"] },
  "application/x-tex-tfm": { "source": "apache", "extensions": ["tfm"] },
  "application/x-texinfo": { "source": "apache", "extensions": ["texinfo", "texi"] },
  "application/x-tgif": { "source": "apache", "extensions": ["obj"] },
  "application/x-ustar": { "source": "apache", "extensions": ["ustar"] },
  "application/x-virtualbox-hdd": { "compressible": true, "extensions": ["hdd"] },
  "application/x-virtualbox-ova": { "compressible": true, "extensions": ["ova"] },
  "application/x-virtualbox-ovf": { "compressible": true, "extensions": ["ovf"] },
  "application/x-virtualbox-vbox": { "compressible": true, "extensions": ["vbox"] },
  "application/x-virtualbox-vbox-extpack": { "compressible": false, "extensions": ["vbox-extpack"] },
  "application/x-virtualbox-vdi": { "compressible": true, "extensions": ["vdi"] },
  "application/x-virtualbox-vhd": { "compressible": true, "extensions": ["vhd"] },
  "application/x-virtualbox-vmdk": { "compressible": true, "extensions": ["vmdk"] },
  "application/x-wais-source": { "source": "apache", "extensions": ["src"] },
  "application/x-web-app-manifest+json": { "compressible": true, "extensions": ["webapp"] },
  "application/x-www-form-urlencoded": { "source": "iana", "compressible": true },
  "application/x-x509-ca-cert": { "source": "iana", "extensions": ["der", "crt", "pem"] },
  "application/x-x509-ca-ra-cert": { "source": "iana" },
  "application/x-x509-next-ca-cert": { "source": "iana" },
  "application/x-xfig": { "source": "apache", "extensions": ["fig"] },
  "application/x-xliff+xml": { "source": "apache", "compressible": true, "extensions": ["xlf"] },
  "application/x-xpinstall": { "source": "apache", "compressible": false, "extensions": ["xpi"] },
  "application/x-xz": { "source": "apache", "extensions": ["xz"] },
  "application/x-zip-compressed": { "extensions": ["zip"] },
  "application/x-zmachine": { "source": "apache", "extensions": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"] },
  "application/x400-bp": { "source": "iana" },
  "application/xacml+xml": { "source": "iana", "compressible": true },
  "application/xaml+xml": { "source": "apache", "compressible": true, "extensions": ["xaml"] },
  "application/xcap-att+xml": { "source": "iana", "compressible": true, "extensions": ["xav"] },
  "application/xcap-caps+xml": { "source": "iana", "compressible": true, "extensions": ["xca"] },
  "application/xcap-diff+xml": { "source": "iana", "compressible": true, "extensions": ["xdf"] },
  "application/xcap-el+xml": { "source": "iana", "compressible": true, "extensions": ["xel"] },
  "application/xcap-error+xml": { "source": "iana", "compressible": true },
  "application/xcap-ns+xml": { "source": "iana", "compressible": true, "extensions": ["xns"] },
  "application/xcon-conference-info+xml": { "source": "iana", "compressible": true },
  "application/xcon-conference-info-diff+xml": { "source": "iana", "compressible": true },
  "application/xenc+xml": { "source": "iana", "compressible": true, "extensions": ["xenc"] },
  "application/xfdf": { "source": "iana", "extensions": ["xfdf"] },
  "application/xhtml+xml": { "source": "iana", "compressible": true, "extensions": ["xhtml", "xht"] },
  "application/xhtml-voice+xml": { "source": "apache", "compressible": true },
  "application/xliff+xml": { "source": "iana", "compressible": true, "extensions": ["xlf"] },
  "application/xml": { "source": "iana", "compressible": true, "extensions": ["xml", "xsl", "xsd", "rng"] },
  "application/xml-dtd": { "source": "iana", "compressible": true, "extensions": ["dtd"] },
  "application/xml-external-parsed-entity": { "source": "iana" },
  "application/xml-patch+xml": { "source": "iana", "compressible": true },
  "application/xmpp+xml": { "source": "iana", "compressible": true },
  "application/xop+xml": { "source": "iana", "compressible": true, "extensions": ["xop"] },
  "application/xproc+xml": { "source": "apache", "compressible": true, "extensions": ["xpl"] },
  "application/xslt+xml": { "source": "iana", "compressible": true, "extensions": ["xsl", "xslt"] },
  "application/xspf+xml": { "source": "apache", "compressible": true, "extensions": ["xspf"] },
  "application/xv+xml": { "source": "iana", "compressible": true, "extensions": ["mxml", "xhvml", "xvml", "xvm"] },
  "application/yaml": { "source": "iana" },
  "application/yang": { "source": "iana", "extensions": ["yang"] },
  "application/yang-data+cbor": { "source": "iana" },
  "application/yang-data+json": { "source": "iana", "compressible": true },
  "application/yang-data+xml": { "source": "iana", "compressible": true },
  "application/yang-patch+json": { "source": "iana", "compressible": true },
  "application/yang-patch+xml": { "source": "iana", "compressible": true },
  "application/yang-sid+json": { "source": "iana", "compressible": true },
  "application/yin+xml": { "source": "iana", "compressible": true, "extensions": ["yin"] },
  "application/zip": { "source": "iana", "compressible": false, "extensions": ["zip"] },
  "application/zip+dotlottie": { "extensions": ["lottie"] },
  "application/zlib": { "source": "iana" },
  "application/zstd": { "source": "iana" },
  "audio/1d-interleaved-parityfec": { "source": "iana" },
  "audio/32kadpcm": { "source": "iana" },
  "audio/3gpp": { "source": "iana", "compressible": false, "extensions": ["3gpp"] },
  "audio/3gpp2": { "source": "iana" },
  "audio/aac": { "source": "iana", "extensions": ["adts", "aac"] },
  "audio/ac3": { "source": "iana" },
  "audio/adpcm": { "source": "apache", "extensions": ["adp"] },
  "audio/amr": { "source": "iana", "extensions": ["amr"] },
  "audio/amr-wb": { "source": "iana" },
  "audio/amr-wb+": { "source": "iana" },
  "audio/aptx": { "source": "iana" },
  "audio/asc": { "source": "iana" },
  "audio/atrac-advanced-lossless": { "source": "iana" },
  "audio/atrac-x": { "source": "iana" },
  "audio/atrac3": { "source": "iana" },
  "audio/basic": { "source": "iana", "compressible": false, "extensions": ["au", "snd"] },
  "audio/bv16": { "source": "iana" },
  "audio/bv32": { "source": "iana" },
  "audio/clearmode": { "source": "iana" },
  "audio/cn": { "source": "iana" },
  "audio/dat12": { "source": "iana" },
  "audio/dls": { "source": "iana" },
  "audio/dsr-es201108": { "source": "iana" },
  "audio/dsr-es202050": { "source": "iana" },
  "audio/dsr-es202211": { "source": "iana" },
  "audio/dsr-es202212": { "source": "iana" },
  "audio/dv": { "source": "iana" },
  "audio/dvi4": { "source": "iana" },
  "audio/eac3": { "source": "iana" },
  "audio/encaprtp": { "source": "iana" },
  "audio/evrc": { "source": "iana" },
  "audio/evrc-qcp": { "source": "iana" },
  "audio/evrc0": { "source": "iana" },
  "audio/evrc1": { "source": "iana" },
  "audio/evrcb": { "source": "iana" },
  "audio/evrcb0": { "source": "iana" },
  "audio/evrcb1": { "source": "iana" },
  "audio/evrcnw": { "source": "iana" },
  "audio/evrcnw0": { "source": "iana" },
  "audio/evrcnw1": { "source": "iana" },
  "audio/evrcwb": { "source": "iana" },
  "audio/evrcwb0": { "source": "iana" },
  "audio/evrcwb1": { "source": "iana" },
  "audio/evs": { "source": "iana" },
  "audio/flac": { "source": "iana" },
  "audio/flexfec": { "source": "iana" },
  "audio/fwdred": { "source": "iana" },
  "audio/g711-0": { "source": "iana" },
  "audio/g719": { "source": "iana" },
  "audio/g722": { "source": "iana" },
  "audio/g7221": { "source": "iana" },
  "audio/g723": { "source": "iana" },
  "audio/g726-16": { "source": "iana" },
  "audio/g726-24": { "source": "iana" },
  "audio/g726-32": { "source": "iana" },
  "audio/g726-40": { "source": "iana" },
  "audio/g728": { "source": "iana" },
  "audio/g729": { "source": "iana" },
  "audio/g7291": { "source": "iana" },
  "audio/g729d": { "source": "iana" },
  "audio/g729e": { "source": "iana" },
  "audio/gsm": { "source": "iana" },
  "audio/gsm-efr": { "source": "iana" },
  "audio/gsm-hr-08": { "source": "iana" },
  "audio/ilbc": { "source": "iana" },
  "audio/ip-mr_v2.5": { "source": "iana" },
  "audio/isac": { "source": "apache" },
  "audio/l16": { "source": "iana" },
  "audio/l20": { "source": "iana" },
  "audio/l24": { "source": "iana", "compressible": false },
  "audio/l8": { "source": "iana" },
  "audio/lpc": { "source": "iana" },
  "audio/matroska": { "source": "iana" },
  "audio/melp": { "source": "iana" },
  "audio/melp1200": { "source": "iana" },
  "audio/melp2400": { "source": "iana" },
  "audio/melp600": { "source": "iana" },
  "audio/mhas": { "source": "iana" },
  "audio/midi": { "source": "apache", "extensions": ["mid", "midi", "kar", "rmi"] },
  "audio/midi-clip": { "source": "iana" },
  "audio/mobile-xmf": { "source": "iana", "extensions": ["mxmf"] },
  "audio/mp3": { "compressible": false, "extensions": ["mp3"] },
  "audio/mp4": { "source": "iana", "compressible": false, "extensions": ["m4a", "mp4a", "m4b"] },
  "audio/mp4a-latm": { "source": "iana" },
  "audio/mpa": { "source": "iana" },
  "audio/mpa-robust": { "source": "iana" },
  "audio/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"] },
  "audio/mpeg4-generic": { "source": "iana" },
  "audio/musepack": { "source": "apache" },
  "audio/ogg": { "source": "iana", "compressible": false, "extensions": ["oga", "ogg", "spx", "opus"] },
  "audio/opus": { "source": "iana" },
  "audio/parityfec": { "source": "iana" },
  "audio/pcma": { "source": "iana" },
  "audio/pcma-wb": { "source": "iana" },
  "audio/pcmu": { "source": "iana" },
  "audio/pcmu-wb": { "source": "iana" },
  "audio/prs.sid": { "source": "iana" },
  "audio/qcelp": { "source": "iana" },
  "audio/raptorfec": { "source": "iana" },
  "audio/red": { "source": "iana" },
  "audio/rtp-enc-aescm128": { "source": "iana" },
  "audio/rtp-midi": { "source": "iana" },
  "audio/rtploopback": { "source": "iana" },
  "audio/rtx": { "source": "iana" },
  "audio/s3m": { "source": "apache", "extensions": ["s3m"] },
  "audio/scip": { "source": "iana" },
  "audio/silk": { "source": "apache", "extensions": ["sil"] },
  "audio/smv": { "source": "iana" },
  "audio/smv-qcp": { "source": "iana" },
  "audio/smv0": { "source": "iana" },
  "audio/sofa": { "source": "iana" },
  "audio/sp-midi": { "source": "iana" },
  "audio/speex": { "source": "iana" },
  "audio/t140c": { "source": "iana" },
  "audio/t38": { "source": "iana" },
  "audio/telephone-event": { "source": "iana" },
  "audio/tetra_acelp": { "source": "iana" },
  "audio/tetra_acelp_bb": { "source": "iana" },
  "audio/tone": { "source": "iana" },
  "audio/tsvcis": { "source": "iana" },
  "audio/uemclip": { "source": "iana" },
  "audio/ulpfec": { "source": "iana" },
  "audio/usac": { "source": "iana" },
  "audio/vdvi": { "source": "iana" },
  "audio/vmr-wb": { "source": "iana" },
  "audio/vnd.3gpp.iufp": { "source": "iana" },
  "audio/vnd.4sb": { "source": "iana" },
  "audio/vnd.audiokoz": { "source": "iana" },
  "audio/vnd.celp": { "source": "iana" },
  "audio/vnd.cisco.nse": { "source": "iana" },
  "audio/vnd.cmles.radio-events": { "source": "iana" },
  "audio/vnd.cns.anp1": { "source": "iana" },
  "audio/vnd.cns.inf1": { "source": "iana" },
  "audio/vnd.dece.audio": { "source": "iana", "extensions": ["uva", "uvva"] },
  "audio/vnd.digital-winds": { "source": "iana", "extensions": ["eol"] },
  "audio/vnd.dlna.adts": { "source": "iana" },
  "audio/vnd.dolby.heaac.1": { "source": "iana" },
  "audio/vnd.dolby.heaac.2": { "source": "iana" },
  "audio/vnd.dolby.mlp": { "source": "iana" },
  "audio/vnd.dolby.mps": { "source": "iana" },
  "audio/vnd.dolby.pl2": { "source": "iana" },
  "audio/vnd.dolby.pl2x": { "source": "iana" },
  "audio/vnd.dolby.pl2z": { "source": "iana" },
  "audio/vnd.dolby.pulse.1": { "source": "iana" },
  "audio/vnd.dra": { "source": "iana", "extensions": ["dra"] },
  "audio/vnd.dts": { "source": "iana", "extensions": ["dts"] },
  "audio/vnd.dts.hd": { "source": "iana", "extensions": ["dtshd"] },
  "audio/vnd.dts.uhd": { "source": "iana" },
  "audio/vnd.dvb.file": { "source": "iana" },
  "audio/vnd.everad.plj": { "source": "iana" },
  "audio/vnd.hns.audio": { "source": "iana" },
  "audio/vnd.lucent.voice": { "source": "iana", "extensions": ["lvp"] },
  "audio/vnd.ms-playready.media.pya": { "source": "iana", "extensions": ["pya"] },
  "audio/vnd.nokia.mobile-xmf": { "source": "iana" },
  "audio/vnd.nortel.vbk": { "source": "iana" },
  "audio/vnd.nuera.ecelp4800": { "source": "iana", "extensions": ["ecelp4800"] },
  "audio/vnd.nuera.ecelp7470": { "source": "iana", "extensions": ["ecelp7470"] },
  "audio/vnd.nuera.ecelp9600": { "source": "iana", "extensions": ["ecelp9600"] },
  "audio/vnd.octel.sbc": { "source": "iana" },
  "audio/vnd.presonus.multitrack": { "source": "iana" },
  "audio/vnd.qcelp": { "source": "apache" },
  "audio/vnd.rhetorex.32kadpcm": { "source": "iana" },
  "audio/vnd.rip": { "source": "iana", "extensions": ["rip"] },
  "audio/vnd.rn-realaudio": { "compressible": false },
  "audio/vnd.sealedmedia.softseal.mpeg": { "source": "iana" },
  "audio/vnd.vmx.cvsd": { "source": "iana" },
  "audio/vnd.wave": { "compressible": false },
  "audio/vorbis": { "source": "iana", "compressible": false },
  "audio/vorbis-config": { "source": "iana" },
  "audio/wav": { "compressible": false, "extensions": ["wav"] },
  "audio/wave": { "compressible": false, "extensions": ["wav"] },
  "audio/webm": { "source": "apache", "compressible": false, "extensions": ["weba"] },
  "audio/x-aac": { "source": "apache", "compressible": false, "extensions": ["aac"] },
  "audio/x-aiff": { "source": "apache", "extensions": ["aif", "aiff", "aifc"] },
  "audio/x-caf": { "source": "apache", "compressible": false, "extensions": ["caf"] },
  "audio/x-flac": { "source": "apache", "extensions": ["flac"] },
  "audio/x-m4a": { "source": "nginx", "extensions": ["m4a"] },
  "audio/x-matroska": { "source": "apache", "extensions": ["mka"] },
  "audio/x-mpegurl": { "source": "apache", "extensions": ["m3u"] },
  "audio/x-ms-wax": { "source": "apache", "extensions": ["wax"] },
  "audio/x-ms-wma": { "source": "apache", "extensions": ["wma"] },
  "audio/x-pn-realaudio": { "source": "apache", "extensions": ["ram", "ra"] },
  "audio/x-pn-realaudio-plugin": { "source": "apache", "extensions": ["rmp"] },
  "audio/x-realaudio": { "source": "nginx", "extensions": ["ra"] },
  "audio/x-tta": { "source": "apache" },
  "audio/x-wav": { "source": "apache", "extensions": ["wav"] },
  "audio/xm": { "source": "apache", "extensions": ["xm"] },
  "chemical/x-cdx": { "source": "apache", "extensions": ["cdx"] },
  "chemical/x-cif": { "source": "apache", "extensions": ["cif"] },
  "chemical/x-cmdf": { "source": "apache", "extensions": ["cmdf"] },
  "chemical/x-cml": { "source": "apache", "extensions": ["cml"] },
  "chemical/x-csml": { "source": "apache", "extensions": ["csml"] },
  "chemical/x-pdb": { "source": "apache" },
  "chemical/x-xyz": { "source": "apache", "extensions": ["xyz"] },
  "font/collection": { "source": "iana", "extensions": ["ttc"] },
  "font/otf": { "source": "iana", "compressible": true, "extensions": ["otf"] },
  "font/sfnt": { "source": "iana" },
  "font/ttf": { "source": "iana", "compressible": true, "extensions": ["ttf"] },
  "font/woff": { "source": "iana", "extensions": ["woff"] },
  "font/woff2": { "source": "iana", "extensions": ["woff2"] },
  "image/aces": { "source": "iana", "extensions": ["exr"] },
  "image/apng": { "source": "iana", "compressible": false, "extensions": ["apng"] },
  "image/avci": { "source": "iana", "extensions": ["avci"] },
  "image/avcs": { "source": "iana", "extensions": ["avcs"] },
  "image/avif": { "source": "iana", "compressible": false, "extensions": ["avif"] },
  "image/bmp": { "source": "iana", "compressible": true, "extensions": ["bmp", "dib"] },
  "image/cgm": { "source": "iana", "extensions": ["cgm"] },
  "image/dicom-rle": { "source": "iana", "extensions": ["drle"] },
  "image/dpx": { "source": "iana", "extensions": ["dpx"] },
  "image/emf": { "source": "iana", "extensions": ["emf"] },
  "image/fits": { "source": "iana", "extensions": ["fits"] },
  "image/g3fax": { "source": "iana", "extensions": ["g3"] },
  "image/gif": { "source": "iana", "compressible": false, "extensions": ["gif"] },
  "image/heic": { "source": "iana", "extensions": ["heic"] },
  "image/heic-sequence": { "source": "iana", "extensions": ["heics"] },
  "image/heif": { "source": "iana", "extensions": ["heif"] },
  "image/heif-sequence": { "source": "iana", "extensions": ["heifs"] },
  "image/hej2k": { "source": "iana", "extensions": ["hej2"] },
  "image/ief": { "source": "iana", "extensions": ["ief"] },
  "image/j2c": { "source": "iana" },
  "image/jaii": { "source": "iana", "extensions": ["jaii"] },
  "image/jais": { "source": "iana", "extensions": ["jais"] },
  "image/jls": { "source": "iana", "extensions": ["jls"] },
  "image/jp2": { "source": "iana", "compressible": false, "extensions": ["jp2", "jpg2"] },
  "image/jpeg": { "source": "iana", "compressible": false, "extensions": ["jpg", "jpeg", "jpe"] },
  "image/jph": { "source": "iana", "extensions": ["jph"] },
  "image/jphc": { "source": "iana", "extensions": ["jhc"] },
  "image/jpm": { "source": "iana", "compressible": false, "extensions": ["jpm", "jpgm"] },
  "image/jpx": { "source": "iana", "compressible": false, "extensions": ["jpx", "jpf"] },
  "image/jxl": { "source": "iana", "extensions": ["jxl"] },
  "image/jxr": { "source": "iana", "extensions": ["jxr"] },
  "image/jxra": { "source": "iana", "extensions": ["jxra"] },
  "image/jxrs": { "source": "iana", "extensions": ["jxrs"] },
  "image/jxs": { "source": "iana", "extensions": ["jxs"] },
  "image/jxsc": { "source": "iana", "extensions": ["jxsc"] },
  "image/jxsi": { "source": "iana", "extensions": ["jxsi"] },
  "image/jxss": { "source": "iana", "extensions": ["jxss"] },
  "image/ktx": { "source": "iana", "extensions": ["ktx"] },
  "image/ktx2": { "source": "iana", "extensions": ["ktx2"] },
  "image/naplps": { "source": "iana" },
  "image/pjpeg": { "compressible": false, "extensions": ["jfif"] },
  "image/png": { "source": "iana", "compressible": false, "extensions": ["png"] },
  "image/prs.btif": { "source": "iana", "extensions": ["btif", "btf"] },
  "image/prs.pti": { "source": "iana", "extensions": ["pti"] },
  "image/pwg-raster": { "source": "iana" },
  "image/sgi": { "source": "apache", "extensions": ["sgi"] },
  "image/svg+xml": { "source": "iana", "compressible": true, "extensions": ["svg", "svgz"] },
  "image/t38": { "source": "iana", "extensions": ["t38"] },
  "image/tiff": { "source": "iana", "compressible": false, "extensions": ["tif", "tiff"] },
  "image/tiff-fx": { "source": "iana", "extensions": ["tfx"] },
  "image/vnd.adobe.photoshop": { "source": "iana", "compressible": true, "extensions": ["psd"] },
  "image/vnd.airzip.accelerator.azv": { "source": "iana", "extensions": ["azv"] },
  "image/vnd.clip": { "source": "iana" },
  "image/vnd.cns.inf2": { "source": "iana" },
  "image/vnd.dece.graphic": { "source": "iana", "extensions": ["uvi", "uvvi", "uvg", "uvvg"] },
  "image/vnd.djvu": { "source": "iana", "extensions": ["djvu", "djv"] },
  "image/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "image/vnd.dwg": { "source": "iana", "extensions": ["dwg"] },
  "image/vnd.dxf": { "source": "iana", "extensions": ["dxf"] },
  "image/vnd.fastbidsheet": { "source": "iana", "extensions": ["fbs"] },
  "image/vnd.fpx": { "source": "iana", "extensions": ["fpx"] },
  "image/vnd.fst": { "source": "iana", "extensions": ["fst"] },
  "image/vnd.fujixerox.edmics-mmr": { "source": "iana", "extensions": ["mmr"] },
  "image/vnd.fujixerox.edmics-rlc": { "source": "iana", "extensions": ["rlc"] },
  "image/vnd.globalgraphics.pgb": { "source": "iana" },
  "image/vnd.microsoft.icon": { "source": "iana", "compressible": true, "extensions": ["ico"] },
  "image/vnd.mix": { "source": "iana" },
  "image/vnd.mozilla.apng": { "source": "iana" },
  "image/vnd.ms-dds": { "compressible": true, "extensions": ["dds"] },
  "image/vnd.ms-modi": { "source": "iana", "extensions": ["mdi"] },
  "image/vnd.ms-photo": { "source": "apache", "extensions": ["wdp"] },
  "image/vnd.net-fpx": { "source": "iana", "extensions": ["npx"] },
  "image/vnd.pco.b16": { "source": "iana", "extensions": ["b16"] },
  "image/vnd.radiance": { "source": "iana" },
  "image/vnd.sealed.png": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.gif": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.jpg": { "source": "iana" },
  "image/vnd.svf": { "source": "iana" },
  "image/vnd.tencent.tap": { "source": "iana", "extensions": ["tap"] },
  "image/vnd.valve.source.texture": { "source": "iana", "extensions": ["vtf"] },
  "image/vnd.wap.wbmp": { "source": "iana", "extensions": ["wbmp"] },
  "image/vnd.xiff": { "source": "iana", "extensions": ["xif"] },
  "image/vnd.zbrush.pcx": { "source": "iana", "extensions": ["pcx"] },
  "image/webp": { "source": "iana", "extensions": ["webp"] },
  "image/wmf": { "source": "iana", "extensions": ["wmf"] },
  "image/x-3ds": { "source": "apache", "extensions": ["3ds"] },
  "image/x-adobe-dng": { "extensions": ["dng"] },
  "image/x-cmu-raster": { "source": "apache", "extensions": ["ras"] },
  "image/x-cmx": { "source": "apache", "extensions": ["cmx"] },
  "image/x-emf": { "source": "iana" },
  "image/x-freehand": { "source": "apache", "extensions": ["fh", "fhc", "fh4", "fh5", "fh7"] },
  "image/x-icon": { "source": "apache", "compressible": true, "extensions": ["ico"] },
  "image/x-jng": { "source": "nginx", "extensions": ["jng"] },
  "image/x-mrsid-image": { "source": "apache", "extensions": ["sid"] },
  "image/x-ms-bmp": { "source": "nginx", "compressible": true, "extensions": ["bmp"] },
  "image/x-pcx": { "source": "apache", "extensions": ["pcx"] },
  "image/x-pict": { "source": "apache", "extensions": ["pic", "pct"] },
  "image/x-portable-anymap": { "source": "apache", "extensions": ["pnm"] },
  "image/x-portable-bitmap": { "source": "apache", "extensions": ["pbm"] },
  "image/x-portable-graymap": { "source": "apache", "extensions": ["pgm"] },
  "image/x-portable-pixmap": { "source": "apache", "extensions": ["ppm"] },
  "image/x-rgb": { "source": "apache", "extensions": ["rgb"] },
  "image/x-tga": { "source": "apache", "extensions": ["tga"] },
  "image/x-wmf": { "source": "iana" },
  "image/x-xbitmap": { "source": "apache", "extensions": ["xbm"] },
  "image/x-xcf": { "compressible": false },
  "image/x-xpixmap": { "source": "apache", "extensions": ["xpm"] },
  "image/x-xwindowdump": { "source": "apache", "extensions": ["xwd"] },
  "message/bhttp": { "source": "iana" },
  "message/cpim": { "source": "iana" },
  "message/delivery-status": { "source": "iana" },
  "message/disposition-notification": { "source": "iana", "extensions": ["disposition-notification"] },
  "message/external-body": { "source": "iana" },
  "message/feedback-report": { "source": "iana" },
  "message/global": { "source": "iana", "extensions": ["u8msg"] },
  "message/global-delivery-status": { "source": "iana", "extensions": ["u8dsn"] },
  "message/global-disposition-notification": { "source": "iana", "extensions": ["u8mdn"] },
  "message/global-headers": { "source": "iana", "extensions": ["u8hdr"] },
  "message/http": { "source": "iana", "compressible": false },
  "message/imdn+xml": { "source": "iana", "compressible": true },
  "message/mls": { "source": "iana" },
  "message/news": { "source": "apache" },
  "message/ohttp-req": { "source": "iana" },
  "message/ohttp-res": { "source": "iana" },
  "message/partial": { "source": "iana", "compressible": false },
  "message/rfc822": { "source": "iana", "compressible": true, "extensions": ["eml", "mime", "mht", "mhtml"] },
  "message/s-http": { "source": "apache" },
  "message/sip": { "source": "iana" },
  "message/sipfrag": { "source": "iana" },
  "message/tracking-status": { "source": "iana" },
  "message/vnd.si.simp": { "source": "apache" },
  "message/vnd.wfa.wsc": { "source": "iana", "extensions": ["wsc"] },
  "model/3mf": { "source": "iana", "extensions": ["3mf"] },
  "model/e57": { "source": "iana" },
  "model/gltf+json": { "source": "iana", "compressible": true, "extensions": ["gltf"] },
  "model/gltf-binary": { "source": "iana", "compressible": true, "extensions": ["glb"] },
  "model/iges": { "source": "iana", "compressible": false, "extensions": ["igs", "iges"] },
  "model/jt": { "source": "iana", "extensions": ["jt"] },
  "model/mesh": { "source": "iana", "compressible": false, "extensions": ["msh", "mesh", "silo"] },
  "model/mtl": { "source": "iana", "extensions": ["mtl"] },
  "model/obj": { "source": "iana", "extensions": ["obj"] },
  "model/prc": { "source": "iana", "extensions": ["prc"] },
  "model/step": { "source": "iana", "extensions": ["step", "stp", "stpnc", "p21", "210"] },
  "model/step+xml": { "source": "iana", "compressible": true, "extensions": ["stpx"] },
  "model/step+zip": { "source": "iana", "compressible": false, "extensions": ["stpz"] },
  "model/step-xml+zip": { "source": "iana", "compressible": false, "extensions": ["stpxz"] },
  "model/stl": { "source": "iana", "extensions": ["stl"] },
  "model/u3d": { "source": "iana", "extensions": ["u3d"] },
  "model/vnd.bary": { "source": "iana", "extensions": ["bary"] },
  "model/vnd.cld": { "source": "iana", "extensions": ["cld"] },
  "model/vnd.collada+xml": { "source": "iana", "compressible": true, "extensions": ["dae"] },
  "model/vnd.dwf": { "source": "iana", "extensions": ["dwf"] },
  "model/vnd.flatland.3dml": { "source": "iana" },
  "model/vnd.gdl": { "source": "iana", "extensions": ["gdl"] },
  "model/vnd.gs-gdl": { "source": "apache" },
  "model/vnd.gs.gdl": { "source": "iana" },
  "model/vnd.gtw": { "source": "iana", "extensions": ["gtw"] },
  "model/vnd.moml+xml": { "source": "iana", "compressible": true },
  "model/vnd.mts": { "source": "iana", "extensions": ["mts"] },
  "model/vnd.opengex": { "source": "iana", "extensions": ["ogex"] },
  "model/vnd.parasolid.transmit.binary": { "source": "iana", "extensions": ["x_b"] },
  "model/vnd.parasolid.transmit.text": { "source": "iana", "extensions": ["x_t"] },
  "model/vnd.pytha.pyox": { "source": "iana", "extensions": ["pyo", "pyox"] },
  "model/vnd.rosette.annotated-data-model": { "source": "iana" },
  "model/vnd.sap.vds": { "source": "iana", "extensions": ["vds"] },
  "model/vnd.usda": { "source": "iana", "extensions": ["usda"] },
  "model/vnd.usdz+zip": { "source": "iana", "compressible": false, "extensions": ["usdz"] },
  "model/vnd.valve.source.compiled-map": { "source": "iana", "extensions": ["bsp"] },
  "model/vnd.vtu": { "source": "iana", "extensions": ["vtu"] },
  "model/vrml": { "source": "iana", "compressible": false, "extensions": ["wrl", "vrml"] },
  "model/x3d+binary": { "source": "apache", "compressible": false, "extensions": ["x3db", "x3dbz"] },
  "model/x3d+fastinfoset": { "source": "iana", "extensions": ["x3db"] },
  "model/x3d+vrml": { "source": "apache", "compressible": false, "extensions": ["x3dv", "x3dvz"] },
  "model/x3d+xml": { "source": "iana", "compressible": true, "extensions": ["x3d", "x3dz"] },
  "model/x3d-vrml": { "source": "iana", "extensions": ["x3dv"] },
  "multipart/alternative": { "source": "iana", "compressible": false },
  "multipart/appledouble": { "source": "iana" },
  "multipart/byteranges": { "source": "iana" },
  "multipart/digest": { "source": "iana" },
  "multipart/encrypted": { "source": "iana", "compressible": false },
  "multipart/form-data": { "source": "iana", "compressible": false },
  "multipart/header-set": { "source": "iana" },
  "multipart/mixed": { "source": "iana" },
  "multipart/multilingual": { "source": "iana" },
  "multipart/parallel": { "source": "iana" },
  "multipart/related": { "source": "iana", "compressible": false },
  "multipart/report": { "source": "iana" },
  "multipart/signed": { "source": "iana", "compressible": false },
  "multipart/vnd.bint.med-plus": { "source": "iana" },
  "multipart/voice-message": { "source": "iana" },
  "multipart/x-mixed-replace": { "source": "iana" },
  "text/1d-interleaved-parityfec": { "source": "iana" },
  "text/cache-manifest": { "source": "iana", "compressible": true, "extensions": ["appcache", "manifest"] },
  "text/calendar": { "source": "iana", "extensions": ["ics", "ifb"] },
  "text/calender": { "compressible": true },
  "text/cmd": { "compressible": true },
  "text/coffeescript": { "extensions": ["coffee", "litcoffee"] },
  "text/cql": { "source": "iana" },
  "text/cql-expression": { "source": "iana" },
  "text/cql-identifier": { "source": "iana" },
  "text/css": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["css"] },
  "text/csv": { "source": "iana", "compressible": true, "extensions": ["csv"] },
  "text/csv-schema": { "source": "iana" },
  "text/directory": { "source": "iana" },
  "text/dns": { "source": "iana" },
  "text/ecmascript": { "source": "apache" },
  "text/encaprtp": { "source": "iana" },
  "text/enriched": { "source": "iana" },
  "text/fhirpath": { "source": "iana" },
  "text/flexfec": { "source": "iana" },
  "text/fwdred": { "source": "iana" },
  "text/gff3": { "source": "iana" },
  "text/grammar-ref-list": { "source": "iana" },
  "text/hl7v2": { "source": "iana" },
  "text/html": { "source": "iana", "compressible": true, "extensions": ["html", "htm", "shtml"] },
  "text/jade": { "extensions": ["jade"] },
  "text/javascript": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["js", "mjs"] },
  "text/jcr-cnd": { "source": "iana" },
  "text/jsx": { "compressible": true, "extensions": ["jsx"] },
  "text/less": { "compressible": true, "extensions": ["less"] },
  "text/markdown": { "source": "iana", "compressible": true, "extensions": ["md", "markdown"] },
  "text/mathml": { "source": "nginx", "extensions": ["mml"] },
  "text/mdx": { "compressible": true, "extensions": ["mdx"] },
  "text/mizar": { "source": "iana" },
  "text/n3": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["n3"] },
  "text/parameters": { "source": "iana", "charset": "UTF-8" },
  "text/parityfec": { "source": "iana" },
  "text/plain": { "source": "iana", "compressible": true, "extensions": ["txt", "text", "conf", "def", "list", "log", "in", "ini"] },
  "text/provenance-notation": { "source": "iana", "charset": "UTF-8" },
  "text/prs.fallenstein.rst": { "source": "iana" },
  "text/prs.lines.tag": { "source": "iana", "extensions": ["dsc"] },
  "text/prs.prop.logic": { "source": "iana" },
  "text/prs.texi": { "source": "iana" },
  "text/raptorfec": { "source": "iana" },
  "text/red": { "source": "iana" },
  "text/rfc822-headers": { "source": "iana" },
  "text/richtext": { "source": "iana", "compressible": true, "extensions": ["rtx"] },
  "text/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "text/rtp-enc-aescm128": { "source": "iana" },
  "text/rtploopback": { "source": "iana" },
  "text/rtx": { "source": "iana" },
  "text/sgml": { "source": "iana", "extensions": ["sgml", "sgm"] },
  "text/shaclc": { "source": "iana" },
  "text/shex": { "source": "iana", "extensions": ["shex"] },
  "text/slim": { "extensions": ["slim", "slm"] },
  "text/spdx": { "source": "iana", "extensions": ["spdx"] },
  "text/strings": { "source": "iana" },
  "text/stylus": { "extensions": ["stylus", "styl"] },
  "text/t140": { "source": "iana" },
  "text/tab-separated-values": { "source": "iana", "compressible": true, "extensions": ["tsv"] },
  "text/troff": { "source": "iana", "extensions": ["t", "tr", "roff", "man", "me", "ms"] },
  "text/turtle": { "source": "iana", "charset": "UTF-8", "extensions": ["ttl"] },
  "text/ulpfec": { "source": "iana" },
  "text/uri-list": { "source": "iana", "compressible": true, "extensions": ["uri", "uris", "urls"] },
  "text/vcard": { "source": "iana", "compressible": true, "extensions": ["vcard"] },
  "text/vnd.a": { "source": "iana" },
  "text/vnd.abc": { "source": "iana" },
  "text/vnd.ascii-art": { "source": "iana" },
  "text/vnd.curl": { "source": "iana", "extensions": ["curl"] },
  "text/vnd.curl.dcurl": { "source": "apache", "extensions": ["dcurl"] },
  "text/vnd.curl.mcurl": { "source": "apache", "extensions": ["mcurl"] },
  "text/vnd.curl.scurl": { "source": "apache", "extensions": ["scurl"] },
  "text/vnd.debian.copyright": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.dmclientscript": { "source": "iana" },
  "text/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "text/vnd.esmertec.theme-descriptor": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.exchangeable": { "source": "iana" },
  "text/vnd.familysearch.gedcom": { "source": "iana", "extensions": ["ged"] },
  "text/vnd.ficlab.flt": { "source": "iana" },
  "text/vnd.fly": { "source": "iana", "extensions": ["fly"] },
  "text/vnd.fmi.flexstor": { "source": "iana", "extensions": ["flx"] },
  "text/vnd.gml": { "source": "iana" },
  "text/vnd.graphviz": { "source": "iana", "extensions": ["gv"] },
  "text/vnd.hans": { "source": "iana" },
  "text/vnd.hgl": { "source": "iana" },
  "text/vnd.in3d.3dml": { "source": "iana", "extensions": ["3dml"] },
  "text/vnd.in3d.spot": { "source": "iana", "extensions": ["spot"] },
  "text/vnd.iptc.newsml": { "source": "iana" },
  "text/vnd.iptc.nitf": { "source": "iana" },
  "text/vnd.latex-z": { "source": "iana" },
  "text/vnd.motorola.reflex": { "source": "iana" },
  "text/vnd.ms-mediapackage": { "source": "iana" },
  "text/vnd.net2phone.commcenter.command": { "source": "iana" },
  "text/vnd.radisys.msml-basic-layout": { "source": "iana" },
  "text/vnd.senx.warpscript": { "source": "iana" },
  "text/vnd.si.uricatalogue": { "source": "apache" },
  "text/vnd.sosi": { "source": "iana" },
  "text/vnd.sun.j2me.app-descriptor": { "source": "iana", "charset": "UTF-8", "extensions": ["jad"] },
  "text/vnd.trolltech.linguist": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.vcf": { "source": "iana" },
  "text/vnd.wap.si": { "source": "iana" },
  "text/vnd.wap.sl": { "source": "iana" },
  "text/vnd.wap.wml": { "source": "iana", "extensions": ["wml"] },
  "text/vnd.wap.wmlscript": { "source": "iana", "extensions": ["wmls"] },
  "text/vnd.zoo.kcl": { "source": "iana" },
  "text/vtt": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["vtt"] },
  "text/wgsl": { "source": "iana", "extensions": ["wgsl"] },
  "text/x-asm": { "source": "apache", "extensions": ["s", "asm"] },
  "text/x-c": { "source": "apache", "extensions": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"] },
  "text/x-component": { "source": "nginx", "extensions": ["htc"] },
  "text/x-fortran": { "source": "apache", "extensions": ["f", "for", "f77", "f90"] },
  "text/x-gwt-rpc": { "compressible": true },
  "text/x-handlebars-template": { "extensions": ["hbs"] },
  "text/x-java-source": { "source": "apache", "extensions": ["java"] },
  "text/x-jquery-tmpl": { "compressible": true },
  "text/x-lua": { "extensions": ["lua"] },
  "text/x-markdown": { "compressible": true, "extensions": ["mkd"] },
  "text/x-nfo": { "source": "apache", "extensions": ["nfo"] },
  "text/x-opml": { "source": "apache", "extensions": ["opml"] },
  "text/x-org": { "compressible": true, "extensions": ["org"] },
  "text/x-pascal": { "source": "apache", "extensions": ["p", "pas"] },
  "text/x-processing": { "compressible": true, "extensions": ["pde"] },
  "text/x-sass": { "extensions": ["sass"] },
  "text/x-scss": { "extensions": ["scss"] },
  "text/x-setext": { "source": "apache", "extensions": ["etx"] },
  "text/x-sfv": { "source": "apache", "extensions": ["sfv"] },
  "text/x-suse-ymp": { "compressible": true, "extensions": ["ymp"] },
  "text/x-uuencode": { "source": "apache", "extensions": ["uu"] },
  "text/x-vcalendar": { "source": "apache", "extensions": ["vcs"] },
  "text/x-vcard": { "source": "apache", "extensions": ["vcf"] },
  "text/xml": { "source": "iana", "compressible": true, "extensions": ["xml"] },
  "text/xml-external-parsed-entity": { "source": "iana" },
  "text/yaml": { "compressible": true, "extensions": ["yaml", "yml"] },
  "video/1d-interleaved-parityfec": { "source": "iana" },
  "video/3gpp": { "source": "iana", "extensions": ["3gp", "3gpp"] },
  "video/3gpp-tt": { "source": "iana" },
  "video/3gpp2": { "source": "iana", "extensions": ["3g2"] },
  "video/av1": { "source": "iana" },
  "video/bmpeg": { "source": "iana" },
  "video/bt656": { "source": "iana" },
  "video/celb": { "source": "iana" },
  "video/dv": { "source": "iana" },
  "video/encaprtp": { "source": "iana" },
  "video/evc": { "source": "iana" },
  "video/ffv1": { "source": "iana" },
  "video/flexfec": { "source": "iana" },
  "video/h261": { "source": "iana", "extensions": ["h261"] },
  "video/h263": { "source": "iana", "extensions": ["h263"] },
  "video/h263-1998": { "source": "iana" },
  "video/h263-2000": { "source": "iana" },
  "video/h264": { "source": "iana", "extensions": ["h264"] },
  "video/h264-rcdo": { "source": "iana" },
  "video/h264-svc": { "source": "iana" },
  "video/h265": { "source": "iana" },
  "video/h266": { "source": "iana" },
  "video/iso.segment": { "source": "iana", "extensions": ["m4s"] },
  "video/jpeg": { "source": "iana", "extensions": ["jpgv"] },
  "video/jpeg2000": { "source": "iana" },
  "video/jpm": { "source": "apache", "extensions": ["jpm", "jpgm"] },
  "video/jxsv": { "source": "iana" },
  "video/lottie+json": { "source": "iana", "compressible": true },
  "video/matroska": { "source": "iana" },
  "video/matroska-3d": { "source": "iana" },
  "video/mj2": { "source": "iana", "extensions": ["mj2", "mjp2"] },
  "video/mp1s": { "source": "iana" },
  "video/mp2p": { "source": "iana" },
  "video/mp2t": { "source": "iana", "extensions": ["ts", "m2t", "m2ts", "mts"] },
  "video/mp4": { "source": "iana", "compressible": false, "extensions": ["mp4", "mp4v", "mpg4"] },
  "video/mp4v-es": { "source": "iana" },
  "video/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpeg", "mpg", "mpe", "m1v", "m2v"] },
  "video/mpeg4-generic": { "source": "iana" },
  "video/mpv": { "source": "iana" },
  "video/nv": { "source": "iana" },
  "video/ogg": { "source": "iana", "compressible": false, "extensions": ["ogv"] },
  "video/parityfec": { "source": "iana" },
  "video/pointer": { "source": "iana" },
  "video/quicktime": { "source": "iana", "compressible": false, "extensions": ["qt", "mov"] },
  "video/raptorfec": { "source": "iana" },
  "video/raw": { "source": "iana" },
  "video/rtp-enc-aescm128": { "source": "iana" },
  "video/rtploopback": { "source": "iana" },
  "video/rtx": { "source": "iana" },
  "video/scip": { "source": "iana" },
  "video/smpte291": { "source": "iana" },
  "video/smpte292m": { "source": "iana" },
  "video/ulpfec": { "source": "iana" },
  "video/vc1": { "source": "iana" },
  "video/vc2": { "source": "iana" },
  "video/vnd.cctv": { "source": "iana" },
  "video/vnd.dece.hd": { "source": "iana", "extensions": ["uvh", "uvvh"] },
  "video/vnd.dece.mobile": { "source": "iana", "extensions": ["uvm", "uvvm"] },
  "video/vnd.dece.mp4": { "source": "iana" },
  "video/vnd.dece.pd": { "source": "iana", "extensions": ["uvp", "uvvp"] },
  "video/vnd.dece.sd": { "source": "iana", "extensions": ["uvs", "uvvs"] },
  "video/vnd.dece.video": { "source": "iana", "extensions": ["uvv", "uvvv"] },
  "video/vnd.directv.mpeg": { "source": "iana" },
  "video/vnd.directv.mpeg-tts": { "source": "iana" },
  "video/vnd.dlna.mpeg-tts": { "source": "iana" },
  "video/vnd.dvb.file": { "source": "iana", "extensions": ["dvb"] },
  "video/vnd.fvt": { "source": "iana", "extensions": ["fvt"] },
  "video/vnd.hns.video": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.ttsavc": { "source": "iana" },
  "video/vnd.iptvforum.ttsmpeg2": { "source": "iana" },
  "video/vnd.motorola.video": { "source": "iana" },
  "video/vnd.motorola.videop": { "source": "iana" },
  "video/vnd.mpegurl": { "source": "iana", "extensions": ["mxu", "m4u"] },
  "video/vnd.ms-playready.media.pyv": { "source": "iana", "extensions": ["pyv"] },
  "video/vnd.nokia.interleaved-multimedia": { "source": "iana" },
  "video/vnd.nokia.mp4vr": { "source": "iana" },
  "video/vnd.nokia.videovoip": { "source": "iana" },
  "video/vnd.objectvideo": { "source": "iana" },
  "video/vnd.planar": { "source": "iana" },
  "video/vnd.radgamettools.bink": { "source": "iana" },
  "video/vnd.radgamettools.smacker": { "source": "apache" },
  "video/vnd.sealed.mpeg1": { "source": "iana" },
  "video/vnd.sealed.mpeg4": { "source": "iana" },
  "video/vnd.sealed.swf": { "source": "iana" },
  "video/vnd.sealedmedia.softseal.mov": { "source": "iana" },
  "video/vnd.uvvu.mp4": { "source": "iana", "extensions": ["uvu", "uvvu"] },
  "video/vnd.vivo": { "source": "iana", "extensions": ["viv"] },
  "video/vnd.youtube.yt": { "source": "iana" },
  "video/vp8": { "source": "iana" },
  "video/vp9": { "source": "iana" },
  "video/webm": { "source": "apache", "compressible": false, "extensions": ["webm"] },
  "video/x-f4v": { "source": "apache", "extensions": ["f4v"] },
  "video/x-fli": { "source": "apache", "extensions": ["fli"] },
  "video/x-flv": { "source": "apache", "compressible": false, "extensions": ["flv"] },
  "video/x-m4v": { "source": "apache", "extensions": ["m4v"] },
  "video/x-matroska": { "source": "apache", "compressible": false, "extensions": ["mkv", "mk3d", "mks"] },
  "video/x-mng": { "source": "apache", "extensions": ["mng"] },
  "video/x-ms-asf": { "source": "apache", "extensions": ["asf", "asx"] },
  "video/x-ms-vob": { "source": "apache", "extensions": ["vob"] },
  "video/x-ms-wm": { "source": "apache", "extensions": ["wm"] },
  "video/x-ms-wmv": { "source": "apache", "compressible": false, "extensions": ["wmv"] },
  "video/x-ms-wmx": { "source": "apache", "extensions": ["wmx"] },
  "video/x-ms-wvx": { "source": "apache", "extensions": ["wvx"] },
  "video/x-msvideo": { "source": "apache", "extensions": ["avi"] },
  "video/x-sgi-movie": { "source": "apache", "extensions": ["movie"] },
  "video/x-smv": { "source": "apache", "extensions": ["smv"] },
  "x-conference/x-cooltalk": { "source": "apache", "extensions": ["ice"] },
  "x-shader/x-fragment": { "compressible": true },
  "x-shader/x-vertex": { "compressible": true }
};
var mimeDb$1;
var hasRequiredMimeDb$1;
function requireMimeDb$1() {
  if (hasRequiredMimeDb$1) return mimeDb$1;
  hasRequiredMimeDb$1 = 1;
  mimeDb$1 = require$$0$1;
  return mimeDb$1;
}
var mimeScore;
var hasRequiredMimeScore;
function requireMimeScore() {
  if (hasRequiredMimeScore) return mimeScore;
  hasRequiredMimeScore = 1;
  var FACET_SCORES = {
    "prs.": 100,
    "x-": 200,
    "x.": 300,
    "vnd.": 400,
    default: 900
  };
  var SOURCE_SCORES = {
    nginx: 10,
    apache: 20,
    iana: 40,
    default: 30
    // definitions added by `jshttp/mime-db` project?
  };
  var TYPE_SCORES = {
    // prefer application/xml over text/xml
    // prefer application/rtf over text/rtf
    application: 1,
    // prefer font/woff over application/font-woff
    font: 2,
    // prefer video/mp4 over audio/mp4 over application/mp4
    // See https://www.rfc-editor.org/rfc/rfc4337.html#section-2
    audio: 2,
    video: 3,
    default: 0
  };
  mimeScore = function mimeScore2(mimeType, source2 = "default") {
    if (mimeType === "application/octet-stream") {
      return 0;
    }
    const [type2, subtype] = mimeType.split("/");
    const facet = subtype.replace(/(\.|x-).*/, "$1");
    const facetScore = FACET_SCORES[facet] || FACET_SCORES.default;
    const sourceScore = SOURCE_SCORES[source2] || SOURCE_SCORES.default;
    const typeScore = TYPE_SCORES[type2] || TYPE_SCORES.default;
    const lengthScore = 1 - mimeType.length / 100;
    return facetScore + sourceScore + typeScore + lengthScore;
  };
  return mimeScore;
}
var hasRequiredMimeTypes$1;
function requireMimeTypes$1() {
  if (hasRequiredMimeTypes$1) return mimeTypes$1;
  hasRequiredMimeTypes$1 = 1;
  (function(exports$1) {
    var db = requireMimeDb$1();
    var extname = path$1.extname;
    var mimeScore2 = requireMimeScore();
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports$1.charset = charset2;
    exports$1.charsets = { lookup: charset2 };
    exports$1.contentType = contentType2;
    exports$1.extension = extension;
    exports$1.extensions = /* @__PURE__ */ Object.create(null);
    exports$1.lookup = lookup;
    exports$1.types = /* @__PURE__ */ Object.create(null);
    exports$1._extensionConflicts = [];
    populateMaps(exports$1.extensions, exports$1.types);
    function charset2(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType2(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports$1.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset3 = exports$1.charset(mime);
        if (charset3) mime += "; charset=" + charset3.toLowerCase();
      }
      return mime;
    }
    function extension(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var exts = match && exports$1.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path2) {
      if (!path2 || typeof path2 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path2).toLowerCase().slice(1);
      if (!extension2) {
        return false;
      }
      return exports$1.types[extension2] || false;
    }
    function populateMaps(extensions, types2) {
      Object.keys(db).forEach(function forEachMimeType(type2) {
        var mime = db[type2];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type2] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          types2[extension2] = _preferredType(extension2, types2[extension2], type2);
          const legacyType = _preferredTypeLegacy(
            extension2,
            types2[extension2],
            type2
          );
          if (legacyType !== types2[extension2]) {
            exports$1._extensionConflicts.push([extension2, legacyType, types2[extension2]]);
          }
        }
      });
    }
    function _preferredType(ext, type0, type1) {
      var score0 = type0 ? mimeScore2(type0, db[type0].source) : 0;
      var score1 = type1 ? mimeScore2(type1, db[type1].source) : 0;
      return score0 > score1 ? type0 : type1;
    }
    function _preferredTypeLegacy(ext, type0, type1) {
      var SOURCE_RANK = ["nginx", "apache", void 0, "iana"];
      var score0 = type0 ? SOURCE_RANK.indexOf(db[type0].source) : 0;
      var score1 = type1 ? SOURCE_RANK.indexOf(db[type1].source) : 0;
      if (exports$1.types[extension] !== "application/octet-stream" && (score0 > score1 || score0 === score1 && exports$1.types[extension]?.slice(0, 12) === "application/")) {
        return type0;
      }
      return score0 > score1 ? type0 : type1;
    }
  })(mimeTypes$1);
  return mimeTypes$1;
}
var mediaTyper$1 = {};
var hasRequiredMediaTyper$1;
function requireMediaTyper$1() {
  if (hasRequiredMediaTyper$1) return mediaTyper$1;
  hasRequiredMediaTyper$1 = 1;
  var SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
  var TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
  var TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
  mediaTyper$1.format = format;
  mediaTyper$1.parse = parse3;
  mediaTyper$1.test = test;
  function format(obj) {
    if (!obj || typeof obj !== "object") {
      throw new TypeError("argument obj is required");
    }
    var subtype = obj.subtype;
    var suffix = obj.suffix;
    var type2 = obj.type;
    if (!type2 || !TYPE_NAME_REGEXP.test(type2)) {
      throw new TypeError("invalid type");
    }
    if (!subtype || !SUBTYPE_NAME_REGEXP.test(subtype)) {
      throw new TypeError("invalid subtype");
    }
    var string2 = type2 + "/" + subtype;
    if (suffix) {
      if (!TYPE_NAME_REGEXP.test(suffix)) {
        throw new TypeError("invalid suffix");
      }
      string2 += "+" + suffix;
    }
    return string2;
  }
  function test(string2) {
    if (!string2) {
      throw new TypeError("argument string is required");
    }
    if (typeof string2 !== "string") {
      throw new TypeError("argument string is required to be a string");
    }
    return TYPE_REGEXP.test(string2.toLowerCase());
  }
  function parse3(string2) {
    if (!string2) {
      throw new TypeError("argument string is required");
    }
    if (typeof string2 !== "string") {
      throw new TypeError("argument string is required to be a string");
    }
    var match = TYPE_REGEXP.exec(string2.toLowerCase());
    if (!match) {
      throw new TypeError("invalid media type");
    }
    var type2 = match[1];
    var subtype = match[2];
    var suffix;
    var index2 = subtype.lastIndexOf("+");
    if (index2 !== -1) {
      suffix = subtype.substr(index2 + 1);
      subtype = subtype.substr(0, index2);
    }
    return new MediaType(type2, subtype, suffix);
  }
  function MediaType(type2, subtype, suffix) {
    this.type = type2;
    this.subtype = subtype;
    this.suffix = suffix;
  }
  return mediaTyper$1;
}
var hasRequiredTypeIs$1;
function requireTypeIs$1() {
  if (hasRequiredTypeIs$1) return typeIs$1.exports;
  hasRequiredTypeIs$1 = 1;
  var contentType2 = requireContentType();
  var mime = requireMimeTypes$1();
  var typer = requireMediaTyper$1();
  typeIs$1.exports = typeofrequest;
  typeIs$1.exports.is = typeis;
  typeIs$1.exports.hasBody = hasbody;
  typeIs$1.exports.normalize = normalize;
  typeIs$1.exports.match = mimeMatch;
  function typeis(value, types_) {
    var i;
    var types2 = types_;
    var val = tryNormalizeType(value);
    if (!val) {
      return false;
    }
    if (types2 && !Array.isArray(types2)) {
      types2 = new Array(arguments.length - 1);
      for (i = 0; i < types2.length; i++) {
        types2[i] = arguments[i + 1];
      }
    }
    if (!types2 || !types2.length) {
      return val;
    }
    var type2;
    for (i = 0; i < types2.length; i++) {
      if (mimeMatch(normalize(type2 = types2[i]), val)) {
        return type2[0] === "+" || type2.indexOf("*") !== -1 ? val : type2;
      }
    }
    return false;
  }
  function hasbody(req) {
    return req.headers["transfer-encoding"] !== void 0 || !isNaN(req.headers["content-length"]);
  }
  function typeofrequest(req, types_) {
    if (!hasbody(req)) return null;
    var types2 = arguments.length > 2 ? Array.prototype.slice.call(arguments, 1) : types_;
    var value = req.headers["content-type"];
    return typeis(value, types2);
  }
  function normalize(type2) {
    if (typeof type2 !== "string") {
      return false;
    }
    switch (type2) {
      case "urlencoded":
        return "application/x-www-form-urlencoded";
      case "multipart":
        return "multipart/*";
    }
    if (type2[0] === "+") {
      return "*/*" + type2;
    }
    return type2.indexOf("/") === -1 ? mime.lookup(type2) : type2;
  }
  function mimeMatch(expected, actual) {
    if (expected === false) {
      return false;
    }
    var actualParts = actual.split("/");
    var expectedParts = expected.split("/");
    if (actualParts.length !== 2 || expectedParts.length !== 2) {
      return false;
    }
    if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) {
      return false;
    }
    if (expectedParts[1].slice(0, 2) === "*+") {
      return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].slice(1) === actualParts[1].slice(1 - expectedParts[1].length);
    }
    if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) {
      return false;
    }
    return true;
  }
  function normalizeType(value) {
    var type2 = contentType2.parse(value).type;
    return typer.test(type2) ? type2 : null;
  }
  function tryNormalizeType(value) {
    try {
      return value ? normalizeType(value) : null;
    } catch (err) {
      return null;
    }
  }
  return typeIs$1.exports;
}
var utils$3;
var hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$3;
  hasRequiredUtils$3 = 1;
  var bytes2 = requireBytes();
  var contentType2 = requireContentType();
  var typeis = requireTypeIs$1();
  utils$3 = {
    getCharset,
    normalizeOptions,
    passthrough
  };
  function getCharset(req) {
    try {
      return (contentType2.parse(req).parameters.charset || "").toLowerCase();
    } catch {
      return void 0;
    }
  }
  function typeChecker(type2) {
    return function checkType(req) {
      return Boolean(typeis(req, type2));
    };
  }
  function normalizeOptions(options, defaultType) {
    if (!defaultType) {
      throw new TypeError("defaultType must be provided");
    }
    var inflate = options?.inflate !== false;
    var limit = typeof options?.limit !== "number" ? bytes2.parse(options?.limit || "100kb") : options?.limit;
    var type2 = options?.type || defaultType;
    var verify = options?.verify || false;
    var defaultCharset = options?.defaultCharset || "utf-8";
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type2 !== "function" ? typeChecker(type2) : type2;
    return {
      inflate,
      limit,
      verify,
      defaultCharset,
      shouldParse
    };
  }
  function passthrough(value) {
    return value;
  }
  return utils$3;
}
var read_1;
var hasRequiredRead;
function requireRead() {
  if (hasRequiredRead) return read_1;
  hasRequiredRead = 1;
  var createError = requireHttpErrors();
  var getBody = requireRawBody();
  var iconv = requireLib$3();
  var onFinished2 = requireOnFinished();
  var zlib = require$$4$1;
  var hasBody = requireTypeIs$1().hasBody;
  var { getCharset } = requireUtils$3();
  read_1 = read2;
  function read2(req, res, next, parse3, debug, options) {
    if (onFinished2.isFinished(req)) {
      debug("body already parsed");
      next();
      return;
    }
    if (!("body" in req)) {
      req.body = void 0;
    }
    if (!hasBody(req)) {
      debug("skip empty body");
      next();
      return;
    }
    debug("content-type %j", req.headers["content-type"]);
    if (!options.shouldParse(req)) {
      debug("skip parsing");
      next();
      return;
    }
    var encoding2 = null;
    if (options?.skipCharset !== true) {
      encoding2 = getCharset(req) || options.defaultCharset;
      if (!!options?.isValidCharset && !options.isValidCharset(encoding2)) {
        debug("invalid charset");
        next(createError(415, 'unsupported charset "' + encoding2.toUpperCase() + '"', {
          charset: encoding2,
          type: "charset.unsupported"
        }));
        return;
      }
    }
    var length;
    var opts = options;
    var stream;
    var verify = opts.verify;
    try {
      stream = contentstream(req, debug, opts.inflate);
      length = stream.length;
      stream.length = void 0;
    } catch (err) {
      return next(err);
    }
    opts.length = length;
    opts.encoding = verify ? null : encoding2;
    if (opts.encoding === null && encoding2 !== null && !iconv.encodingExists(encoding2)) {
      return next(createError(415, 'unsupported charset "' + encoding2.toUpperCase() + '"', {
        charset: encoding2.toLowerCase(),
        type: "charset.unsupported"
      }));
    }
    debug("read body");
    getBody(stream, opts, function(error2, body) {
      if (error2) {
        var _error;
        if (error2.type === "encoding.unsupported") {
          _error = createError(415, 'unsupported charset "' + encoding2.toUpperCase() + '"', {
            charset: encoding2.toLowerCase(),
            type: "charset.unsupported"
          });
        } else {
          _error = createError(400, error2);
        }
        if (stream !== req) {
          req.unpipe();
          stream.destroy();
        }
        dump(req, function onfinished() {
          next(createError(400, _error));
        });
        return;
      }
      if (verify) {
        try {
          debug("verify body");
          verify(req, res, body, encoding2);
        } catch (err) {
          next(createError(403, err, {
            body,
            type: err.type || "entity.verify.failed"
          }));
          return;
        }
      }
      var str = body;
      try {
        debug("parse body");
        str = typeof body !== "string" && encoding2 !== null ? iconv.decode(body, encoding2) : body;
        req.body = parse3(str, encoding2);
      } catch (err) {
        next(createError(400, err, {
          body: str,
          type: err.type || "entity.parse.failed"
        }));
        return;
      }
      next();
    });
  }
  function contentstream(req, debug, inflate) {
    var encoding2 = (req.headers["content-encoding"] || "identity").toLowerCase();
    var length = req.headers["content-length"];
    debug('content-encoding "%s"', encoding2);
    if (inflate === false && encoding2 !== "identity") {
      throw createError(415, "content encoding unsupported", {
        encoding: encoding2,
        type: "encoding.unsupported"
      });
    }
    if (encoding2 === "identity") {
      req.length = length;
      return req;
    }
    var stream = createDecompressionStream(encoding2, debug);
    req.pipe(stream);
    return stream;
  }
  function createDecompressionStream(encoding2, debug) {
    switch (encoding2) {
      case "deflate":
        debug("inflate body");
        return zlib.createInflate();
      case "gzip":
        debug("gunzip body");
        return zlib.createGunzip();
      case "br":
        debug("brotli decompress body");
        return zlib.createBrotliDecompress();
      default:
        throw createError(415, 'unsupported content encoding "' + encoding2 + '"', {
          encoding: encoding2,
          type: "encoding.unsupported"
        });
    }
  }
  function dump(req, callback) {
    if (onFinished2.isFinished(req)) {
      callback(null);
    } else {
      onFinished2(req, callback);
      req.resume();
    }
  }
  return read_1;
}
var json_1;
var hasRequiredJson;
function requireJson() {
  if (hasRequiredJson) return json_1;
  hasRequiredJson = 1;
  var debug = require$$0$9("body-parser:json");
  var read2 = requireRead();
  var { normalizeOptions } = requireUtils$3();
  json_1 = json2;
  var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
  var JSON_SYNTAX_CHAR = "#";
  var JSON_SYNTAX_REGEXP = /#+/g;
  function json2(options) {
    const normalizedOptions = normalizeOptions(options, "application/json");
    var reviver = options?.reviver;
    var strict = options?.strict !== false;
    function parse3(body) {
      if (body.length === 0) {
        return {};
      }
      if (strict) {
        var first = firstchar(body);
        if (first !== "{" && first !== "[") {
          debug("strict violation");
          throw createStrictSyntaxError(body, first);
        }
      }
      try {
        debug("parse json");
        return JSON.parse(body, reviver);
      } catch (e) {
        throw normalizeJsonSyntaxError(e, {
          message: e.message,
          stack: e.stack
        });
      }
    }
    const readOptions = {
      ...normalizedOptions,
      // assert charset per RFC 7159 sec 8.1
      isValidCharset: (charset2) => charset2.slice(0, 4) === "utf-"
    };
    return function jsonParser(req, res, next) {
      read2(req, res, next, parse3, debug, readOptions);
    };
  }
  function createStrictSyntaxError(str, char) {
    var index2 = str.indexOf(char);
    var partial2 = "";
    if (index2 !== -1) {
      partial2 = str.substring(0, index2) + JSON_SYNTAX_CHAR;
      for (var i = index2 + 1; i < str.length; i++) {
        partial2 += JSON_SYNTAX_CHAR;
      }
    }
    try {
      JSON.parse(partial2);
      throw new SyntaxError("strict violation");
    } catch (e) {
      return normalizeJsonSyntaxError(e, {
        message: e.message.replace(JSON_SYNTAX_REGEXP, function(placeholder) {
          return str.substring(index2, index2 + placeholder.length);
        }),
        stack: e.stack
      });
    }
  }
  function firstchar(str) {
    var match = FIRST_CHAR_REGEXP.exec(str);
    return match ? match[1] : void 0;
  }
  function normalizeJsonSyntaxError(error2, obj) {
    var keys = Object.getOwnPropertyNames(error2);
    for (var i = 0; i < keys.length; i++) {
      var key2 = keys[i];
      if (key2 !== "stack" && key2 !== "message") {
        delete error2[key2];
      }
    }
    error2.stack = obj.stack.replace(error2.message, obj.message);
    error2.message = obj.message;
    return error2;
  }
  return json_1;
}
var raw_1;
var hasRequiredRaw;
function requireRaw() {
  if (hasRequiredRaw) return raw_1;
  hasRequiredRaw = 1;
  var debug = require$$0$9("body-parser:raw");
  var read2 = requireRead();
  var { normalizeOptions, passthrough } = requireUtils$3();
  raw_1 = raw;
  function raw(options) {
    const normalizedOptions = normalizeOptions(options, "application/octet-stream");
    const readOptions = {
      ...normalizedOptions,
      // Skip charset validation and parse the body as is
      skipCharset: true
    };
    return function rawParser(req, res, next) {
      read2(req, res, next, passthrough, debug, readOptions);
    };
  }
  return raw_1;
}
var text_1;
var hasRequiredText;
function requireText() {
  if (hasRequiredText) return text_1;
  hasRequiredText = 1;
  var debug = require$$0$9("body-parser:text");
  var read2 = requireRead();
  var { normalizeOptions, passthrough } = requireUtils$3();
  text_1 = text;
  function text(options) {
    const normalizedOptions = normalizeOptions(options, "text/plain");
    return function textParser(req, res, next) {
      read2(req, res, next, passthrough, debug, normalizedOptions);
    };
  }
  return text_1;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
var sideChannelList;
var hasRequiredSideChannelList;
function requireSideChannelList() {
  if (hasRequiredSideChannelList) return sideChannelList;
  hasRequiredSideChannelList = 1;
  var inspect2 = require$$2$1;
  var $TypeError = /* @__PURE__ */ requireType();
  var listGetNode = function(list, key2, isDelete) {
    var prev = list;
    var curr;
    for (; (curr = prev.next) != null; prev = curr) {
      if (curr.key === key2) {
        prev.next = curr.next;
        if (!isDelete) {
          curr.next = /** @type {NonNullable<typeof list.next>} */
          list.next;
          list.next = curr;
        }
        return curr;
      }
    }
  };
  var listGet = function(objects, key2) {
    if (!objects) {
      return void 0;
    }
    var node = listGetNode(objects, key2);
    return node && node.value;
  };
  var listSet = function(objects, key2, value) {
    var node = listGetNode(objects, key2);
    if (node) {
      node.value = value;
    } else {
      objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
      {
        // eslint-disable-line no-param-reassign, no-extra-parens
        key: key2,
        next: objects.next,
        value
      };
    }
  };
  var listHas = function(objects, key2) {
    if (!objects) {
      return false;
    }
    return !!listGetNode(objects, key2);
  };
  var listDelete = function(objects, key2) {
    if (objects) {
      return listGetNode(objects, key2, true);
    }
  };
  sideChannelList = function getSideChannelList() {
    var $o;
    var channel = {
      assert: function(key2) {
        if (!channel.has(key2)) {
          throw new $TypeError("Side channel does not contain " + inspect2(key2));
        }
      },
      "delete": function(key2) {
        var root2 = $o && $o.next;
        var deletedNode = listDelete($o, key2);
        if (deletedNode && root2 && root2 === deletedNode) {
          $o = void 0;
        }
        return !!deletedNode;
      },
      get: function(key2) {
        return listGet($o, key2);
      },
      has: function(key2) {
        return listHas($o, key2);
      },
      set: function(key2, value) {
        if (!$o) {
          $o = {
            next: void 0
          };
        }
        listSet(
          /** @type {NonNullable<typeof $o>} */
          $o,
          key2,
          value
        );
      }
    };
    return channel;
  };
  return sideChannelList;
}
var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  if (hasRequiredEsObjectAtoms) return esObjectAtoms;
  hasRequiredEsObjectAtoms = 1;
  esObjectAtoms = Object;
  return esObjectAtoms;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  range = RangeError;
  return range;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = ReferenceError;
  return ref;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
var abs;
var hasRequiredAbs;
function requireAbs() {
  if (hasRequiredAbs) return abs;
  hasRequiredAbs = 1;
  abs = Math.abs;
  return abs;
}
var floor;
var hasRequiredFloor;
function requireFloor() {
  if (hasRequiredFloor) return floor;
  hasRequiredFloor = 1;
  floor = Math.floor;
  return floor;
}
var max;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max;
  hasRequiredMax = 1;
  max = Math.max;
  return max;
}
var min;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min;
  hasRequiredMin = 1;
  min = Math.min;
  return min;
}
var pow;
var hasRequiredPow;
function requirePow() {
  if (hasRequiredPow) return pow;
  hasRequiredPow = 1;
  pow = Math.pow;
  return pow;
}
var round;
var hasRequiredRound;
function requireRound() {
  if (hasRequiredRound) return round;
  hasRequiredRound = 1;
  round = Math.round;
  return round;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
  if (hasRequired_isNaN) return _isNaN;
  hasRequired_isNaN = 1;
  _isNaN = Number.isNaN || function isNaN2(a) {
    return a !== a;
  };
  return _isNaN;
}
var sign;
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign;
  hasRequiredSign = 1;
  var $isNaN = /* @__PURE__ */ require_isNaN();
  sign = function sign2(number2) {
    if ($isNaN(number2) || number2 === 0) {
      return number2;
    }
    return number2 < 0 ? -1 : 1;
  };
  return sign;
}
var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
  if (hasRequiredGOPD) return gOPD;
  hasRequiredGOPD = 1;
  gOPD = Object.getOwnPropertyDescriptor;
  return gOPD;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var $gOPD = /* @__PURE__ */ requireGOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  shams = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = /* @__PURE__ */ Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof /* @__PURE__ */ Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  Object_getPrototypeOf = $Object.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b) {
    var arr = [];
    for (var i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0; i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind = requireFunctionBind();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind.call($call, $apply);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind = requireFunctionBind();
  var $TypeError = /* @__PURE__ */ requireType();
  var $call = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind, $call, args);
  };
  return callBindApplyHelpers;
}
var get;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var callBind = requireCallBindApplyHelpers();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  get = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    }
  ) : false;
  return get;
}
var getProto;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = /* @__PURE__ */ requireGet();
  getProto = reflectGetProto ? function getProto2(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto2(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto2(O) {
    return getDunderProto(O);
  } : null;
  return getProto;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = requireFunctionBind();
  hasown = bind.call(call, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  var $Error = /* @__PURE__ */ requireEsErrors();
  var $EvalError = /* @__PURE__ */ require_eval();
  var $RangeError = /* @__PURE__ */ requireRange();
  var $ReferenceError = /* @__PURE__ */ requireRef();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var $URIError = /* @__PURE__ */ requireUri();
  var abs2 = /* @__PURE__ */ requireAbs();
  var floor2 = /* @__PURE__ */ requireFloor();
  var max2 = /* @__PURE__ */ requireMax();
  var min2 = /* @__PURE__ */ requireMin();
  var pow2 = /* @__PURE__ */ requirePow();
  var round2 = /* @__PURE__ */ requireRound();
  var sign2 = /* @__PURE__ */ requireSign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = /* @__PURE__ */ requireGopd();
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? (function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  })() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var getProto2 = requireGetProto();
  var $ObjectGPO = requireObject_getPrototypeOf();
  var $ReflectGPO = requireReflect_getPrototypeOf();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs2,
    "%Math.floor%": floor2,
    "%Math.max%": max2,
    "%Math.min%": min2,
    "%Math.pow%": pow2,
    "%Math.round%": round2,
    "%Math.sign%": sign2,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto2) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto2(getProto2(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto2) {
        value = getProto2(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = requireFunctionBind();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var $concat = bind.call($call, Array.prototype.concat);
  var $spliceApply = bind.call($apply, Array.prototype.splice);
  var $replace = bind.call($call, String.prototype.replace);
  var $strSlice = bind.call($call, String.prototype.slice);
  var $exec = bind.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string2) {
    var first = $strSlice(string2, 0, 1);
    var last = $strSlice(string2, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string2, rePropName, function(match, number2, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void undefined$1;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBindBasic = requireCallBindApplyHelpers();
  var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
  callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      GetIntrinsic(name, !!allowMissing)
    );
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBindBasic(
        /** @type {const} */
        [intrinsic]
      );
    }
    return intrinsic;
  };
  return callBound;
}
var sideChannelMap;
var hasRequiredSideChannelMap;
function requireSideChannelMap() {
  if (hasRequiredSideChannelMap) return sideChannelMap;
  hasRequiredSideChannelMap = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var inspect2 = require$$2$1;
  var $TypeError = /* @__PURE__ */ requireType();
  var $Map = GetIntrinsic("%Map%", true);
  var $mapGet = callBound2("Map.prototype.get", true);
  var $mapSet = callBound2("Map.prototype.set", true);
  var $mapHas = callBound2("Map.prototype.has", true);
  var $mapDelete = callBound2("Map.prototype.delete", true);
  var $mapSize = callBound2("Map.prototype.size", true);
  sideChannelMap = !!$Map && /** @type {Exclude<import('.'), false>} */
  function getSideChannelMap() {
    var $m;
    var channel = {
      assert: function(key2) {
        if (!channel.has(key2)) {
          throw new $TypeError("Side channel does not contain " + inspect2(key2));
        }
      },
      "delete": function(key2) {
        if ($m) {
          var result = $mapDelete($m, key2);
          if ($mapSize($m) === 0) {
            $m = void 0;
          }
          return result;
        }
        return false;
      },
      get: function(key2) {
        if ($m) {
          return $mapGet($m, key2);
        }
      },
      has: function(key2) {
        if ($m) {
          return $mapHas($m, key2);
        }
        return false;
      },
      set: function(key2, value) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key2, value);
      }
    };
    return channel;
  };
  return sideChannelMap;
}
var sideChannelWeakmap;
var hasRequiredSideChannelWeakmap;
function requireSideChannelWeakmap() {
  if (hasRequiredSideChannelWeakmap) return sideChannelWeakmap;
  hasRequiredSideChannelWeakmap = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var inspect2 = require$$2$1;
  var getSideChannelMap = requireSideChannelMap();
  var $TypeError = /* @__PURE__ */ requireType();
  var $WeakMap = GetIntrinsic("%WeakMap%", true);
  var $weakMapGet = callBound2("WeakMap.prototype.get", true);
  var $weakMapSet = callBound2("WeakMap.prototype.set", true);
  var $weakMapHas = callBound2("WeakMap.prototype.has", true);
  var $weakMapDelete = callBound2("WeakMap.prototype.delete", true);
  sideChannelWeakmap = $WeakMap ? (
    /** @type {Exclude<import('.'), false>} */
    function getSideChannelWeakMap() {
      var $wm;
      var $m;
      var channel = {
        assert: function(key2) {
          if (!channel.has(key2)) {
            throw new $TypeError("Side channel does not contain " + inspect2(key2));
          }
        },
        "delete": function(key2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if ($wm) {
              return $weakMapDelete($wm, key2);
            }
          } else if (getSideChannelMap) {
            if ($m) {
              return $m["delete"](key2);
            }
          }
          return false;
        },
        get: function(key2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key2);
            }
          }
          return $m && $m.get(key2);
        },
        has: function(key2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key2);
            }
          }
          return !!$m && $m.has(key2);
        },
        set: function(key2, value) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key2, value);
          } else if (getSideChannelMap) {
            if (!$m) {
              $m = getSideChannelMap();
            }
            $m.set(key2, value);
          }
        }
      };
      return channel;
    }
  ) : getSideChannelMap;
  return sideChannelWeakmap;
}
var sideChannel;
var hasRequiredSideChannel;
function requireSideChannel() {
  if (hasRequiredSideChannel) return sideChannel;
  hasRequiredSideChannel = 1;
  var $TypeError = /* @__PURE__ */ requireType();
  var inspect2 = require$$2$1;
  var getSideChannelList = requireSideChannelList();
  var getSideChannelMap = requireSideChannelMap();
  var getSideChannelWeakMap = requireSideChannelWeakmap();
  var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
  sideChannel = function getSideChannel() {
    var $channelData;
    var channel = {
      assert: function(key2) {
        if (!channel.has(key2)) {
          throw new $TypeError("Side channel does not contain " + inspect2(key2));
        }
      },
      "delete": function(key2) {
        return !!$channelData && $channelData["delete"](key2);
      },
      get: function(key2) {
        return $channelData && $channelData.get(key2);
      },
      has: function(key2) {
        return !!$channelData && $channelData.has(key2);
      },
      set: function(key2, value) {
        if (!$channelData) {
          $channelData = makeChannel();
        }
        $channelData.set(key2, value);
      }
    };
    return channel;
  };
  return sideChannel;
}
var formats;
var hasRequiredFormats;
function requireFormats() {
  if (hasRequiredFormats) return formats;
  hasRequiredFormats = 1;
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  var Format = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  formats = {
    "default": Format.RFC3986,
    formatters: {
      RFC1738: function(value) {
        return replace.call(value, percentTwenties, "+");
      },
      RFC3986: function(value) {
        return String(value);
      }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
  };
  return formats;
}
var utils$2;
var hasRequiredUtils$2;
function requireUtils$2() {
  if (hasRequiredUtils$2) return utils$2;
  hasRequiredUtils$2 = 1;
  var formats2 = /* @__PURE__ */ requireFormats();
  var getSideChannel = requireSideChannel();
  var has = Object.prototype.hasOwnProperty;
  var isArray = Array.isArray;
  var overflowChannel = getSideChannel();
  var markOverflow = function markOverflow2(obj, maxIndex) {
    overflowChannel.set(obj, maxIndex);
    return obj;
  };
  var isOverflow = function isOverflow2(obj) {
    return overflowChannel.has(obj);
  };
  var getMaxIndex = function getMaxIndex2(obj) {
    return overflowChannel.get(obj);
  };
  var setMaxIndex = function setMaxIndex2(obj, maxIndex) {
    overflowChannel.set(obj, maxIndex);
  };
  var hexTable = (function() {
    var array2 = [];
    for (var i = 0; i < 256; ++i) {
      array2.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
    }
    return array2;
  })();
  var compactQueue = function compactQueue2(queue2) {
    while (queue2.length > 1) {
      var item = queue2.pop();
      var obj = item.obj[item.prop];
      if (isArray(obj)) {
        var compacted = [];
        for (var j = 0; j < obj.length; ++j) {
          if (typeof obj[j] !== "undefined") {
            compacted.push(obj[j]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
  };
  var arrayToObject = function arrayToObject2(source2, options) {
    var obj = options && options.plainObjects ? { __proto__: null } : {};
    for (var i = 0; i < source2.length; ++i) {
      if (typeof source2[i] !== "undefined") {
        obj[i] = source2[i];
      }
    }
    return obj;
  };
  var merge2 = function merge3(target, source2, options) {
    if (!source2) {
      return target;
    }
    if (typeof source2 !== "object" && typeof source2 !== "function") {
      if (isArray(target)) {
        target.push(source2);
      } else if (target && typeof target === "object") {
        if (isOverflow(target)) {
          var newIndex = getMaxIndex(target) + 1;
          target[newIndex] = source2;
          setMaxIndex(target, newIndex);
        } else if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source2)) {
          target[source2] = true;
        }
      } else {
        return [target, source2];
      }
      return target;
    }
    if (!target || typeof target !== "object") {
      if (isOverflow(source2)) {
        var sourceKeys = Object.keys(source2);
        var result = options && options.plainObjects ? { __proto__: null, 0: target } : { 0: target };
        for (var m = 0; m < sourceKeys.length; m++) {
          var oldKey = parseInt(sourceKeys[m], 10);
          result[oldKey + 1] = source2[sourceKeys[m]];
        }
        return markOverflow(result, getMaxIndex(source2) + 1);
      }
      return [target].concat(source2);
    }
    var mergeTarget = target;
    if (isArray(target) && !isArray(source2)) {
      mergeTarget = arrayToObject(target, options);
    }
    if (isArray(target) && isArray(source2)) {
      source2.forEach(function(item, i) {
        if (has.call(target, i)) {
          var targetItem = target[i];
          if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
            target[i] = merge3(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }
    return Object.keys(source2).reduce(function(acc, key2) {
      var value = source2[key2];
      if (has.call(acc, key2)) {
        acc[key2] = merge3(acc[key2], value, options);
      } else {
        acc[key2] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source2) {
    return Object.keys(source2).reduce(function(acc, key2) {
      acc[key2] = source2[key2];
      return acc;
    }, target);
  };
  var decode2 = function(str, defaultDecoder, charset2) {
    var strWithoutPlus = str.replace(/\+/g, " ");
    if (charset2 === "iso-8859-1") {
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e) {
      return strWithoutPlus;
    }
  };
  var limit = 1024;
  var encode2 = function encode3(str, defaultEncoder, charset2, kind, format) {
    if (str.length === 0) {
      return str;
    }
    var string2 = str;
    if (typeof str === "symbol") {
      string2 = Symbol.prototype.toString.call(str);
    } else if (typeof str !== "string") {
      string2 = String(str);
    }
    if (charset2 === "iso-8859-1") {
      return escape(string2).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    var out = "";
    for (var j = 0; j < string2.length; j += limit) {
      var segment = string2.length >= limit ? string2.slice(j, j + limit) : string2;
      var arr = [];
      for (var i = 0; i < segment.length; ++i) {
        var c2 = segment.charCodeAt(i);
        if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format === formats2.RFC1738 && (c2 === 40 || c2 === 41)) {
          arr[arr.length] = segment.charAt(i);
          continue;
        }
        if (c2 < 128) {
          arr[arr.length] = hexTable[c2];
          continue;
        }
        if (c2 < 2048) {
          arr[arr.length] = hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63];
          continue;
        }
        if (c2 < 55296 || c2 >= 57344) {
          arr[arr.length] = hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
          continue;
        }
        i += 1;
        c2 = 65536 + ((c2 & 1023) << 10 | segment.charCodeAt(i) & 1023);
        arr[arr.length] = hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
      }
      out += arr.join("");
    }
    return out;
  };
  var compact = function compact2(value) {
    var queue2 = [{ obj: { o: value }, prop: "o" }];
    var refs = [];
    for (var i = 0; i < queue2.length; ++i) {
      var item = queue2[i];
      var obj = item.obj[item.prop];
      var keys = Object.keys(obj);
      for (var j = 0; j < keys.length; ++j) {
        var key2 = keys[j];
        var val = obj[key2];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue2.push({ obj, prop: key2 });
          refs.push(val);
        }
      }
    }
    compactQueue(queue2);
    return value;
  };
  var isRegExp = function isRegExp2(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var isBuffer = function isBuffer2(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  var combine = function combine2(a, b, arrayLimit, plainObjects) {
    if (isOverflow(a)) {
      var newIndex = getMaxIndex(a) + 1;
      a[newIndex] = b;
      setMaxIndex(a, newIndex);
      return a;
    }
    var result = [].concat(a, b);
    if (result.length > arrayLimit) {
      return markOverflow(arrayToObject(result, { plainObjects }), result.length - 1);
    }
    return result;
  };
  var maybeMap = function maybeMap2(val, fn) {
    if (isArray(val)) {
      var mapped = [];
      for (var i = 0; i < val.length; i += 1) {
        mapped.push(fn(val[i]));
      }
      return mapped;
    }
    return fn(val);
  };
  utils$2 = {
    arrayToObject,
    assign,
    combine,
    compact,
    decode: decode2,
    encode: encode2,
    isBuffer,
    isOverflow,
    isRegExp,
    maybeMap,
    merge: merge2
  };
  return utils$2;
}
var stringify_1;
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify_1;
  hasRequiredStringify = 1;
  var getSideChannel = requireSideChannel();
  var utils2 = /* @__PURE__ */ requireUtils$2();
  var formats2 = /* @__PURE__ */ requireFormats();
  var has = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + "[]";
    },
    comma: "comma",
    indices: function indices(prefix, key2) {
      return prefix + "[" + key2 + "]";
    },
    repeat: function repeat(prefix) {
      return prefix;
    }
  };
  var isArray = Array.isArray;
  var push2 = Array.prototype.push;
  var pushToArray = function(arr, valueOrArray) {
    push2.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaultFormat = formats2["default"];
  var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: false,
    commaRoundTrip: false,
    delimiter: "&",
    encode: true,
    encodeDotInKeys: false,
    encoder: utils2.encode,
    encodeValuesOnly: false,
    filter: void 0,
    format: defaultFormat,
    formatter: formats2.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date2) {
      return toISO.call(date2);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
    return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
  };
  var sentinel = {};
  var stringify3 = function stringify4(object2, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset2, sideChannel2) {
    var obj = object2;
    var tmpSc = sideChannel2;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
      var pos2 = tmpSc.get(object2);
      step += 1;
      if (typeof pos2 !== "undefined") {
        if (pos2 === step) {
          throw new RangeError("Cyclic object value");
        } else {
          findFlag = true;
        }
      }
      if (typeof tmpSc.get(sentinel) === "undefined") {
        step = 0;
      }
    }
    if (typeof filter === "function") {
      obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (generateArrayPrefix === "comma" && isArray(obj)) {
      obj = utils2.maybeMap(obj, function(value2) {
        if (value2 instanceof Date) {
          return serializeDate(value2);
        }
        return value2;
      });
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset2, "key", format) : prefix;
      }
      obj = "";
    }
    if (isNonNullishPrimitive(obj) || utils2.isBuffer(obj)) {
      if (encoder) {
        var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset2, "key", format);
        return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset2, "value", format))];
      }
      return [formatter(prefix) + "=" + formatter(String(obj))];
    }
    var values = [];
    if (typeof obj === "undefined") {
      return values;
    }
    var objKeys;
    if (generateArrayPrefix === "comma" && isArray(obj)) {
      if (encodeValuesOnly && encoder) {
        obj = utils2.maybeMap(obj, encoder);
      }
      objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
    } else if (isArray(filter)) {
      objKeys = filter;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort ? keys.sort(sort) : keys;
    }
    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
      return adjustedPrefix + "[]";
    }
    for (var j = 0; j < objKeys.length; ++j) {
      var key2 = objKeys[j];
      var value = typeof key2 === "object" && key2 && typeof key2.value !== "undefined" ? key2.value : obj[key2];
      if (skipNulls && value === null) {
        continue;
      }
      var encodedKey = allowDots && encodeDotInKeys ? String(key2).replace(/\./g, "%2E") : String(key2);
      var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
      sideChannel2.set(object2, step);
      var valueSideChannel = getSideChannel();
      valueSideChannel.set(sentinel, sideChannel2);
      pushToArray(values, stringify4(
        value,
        keyPrefix,
        generateArrayPrefix,
        commaRoundTrip,
        allowEmptyArrays,
        strictNullHandling,
        skipNulls,
        encodeDotInKeys,
        generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
        filter,
        sort,
        allowDots,
        serializeDate,
        format,
        formatter,
        encodeValuesOnly,
        charset2,
        valueSideChannel
      ));
    }
    return values;
  };
  var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
    if (!opts) {
      return defaults;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
      throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var charset2 = opts.charset || defaults.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var format = formats2["default"];
    if (typeof opts.format !== "undefined") {
      if (!has.call(formats2.formatters, opts.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      format = opts.format;
    }
    var formatter = formats2.formatters[format];
    var filter = defaults.filter;
    if (typeof opts.filter === "function" || isArray(opts.filter)) {
      filter = opts.filter;
    }
    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if ("indices" in opts) {
      arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
      arrayFormat = defaults.arrayFormat;
    }
    if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
      arrayFormat,
      charset: charset2,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
      commaRoundTrip: !!opts.commaRoundTrip,
      delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
      encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
      encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
      encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
      filter,
      format,
      formatter,
      serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
      skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
      sort: typeof opts.sort === "function" ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
    };
  };
  stringify_1 = function(object2, opts) {
    var obj = object2;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter;
    if (typeof options.filter === "function") {
      filter = options.filter;
      obj = filter("", obj);
    } else if (isArray(options.filter)) {
      filter = options.filter;
      objKeys = filter;
    }
    var keys = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (options.sort) {
      objKeys.sort(options.sort);
    }
    var sideChannel2 = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
      var key2 = objKeys[i];
      var value = obj[key2];
      if (options.skipNulls && value === null) {
        continue;
      }
      pushToArray(keys, stringify3(
        value,
        key2,
        generateArrayPrefix,
        commaRoundTrip,
        options.allowEmptyArrays,
        options.strictNullHandling,
        options.skipNulls,
        options.encodeDotInKeys,
        options.encode ? options.encoder : null,
        options.filter,
        options.sort,
        options.allowDots,
        options.serializeDate,
        options.format,
        options.formatter,
        options.encodeValuesOnly,
        options.charset,
        sideChannel2
      ));
    }
    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? "?" : "";
    if (options.charsetSentinel) {
      if (options.charset === "iso-8859-1") {
        prefix += "utf8=%26%2310003%3B&";
      } else {
        prefix += "utf8=%E2%9C%93&";
      }
    }
    return joined.length > 0 ? prefix + joined : "";
  };
  return stringify_1;
}
var parse$2;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse$2;
  hasRequiredParse = 1;
  var utils2 = /* @__PURE__ */ requireUtils$2();
  var has = Object.prototype.hasOwnProperty;
  var isArray = Array.isArray;
  var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils2.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1e3,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false,
    throwOnLimitExceeded: false
  };
  var interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };
  var parseArrayValue = function(val, options, currentArrayLength) {
    if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
      return val.split(",");
    }
    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
      throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
    }
    return val;
  };
  var isoSentinel = "utf8=%26%2310003%3B";
  var charsetSentinel = "utf8=%E2%9C%93";
  var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
    cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
    var parts = cleanStr.split(
      options.delimiter,
      options.throwOnLimitExceeded ? limit + 1 : limit
    );
    if (options.throwOnLimitExceeded && parts.length > limit) {
      throw new RangeError("Parameter limit exceeded. Only " + limit + " parameter" + (limit === 1 ? "" : "s") + " allowed.");
    }
    var skipIndex = -1;
    var i;
    var charset2 = options.charset;
    if (options.charsetSentinel) {
      for (i = 0; i < parts.length; ++i) {
        if (parts[i].indexOf("utf8=") === 0) {
          if (parts[i] === charsetSentinel) {
            charset2 = "utf-8";
          } else if (parts[i] === isoSentinel) {
            charset2 = "iso-8859-1";
          }
          skipIndex = i;
          i = parts.length;
        }
      }
    }
    for (i = 0; i < parts.length; ++i) {
      if (i === skipIndex) {
        continue;
      }
      var part = parts[i];
      var bracketEqualsPos = part.indexOf("]=");
      var pos2 = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key2;
      var val;
      if (pos2 === -1) {
        key2 = options.decoder(part, defaults.decoder, charset2, "key");
        val = options.strictNullHandling ? null : "";
      } else {
        key2 = options.decoder(part.slice(0, pos2), defaults.decoder, charset2, "key");
        if (key2 !== null) {
          val = utils2.maybeMap(
            parseArrayValue(
              part.slice(pos2 + 1),
              options,
              isArray(obj[key2]) ? obj[key2].length : 0
            ),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset2, "value");
            }
          );
        }
      }
      if (val && options.interpretNumericEntities && charset2 === "iso-8859-1") {
        val = interpretNumericEntities(String(val));
      }
      if (part.indexOf("[]=") > -1) {
        val = isArray(val) ? [val] : val;
      }
      if (key2 !== null) {
        var existing = has.call(obj, key2);
        if (existing && options.duplicates === "combine") {
          obj[key2] = utils2.combine(
            obj[key2],
            val,
            options.arrayLimit,
            options.plainObjects
          );
        } else if (!existing || options.duplicates === "last") {
          obj[key2] = val;
        }
      }
    }
    return obj;
  };
  var parseObject = function(chain, val, options, valuesParsed) {
    var currentArrayLength = 0;
    if (chain.length > 0 && chain[chain.length - 1] === "[]") {
      var parentKey = chain.slice(0, -1).join("");
      currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
    }
    var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
    for (var i = chain.length - 1; i >= 0; --i) {
      var obj;
      var root2 = chain[i];
      if (root2 === "[]" && options.parseArrays) {
        if (utils2.isOverflow(leaf)) {
          obj = leaf;
        } else {
          obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : utils2.combine(
            [],
            leaf,
            options.arrayLimit,
            options.plainObjects
          );
        }
      } else {
        obj = options.plainObjects ? { __proto__: null } : {};
        var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
        var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
        var index2 = parseInt(decodedRoot, 10);
        if (!options.parseArrays && decodedRoot === "") {
          obj = { 0: leaf };
        } else if (!isNaN(index2) && root2 !== decodedRoot && String(index2) === decodedRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
          obj = [];
          obj[index2] = leaf;
        } else if (decodedRoot !== "__proto__") {
          obj[decodedRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var splitKeyIntoSegments = function splitKeyIntoSegments2(givenKey, options) {
    var key2 = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    if (options.depth <= 0) {
      if (!options.plainObjects && has.call(Object.prototype, key2)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      return [key2];
    }
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = brackets.exec(key2);
    var parent = segment ? key2.slice(0, segment.index) : key2;
    var keys = [];
    if (parent) {
      if (!options.plainObjects && has.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(parent);
    }
    var i = 0;
    while ((segment = child.exec(key2)) !== null && i < options.depth) {
      i += 1;
      var segmentContent = segment[1].slice(1, -1);
      if (!options.plainObjects && has.call(Object.prototype, segmentContent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      if (options.strictDepth === true) {
        throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
      }
      keys.push("[" + key2.slice(segment.index) + "]");
    }
    return keys;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
      return;
    }
    var keys = splitKeyIntoSegments(givenKey, options);
    if (!keys) {
      return;
    }
    return parseObject(keys, val, options, valuesParsed);
  };
  var normalizeParseOptions = function normalizeParseOptions2(opts) {
    if (!opts) {
      return defaults;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
      throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") {
      throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
    }
    var charset2 = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
    var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
    if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
      throw new TypeError("The duplicates option must be either combine, first, or last");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
      allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
      allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
      arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
      charset: charset2,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
      comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
      decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
      decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
      delimiter: typeof opts.delimiter === "string" || utils2.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
      duplicates,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
      strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling,
      throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
    };
  };
  parse$2 = function(str, opts) {
    var options = normalizeParseOptions(opts);
    if (str === "" || str === null || typeof str === "undefined") {
      return options.plainObjects ? { __proto__: null } : {};
    }
    var tempObj = typeof str === "string" ? parseValues(str, options) : str;
    var obj = options.plainObjects ? { __proto__: null } : {};
    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
      var key2 = keys[i];
      var newObj = parseKeys(key2, tempObj[key2], options, typeof str === "string");
      obj = utils2.merge(obj, newObj, options);
    }
    if (options.allowSparse === true) {
      return obj;
    }
    return utils2.compact(obj);
  };
  return parse$2;
}
var lib$2;
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$2;
  hasRequiredLib$2 = 1;
  var stringify3 = /* @__PURE__ */ requireStringify();
  var parse3 = /* @__PURE__ */ requireParse();
  var formats2 = /* @__PURE__ */ requireFormats();
  lib$2 = {
    formats: formats2,
    parse: parse3,
    stringify: stringify3
  };
  return lib$2;
}
var urlencoded_1;
var hasRequiredUrlencoded$1;
function requireUrlencoded$1() {
  if (hasRequiredUrlencoded$1) return urlencoded_1;
  hasRequiredUrlencoded$1 = 1;
  var createError = requireHttpErrors();
  var debug = require$$0$9("body-parser:urlencoded");
  var read2 = requireRead();
  var qs = /* @__PURE__ */ requireLib$2();
  var { normalizeOptions } = requireUtils$3();
  urlencoded_1 = urlencoded2;
  function urlencoded2(options) {
    const normalizedOptions = normalizeOptions(options, "application/x-www-form-urlencoded");
    if (normalizedOptions.defaultCharset !== "utf-8" && normalizedOptions.defaultCharset !== "iso-8859-1") {
      throw new TypeError("option defaultCharset must be either utf-8 or iso-8859-1");
    }
    var queryparse = createQueryParser(options);
    function parse3(body, encoding2) {
      return body.length ? queryparse(body, encoding2) : {};
    }
    const readOptions = {
      ...normalizedOptions,
      // assert charset
      isValidCharset: (charset2) => charset2 === "utf-8" || charset2 === "iso-8859-1"
    };
    return function urlencodedParser(req, res, next) {
      read2(req, res, next, parse3, debug, readOptions);
    };
  }
  function createQueryParser(options) {
    var extended = Boolean(options?.extended);
    var parameterLimit = options?.parameterLimit !== void 0 ? options?.parameterLimit : 1e3;
    var charsetSentinel = options?.charsetSentinel;
    var interpretNumericEntities = options?.interpretNumericEntities;
    var depth = extended ? options?.depth !== void 0 ? options?.depth : 32 : 0;
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isNaN(depth) || depth < 0) {
      throw new TypeError("option depth must be a zero or a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body, encoding2) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === void 0) {
        debug("too many parameters");
        throw createError(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      var arrayLimit = extended ? Math.max(100, paramCount) : 0;
      debug("parse " + (extended ? "extended " : "") + "urlencoding");
      try {
        return qs.parse(body, {
          allowPrototypes: true,
          arrayLimit,
          depth,
          charsetSentinel,
          interpretNumericEntities,
          charset: encoding2,
          parameterLimit,
          strictDepth: true
        });
      } catch (err) {
        if (err instanceof RangeError) {
          throw createError(400, "The input exceeded the depth", {
            type: "querystring.parse.rangeError"
          });
        } else {
          throw err;
        }
      }
    };
  }
  function parameterCount(body, limit) {
    let count = 0;
    let index2 = -1;
    do {
      count++;
      if (count > limit) return void 0;
      index2 = body.indexOf("&", index2 + 1);
    } while (index2 !== -1);
    return count;
  }
  return urlencoded_1;
}
var hasRequiredBodyParser;
function requireBodyParser() {
  if (hasRequiredBodyParser) return bodyParser.exports;
  hasRequiredBodyParser = 1;
  (function(module, exports$1) {
    exports$1 = module.exports = bodyParser2;
    Object.defineProperty(exports$1, "json", {
      configurable: true,
      enumerable: true,
      get: () => requireJson()
    });
    Object.defineProperty(exports$1, "raw", {
      configurable: true,
      enumerable: true,
      get: () => requireRaw()
    });
    Object.defineProperty(exports$1, "text", {
      configurable: true,
      enumerable: true,
      get: () => requireText()
    });
    Object.defineProperty(exports$1, "urlencoded", {
      configurable: true,
      enumerable: true,
      get: () => requireUrlencoded$1()
    });
    function bodyParser2() {
      throw new Error("The bodyParser() generic has been split into individual middleware to use instead.");
    }
  })(bodyParser, bodyParser.exports);
  return bodyParser.exports;
}
var mergeDescriptors_1;
var hasRequiredMergeDescriptors;
function requireMergeDescriptors() {
  if (hasRequiredMergeDescriptors) return mergeDescriptors_1;
  hasRequiredMergeDescriptors = 1;
  function mergeDescriptors(destination, source2, overwrite = true) {
    if (!destination) {
      throw new TypeError("The `destination` argument is required.");
    }
    if (!source2) {
      throw new TypeError("The `source` argument is required.");
    }
    for (const name of Object.getOwnPropertyNames(source2)) {
      if (!overwrite && Object.hasOwn(destination, name)) {
        continue;
      }
      const descriptor = Object.getOwnPropertyDescriptor(source2, name);
      Object.defineProperty(destination, name, descriptor);
    }
    return destination;
  }
  mergeDescriptors_1 = mergeDescriptors;
  return mergeDescriptors_1;
}
var application = { exports: {} };
var encodeurl;
var hasRequiredEncodeurl;
function requireEncodeurl() {
  if (hasRequiredEncodeurl) return encodeurl;
  hasRequiredEncodeurl = 1;
  encodeurl = encodeUrl;
  var ENCODE_CHARS_REGEXP = /(?:[^\x21\x23-\x3B\x3D\x3F-\x5F\x61-\x7A\x7C\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
  var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
  var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1$2";
  function encodeUrl(url2) {
    return String(url2).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
  }
  return encodeurl;
}
var escapeHtml_1;
var hasRequiredEscapeHtml;
function requireEscapeHtml() {
  if (hasRequiredEscapeHtml) return escapeHtml_1;
  hasRequiredEscapeHtml = 1;
  var matchHtmlRegExp = /["'&<>]/;
  escapeHtml_1 = escapeHtml;
  function escapeHtml(string2) {
    var str = "" + string2;
    var match = matchHtmlRegExp.exec(str);
    if (!match) {
      return str;
    }
    var escape2;
    var html = "";
    var index2 = 0;
    var lastIndex = 0;
    for (index2 = match.index; index2 < str.length; index2++) {
      switch (str.charCodeAt(index2)) {
        case 34:
          escape2 = "&quot;";
          break;
        case 38:
          escape2 = "&amp;";
          break;
        case 39:
          escape2 = "&#39;";
          break;
        case 60:
          escape2 = "&lt;";
          break;
        case 62:
          escape2 = "&gt;";
          break;
        default:
          continue;
      }
      if (lastIndex !== index2) {
        html += str.substring(lastIndex, index2);
      }
      lastIndex = index2 + 1;
      html += escape2;
    }
    return lastIndex !== index2 ? html + str.substring(lastIndex, index2) : html;
  }
  return escapeHtml_1;
}
var parseurl = { exports: {} };
var hasRequiredParseurl;
function requireParseurl() {
  if (hasRequiredParseurl) return parseurl.exports;
  hasRequiredParseurl = 1;
  var url2 = require$$0$a;
  var parse3 = url2.parse;
  var Url = url2.Url;
  parseurl.exports = parseurl$1;
  parseurl.exports.original = originalurl;
  function parseurl$1(req) {
    var url3 = req.url;
    if (url3 === void 0) {
      return void 0;
    }
    var parsed = req._parsedUrl;
    if (fresh(url3, parsed)) {
      return parsed;
    }
    parsed = fastparse(url3);
    parsed._raw = url3;
    return req._parsedUrl = parsed;
  }
  function originalurl(req) {
    var url3 = req.originalUrl;
    if (typeof url3 !== "string") {
      return parseurl$1(req);
    }
    var parsed = req._parsedOriginalUrl;
    if (fresh(url3, parsed)) {
      return parsed;
    }
    parsed = fastparse(url3);
    parsed._raw = url3;
    return req._parsedOriginalUrl = parsed;
  }
  function fastparse(str) {
    if (typeof str !== "string" || str.charCodeAt(0) !== 47) {
      return parse3(str);
    }
    var pathname = str;
    var query = null;
    var search = null;
    for (var i = 1; i < str.length; i++) {
      switch (str.charCodeAt(i)) {
        case 63:
          if (search === null) {
            pathname = str.substring(0, i);
            query = str.substring(i + 1);
            search = str.substring(i);
          }
          break;
        case 9:
        /* \t */
        case 10:
        /* \n */
        case 12:
        /* \f */
        case 13:
        /* \r */
        case 32:
        /*    */
        case 35:
        /* #  */
        case 160:
        case 65279:
          return parse3(str);
      }
    }
    var url3 = Url !== void 0 ? new Url() : {};
    url3.path = str;
    url3.href = str;
    url3.pathname = pathname;
    if (search !== null) {
      url3.query = query;
      url3.search = search;
    }
    return url3;
  }
  function fresh(url3, parsedUrl) {
    return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url3;
  }
  return parseurl.exports;
}
var finalhandler_1;
var hasRequiredFinalhandler;
function requireFinalhandler() {
  if (hasRequiredFinalhandler) return finalhandler_1;
  hasRequiredFinalhandler = 1;
  var debug = require$$0$9("finalhandler");
  var encodeUrl = requireEncodeurl();
  var escapeHtml = requireEscapeHtml();
  var onFinished2 = requireOnFinished();
  var parseUrl = requireParseurl();
  var statuses2 = requireStatuses();
  var isFinished = onFinished2.isFinished;
  function createHtmlDocument(message) {
    var body = escapeHtml(message).replaceAll("\n", "<br>").replaceAll("  ", " &nbsp;");
    return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
  }
  finalhandler_1 = finalhandler;
  function finalhandler(req, res, options) {
    var opts = options || {};
    var env = opts.env || "production";
    var onerror = opts.onerror;
    return function(err) {
      var headers;
      var msg;
      var status;
      if (!err && res.headersSent) {
        debug("cannot 404 after headers sent");
        return;
      }
      if (err) {
        status = getErrorStatusCode(err);
        if (status === void 0) {
          status = getResponseStatusCode(res);
        } else {
          headers = getErrorHeaders(err);
        }
        msg = getErrorMessage(err, status, env);
      } else {
        status = 404;
        msg = "Cannot " + req.method + " " + encodeUrl(getResourceName(req));
      }
      debug("default %s", status);
      if (err && onerror) {
        setImmediate(onerror, err, req, res);
      }
      if (res.headersSent) {
        debug("cannot %d after headers sent", status);
        if (req.socket) {
          req.socket.destroy();
        }
        return;
      }
      send(req, res, status, headers, msg);
    };
  }
  function getErrorHeaders(err) {
    if (!err.headers || typeof err.headers !== "object") {
      return void 0;
    }
    return { ...err.headers };
  }
  function getErrorMessage(err, status, env) {
    var msg;
    if (env !== "production") {
      msg = err.stack;
      if (!msg && typeof err.toString === "function") {
        msg = err.toString();
      }
    }
    return msg || statuses2.message[status];
  }
  function getErrorStatusCode(err) {
    if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
      return err.status;
    }
    if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) {
      return err.statusCode;
    }
    return void 0;
  }
  function getResourceName(req) {
    try {
      return parseUrl.original(req).pathname;
    } catch (e) {
      return "resource";
    }
  }
  function getResponseStatusCode(res) {
    var status = res.statusCode;
    if (typeof status !== "number" || status < 400 || status > 599) {
      status = 500;
    }
    return status;
  }
  function send(req, res, status, headers, message) {
    function write() {
      var body = createHtmlDocument(message);
      res.statusCode = status;
      if (req.httpVersionMajor < 2) {
        res.statusMessage = statuses2.message[status];
      }
      res.removeHeader("Content-Encoding");
      res.removeHeader("Content-Language");
      res.removeHeader("Content-Range");
      for (const [key2, value] of Object.entries(headers ?? {})) {
        res.setHeader(key2, value);
      }
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.setHeader("Content-Type", "text/html; charset=utf-8");
      res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
      if (req.method === "HEAD") {
        res.end();
        return;
      }
      res.end(body, "utf8");
    }
    if (isFinished(req)) {
      write();
      return;
    }
    req.unpipe();
    onFinished2(req, write);
    req.resume();
  }
  return finalhandler_1;
}
var view;
var hasRequiredView;
function requireView() {
  if (hasRequiredView) return view;
  hasRequiredView = 1;
  var debug = require$$0$9("express:view");
  var path2 = path__default;
  var fs2 = fs__default;
  var dirname = path2.dirname;
  var basename = path2.basename;
  var extname = path2.extname;
  var join = path2.join;
  var resolve2 = path2.resolve;
  view = View;
  function View(name, options) {
    var opts = options || {};
    this.defaultEngine = opts.defaultEngine;
    this.ext = extname(name);
    this.name = name;
    this.root = opts.root;
    if (!this.ext && !this.defaultEngine) {
      throw new Error("No default engine was specified and no extension was provided.");
    }
    var fileName = name;
    if (!this.ext) {
      this.ext = this.defaultEngine[0] !== "." ? "." + this.defaultEngine : this.defaultEngine;
      fileName += this.ext;
    }
    if (!opts.engines[this.ext]) {
      var mod = this.ext.slice(1);
      debug('require "%s"', mod);
      var fn = commonjsRequire(mod).__express;
      if (typeof fn !== "function") {
        throw new Error('Module "' + mod + '" does not provide a view engine.');
      }
      opts.engines[this.ext] = fn;
    }
    this.engine = opts.engines[this.ext];
    this.path = this.lookup(fileName);
  }
  View.prototype.lookup = function lookup(name) {
    var path3;
    var roots = [].concat(this.root);
    debug('lookup "%s"', name);
    for (var i = 0; i < roots.length && !path3; i++) {
      var root2 = roots[i];
      var loc = resolve2(root2, name);
      var dir = dirname(loc);
      var file2 = basename(loc);
      path3 = this.resolve(dir, file2);
    }
    return path3;
  };
  View.prototype.render = function render(options, callback) {
    var sync = true;
    debug('render "%s"', this.path);
    this.engine(this.path, options, function onRender() {
      if (!sync) {
        return callback.apply(this, arguments);
      }
      var args = new Array(arguments.length);
      var cntx = this;
      for (var i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      return process.nextTick(function renderTick() {
        return callback.apply(cntx, args);
      });
    });
    sync = false;
  };
  View.prototype.resolve = function resolve3(dir, file2) {
    var ext = this.ext;
    var path3 = join(dir, file2);
    var stat2 = tryStat(path3);
    if (stat2 && stat2.isFile()) {
      return path3;
    }
    path3 = join(dir, basename(file2, ext), "index" + ext);
    stat2 = tryStat(path3);
    if (stat2 && stat2.isFile()) {
      return path3;
    }
  };
  function tryStat(path3) {
    debug('stat "%s"', path3);
    try {
      return fs2.statSync(path3);
    } catch (e) {
      return void 0;
    }
  }
  return view;
}
var utils$1 = {};
var etag_1;
var hasRequiredEtag;
function requireEtag() {
  if (hasRequiredEtag) return etag_1;
  hasRequiredEtag = 1;
  etag_1 = etag;
  var crypto2 = require$$0$b;
  var Stats = require$$0$4.Stats;
  var toString = Object.prototype.toString;
  function entitytag(entity) {
    if (entity.length === 0) {
      return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
    }
    var hash2 = crypto2.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
    var len = typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length;
    return '"' + len.toString(16) + "-" + hash2 + '"';
  }
  function etag(entity, options) {
    if (entity == null) {
      throw new TypeError("argument entity is required");
    }
    var isStats = isstats(entity);
    var weak = options && typeof options.weak === "boolean" ? options.weak : isStats;
    if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) {
      throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
    }
    var tag = isStats ? stattag(entity) : entitytag(entity);
    return weak ? "W/" + tag : tag;
  }
  function isstats(obj) {
    if (typeof Stats === "function" && obj instanceof Stats) {
      return true;
    }
    return obj && typeof obj === "object" && "ctime" in obj && toString.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
  }
  function stattag(stat2) {
    var mtime = stat2.mtime.getTime().toString(16);
    var size = stat2.size.toString(16);
    return '"' + size + "-" + mtime + '"';
  }
  return etag_1;
}
var proxyAddr = { exports: {} };
var forwarded_1;
var hasRequiredForwarded;
function requireForwarded() {
  if (hasRequiredForwarded) return forwarded_1;
  hasRequiredForwarded = 1;
  forwarded_1 = forwarded;
  function forwarded(req) {
    if (!req) {
      throw new TypeError("argument req is required");
    }
    var proxyAddrs = parse3(req.headers["x-forwarded-for"] || "");
    var socketAddr = getSocketAddr(req);
    var addrs = [socketAddr].concat(proxyAddrs);
    return addrs;
  }
  function getSocketAddr(req) {
    return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
  }
  function parse3(header) {
    var end = header.length;
    var list = [];
    var start = header.length;
    for (var i = header.length - 1; i >= 0; i--) {
      switch (header.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i;
          }
          break;
        case 44:
          if (start !== end) {
            list.push(header.substring(start, end));
          }
          start = end = i;
          break;
        default:
          start = i;
          break;
      }
    }
    if (start !== end) {
      list.push(header.substring(start, end));
    }
    return list;
  }
  return forwarded_1;
}
var ipaddr$1 = { exports: {} };
var ipaddr = ipaddr$1.exports;
var hasRequiredIpaddr;
function requireIpaddr() {
  if (hasRequiredIpaddr) return ipaddr$1.exports;
  hasRequiredIpaddr = 1;
  (function(module) {
    (function() {
      var expandIPv6, ipaddr2, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root2, zoneIndex;
      ipaddr2 = {};
      root2 = this;
      if (module !== null && module.exports) {
        module.exports = ipaddr2;
      } else {
        root2["ipaddr"] = ipaddr2;
      }
      matchCIDR = function(first, second, partSize, cidrBits) {
        var part, shift;
        if (first.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        part = 0;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      };
      ipaddr2.subnetMatch = function(address, rangeList, defaultName) {
        var k, len, rangeName, rangeSubnets, subnet;
        if (defaultName == null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          rangeSubnets = rangeList[rangeName];
          if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
            rangeSubnets = [rangeSubnets];
          }
          for (k = 0, len = rangeSubnets.length; k < len; k++) {
            subnet = rangeSubnets[k];
            if (address.kind() === subnet[0].kind()) {
              if (address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      ipaddr2.IPv4 = (function() {
        function IPv4(octets) {
          var k, len, octet;
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          for (k = 0, len = octets.length; k < len; k++) {
            octet = octets[k];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.match = function(other, cidrRange) {
          var ref2;
          if (cidrRange === void 0) {
            ref2 = other, other = ref2[0], cidrRange = ref2[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
          reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
        };
        IPv4.prototype.range = function() {
          return ipaddr2.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr2.IPv6.parse("::ffff:" + this.toString());
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          var cidr, i, k, octet, stop, zeros, zerotable;
          zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 3; k >= 0; i = k += -1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        return IPv4;
      })();
      ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      ipv4Regexes = {
        fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
        longValue: new RegExp("^" + ipv4Part + "$", "i")
      };
      ipaddr2.IPv4.parser = function(string2) {
        var match, parseIntAuto, part, shift, value;
        parseIntAuto = function(string3) {
          if (string3[0] === "0" && string3[1] !== "x") {
            return parseInt(string3, 8);
          } else {
            return parseInt(string3);
          }
        };
        if (match = string2.match(ipv4Regexes.fourOctet)) {
          return (function() {
            var k, len, ref2, results;
            ref2 = match.slice(1, 6);
            results = [];
            for (k = 0, len = ref2.length; k < len; k++) {
              part = ref2[k];
              results.push(parseIntAuto(part));
            }
            return results;
          })();
        } else if (match = string2.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return (function() {
            var k, results;
            results = [];
            for (shift = k = 0; k <= 24; shift = k += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          })().reverse();
        } else {
          return null;
        }
      };
      ipaddr2.IPv6 = (function() {
        function IPv6(parts, zoneId) {
          var i, k, l, len, part, ref2;
          if (parts.length === 16) {
            this.parts = [];
            for (i = k = 0; k <= 14; i = k += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          ref2 = this.parts;
          for (l = 0, len = ref2.length; l < len; l++) {
            part = ref2[l];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.toString = function() {
          return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
        };
        IPv6.prototype.toRFC5952String = function() {
          var bestMatchIndex, bestMatchLength, match, regex, string2;
          regex = /((^|:)(0(:|$)){2,})/g;
          string2 = this.toNormalizedString();
          bestMatchIndex = 0;
          bestMatchLength = -1;
          while (match = regex.exec(string2)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string2;
          }
          return string2.substring(0, bestMatchIndex) + "::" + string2.substring(bestMatchIndex + bestMatchLength);
        };
        IPv6.prototype.toByteArray = function() {
          var bytes2, k, len, part, ref2;
          bytes2 = [];
          ref2 = this.parts;
          for (k = 0, len = ref2.length; k < len; k++) {
            part = ref2[k];
            bytes2.push(part >> 8);
            bytes2.push(part & 255);
          }
          return bytes2;
        };
        IPv6.prototype.toNormalizedString = function() {
          var addr, part, suffix;
          addr = (function() {
            var k, len, ref2, results;
            ref2 = this.parts;
            results = [];
            for (k = 0, len = ref2.length; k < len; k++) {
              part = ref2[k];
              results.push(part.toString(16));
            }
            return results;
          }).call(this).join(":");
          suffix = "";
          if (this.zoneId) {
            suffix = "%" + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.toFixedLengthString = function() {
          var addr, part, suffix;
          addr = (function() {
            var k, len, ref2, results;
            ref2 = this.parts;
            results = [];
            for (k = 0, len = ref2.length; k < len; k++) {
              part = ref2[k];
              results.push(part.toString(16).padStart(4, "0"));
            }
            return results;
          }).call(this).join(":");
          suffix = "";
          if (this.zoneId) {
            suffix = "%" + this.zoneId;
          }
          return addr + suffix;
        };
        IPv6.prototype.match = function(other, cidrRange) {
          var ref2;
          if (cidrRange === void 0) {
            ref2 = other, other = ref2[0], cidrRange = ref2[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.SpecialRanges = {
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
        };
        IPv6.prototype.range = function() {
          return ipaddr2.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.toIPv4Address = function() {
          var high, low, ref2;
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          ref2 = this.parts.slice(-2), high = ref2[0], low = ref2[1];
          return new ipaddr2.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          var cidr, i, k, part, stop, zeros, zerotable;
          zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          cidr = 0;
          stop = false;
          for (i = k = 7; k >= 0; i = k += -1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        return IPv6;
      })();
      ipv6Part = "(?:[0-9a-f]+::?)+";
      zoneIndex = "%[0-9a-z]{1,}";
      ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
        transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
      };
      expandIPv6 = function(string2, parts) {
        var colonCount, lastColon, part, replacement, replacementCount, zoneId;
        if (string2.indexOf("::") !== string2.lastIndexOf("::")) {
          return null;
        }
        zoneId = (string2.match(ipv6Regexes["zoneIndex"]) || [])[0];
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string2 = string2.replace(/%.+$/, "");
        }
        colonCount = 0;
        lastColon = -1;
        while ((lastColon = string2.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string2.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string2.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string2 = string2.replace("::", replacement);
        if (string2[0] === ":") {
          string2 = string2.slice(1);
        }
        if (string2[string2.length - 1] === ":") {
          string2 = string2.slice(0, -1);
        }
        parts = (function() {
          var k, len, ref2, results;
          ref2 = string2.split(":");
          results = [];
          for (k = 0, len = ref2.length; k < len; k++) {
            part = ref2[k];
            results.push(parseInt(part, 16));
          }
          return results;
        })();
        return {
          parts,
          zoneId
        };
      };
      ipaddr2.IPv6.parser = function(string2) {
        var addr, k, len, match, octet, octets, zoneId;
        if (ipv6Regexes["native"].test(string2)) {
          return expandIPv6(string2, 8);
        } else if (match = string2.match(ipv6Regexes["transitional"])) {
          zoneId = match[6] || "";
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
            for (k = 0, len = octets.length; k < len; k++) {
              octet = octets[k];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr2.IPv4.isIPv4 = ipaddr2.IPv6.isIPv6 = function(string2) {
        return this.parser(string2) !== null;
      };
      ipaddr2.IPv4.isValid = function(string2) {
        try {
          new this(this.parser(string2));
          return true;
        } catch (error1) {
          return false;
        }
      };
      ipaddr2.IPv4.isValidFourPartDecimal = function(string2) {
        if (ipaddr2.IPv4.isValid(string2) && string2.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr2.IPv6.isValid = function(string2) {
        var addr;
        if (typeof string2 === "string" && string2.indexOf(":") === -1) {
          return false;
        }
        try {
          addr = this.parser(string2);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (error1) {
          return false;
        }
      };
      ipaddr2.IPv4.parse = function(string2) {
        var parts;
        parts = this.parser(string2);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(parts);
      };
      ipaddr2.IPv6.parse = function(string2) {
        var addr;
        addr = this.parser(string2);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like ip address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr2.IPv4.parseCIDR = function(string2) {
        var maskLength, match, parsed;
        if (match = string2.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr2.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        var filledOctetCount, j, octets;
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        octets = [0, 0, 0, 0];
        j = 0;
        filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr2.IPv4.broadcastAddressFromCIDR = function(string2) {
        var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string2);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (error1) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr2.IPv4.networkAddressFromCIDR = function(string2) {
        var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string2);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (error1) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr2.IPv6.parseCIDR = function(string2) {
        var maskLength, match, parsed;
        if (match = string2.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr2.isValid = function(string2) {
        return ipaddr2.IPv6.isValid(string2) || ipaddr2.IPv4.isValid(string2);
      };
      ipaddr2.parse = function(string2) {
        if (ipaddr2.IPv6.isValid(string2)) {
          return ipaddr2.IPv6.parse(string2);
        } else if (ipaddr2.IPv4.isValid(string2)) {
          return ipaddr2.IPv4.parse(string2);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr2.parseCIDR = function(string2) {
        try {
          return ipaddr2.IPv6.parseCIDR(string2);
        } catch (error1) {
          try {
            return ipaddr2.IPv4.parseCIDR(string2);
          } catch (error12) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr2.fromByteArray = function(bytes2) {
        var length;
        length = bytes2.length;
        if (length === 4) {
          return new ipaddr2.IPv4(bytes2);
        } else if (length === 16) {
          return new ipaddr2.IPv6(bytes2);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr2.process = function(string2) {
        var addr;
        addr = this.parse(string2);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
    }).call(ipaddr);
  })(ipaddr$1);
  return ipaddr$1.exports;
}
var hasRequiredProxyAddr;
function requireProxyAddr() {
  if (hasRequiredProxyAddr) return proxyAddr.exports;
  hasRequiredProxyAddr = 1;
  proxyAddr.exports = proxyaddr;
  proxyAddr.exports.all = alladdrs;
  proxyAddr.exports.compile = compile;
  var forwarded = requireForwarded();
  var ipaddr2 = requireIpaddr();
  var DIGIT_REGEXP = /^[0-9]+$/;
  var isip = ipaddr2.isValid;
  var parseip = ipaddr2.parse;
  var IP_RANGES = {
    linklocal: ["169.254.0.0/16", "fe80::/10"],
    loopback: ["127.0.0.1/8", "::1/128"],
    uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
  };
  function alladdrs(req, trust) {
    var addrs = forwarded(req);
    if (!trust) {
      return addrs;
    }
    if (typeof trust !== "function") {
      trust = compile(trust);
    }
    for (var i = 0; i < addrs.length - 1; i++) {
      if (trust(addrs[i], i)) continue;
      addrs.length = i + 1;
    }
    return addrs;
  }
  function compile(val) {
    if (!val) {
      throw new TypeError("argument is required");
    }
    var trust;
    if (typeof val === "string") {
      trust = [val];
    } else if (Array.isArray(val)) {
      trust = val.slice();
    } else {
      throw new TypeError("unsupported trust argument");
    }
    for (var i = 0; i < trust.length; i++) {
      val = trust[i];
      if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
        continue;
      }
      val = IP_RANGES[val];
      trust.splice.apply(trust, [i, 1].concat(val));
      i += val.length - 1;
    }
    return compileTrust(compileRangeSubnets(trust));
  }
  function compileRangeSubnets(arr) {
    var rangeSubnets = new Array(arr.length);
    for (var i = 0; i < arr.length; i++) {
      rangeSubnets[i] = parseipNotation(arr[i]);
    }
    return rangeSubnets;
  }
  function compileTrust(rangeSubnets) {
    var len = rangeSubnets.length;
    return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
  }
  function parseipNotation(note) {
    var pos2 = note.lastIndexOf("/");
    var str = pos2 !== -1 ? note.substring(0, pos2) : note;
    if (!isip(str)) {
      throw new TypeError("invalid IP address: " + str);
    }
    var ip = parseip(str);
    if (pos2 === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) {
      ip = ip.toIPv4Address();
    }
    var max2 = ip.kind() === "ipv6" ? 128 : 32;
    var range2 = pos2 !== -1 ? note.substring(pos2 + 1, note.length) : null;
    if (range2 === null) {
      range2 = max2;
    } else if (DIGIT_REGEXP.test(range2)) {
      range2 = parseInt(range2, 10);
    } else if (ip.kind() === "ipv4" && isip(range2)) {
      range2 = parseNetmask(range2);
    } else {
      range2 = null;
    }
    if (range2 <= 0 || range2 > max2) {
      throw new TypeError("invalid range on address: " + note);
    }
    return [ip, range2];
  }
  function parseNetmask(netmask) {
    var ip = parseip(netmask);
    var kind = ip.kind();
    return kind === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
  }
  function proxyaddr(req, trust) {
    if (!req) {
      throw new TypeError("req argument is required");
    }
    if (!trust) {
      throw new TypeError("trust argument is required");
    }
    var addrs = alladdrs(req, trust);
    var addr = addrs[addrs.length - 1];
    return addr;
  }
  function trustNone() {
    return false;
  }
  function trustMulti(subnets) {
    return function trust(addr) {
      if (!isip(addr)) return false;
      var ip = parseip(addr);
      var ipconv;
      var kind = ip.kind();
      for (var i = 0; i < subnets.length; i++) {
        var subnet = subnets[i];
        var subnetip = subnet[0];
        var subnetkind = subnetip.kind();
        var subnetrange = subnet[1];
        var trusted = ip;
        if (kind !== subnetkind) {
          if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) {
            continue;
          }
          if (!ipconv) {
            ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
          }
          trusted = ipconv;
        }
        if (trusted.match(subnetip, subnetrange)) {
          return true;
        }
      }
      return false;
    };
  }
  function trustSingle(subnet) {
    var subnetip = subnet[0];
    var subnetkind = subnetip.kind();
    var subnetisipv4 = subnetkind === "ipv4";
    var subnetrange = subnet[1];
    return function trust(addr) {
      if (!isip(addr)) return false;
      var ip = parseip(addr);
      var kind = ip.kind();
      if (kind !== subnetkind) {
        if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
          return false;
        }
        ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
      }
      return ip.match(subnetip, subnetrange);
    };
  }
  return proxyAddr.exports;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  (function(exports$1) {
    var { METHODS } = require$$2$2;
    var contentType2 = requireContentType();
    var etag = requireEtag();
    var mime = requireMimeTypes$1();
    var proxyaddr = requireProxyAddr();
    var qs = /* @__PURE__ */ requireLib$2();
    var querystring = require$$6$1;
    const { Buffer: Buffer2 } = require$$7$1;
    exports$1.methods = METHODS.map((method) => method.toLowerCase());
    exports$1.etag = createETagGenerator({ weak: false });
    exports$1.wetag = createETagGenerator({ weak: true });
    exports$1.normalizeType = function(type2) {
      return ~type2.indexOf("/") ? acceptParams(type2) : { value: mime.lookup(type2) || "application/octet-stream", params: {} };
    };
    exports$1.normalizeTypes = function(types2) {
      return types2.map(exports$1.normalizeType);
    };
    function acceptParams(str) {
      var length = str.length;
      var colonIndex = str.indexOf(";");
      var index2 = colonIndex === -1 ? length : colonIndex;
      var ret = { value: str.slice(0, index2).trim(), quality: 1, params: {} };
      while (index2 < length) {
        var splitIndex = str.indexOf("=", index2);
        if (splitIndex === -1) break;
        var colonIndex = str.indexOf(";", index2);
        var endIndex = colonIndex === -1 ? length : colonIndex;
        if (splitIndex > endIndex) {
          index2 = str.lastIndexOf(";", splitIndex - 1) + 1;
          continue;
        }
        var key2 = str.slice(index2, splitIndex).trim();
        var value = str.slice(splitIndex + 1, endIndex).trim();
        if (key2 === "q") {
          ret.quality = parseFloat(value);
        } else {
          ret.params[key2] = value;
        }
        index2 = endIndex + 1;
      }
      return ret;
    }
    exports$1.compileETag = function(val) {
      var fn;
      if (typeof val === "function") {
        return val;
      }
      switch (val) {
        case true:
        case "weak":
          fn = exports$1.wetag;
          break;
        case false:
          break;
        case "strong":
          fn = exports$1.etag;
          break;
        default:
          throw new TypeError("unknown value for etag function: " + val);
      }
      return fn;
    };
    exports$1.compileQueryParser = function compileQueryParser(val) {
      var fn;
      if (typeof val === "function") {
        return val;
      }
      switch (val) {
        case true:
        case "simple":
          fn = querystring.parse;
          break;
        case false:
          break;
        case "extended":
          fn = parseExtendedQueryString;
          break;
        default:
          throw new TypeError("unknown value for query parser function: " + val);
      }
      return fn;
    };
    exports$1.compileTrust = function(val) {
      if (typeof val === "function") return val;
      if (val === true) {
        return function() {
          return true;
        };
      }
      if (typeof val === "number") {
        return function(a, i) {
          return i < val;
        };
      }
      if (typeof val === "string") {
        val = val.split(",").map(function(v) {
          return v.trim();
        });
      }
      return proxyaddr.compile(val || []);
    };
    exports$1.setCharset = function setCharset(type2, charset2) {
      if (!type2 || !charset2) {
        return type2;
      }
      var parsed = contentType2.parse(type2);
      parsed.parameters.charset = charset2;
      return contentType2.format(parsed);
    };
    function createETagGenerator(options) {
      return function generateETag(body, encoding2) {
        var buf = !Buffer2.isBuffer(body) ? Buffer2.from(body, encoding2) : body;
        return etag(buf, options);
      };
    }
    function parseExtendedQueryString(str) {
      return qs.parse(str, {
        allowPrototypes: true
      });
    }
  })(utils$1);
  return utils$1;
}
var once = { exports: {} };
var wrappy_1;
var hasRequiredWrappy;
function requireWrappy() {
  if (hasRequiredWrappy) return wrappy_1;
  hasRequiredWrappy = 1;
  wrappy_1 = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb) return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb2 = args[args.length - 1];
      if (typeof ret === "function" && ret !== cb2) {
        Object.keys(cb2).forEach(function(k) {
          ret[k] = cb2[k];
        });
      }
      return ret;
    }
  }
  return wrappy_1;
}
var hasRequiredOnce;
function requireOnce() {
  if (hasRequiredOnce) return once.exports;
  hasRequiredOnce = 1;
  var wrappy = requireWrappy();
  once.exports = wrappy(once$1);
  once.exports.strict = wrappy(onceStrict);
  once$1.proto = once$1(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once$1(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: true
    });
  });
  function once$1(fn) {
    var f = function() {
      if (f.called) return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || "Function wrapped with `once`";
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
  return once.exports;
}
var router = { exports: {} };
var isPromise = { exports: {} };
var hasRequiredIsPromise;
function requireIsPromise() {
  if (hasRequiredIsPromise) return isPromise.exports;
  hasRequiredIsPromise = 1;
  isPromise.exports = isPromise$1;
  isPromise.exports.default = isPromise$1;
  function isPromise$1(obj) {
    return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
  }
  return isPromise.exports;
}
var dist = {};
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  Object.defineProperty(dist, "__esModule", { value: true });
  dist.PathError = dist.TokenData = void 0;
  dist.parse = parse3;
  dist.compile = compile;
  dist.match = match;
  dist.pathToRegexp = pathToRegexp;
  dist.stringify = stringify3;
  const DEFAULT_DELIMITER = "/";
  const NOOP_VALUE = (value) => value;
  const ID_START = /^[$_\p{ID_Start}]$/u;
  const ID_CONTINUE = /^[$\u200c\u200d\p{ID_Continue}]$/u;
  const SIMPLE_TOKENS = {
    // Groups.
    "{": "{",
    "}": "}",
    // Reserved.
    "(": "(",
    ")": ")",
    "[": "[",
    "]": "]",
    "+": "+",
    "?": "?",
    "!": "!"
  };
  function escapeText(str) {
    return str.replace(/[{}()\[\]+?!:*\\]/g, "\\$&");
  }
  function escape2(str) {
    return str.replace(/[.+*?^${}()[\]|/\\]/g, "\\$&");
  }
  class TokenData {
    constructor(tokens, originalPath) {
      this.tokens = tokens;
      this.originalPath = originalPath;
    }
  }
  dist.TokenData = TokenData;
  class PathError extends TypeError {
    constructor(message, originalPath) {
      let text = message;
      if (originalPath)
        text += `: ${originalPath}`;
      text += `; visit https://git.new/pathToRegexpError for info`;
      super(text);
      this.originalPath = originalPath;
    }
  }
  dist.PathError = PathError;
  function parse3(str, options = {}) {
    const { encodePath = NOOP_VALUE } = options;
    const chars = [...str];
    const tokens = [];
    let index2 = 0;
    let pos2 = 0;
    function name() {
      let value = "";
      if (ID_START.test(chars[index2])) {
        do {
          value += chars[index2++];
        } while (ID_CONTINUE.test(chars[index2]));
      } else if (chars[index2] === '"') {
        let quoteStart = index2;
        while (index2++ < chars.length) {
          if (chars[index2] === '"') {
            index2++;
            quoteStart = 0;
            break;
          }
          if (chars[index2] === "\\")
            index2++;
          value += chars[index2];
        }
        if (quoteStart) {
          throw new PathError(`Unterminated quote at index ${quoteStart}`, str);
        }
      }
      if (!value) {
        throw new PathError(`Missing parameter name at index ${index2}`, str);
      }
      return value;
    }
    while (index2 < chars.length) {
      const value = chars[index2];
      const type2 = SIMPLE_TOKENS[value];
      if (type2) {
        tokens.push({ type: type2, index: index2++, value });
      } else if (value === "\\") {
        tokens.push({ type: "escape", index: index2++, value: chars[index2++] });
      } else if (value === ":") {
        tokens.push({ type: "param", index: index2++, value: name() });
      } else if (value === "*") {
        tokens.push({ type: "wildcard", index: index2++, value: name() });
      } else {
        tokens.push({ type: "char", index: index2++, value });
      }
    }
    tokens.push({ type: "end", index: index2, value: "" });
    function consumeUntil(endType) {
      const output2 = [];
      while (true) {
        const token2 = tokens[pos2++];
        if (token2.type === endType)
          break;
        if (token2.type === "char" || token2.type === "escape") {
          let path2 = token2.value;
          let cur = tokens[pos2];
          while (cur.type === "char" || cur.type === "escape") {
            path2 += cur.value;
            cur = tokens[++pos2];
          }
          output2.push({
            type: "text",
            value: encodePath(path2)
          });
          continue;
        }
        if (token2.type === "param" || token2.type === "wildcard") {
          output2.push({
            type: token2.type,
            name: token2.value
          });
          continue;
        }
        if (token2.type === "{") {
          output2.push({
            type: "group",
            tokens: consumeUntil("}")
          });
          continue;
        }
        throw new PathError(`Unexpected ${token2.type} at index ${token2.index}, expected ${endType}`, str);
      }
      return output2;
    }
    return new TokenData(consumeUntil("end"), str);
  }
  function compile(path2, options = {}) {
    const { encode: encode2 = encodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;
    const data = typeof path2 === "object" ? path2 : parse3(path2, options);
    const fn = tokensToFunction(data.tokens, delimiter, encode2);
    return function path3(params = {}) {
      const [path4, ...missing] = fn(params);
      if (missing.length) {
        throw new TypeError(`Missing parameters: ${missing.join(", ")}`);
      }
      return path4;
    };
  }
  function tokensToFunction(tokens, delimiter, encode2) {
    const encoders = tokens.map((token2) => tokenToFunction(token2, delimiter, encode2));
    return (data) => {
      const result = [""];
      for (const encoder of encoders) {
        const [value, ...extras] = encoder(data);
        result[0] += value;
        result.push(...extras);
      }
      return result;
    };
  }
  function tokenToFunction(token2, delimiter, encode2) {
    if (token2.type === "text")
      return () => [token2.value];
    if (token2.type === "group") {
      const fn = tokensToFunction(token2.tokens, delimiter, encode2);
      return (data) => {
        const [value, ...missing] = fn(data);
        if (!missing.length)
          return [value];
        return [""];
      };
    }
    const encodeValue = encode2 || NOOP_VALUE;
    if (token2.type === "wildcard" && encode2 !== false) {
      return (data) => {
        const value = data[token2.name];
        if (value == null)
          return ["", token2.name];
        if (!Array.isArray(value) || value.length === 0) {
          throw new TypeError(`Expected "${token2.name}" to be a non-empty array`);
        }
        return [
          value.map((value2, index2) => {
            if (typeof value2 !== "string") {
              throw new TypeError(`Expected "${token2.name}/${index2}" to be a string`);
            }
            return encodeValue(value2);
          }).join(delimiter)
        ];
      };
    }
    return (data) => {
      const value = data[token2.name];
      if (value == null)
        return ["", token2.name];
      if (typeof value !== "string") {
        throw new TypeError(`Expected "${token2.name}" to be a string`);
      }
      return [encodeValue(value)];
    };
  }
  function match(path2, options = {}) {
    const { decode: decode2 = decodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;
    const { regexp, keys } = pathToRegexp(path2, options);
    const decoders = keys.map((key2) => {
      if (decode2 === false)
        return NOOP_VALUE;
      if (key2.type === "param")
        return decode2;
      return (value) => value.split(delimiter).map(decode2);
    });
    return function match2(input) {
      const m = regexp.exec(input);
      if (!m)
        return false;
      const path3 = m[0];
      const params = /* @__PURE__ */ Object.create(null);
      for (let i = 1; i < m.length; i++) {
        if (m[i] === void 0)
          continue;
        const key2 = keys[i - 1];
        const decoder2 = decoders[i - 1];
        params[key2.name] = decoder2(m[i]);
      }
      return { path: path3, params };
    };
  }
  function pathToRegexp(path2, options = {}) {
    const { delimiter = DEFAULT_DELIMITER, end = true, sensitive = false, trailing = true } = options;
    const keys = [];
    const flags = sensitive ? "" : "i";
    const sources = [];
    for (const input of pathsToArray(path2, [])) {
      const data = typeof input === "object" ? input : parse3(input, options);
      for (const tokens of flatten2(data.tokens, 0, [])) {
        sources.push(toRegExpSource(tokens, delimiter, keys, data.originalPath));
      }
    }
    let pattern2 = `^(?:${sources.join("|")})`;
    if (trailing)
      pattern2 += `(?:${escape2(delimiter)}$)?`;
    pattern2 += end ? "$" : `(?=${escape2(delimiter)}|$)`;
    const regexp = new RegExp(pattern2, flags);
    return { regexp, keys };
  }
  function pathsToArray(paths, init2) {
    if (Array.isArray(paths)) {
      for (const p of paths)
        pathsToArray(p, init2);
    } else {
      init2.push(paths);
    }
    return init2;
  }
  function* flatten2(tokens, index2, init2) {
    if (index2 === tokens.length) {
      return yield init2;
    }
    const token2 = tokens[index2];
    if (token2.type === "group") {
      for (const seq of flatten2(token2.tokens, 0, init2.slice())) {
        yield* flatten2(tokens, index2 + 1, seq);
      }
    } else {
      init2.push(token2);
    }
    yield* flatten2(tokens, index2 + 1, init2);
  }
  function toRegExpSource(tokens, delimiter, keys, originalPath) {
    let result = "";
    let backtrack = "";
    let isSafeSegmentParam = true;
    for (const token2 of tokens) {
      if (token2.type === "text") {
        result += escape2(token2.value);
        backtrack += token2.value;
        isSafeSegmentParam || (isSafeSegmentParam = token2.value.includes(delimiter));
        continue;
      }
      if (token2.type === "param" || token2.type === "wildcard") {
        if (!isSafeSegmentParam && !backtrack) {
          throw new PathError(`Missing text before "${token2.name}" ${token2.type}`, originalPath);
        }
        if (token2.type === "param") {
          result += `(${negate(delimiter, isSafeSegmentParam ? "" : backtrack)}+)`;
        } else {
          result += `([\\s\\S]+)`;
        }
        keys.push(token2);
        backtrack = "";
        isSafeSegmentParam = false;
        continue;
      }
    }
    return result;
  }
  function negate(delimiter, backtrack) {
    if (backtrack.length < 2) {
      if (delimiter.length < 2)
        return `[^${escape2(delimiter + backtrack)}]`;
      return `(?:(?!${escape2(delimiter)})[^${escape2(backtrack)}])`;
    }
    if (delimiter.length < 2) {
      return `(?:(?!${escape2(backtrack)})[^${escape2(delimiter)}])`;
    }
    return `(?:(?!${escape2(backtrack)}|${escape2(delimiter)})[\\s\\S])`;
  }
  function stringifyTokens(tokens) {
    let value = "";
    let i = 0;
    function name(value2) {
      const isSafe = isNameSafe(value2) && isNextNameSafe(tokens[i]);
      return isSafe ? value2 : JSON.stringify(value2);
    }
    while (i < tokens.length) {
      const token2 = tokens[i++];
      if (token2.type === "text") {
        value += escapeText(token2.value);
        continue;
      }
      if (token2.type === "group") {
        value += `{${stringifyTokens(token2.tokens)}}`;
        continue;
      }
      if (token2.type === "param") {
        value += `:${name(token2.name)}`;
        continue;
      }
      if (token2.type === "wildcard") {
        value += `*${name(token2.name)}`;
        continue;
      }
      throw new TypeError(`Unknown token type: ${token2.type}`);
    }
    return value;
  }
  function stringify3(data) {
    return stringifyTokens(data.tokens);
  }
  function isNameSafe(name) {
    const [first, ...rest] = name;
    return ID_START.test(first) && rest.every((char) => ID_CONTINUE.test(char));
  }
  function isNextNameSafe(token2) {
    if (token2 && token2.type === "text")
      return !ID_CONTINUE.test(token2.value[0]);
    return true;
  }
  return dist;
}
var layer;
var hasRequiredLayer;
function requireLayer() {
  if (hasRequiredLayer) return layer;
  hasRequiredLayer = 1;
  const isPromise2 = requireIsPromise();
  const pathRegexp = requireDist();
  const debug = require$$0$9("router:layer");
  const deprecate = requireBrowser$1()("router");
  const TRAILING_SLASH_REGEXP = /\/+$/;
  const MATCHING_GROUP_REGEXP = /\((?:\?<(.*?)>)?(?!\?)/g;
  layer = Layer;
  function Layer(path2, options, fn) {
    if (!(this instanceof Layer)) {
      return new Layer(path2, options, fn);
    }
    debug("new %o", path2);
    const opts = options || {};
    this.handle = fn;
    this.keys = [];
    this.name = fn.name || "<anonymous>";
    this.params = void 0;
    this.path = void 0;
    this.slash = path2 === "/" && opts.end === false;
    function matcher(_path) {
      if (_path instanceof RegExp) {
        const keys = [];
        let name = 0;
        let m;
        while (m = MATCHING_GROUP_REGEXP.exec(_path.source)) {
          keys.push({
            name: m[1] || name++,
            offset: m.index
          });
        }
        return function regexpMatcher(p) {
          const match = _path.exec(p);
          if (!match) {
            return false;
          }
          const params = {};
          for (let i = 1; i < match.length; i++) {
            const key2 = keys[i - 1];
            const prop = key2.name;
            const val = decodeParam(match[i]);
            if (val !== void 0) {
              params[prop] = val;
            }
          }
          return {
            params,
            path: match[0]
          };
        };
      }
      return pathRegexp.match(opts.strict ? _path : loosen(_path), {
        sensitive: opts.sensitive,
        end: opts.end,
        trailing: !opts.strict,
        decode: decodeParam
      });
    }
    this.matchers = Array.isArray(path2) ? path2.map(matcher) : [matcher(path2)];
  }
  Layer.prototype.handleError = function handleError(error2, req, res, next) {
    const fn = this.handle;
    if (fn.length !== 4) {
      return next(error2);
    }
    try {
      const ret = fn(error2, req, res, next);
      if (isPromise2(ret)) {
        if (!(ret instanceof Promise)) {
          deprecate("handlers that are Promise-like are deprecated, use a native Promise instead");
        }
        ret.then(null, function(error3) {
          next(error3 || new Error("Rejected promise"));
        });
      }
    } catch (err) {
      next(err);
    }
  };
  Layer.prototype.handleRequest = function handleRequest(req, res, next) {
    const fn = this.handle;
    if (fn.length > 3) {
      return next();
    }
    try {
      const ret = fn(req, res, next);
      if (isPromise2(ret)) {
        if (!(ret instanceof Promise)) {
          deprecate("handlers that are Promise-like are deprecated, use a native Promise instead");
        }
        ret.then(null, function(error2) {
          next(error2 || new Error("Rejected promise"));
        });
      }
    } catch (err) {
      next(err);
    }
  };
  Layer.prototype.match = function match(path2) {
    let match2;
    if (path2 != null) {
      if (this.slash) {
        this.params = {};
        this.path = "";
        return true;
      }
      let i = 0;
      while (!match2 && i < this.matchers.length) {
        match2 = this.matchers[i](path2);
        i++;
      }
    }
    if (!match2) {
      this.params = void 0;
      this.path = void 0;
      return false;
    }
    this.params = match2.params;
    this.path = match2.path;
    this.keys = Object.keys(match2.params);
    return true;
  };
  function decodeParam(val) {
    if (typeof val !== "string" || val.length === 0) {
      return val;
    }
    try {
      return decodeURIComponent(val);
    } catch (err) {
      if (err instanceof URIError) {
        err.message = "Failed to decode param '" + val + "'";
        err.status = 400;
      }
      throw err;
    }
  }
  function loosen(path2) {
    if (path2 instanceof RegExp || path2 === "/") {
      return path2;
    }
    return Array.isArray(path2) ? path2.map(function(p) {
      return loosen(p);
    }) : String(path2).replace(TRAILING_SLASH_REGEXP, "");
  }
  return layer;
}
var route;
var hasRequiredRoute;
function requireRoute() {
  if (hasRequiredRoute) return route;
  hasRequiredRoute = 1;
  const debug = require$$0$9("router:route");
  const Layer = requireLayer();
  const { METHODS } = require$$2$2;
  const slice = Array.prototype.slice;
  const flatten2 = Array.prototype.flat;
  const methods2 = METHODS.map((method) => method.toLowerCase());
  route = Route;
  function Route(path2) {
    debug("new %o", path2);
    this.path = path2;
    this.stack = [];
    this.methods = /* @__PURE__ */ Object.create(null);
  }
  Route.prototype._handlesMethod = function _handlesMethod(method) {
    if (this.methods._all) {
      return true;
    }
    let name = typeof method === "string" ? method.toLowerCase() : method;
    if (name === "head" && !this.methods.head) {
      name = "get";
    }
    return Boolean(this.methods[name]);
  };
  Route.prototype._methods = function _methods() {
    const methods3 = Object.keys(this.methods);
    if (this.methods.get && !this.methods.head) {
      methods3.push("head");
    }
    for (let i = 0; i < methods3.length; i++) {
      methods3[i] = methods3[i].toUpperCase();
    }
    return methods3;
  };
  Route.prototype.dispatch = function dispatch(req, res, done) {
    let idx = 0;
    const stack2 = this.stack;
    let sync = 0;
    if (stack2.length === 0) {
      return done();
    }
    let method = typeof req.method === "string" ? req.method.toLowerCase() : req.method;
    if (method === "head" && !this.methods.head) {
      method = "get";
    }
    req.route = this;
    next();
    function next(err) {
      if (err && err === "route") {
        return done();
      }
      if (err && err === "router") {
        return done(err);
      }
      if (idx >= stack2.length) {
        return done(err);
      }
      if (++sync > 100) {
        return setImmediate(next, err);
      }
      let layer2;
      let match;
      while (match !== true && idx < stack2.length) {
        layer2 = stack2[idx++];
        match = !layer2.method || layer2.method === method;
      }
      if (match !== true) {
        return done(err);
      }
      if (err) {
        layer2.handleError(err, req, res, next);
      } else {
        layer2.handleRequest(req, res, next);
      }
      sync = 0;
    }
  };
  Route.prototype.all = function all(handler) {
    const callbacks = flatten2.call(slice.call(arguments), Infinity);
    if (callbacks.length === 0) {
      throw new TypeError("argument handler is required");
    }
    for (let i = 0; i < callbacks.length; i++) {
      const fn = callbacks[i];
      if (typeof fn !== "function") {
        throw new TypeError("argument handler must be a function");
      }
      const layer2 = Layer("/", {}, fn);
      layer2.method = void 0;
      this.methods._all = true;
      this.stack.push(layer2);
    }
    return this;
  };
  methods2.forEach(function(method) {
    Route.prototype[method] = function(handler) {
      const callbacks = flatten2.call(slice.call(arguments), Infinity);
      if (callbacks.length === 0) {
        throw new TypeError("argument handler is required");
      }
      for (let i = 0; i < callbacks.length; i++) {
        const fn = callbacks[i];
        if (typeof fn !== "function") {
          throw new TypeError("argument handler must be a function");
        }
        debug("%s %s", method, this.path);
        const layer2 = Layer("/", {}, fn);
        layer2.method = method;
        this.methods[method] = true;
        this.stack.push(layer2);
      }
      return this;
    };
  });
  return route;
}
var hasRequiredRouter;
function requireRouter() {
  if (hasRequiredRouter) return router.exports;
  hasRequiredRouter = 1;
  const isPromise2 = requireIsPromise();
  const Layer = requireLayer();
  const { METHODS } = require$$2$2;
  const parseUrl = requireParseurl();
  const Route = requireRoute();
  const debug = require$$0$9("router");
  const deprecate = requireBrowser$1()("router");
  const slice = Array.prototype.slice;
  const flatten2 = Array.prototype.flat;
  const methods2 = METHODS.map((method) => method.toLowerCase());
  router.exports = Router;
  router.exports.Route = Route;
  function Router(options) {
    if (!(this instanceof Router)) {
      return new Router(options);
    }
    const opts = options || {};
    function router2(req, res, next) {
      router2.handle(req, res, next);
    }
    Object.setPrototypeOf(router2, this);
    router2.caseSensitive = opts.caseSensitive;
    router2.mergeParams = opts.mergeParams;
    router2.params = {};
    router2.strict = opts.strict;
    router2.stack = [];
    return router2;
  }
  Router.prototype = function() {
  };
  Router.prototype.param = function param(name, fn) {
    if (!name) {
      throw new TypeError("argument name is required");
    }
    if (typeof name !== "string") {
      throw new TypeError("argument name must be a string");
    }
    if (!fn) {
      throw new TypeError("argument fn is required");
    }
    if (typeof fn !== "function") {
      throw new TypeError("argument fn must be a function");
    }
    let params = this.params[name];
    if (!params) {
      params = this.params[name] = [];
    }
    params.push(fn);
    return this;
  };
  Router.prototype.handle = function handle(req, res, callback) {
    if (!callback) {
      throw new TypeError("argument callback is required");
    }
    debug("dispatching %s %s", req.method, req.url);
    let idx = 0;
    let methods3;
    const protohost = getProtohost(req.url) || "";
    let removed = "";
    const self2 = this;
    let slashAdded = false;
    let sync = 0;
    const paramcalled = {};
    const stack2 = this.stack;
    const parentParams = req.params;
    const parentUrl = req.baseUrl || "";
    let done = restore(callback, req, "baseUrl", "next", "params");
    req.next = next;
    if (req.method === "OPTIONS") {
      methods3 = [];
      done = wrap(done, generateOptionsResponder(res, methods3));
    }
    req.baseUrl = parentUrl;
    req.originalUrl = req.originalUrl || req.url;
    next();
    function next(err) {
      let layerError = err === "route" ? null : err;
      if (slashAdded) {
        req.url = req.url.slice(1);
        slashAdded = false;
      }
      if (removed.length !== 0) {
        req.baseUrl = parentUrl;
        req.url = protohost + removed + req.url.slice(protohost.length);
        removed = "";
      }
      if (layerError === "router") {
        setImmediate(done, null);
        return;
      }
      if (idx >= stack2.length) {
        setImmediate(done, layerError);
        return;
      }
      if (++sync > 100) {
        return setImmediate(next, err);
      }
      const path2 = getPathname(req);
      if (path2 == null) {
        return done(layerError);
      }
      let layer2;
      let match;
      let route2;
      while (match !== true && idx < stack2.length) {
        layer2 = stack2[idx++];
        match = matchLayer(layer2, path2);
        route2 = layer2.route;
        if (typeof match !== "boolean") {
          layerError = layerError || match;
        }
        if (match !== true) {
          continue;
        }
        if (!route2) {
          continue;
        }
        if (layerError) {
          match = false;
          continue;
        }
        const method = req.method;
        const hasMethod = route2._handlesMethod(method);
        if (!hasMethod && method === "OPTIONS" && methods3) {
          methods3.push.apply(methods3, route2._methods());
        }
        if (!hasMethod && method !== "HEAD") {
          match = false;
        }
      }
      if (match !== true) {
        return done(layerError);
      }
      if (route2) {
        req.route = route2;
      }
      req.params = self2.mergeParams ? mergeParams(layer2.params, parentParams) : layer2.params;
      const layerPath = layer2.path;
      processParams(self2.params, layer2, paramcalled, req, res, function(err2) {
        if (err2) {
          next(layerError || err2);
        } else if (route2) {
          layer2.handleRequest(req, res, next);
        } else {
          trimPrefix(layer2, layerError, layerPath, path2);
        }
        sync = 0;
      });
    }
    function trimPrefix(layer2, layerError, layerPath, path2) {
      if (layerPath.length !== 0) {
        if (layerPath !== path2.substring(0, layerPath.length)) {
          next(layerError);
          return;
        }
        const c2 = path2[layerPath.length];
        if (c2 && c2 !== "/") {
          next(layerError);
          return;
        }
        debug("trim prefix (%s) from url %s", layerPath, req.url);
        removed = layerPath;
        req.url = protohost + req.url.slice(protohost.length + removed.length);
        if (!protohost && req.url[0] !== "/") {
          req.url = "/" + req.url;
          slashAdded = true;
        }
        req.baseUrl = parentUrl + (removed[removed.length - 1] === "/" ? removed.substring(0, removed.length - 1) : removed);
      }
      debug("%s %s : %s", layer2.name, layerPath, req.originalUrl);
      if (layerError) {
        layer2.handleError(layerError, req, res, next);
      } else {
        layer2.handleRequest(req, res, next);
      }
    }
  };
  Router.prototype.use = function use(handler) {
    let offset = 0;
    let path2 = "/";
    if (typeof handler !== "function") {
      let arg = handler;
      while (Array.isArray(arg) && arg.length !== 0) {
        arg = arg[0];
      }
      if (typeof arg !== "function") {
        offset = 1;
        path2 = handler;
      }
    }
    const callbacks = flatten2.call(slice.call(arguments, offset), Infinity);
    if (callbacks.length === 0) {
      throw new TypeError("argument handler is required");
    }
    for (let i = 0; i < callbacks.length; i++) {
      const fn = callbacks[i];
      if (typeof fn !== "function") {
        throw new TypeError("argument handler must be a function");
      }
      debug("use %o %s", path2, fn.name || "<anonymous>");
      const layer2 = new Layer(path2, {
        sensitive: this.caseSensitive,
        strict: false,
        end: false
      }, fn);
      layer2.route = void 0;
      this.stack.push(layer2);
    }
    return this;
  };
  Router.prototype.route = function route2(path2) {
    const route3 = new Route(path2);
    const layer2 = new Layer(path2, {
      sensitive: this.caseSensitive,
      strict: this.strict,
      end: true
    }, handle);
    function handle(req, res, next) {
      route3.dispatch(req, res, next);
    }
    layer2.route = route3;
    this.stack.push(layer2);
    return route3;
  };
  methods2.concat("all").forEach(function(method) {
    Router.prototype[method] = function(path2) {
      const route2 = this.route(path2);
      route2[method].apply(route2, slice.call(arguments, 1));
      return this;
    };
  });
  function generateOptionsResponder(res, methods3) {
    return function onDone(fn, err) {
      if (err || methods3.length === 0) {
        return fn(err);
      }
      trySendOptionsResponse(res, methods3, fn);
    };
  }
  function getPathname(req) {
    try {
      return parseUrl(req).pathname;
    } catch (err) {
      return void 0;
    }
  }
  function getProtohost(url2) {
    if (typeof url2 !== "string" || url2.length === 0 || url2[0] === "/") {
      return void 0;
    }
    const searchIndex = url2.indexOf("?");
    const pathLength = searchIndex !== -1 ? searchIndex : url2.length;
    const fqdnIndex = url2.substring(0, pathLength).indexOf("://");
    return fqdnIndex !== -1 ? url2.substring(0, url2.indexOf("/", 3 + fqdnIndex)) : void 0;
  }
  function matchLayer(layer2, path2) {
    try {
      return layer2.match(path2);
    } catch (err) {
      return err;
    }
  }
  function mergeParams(params, parent) {
    if (typeof parent !== "object" || !parent) {
      return params;
    }
    const obj = Object.assign({}, parent);
    if (!(0 in params) || !(0 in parent)) {
      return Object.assign(obj, params);
    }
    let i = 0;
    let o = 0;
    while (i in params) {
      i++;
    }
    while (o in parent) {
      o++;
    }
    for (i--; i >= 0; i--) {
      params[i + o] = params[i];
      if (i < o) {
        delete params[i];
      }
    }
    return Object.assign(obj, params);
  }
  function processParams(params, layer2, called, req, res, done) {
    const keys = layer2.keys;
    if (!keys || keys.length === 0) {
      return done();
    }
    let i = 0;
    let paramIndex = 0;
    let key2;
    let paramVal;
    let paramCallbacks;
    let paramCalled;
    function param(err) {
      if (err) {
        return done(err);
      }
      if (i >= keys.length) {
        return done();
      }
      paramIndex = 0;
      key2 = keys[i++];
      paramVal = req.params[key2];
      paramCallbacks = params[key2];
      paramCalled = called[key2];
      if (paramVal === void 0 || !paramCallbacks) {
        return param();
      }
      if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== "route")) {
        req.params[key2] = paramCalled.value;
        return param(paramCalled.error);
      }
      called[key2] = paramCalled = {
        error: null,
        match: paramVal,
        value: paramVal
      };
      paramCallback();
    }
    function paramCallback(err) {
      const fn = paramCallbacks[paramIndex++];
      paramCalled.value = req.params[key2];
      if (err) {
        paramCalled.error = err;
        param(err);
        return;
      }
      if (!fn) return param();
      try {
        const ret = fn(req, res, paramCallback, paramVal, key2);
        if (isPromise2(ret)) {
          if (!(ret instanceof Promise)) {
            deprecate("parameters that are Promise-like are deprecated, use a native Promise instead");
          }
          ret.then(null, function(error2) {
            paramCallback(error2 || new Error("Rejected promise"));
          });
        }
      } catch (e) {
        paramCallback(e);
      }
    }
    param();
  }
  function restore(fn, obj) {
    const props = new Array(arguments.length - 2);
    const vals = new Array(arguments.length - 2);
    for (let i = 0; i < props.length; i++) {
      props[i] = arguments[i + 2];
      vals[i] = obj[props[i]];
    }
    return function() {
      for (let i = 0; i < props.length; i++) {
        obj[props[i]] = vals[i];
      }
      return fn.apply(this, arguments);
    };
  }
  function sendOptionsResponse(res, methods3) {
    const options = /* @__PURE__ */ Object.create(null);
    for (let i = 0; i < methods3.length; i++) {
      options[methods3[i]] = true;
    }
    const allow = Object.keys(options).sort().join(", ");
    res.setHeader("Allow", allow);
    res.setHeader("Content-Length", Buffer.byteLength(allow));
    res.setHeader("Content-Type", "text/plain");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.end(allow);
  }
  function trySendOptionsResponse(res, methods3, next) {
    try {
      sendOptionsResponse(res, methods3);
    } catch (err) {
      next(err);
    }
  }
  function wrap(old, fn) {
    return function proxy() {
      const args = new Array(arguments.length + 1);
      args[0] = old;
      for (let i = 0, len = arguments.length; i < len; i++) {
        args[i + 1] = arguments[i];
      }
      fn.apply(this, args);
    };
  }
  return router.exports;
}
var hasRequiredApplication;
function requireApplication() {
  if (hasRequiredApplication) return application.exports;
  hasRequiredApplication = 1;
  (function(module, exports$1) {
    var finalhandler = requireFinalhandler();
    var debug = require$$0$9("express:application");
    var View = requireView();
    var http = require$$2$2;
    var methods2 = requireUtils$1().methods;
    var compileETag = requireUtils$1().compileETag;
    var compileQueryParser = requireUtils$1().compileQueryParser;
    var compileTrust = requireUtils$1().compileTrust;
    var resolve2 = path__default.resolve;
    var once2 = requireOnce();
    var Router = requireRouter();
    var slice = Array.prototype.slice;
    var flatten2 = Array.prototype.flat;
    var app = module.exports = {};
    var trustProxyDefaultSymbol = "@@symbol:trust_proxy_default";
    app.init = function init2() {
      var router2 = null;
      this.cache = /* @__PURE__ */ Object.create(null);
      this.engines = /* @__PURE__ */ Object.create(null);
      this.settings = /* @__PURE__ */ Object.create(null);
      this.defaultConfiguration();
      Object.defineProperty(this, "router", {
        configurable: true,
        enumerable: true,
        get: function getrouter() {
          if (router2 === null) {
            router2 = new Router({
              caseSensitive: this.enabled("case sensitive routing"),
              strict: this.enabled("strict routing")
            });
          }
          return router2;
        }
      });
    };
    app.defaultConfiguration = function defaultConfiguration() {
      var env = "production";
      this.enable("x-powered-by");
      this.set("etag", "weak");
      this.set("env", env);
      this.set("query parser", "simple");
      this.set("subdomain offset", 2);
      this.set("trust proxy", false);
      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
        configurable: true,
        value: true
      });
      debug("booting in %s mode", env);
      this.on("mount", function onmount(parent) {
        if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings["trust proxy fn"] === "function") {
          delete this.settings["trust proxy"];
          delete this.settings["trust proxy fn"];
        }
        Object.setPrototypeOf(this.request, parent.request);
        Object.setPrototypeOf(this.response, parent.response);
        Object.setPrototypeOf(this.engines, parent.engines);
        Object.setPrototypeOf(this.settings, parent.settings);
      });
      this.locals = /* @__PURE__ */ Object.create(null);
      this.mountpath = "/";
      this.locals.settings = this.settings;
      this.set("view", View);
      this.set("views", resolve2("views"));
      this.set("jsonp callback name", "callback");
      {
        this.enable("view cache");
      }
    };
    app.handle = function handle(req, res, callback) {
      var done = callback || finalhandler(req, res, {
        env: this.get("env"),
        onerror: logerror.bind(this)
      });
      if (this.enabled("x-powered-by")) {
        res.setHeader("X-Powered-By", "Express");
      }
      req.res = res;
      res.req = req;
      Object.setPrototypeOf(req, this.request);
      Object.setPrototypeOf(res, this.response);
      if (!res.locals) {
        res.locals = /* @__PURE__ */ Object.create(null);
      }
      this.router.handle(req, res, done);
    };
    app.use = function use(fn) {
      var offset = 0;
      var path2 = "/";
      if (typeof fn !== "function") {
        var arg = fn;
        while (Array.isArray(arg) && arg.length !== 0) {
          arg = arg[0];
        }
        if (typeof arg !== "function") {
          offset = 1;
          path2 = fn;
        }
      }
      var fns = flatten2.call(slice.call(arguments, offset), Infinity);
      if (fns.length === 0) {
        throw new TypeError("app.use() requires a middleware function");
      }
      var router2 = this.router;
      fns.forEach(function(fn2) {
        if (!fn2 || !fn2.handle || !fn2.set) {
          return router2.use(path2, fn2);
        }
        debug(".use app under %s", path2);
        fn2.mountpath = path2;
        fn2.parent = this;
        router2.use(path2, function mounted_app(req, res, next) {
          var orig = req.app;
          fn2.handle(req, res, function(err) {
            Object.setPrototypeOf(req, orig.request);
            Object.setPrototypeOf(res, orig.response);
            next(err);
          });
        });
        fn2.emit("mount", this);
      }, this);
      return this;
    };
    app.route = function route2(path2) {
      return this.router.route(path2);
    };
    app.engine = function engine(ext, fn) {
      if (typeof fn !== "function") {
        throw new Error("callback function required");
      }
      var extension = ext[0] !== "." ? "." + ext : ext;
      this.engines[extension] = fn;
      return this;
    };
    app.param = function param(name, fn) {
      if (Array.isArray(name)) {
        for (var i = 0; i < name.length; i++) {
          this.param(name[i], fn);
        }
        return this;
      }
      this.router.param(name, fn);
      return this;
    };
    app.set = function set2(setting, val) {
      if (arguments.length === 1) {
        return this.settings[setting];
      }
      debug('set "%s" to %o', setting, val);
      this.settings[setting] = val;
      switch (setting) {
        case "etag":
          this.set("etag fn", compileETag(val));
          break;
        case "query parser":
          this.set("query parser fn", compileQueryParser(val));
          break;
        case "trust proxy":
          this.set("trust proxy fn", compileTrust(val));
          Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
            configurable: true,
            value: false
          });
          break;
      }
      return this;
    };
    app.path = function path2() {
      return this.parent ? this.parent.path() + this.mountpath : "";
    };
    app.enabled = function enabled(setting) {
      return Boolean(this.set(setting));
    };
    app.disabled = function disabled(setting) {
      return !this.set(setting);
    };
    app.enable = function enable(setting) {
      return this.set(setting, true);
    };
    app.disable = function disable(setting) {
      return this.set(setting, false);
    };
    methods2.forEach(function(method) {
      app[method] = function(path2) {
        if (method === "get" && arguments.length === 1) {
          return this.set(path2);
        }
        var route2 = this.route(path2);
        route2[method].apply(route2, slice.call(arguments, 1));
        return this;
      };
    });
    app.all = function all(path2) {
      var route2 = this.route(path2);
      var args = slice.call(arguments, 1);
      for (var i = 0; i < methods2.length; i++) {
        route2[methods2[i]].apply(route2, args);
      }
      return this;
    };
    app.render = function render(name, options, callback) {
      var cache = this.cache;
      var done = callback;
      var engines = this.engines;
      var opts = options;
      var view2;
      if (typeof options === "function") {
        done = options;
        opts = {};
      }
      var renderOptions = { ...this.locals, ...opts._locals, ...opts };
      if (renderOptions.cache == null) {
        renderOptions.cache = this.enabled("view cache");
      }
      if (renderOptions.cache) {
        view2 = cache[name];
      }
      if (!view2) {
        var View2 = this.get("view");
        view2 = new View2(name, {
          defaultEngine: this.get("view engine"),
          root: this.get("views"),
          engines
        });
        if (!view2.path) {
          var dirs = Array.isArray(view2.root) && view2.root.length > 1 ? 'directories "' + view2.root.slice(0, -1).join('", "') + '" or "' + view2.root[view2.root.length - 1] + '"' : 'directory "' + view2.root + '"';
          var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
          err.view = view2;
          return done(err);
        }
        if (renderOptions.cache) {
          cache[name] = view2;
        }
      }
      tryRender(view2, renderOptions, done);
    };
    app.listen = function listen() {
      var server = http.createServer(this);
      var args = slice.call(arguments);
      if (typeof args[args.length - 1] === "function") {
        var done = args[args.length - 1] = once2(args[args.length - 1]);
        server.once("error", done);
      }
      return server.listen.apply(server, args);
    };
    function logerror(err) {
      if (this.get("env") !== "test") console.error(err.stack || err.toString());
    }
    function tryRender(view2, options, callback) {
      try {
        view2.render(options, callback);
      } catch (err) {
        callback(err);
      }
    }
  })(application);
  return application.exports;
}
var negotiator = { exports: {} };
var charset = { exports: {} };
var hasRequiredCharset;
function requireCharset() {
  if (hasRequiredCharset) return charset.exports;
  hasRequiredCharset = 1;
  charset.exports = preferredCharsets;
  charset.exports.preferredCharsets = preferredCharsets;
  var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
  function parseAcceptCharset(accept) {
    var accepts2 = accept.split(",");
    for (var i = 0, j = 0; i < accepts2.length; i++) {
      var charset2 = parseCharset(accepts2[i].trim(), i);
      if (charset2) {
        accepts2[j++] = charset2;
      }
    }
    accepts2.length = j;
    return accepts2;
  }
  function parseCharset(str, i) {
    var match = simpleCharsetRegExp.exec(str);
    if (!match) return null;
    var charset2 = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(";");
      for (var j = 0; j < params.length; j++) {
        var p = params[j].trim().split("=");
        if (p[0] === "q") {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      charset: charset2,
      q,
      i
    };
  }
  function getCharsetPriority(charset2, accepted, index2) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(charset2, accepted[i], index2);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(charset2, spec, index2) {
    var s = 0;
    if (spec.charset.toLowerCase() === charset2.toLowerCase()) {
      s |= 1;
    } else if (spec.charset !== "*") {
      return null;
    }
    return {
      i: index2,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredCharsets(accept, provided) {
    var accepts2 = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
    if (!provided) {
      return accepts2.filter(isQuality).sort(compareSpecs).map(getFullCharset);
    }
    var priorities = provided.map(function getPriority(type2, index2) {
      return getCharsetPriority(type2, accepts2, index2);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullCharset(spec) {
    return spec.charset;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  return charset.exports;
}
var encoding = { exports: {} };
var hasRequiredEncoding;
function requireEncoding() {
  if (hasRequiredEncoding) return encoding.exports;
  hasRequiredEncoding = 1;
  encoding.exports = preferredEncodings;
  encoding.exports.preferredEncodings = preferredEncodings;
  var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
  function parseAcceptEncoding(accept) {
    var accepts2 = accept.split(",");
    var hasIdentity = false;
    var minQuality = 1;
    for (var i = 0, j = 0; i < accepts2.length; i++) {
      var encoding2 = parseEncoding(accepts2[i].trim(), i);
      if (encoding2) {
        accepts2[j++] = encoding2;
        hasIdentity = hasIdentity || specify("identity", encoding2);
        minQuality = Math.min(minQuality, encoding2.q || 1);
      }
    }
    if (!hasIdentity) {
      accepts2[j++] = {
        encoding: "identity",
        q: minQuality,
        i
      };
    }
    accepts2.length = j;
    return accepts2;
  }
  function parseEncoding(str, i) {
    var match = simpleEncodingRegExp.exec(str);
    if (!match) return null;
    var encoding2 = match[1];
    var q = 1;
    if (match[2]) {
      var params = match[2].split(";");
      for (var j = 0; j < params.length; j++) {
        var p = params[j].trim().split("=");
        if (p[0] === "q") {
          q = parseFloat(p[1]);
          break;
        }
      }
    }
    return {
      encoding: encoding2,
      q,
      i
    };
  }
  function getEncodingPriority(encoding2, accepted, index2) {
    var priority = { encoding: encoding2, o: -1, q: 0, s: 0 };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(encoding2, accepted[i], index2);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(encoding2, spec, index2) {
    var s = 0;
    if (spec.encoding.toLowerCase() === encoding2.toLowerCase()) {
      s |= 1;
    } else if (spec.encoding !== "*") {
      return null;
    }
    return {
      encoding: encoding2,
      i: index2,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredEncodings(accept, provided, preferred) {
    var accepts2 = parseAcceptEncoding(accept || "");
    var comparator2 = preferred ? function comparator3(a, b) {
      if (a.q !== b.q) {
        return b.q - a.q;
      }
      var aPreferred = preferred.indexOf(a.encoding);
      var bPreferred = preferred.indexOf(b.encoding);
      if (aPreferred === -1 && bPreferred === -1) {
        return b.s - a.s || a.o - b.o || a.i - b.i;
      }
      if (aPreferred !== -1 && bPreferred !== -1) {
        return aPreferred - bPreferred;
      }
      return aPreferred === -1 ? 1 : -1;
    } : compareSpecs;
    if (!provided) {
      return accepts2.filter(isQuality).sort(comparator2).map(getFullEncoding);
    }
    var priorities = provided.map(function getPriority(type2, index2) {
      return getEncodingPriority(type2, accepts2, index2);
    });
    return priorities.filter(isQuality).sort(comparator2).map(function getEncoding(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i;
  }
  function getFullEncoding(spec) {
    return spec.encoding;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  return encoding.exports;
}
var language = { exports: {} };
var hasRequiredLanguage;
function requireLanguage() {
  if (hasRequiredLanguage) return language.exports;
  hasRequiredLanguage = 1;
  language.exports = preferredLanguages;
  language.exports.preferredLanguages = preferredLanguages;
  var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
  function parseAcceptLanguage(accept) {
    var accepts2 = accept.split(",");
    for (var i = 0, j = 0; i < accepts2.length; i++) {
      var language2 = parseLanguage(accepts2[i].trim(), i);
      if (language2) {
        accepts2[j++] = language2;
      }
    }
    accepts2.length = j;
    return accepts2;
  }
  function parseLanguage(str, i) {
    var match = simpleLanguageRegExp.exec(str);
    if (!match) return null;
    var prefix = match[1];
    var suffix = match[2];
    var full = prefix;
    if (suffix) full += "-" + suffix;
    var q = 1;
    if (match[3]) {
      var params = match[3].split(";");
      for (var j = 0; j < params.length; j++) {
        var p = params[j].split("=");
        if (p[0] === "q") q = parseFloat(p[1]);
      }
    }
    return {
      prefix,
      suffix,
      q,
      i,
      full
    };
  }
  function getLanguagePriority(language2, accepted, index2) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(language2, accepted[i], index2);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(language2, spec, index2) {
    var p = parseLanguage(language2);
    if (!p) return null;
    var s = 0;
    if (spec.full.toLowerCase() === p.full.toLowerCase()) {
      s |= 4;
    } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
      s |= 2;
    } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
      s |= 1;
    } else if (spec.full !== "*") {
      return null;
    }
    return {
      i: index2,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredLanguages(accept, provided) {
    var accepts2 = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
    if (!provided) {
      return accepts2.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
    }
    var priorities = provided.map(function getPriority(type2, index2) {
      return getLanguagePriority(type2, accepts2, index2);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullLanguage(spec) {
    return spec.full;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  return language.exports;
}
var mediaType = { exports: {} };
var hasRequiredMediaType;
function requireMediaType() {
  if (hasRequiredMediaType) return mediaType.exports;
  hasRequiredMediaType = 1;
  mediaType.exports = preferredMediaTypes;
  mediaType.exports.preferredMediaTypes = preferredMediaTypes;
  var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
  function parseAccept(accept) {
    var accepts2 = splitMediaTypes(accept);
    for (var i = 0, j = 0; i < accepts2.length; i++) {
      var mediaType2 = parseMediaType(accepts2[i].trim(), i);
      if (mediaType2) {
        accepts2[j++] = mediaType2;
      }
    }
    accepts2.length = j;
    return accepts2;
  }
  function parseMediaType(str, i) {
    var match = simpleMediaTypeRegExp.exec(str);
    if (!match) return null;
    var params = /* @__PURE__ */ Object.create(null);
    var q = 1;
    var subtype = match[2];
    var type2 = match[1];
    if (match[3]) {
      var kvps = splitParameters(match[3]).map(splitKeyValuePair);
      for (var j = 0; j < kvps.length; j++) {
        var pair = kvps[j];
        var key2 = pair[0].toLowerCase();
        var val = pair[1];
        var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.slice(1, -1) : val;
        if (key2 === "q") {
          q = parseFloat(value);
          break;
        }
        params[key2] = value;
      }
    }
    return {
      type: type2,
      subtype,
      params,
      q,
      i
    };
  }
  function getMediaTypePriority(type2, accepted, index2) {
    var priority = { o: -1, q: 0, s: 0 };
    for (var i = 0; i < accepted.length; i++) {
      var spec = specify(type2, accepted[i], index2);
      if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
        priority = spec;
      }
    }
    return priority;
  }
  function specify(type2, spec, index2) {
    var p = parseMediaType(type2);
    var s = 0;
    if (!p) {
      return null;
    }
    if (spec.type.toLowerCase() == p.type.toLowerCase()) {
      s |= 4;
    } else if (spec.type != "*") {
      return null;
    }
    if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
      s |= 2;
    } else if (spec.subtype != "*") {
      return null;
    }
    var keys = Object.keys(spec.params);
    if (keys.length > 0) {
      if (keys.every(function(k) {
        return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
      })) {
        s |= 1;
      } else {
        return null;
      }
    }
    return {
      i: index2,
      o: spec.i,
      q: spec.q,
      s
    };
  }
  function preferredMediaTypes(accept, provided) {
    var accepts2 = parseAccept(accept === void 0 ? "*/*" : accept || "");
    if (!provided) {
      return accepts2.filter(isQuality).sort(compareSpecs).map(getFullType);
    }
    var priorities = provided.map(function getPriority(type2, index2) {
      return getMediaTypePriority(type2, accepts2, index2);
    });
    return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
      return provided[priorities.indexOf(priority)];
    });
  }
  function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
  }
  function getFullType(spec) {
    return spec.type + "/" + spec.subtype;
  }
  function isQuality(spec) {
    return spec.q > 0;
  }
  function quoteCount(string2) {
    var count = 0;
    var index2 = 0;
    while ((index2 = string2.indexOf('"', index2)) !== -1) {
      count++;
      index2++;
    }
    return count;
  }
  function splitKeyValuePair(str) {
    var index2 = str.indexOf("=");
    var key2;
    var val;
    if (index2 === -1) {
      key2 = str;
    } else {
      key2 = str.slice(0, index2);
      val = str.slice(index2 + 1);
    }
    return [key2, val];
  }
  function splitMediaTypes(accept) {
    var accepts2 = accept.split(",");
    for (var i = 1, j = 0; i < accepts2.length; i++) {
      if (quoteCount(accepts2[j]) % 2 == 0) {
        accepts2[++j] = accepts2[i];
      } else {
        accepts2[j] += "," + accepts2[i];
      }
    }
    accepts2.length = j + 1;
    return accepts2;
  }
  function splitParameters(str) {
    var parameters = str.split(";");
    for (var i = 1, j = 0; i < parameters.length; i++) {
      if (quoteCount(parameters[j]) % 2 == 0) {
        parameters[++j] = parameters[i];
      } else {
        parameters[j] += ";" + parameters[i];
      }
    }
    parameters.length = j + 1;
    for (var i = 0; i < parameters.length; i++) {
      parameters[i] = parameters[i].trim();
    }
    return parameters;
  }
  return mediaType.exports;
}
var hasRequiredNegotiator;
function requireNegotiator() {
  if (hasRequiredNegotiator) return negotiator.exports;
  hasRequiredNegotiator = 1;
  var preferredCharsets = requireCharset();
  var preferredEncodings = requireEncoding();
  var preferredLanguages = requireLanguage();
  var preferredMediaTypes = requireMediaType();
  negotiator.exports = Negotiator;
  negotiator.exports.Negotiator = Negotiator;
  function Negotiator(request2) {
    if (!(this instanceof Negotiator)) {
      return new Negotiator(request2);
    }
    this.request = request2;
  }
  Negotiator.prototype.charset = function charset2(available) {
    var set2 = this.charsets(available);
    return set2 && set2[0];
  };
  Negotiator.prototype.charsets = function charsets(available) {
    return preferredCharsets(this.request.headers["accept-charset"], available);
  };
  Negotiator.prototype.encoding = function encoding2(available, opts) {
    var set2 = this.encodings(available, opts);
    return set2 && set2[0];
  };
  Negotiator.prototype.encodings = function encodings2(available, options) {
    var opts = options || {};
    return preferredEncodings(this.request.headers["accept-encoding"], available, opts.preferred);
  };
  Negotiator.prototype.language = function language2(available) {
    var set2 = this.languages(available);
    return set2 && set2[0];
  };
  Negotiator.prototype.languages = function languages(available) {
    return preferredLanguages(this.request.headers["accept-language"], available);
  };
  Negotiator.prototype.mediaType = function mediaType2(available) {
    var set2 = this.mediaTypes(available);
    return set2 && set2[0];
  };
  Negotiator.prototype.mediaTypes = function mediaTypes(available) {
    return preferredMediaTypes(this.request.headers.accept, available);
  };
  Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
  Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
  Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
  Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
  Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
  Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
  Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
  Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
  return negotiator.exports;
}
var accepts;
var hasRequiredAccepts;
function requireAccepts() {
  if (hasRequiredAccepts) return accepts;
  hasRequiredAccepts = 1;
  var Negotiator = requireNegotiator();
  var mime = requireMimeTypes$1();
  accepts = Accepts;
  function Accepts(req) {
    if (!(this instanceof Accepts)) {
      return new Accepts(req);
    }
    this.headers = req.headers;
    this.negotiator = new Negotiator(req);
  }
  Accepts.prototype.type = Accepts.prototype.types = function(types_) {
    var types2 = types_;
    if (types2 && !Array.isArray(types2)) {
      types2 = new Array(arguments.length);
      for (var i = 0; i < types2.length; i++) {
        types2[i] = arguments[i];
      }
    }
    if (!types2 || types2.length === 0) {
      return this.negotiator.mediaTypes();
    }
    if (!this.headers.accept) {
      return types2[0];
    }
    var mimes = types2.map(extToMime);
    var accepts2 = this.negotiator.mediaTypes(mimes.filter(validMime));
    var first = accepts2[0];
    return first ? types2[mimes.indexOf(first)] : false;
  };
  Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
    var encodings2 = encodings_;
    if (encodings2 && !Array.isArray(encodings2)) {
      encodings2 = new Array(arguments.length);
      for (var i = 0; i < encodings2.length; i++) {
        encodings2[i] = arguments[i];
      }
    }
    if (!encodings2 || encodings2.length === 0) {
      return this.negotiator.encodings();
    }
    return this.negotiator.encodings(encodings2)[0] || false;
  };
  Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
    var charsets = charsets_;
    if (charsets && !Array.isArray(charsets)) {
      charsets = new Array(arguments.length);
      for (var i = 0; i < charsets.length; i++) {
        charsets[i] = arguments[i];
      }
    }
    if (!charsets || charsets.length === 0) {
      return this.negotiator.charsets();
    }
    return this.negotiator.charsets(charsets)[0] || false;
  };
  Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
    var languages = languages_;
    if (languages && !Array.isArray(languages)) {
      languages = new Array(arguments.length);
      for (var i = 0; i < languages.length; i++) {
        languages[i] = arguments[i];
      }
    }
    if (!languages || languages.length === 0) {
      return this.negotiator.languages();
    }
    return this.negotiator.languages(languages)[0] || false;
  };
  function extToMime(type2) {
    return type2.indexOf("/") === -1 ? mime.lookup(type2) : type2;
  }
  function validMime(type2) {
    return typeof type2 === "string";
  }
  return accepts;
}
var fresh_1;
var hasRequiredFresh;
function requireFresh() {
  if (hasRequiredFresh) return fresh_1;
  hasRequiredFresh = 1;
  var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
  fresh_1 = fresh;
  function fresh(reqHeaders, resHeaders) {
    var modifiedSince = reqHeaders["if-modified-since"];
    var noneMatch = reqHeaders["if-none-match"];
    if (!modifiedSince && !noneMatch) {
      return false;
    }
    var cacheControl = reqHeaders["cache-control"];
    if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
      return false;
    }
    if (noneMatch) {
      if (noneMatch === "*") {
        return true;
      }
      var etag = resHeaders.etag;
      if (!etag) {
        return false;
      }
      var matches = parseTokenList(noneMatch);
      for (var i = 0; i < matches.length; i++) {
        var match = matches[i];
        if (match === etag || match === "W/" + etag || "W/" + match === etag) {
          return true;
        }
      }
      return false;
    }
    if (modifiedSince) {
      var lastModified = resHeaders["last-modified"];
      var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));
      if (modifiedStale) {
        return false;
      }
    }
    return true;
  }
  function parseHttpDate(date2) {
    var timestamp = date2 && Date.parse(date2);
    return typeof timestamp === "number" ? timestamp : NaN;
  }
  function parseTokenList(str) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = str.length; i < len; i++) {
      switch (str.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          list.push(str.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    list.push(str.substring(start, end));
    return list;
  }
  return fresh_1;
}
var rangeParser_1;
var hasRequiredRangeParser;
function requireRangeParser() {
  if (hasRequiredRangeParser) return rangeParser_1;
  hasRequiredRangeParser = 1;
  rangeParser_1 = rangeParser;
  function rangeParser(size, str, options) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var index2 = str.indexOf("=");
    if (index2 === -1) {
      return -2;
    }
    var arr = str.slice(index2 + 1).split(",");
    var ranges = [];
    ranges.type = str.slice(0, index2);
    for (var i = 0; i < arr.length; i++) {
      var range2 = arr[i].split("-");
      var start = parseInt(range2[0], 10);
      var end = parseInt(range2[1], 10);
      if (isNaN(start)) {
        start = size - end;
        end = size - 1;
      } else if (isNaN(end)) {
        end = size - 1;
      }
      if (end > size - 1) {
        end = size - 1;
      }
      if (isNaN(start) || isNaN(end) || start > end || start < 0) {
        continue;
      }
      ranges.push({
        start,
        end
      });
    }
    if (ranges.length < 1) {
      return -1;
    }
    return options && options.combine ? combineRanges(ranges) : ranges;
  }
  function combineRanges(ranges) {
    var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
    for (var j = 0, i = 1; i < ordered.length; i++) {
      var range2 = ordered[i];
      var current = ordered[j];
      if (range2.start > current.end + 1) {
        ordered[++j] = range2;
      } else if (range2.end > current.end) {
        current.end = range2.end;
        current.index = Math.min(current.index, range2.index);
      }
    }
    ordered.length = j + 1;
    var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
    combined.type = ranges.type;
    return combined;
  }
  function mapWithIndex(range2, index2) {
    return {
      start: range2.start,
      end: range2.end,
      index: index2
    };
  }
  function mapWithoutIndex(range2) {
    return {
      start: range2.start,
      end: range2.end
    };
  }
  function sortByRangeIndex(a, b) {
    return a.index - b.index;
  }
  function sortByRangeStart(a, b) {
    return a.start - b.start;
  }
  return rangeParser_1;
}
var request;
var hasRequiredRequest;
function requireRequest() {
  if (hasRequiredRequest) return request;
  hasRequiredRequest = 1;
  var accepts2 = requireAccepts();
  var isIP = require$$1$4.isIP;
  var typeis = requireTypeIs$1();
  var http = require$$2$2;
  var fresh = requireFresh();
  var parseRange = requireRangeParser();
  var parse3 = requireParseurl();
  var proxyaddr = requireProxyAddr();
  var req = Object.create(http.IncomingMessage.prototype);
  request = req;
  req.get = req.header = function header(name) {
    if (!name) {
      throw new TypeError("name argument is required to req.get");
    }
    if (typeof name !== "string") {
      throw new TypeError("name must be a string to req.get");
    }
    var lc = name.toLowerCase();
    switch (lc) {
      case "referer":
      case "referrer":
        return this.headers.referrer || this.headers.referer;
      default:
        return this.headers[lc];
    }
  };
  req.accepts = function() {
    var accept = accepts2(this);
    return accept.types.apply(accept, arguments);
  };
  req.acceptsEncodings = function() {
    var accept = accepts2(this);
    return accept.encodings.apply(accept, arguments);
  };
  req.acceptsCharsets = function() {
    var accept = accepts2(this);
    return accept.charsets.apply(accept, arguments);
  };
  req.acceptsLanguages = function(...languages) {
    return accepts2(this).languages(...languages);
  };
  req.range = function range2(size, options) {
    var range3 = this.get("Range");
    if (!range3) return;
    return parseRange(size, range3, options);
  };
  defineGetter(req, "query", function query() {
    var queryparse = this.app.get("query parser fn");
    if (!queryparse) {
      return /* @__PURE__ */ Object.create(null);
    }
    var querystring = parse3(this).query;
    return queryparse(querystring);
  });
  req.is = function is2(types2) {
    var arr = types2;
    if (!Array.isArray(types2)) {
      arr = new Array(arguments.length);
      for (var i = 0; i < arr.length; i++) {
        arr[i] = arguments[i];
      }
    }
    return typeis(this, arr);
  };
  defineGetter(req, "protocol", function protocol() {
    var proto = this.socket.encrypted ? "https" : "http";
    var trust = this.app.get("trust proxy fn");
    if (!trust(this.socket.remoteAddress, 0)) {
      return proto;
    }
    var header = this.get("X-Forwarded-Proto") || proto;
    var index2 = header.indexOf(",");
    return index2 !== -1 ? header.substring(0, index2).trim() : header.trim();
  });
  defineGetter(req, "secure", function secure() {
    return this.protocol === "https";
  });
  defineGetter(req, "ip", function ip() {
    var trust = this.app.get("trust proxy fn");
    return proxyaddr(this, trust);
  });
  defineGetter(req, "ips", function ips() {
    var trust = this.app.get("trust proxy fn");
    var addrs = proxyaddr.all(this, trust);
    addrs.reverse().pop();
    return addrs;
  });
  defineGetter(req, "subdomains", function subdomains() {
    var hostname2 = this.hostname;
    if (!hostname2) return [];
    var offset = this.app.get("subdomain offset");
    var subdomains2 = !isIP(hostname2) ? hostname2.split(".").reverse() : [hostname2];
    return subdomains2.slice(offset);
  });
  defineGetter(req, "path", function path2() {
    return parse3(this).pathname;
  });
  defineGetter(req, "host", function host() {
    var trust = this.app.get("trust proxy fn");
    var val = this.get("X-Forwarded-Host");
    if (!val || !trust(this.socket.remoteAddress, 0)) {
      val = this.get("Host");
    } else if (val.indexOf(",") !== -1) {
      val = val.substring(0, val.indexOf(",")).trimRight();
    }
    return val || void 0;
  });
  defineGetter(req, "hostname", function hostname2() {
    var host = this.host;
    if (!host) return;
    var offset = host[0] === "[" ? host.indexOf("]") + 1 : 0;
    var index2 = host.indexOf(":", offset);
    return index2 !== -1 ? host.substring(0, index2) : host;
  });
  defineGetter(req, "fresh", function() {
    var method = this.method;
    var res = this.res;
    var status = res.statusCode;
    if ("GET" !== method && "HEAD" !== method) return false;
    if (status >= 200 && status < 300 || 304 === status) {
      return fresh(this.headers, {
        "etag": res.get("ETag"),
        "last-modified": res.get("Last-Modified")
      });
    }
    return false;
  });
  defineGetter(req, "stale", function stale() {
    return !this.fresh;
  });
  defineGetter(req, "xhr", function xhr() {
    var val = this.get("X-Requested-With") || "";
    return val.toLowerCase() === "xmlhttprequest";
  });
  function defineGetter(obj, name, getter) {
    Object.defineProperty(obj, name, {
      configurable: true,
      enumerable: true,
      get: getter
    });
  }
  return request;
}
var contentDisposition = { exports: {} };
var hasRequiredContentDisposition;
function requireContentDisposition() {
  if (hasRequiredContentDisposition) return contentDisposition.exports;
  hasRequiredContentDisposition = 1;
  contentDisposition.exports = contentDisposition$1;
  contentDisposition.exports.parse = parse3;
  var basename = path$1.basename;
  var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
  var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
  var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
  var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
  var QESC_REGEXP = /\\([\u0000-\u007f])/g;
  var QUOTE_REGEXP = /([\\"])/g;
  var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
  var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
  var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
  var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
  var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
  function contentDisposition$1(filename, options) {
    var opts = options || {};
    var type2 = opts.type || "attachment";
    var params = createparams(filename, opts.fallback);
    return format(new ContentDisposition(type2, params));
  }
  function createparams(filename, fallback) {
    if (filename === void 0) {
      return;
    }
    var params = {};
    if (typeof filename !== "string") {
      throw new TypeError("filename must be a string");
    }
    if (fallback === void 0) {
      fallback = true;
    }
    if (typeof fallback !== "string" && typeof fallback !== "boolean") {
      throw new TypeError("fallback must be a string or boolean");
    }
    if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
      throw new TypeError("fallback must be ISO-8859-1 string");
    }
    var name = basename(filename);
    var isQuotedString = TEXT_REGEXP.test(name);
    var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name) : basename(fallback);
    var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
    if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
      params["filename*"] = name;
    }
    if (isQuotedString || hasFallback) {
      params.filename = hasFallback ? fallbackName : name;
    }
    return params;
  }
  function format(obj) {
    var parameters = obj.parameters;
    var type2 = obj.type;
    if (!type2 || typeof type2 !== "string" || !TOKEN_REGEXP.test(type2)) {
      throw new TypeError("invalid type");
    }
    var string2 = String(type2).toLowerCase();
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0; i < params.length; i++) {
        param = params[i];
        var val = param.slice(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
        string2 += "; " + param + "=" + val;
      }
    }
    return string2;
  }
  function decodefield(str) {
    var match = EXT_VALUE_REGEXP.exec(str);
    if (!match) {
      throw new TypeError("invalid extended field value");
    }
    var charset2 = match[1].toLowerCase();
    var encoded = match[2];
    var value;
    var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
    switch (charset2) {
      case "iso-8859-1":
        value = getlatin1(binary);
        break;
      case "utf-8":
      case "utf8":
        value = Buffer.from(binary, "binary").toString("utf8");
        break;
      default:
        throw new TypeError("unsupported charset in extended field");
    }
    return value;
  }
  function getlatin1(val) {
    return String(val).replace(NON_LATIN1_REGEXP, "?");
  }
  function parse3(string2) {
    if (!string2 || typeof string2 !== "string") {
      throw new TypeError("argument string is required");
    }
    var match = DISPOSITION_TYPE_REGEXP.exec(string2);
    if (!match) {
      throw new TypeError("invalid type format");
    }
    var index2 = match[0].length;
    var type2 = match[1].toLowerCase();
    var key2;
    var names = [];
    var params = {};
    var value;
    index2 = PARAM_REGEXP.lastIndex = match[0].slice(-1) === ";" ? index2 - 1 : index2;
    while (match = PARAM_REGEXP.exec(string2)) {
      if (match.index !== index2) {
        throw new TypeError("invalid parameter format");
      }
      index2 += match[0].length;
      key2 = match[1].toLowerCase();
      value = match[2];
      if (names.indexOf(key2) !== -1) {
        throw new TypeError("invalid duplicate parameter");
      }
      names.push(key2);
      if (key2.indexOf("*") + 1 === key2.length) {
        key2 = key2.slice(0, -1);
        value = decodefield(value);
        params[key2] = value;
        continue;
      }
      if (typeof params[key2] === "string") {
        continue;
      }
      if (value[0] === '"') {
        value = value.slice(1, -1).replace(QESC_REGEXP, "$1");
      }
      params[key2] = value;
    }
    if (index2 !== -1 && index2 !== string2.length) {
      throw new TypeError("invalid parameter format");
    }
    return new ContentDisposition(type2, params);
  }
  function pdecode(str, hex2) {
    return String.fromCharCode(parseInt(hex2, 16));
  }
  function pencode(char) {
    return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
  }
  function qstring(val) {
    var str = String(val);
    return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
  }
  function ustring(val) {
    var str = String(val);
    var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
    return "UTF-8''" + encoded;
  }
  function ContentDisposition(type2, parameters) {
    this.type = type2;
    this.parameters = parameters;
  }
  return contentDisposition.exports;
}
var cookieSignature = {};
var hasRequiredCookieSignature;
function requireCookieSignature() {
  if (hasRequiredCookieSignature) return cookieSignature;
  hasRequiredCookieSignature = 1;
  (function(exports$1) {
    var crypto2 = require$$0$b;
    exports$1.sign = function(val, secret) {
      if ("string" != typeof val) throw new TypeError("Cookie value must be provided as a string.");
      if (null == secret) throw new TypeError("Secret key must be provided.");
      return val + "." + crypto2.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
    };
    exports$1.unsign = function(input, secret) {
      if ("string" != typeof input) throw new TypeError("Signed cookie string must be provided.");
      if (null == secret) throw new TypeError("Secret key must be provided.");
      var tentativeValue = input.slice(0, input.lastIndexOf(".")), expectedInput = exports$1.sign(tentativeValue, secret), expectedBuffer = Buffer.from(expectedInput), inputBuffer = Buffer.from(input);
      return expectedBuffer.length === inputBuffer.length && crypto2.timingSafeEqual(expectedBuffer, inputBuffer) ? tentativeValue : false;
    };
  })(cookieSignature);
  return cookieSignature;
}
var cookie = {};
var hasRequiredCookie;
function requireCookie() {
  if (hasRequiredCookie) return cookie;
  hasRequiredCookie = 1;
  cookie.parse = parse3;
  cookie.serialize = serialize;
  var __toString = Object.prototype.toString;
  var __hasOwnProperty = Object.prototype.hasOwnProperty;
  var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
  var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;
  var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
  var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
  function parse3(str, opt) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var obj = {};
    var len = str.length;
    if (len < 2) return obj;
    var dec = opt && opt.decode || decode2;
    var index2 = 0;
    var eqIdx = 0;
    var endIdx = 0;
    do {
      eqIdx = str.indexOf("=", index2);
      if (eqIdx === -1) break;
      endIdx = str.indexOf(";", index2);
      if (endIdx === -1) {
        endIdx = len;
      } else if (eqIdx > endIdx) {
        index2 = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      var keyStartIdx = startIndex(str, index2, eqIdx);
      var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
      var key2 = str.slice(keyStartIdx, keyEndIdx);
      if (!__hasOwnProperty.call(obj, key2)) {
        var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
        var valEndIdx = endIndex(str, endIdx, valStartIdx);
        if (str.charCodeAt(valStartIdx) === 34 && str.charCodeAt(valEndIdx - 1) === 34) {
          valStartIdx++;
          valEndIdx--;
        }
        var val = str.slice(valStartIdx, valEndIdx);
        obj[key2] = tryDecode(val, dec);
      }
      index2 = endIdx + 1;
    } while (index2 < len);
    return obj;
  }
  function startIndex(str, index2, max2) {
    do {
      var code = str.charCodeAt(index2);
      if (code !== 32 && code !== 9) return index2;
    } while (++index2 < max2);
    return max2;
  }
  function endIndex(str, index2, min2) {
    while (index2 > min2) {
      var code = str.charCodeAt(--index2);
      if (code !== 32 && code !== 9) return index2 + 1;
    }
    return min2;
  }
  function serialize(name, val, opt) {
    var enc = opt && opt.encode || encodeURIComponent;
    if (typeof enc !== "function") {
      throw new TypeError("option encode is invalid");
    }
    if (!cookieNameRegExp.test(name)) {
      throw new TypeError("argument name is invalid");
    }
    var value = enc(val);
    if (!cookieValueRegExp.test(value)) {
      throw new TypeError("argument val is invalid");
    }
    var str = name + "=" + value;
    if (!opt) return str;
    if (null != opt.maxAge) {
      var maxAge = Math.floor(opt.maxAge);
      if (!isFinite(maxAge)) {
        throw new TypeError("option maxAge is invalid");
      }
      str += "; Max-Age=" + maxAge;
    }
    if (opt.domain) {
      if (!domainValueRegExp.test(opt.domain)) {
        throw new TypeError("option domain is invalid");
      }
      str += "; Domain=" + opt.domain;
    }
    if (opt.path) {
      if (!pathValueRegExp.test(opt.path)) {
        throw new TypeError("option path is invalid");
      }
      str += "; Path=" + opt.path;
    }
    if (opt.expires) {
      var expires = opt.expires;
      if (!isDate(expires) || isNaN(expires.valueOf())) {
        throw new TypeError("option expires is invalid");
      }
      str += "; Expires=" + expires.toUTCString();
    }
    if (opt.httpOnly) {
      str += "; HttpOnly";
    }
    if (opt.secure) {
      str += "; Secure";
    }
    if (opt.partitioned) {
      str += "; Partitioned";
    }
    if (opt.priority) {
      var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError("option priority is invalid");
      }
    }
    if (opt.sameSite) {
      var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
      switch (sameSite) {
        case true:
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError("option sameSite is invalid");
      }
    }
    return str;
  }
  function decode2(str) {
    return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
  }
  function isDate(val) {
    return __toString.call(val) === "[object Date]";
  }
  function tryDecode(str, decode3) {
    try {
      return decode3(str);
    } catch (e) {
      return str;
    }
  }
  return cookie;
}
var send_1;
var hasRequiredSend;
function requireSend() {
  if (hasRequiredSend) return send_1;
  hasRequiredSend = 1;
  var createError = requireHttpErrors();
  var debug = require$$0$9("send");
  var encodeUrl = requireEncodeurl();
  var escapeHtml = requireEscapeHtml();
  var etag = requireEtag();
  var fresh = requireFresh();
  var fs2 = require$$0$4;
  var mime = requireMimeTypes$1();
  var ms2 = require$$8;
  var onFinished2 = requireOnFinished();
  var parseRange = requireRangeParser();
  var path2 = path$1;
  var statuses2 = requireStatuses();
  var Stream = require$$0$6;
  var util2 = require$$1$2;
  var extname = path2.extname;
  var join = path2.join;
  var normalize = path2.normalize;
  var resolve2 = path2.resolve;
  var sep = path2.sep;
  var BYTES_RANGE_REGEXP = /^ *bytes=/;
  var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1e3;
  var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
  send_1 = send;
  function send(req, path3, options) {
    return new SendStream(req, path3, options);
  }
  function SendStream(req, path3, options) {
    Stream.call(this);
    var opts = options || {};
    this.options = opts;
    this.path = path3;
    this.req = req;
    this._acceptRanges = opts.acceptRanges !== void 0 ? Boolean(opts.acceptRanges) : true;
    this._cacheControl = opts.cacheControl !== void 0 ? Boolean(opts.cacheControl) : true;
    this._etag = opts.etag !== void 0 ? Boolean(opts.etag) : true;
    this._dotfiles = opts.dotfiles !== void 0 ? opts.dotfiles : "ignore";
    if (this._dotfiles !== "ignore" && this._dotfiles !== "allow" && this._dotfiles !== "deny") {
      throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
    }
    this._extensions = opts.extensions !== void 0 ? normalizeList(opts.extensions, "extensions option") : [];
    this._immutable = opts.immutable !== void 0 ? Boolean(opts.immutable) : false;
    this._index = opts.index !== void 0 ? normalizeList(opts.index, "index option") : ["index.html"];
    this._lastModified = opts.lastModified !== void 0 ? Boolean(opts.lastModified) : true;
    this._maxage = opts.maxAge || opts.maxage;
    this._maxage = typeof this._maxage === "string" ? ms2(this._maxage) : Number(this._maxage);
    this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
    this._root = opts.root ? resolve2(opts.root) : null;
  }
  util2.inherits(SendStream, Stream);
  SendStream.prototype.error = function error2(status, err) {
    if (hasListeners(this, "error")) {
      return this.emit("error", createHttpError(status, err));
    }
    var res = this.res;
    var msg = statuses2.message[status] || String(status);
    var doc = createHtmlDocument("Error", escapeHtml(msg));
    clearHeaders(res);
    if (err && err.headers) {
      setHeaders(res, err.headers);
    }
    res.statusCode = status;
    res.setHeader("Content-Type", "text/html; charset=UTF-8");
    res.setHeader("Content-Length", Buffer.byteLength(doc));
    res.setHeader("Content-Security-Policy", "default-src 'none'");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.end(doc);
  };
  SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
    return this.path[this.path.length - 1] === "/";
  };
  SendStream.prototype.isConditionalGET = function isConditionalGET() {
    return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
  };
  SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
    var req = this.req;
    var res = this.res;
    var match = req.headers["if-match"];
    if (match) {
      var etag2 = res.getHeader("ETag");
      return !etag2 || match !== "*" && parseTokenList(match).every(function(match2) {
        return match2 !== etag2 && match2 !== "W/" + etag2 && "W/" + match2 !== etag2;
      });
    }
    var unmodifiedSince = parseHttpDate(req.headers["if-unmodified-since"]);
    if (!isNaN(unmodifiedSince)) {
      var lastModified = parseHttpDate(res.getHeader("Last-Modified"));
      return isNaN(lastModified) || lastModified > unmodifiedSince;
    }
    return false;
  };
  SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
    var res = this.res;
    res.removeHeader("Content-Encoding");
    res.removeHeader("Content-Language");
    res.removeHeader("Content-Length");
    res.removeHeader("Content-Range");
    res.removeHeader("Content-Type");
  };
  SendStream.prototype.notModified = function notModified() {
    var res = this.res;
    debug("not modified");
    this.removeContentHeaderFields();
    res.statusCode = 304;
    res.end();
  };
  SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
    var err = new Error("Can't set headers after they are sent.");
    debug("headers already sent");
    this.error(500, err);
  };
  SendStream.prototype.isCachable = function isCachable() {
    var statusCode = this.res.statusCode;
    return statusCode >= 200 && statusCode < 300 || statusCode === 304;
  };
  SendStream.prototype.onStatError = function onStatError(error2) {
    switch (error2.code) {
      case "ENAMETOOLONG":
      case "ENOENT":
      case "ENOTDIR":
        this.error(404, error2);
        break;
      default:
        this.error(500, error2);
        break;
    }
  };
  SendStream.prototype.isFresh = function isFresh() {
    return fresh(this.req.headers, {
      etag: this.res.getHeader("ETag"),
      "last-modified": this.res.getHeader("Last-Modified")
    });
  };
  SendStream.prototype.isRangeFresh = function isRangeFresh() {
    var ifRange = this.req.headers["if-range"];
    if (!ifRange) {
      return true;
    }
    if (ifRange.indexOf('"') !== -1) {
      var etag2 = this.res.getHeader("ETag");
      return Boolean(etag2 && ifRange.indexOf(etag2) !== -1);
    }
    var lastModified = this.res.getHeader("Last-Modified");
    return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
  };
  SendStream.prototype.redirect = function redirect(path3) {
    var res = this.res;
    if (hasListeners(this, "directory")) {
      this.emit("directory", res, path3);
      return;
    }
    if (this.hasTrailingSlash()) {
      this.error(403);
      return;
    }
    var loc = encodeUrl(collapseLeadingSlashes(this.path + "/"));
    var doc = createHtmlDocument("Redirecting", "Redirecting to " + escapeHtml(loc));
    res.statusCode = 301;
    res.setHeader("Content-Type", "text/html; charset=UTF-8");
    res.setHeader("Content-Length", Buffer.byteLength(doc));
    res.setHeader("Content-Security-Policy", "default-src 'none'");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.setHeader("Location", loc);
    res.end(doc);
  };
  SendStream.prototype.pipe = function pipe2(res) {
    var root2 = this._root;
    this.res = res;
    var path3 = decode2(this.path);
    if (path3 === -1) {
      this.error(400);
      return res;
    }
    if (~path3.indexOf("\0")) {
      this.error(400);
      return res;
    }
    var parts;
    if (root2 !== null) {
      if (path3) {
        path3 = normalize("." + sep + path3);
      }
      if (UP_PATH_REGEXP.test(path3)) {
        debug('malicious path "%s"', path3);
        this.error(403);
        return res;
      }
      parts = path3.split(sep);
      path3 = normalize(join(root2, path3));
    } else {
      if (UP_PATH_REGEXP.test(path3)) {
        debug('malicious path "%s"', path3);
        this.error(403);
        return res;
      }
      parts = normalize(path3).split(sep);
      path3 = resolve2(path3);
    }
    if (containsDotFile(parts)) {
      debug('%s dotfile "%s"', this._dotfiles, path3);
      switch (this._dotfiles) {
        case "allow":
          break;
        case "deny":
          this.error(403);
          return res;
        case "ignore":
        default:
          this.error(404);
          return res;
      }
    }
    if (this._index.length && this.hasTrailingSlash()) {
      this.sendIndex(path3);
      return res;
    }
    this.sendFile(path3);
    return res;
  };
  SendStream.prototype.send = function send2(path3, stat2) {
    var len = stat2.size;
    var options = this.options;
    var opts = {};
    var res = this.res;
    var req = this.req;
    var ranges = req.headers.range;
    var offset = options.start || 0;
    if (res.headersSent) {
      this.headersAlreadySent();
      return;
    }
    debug('pipe "%s"', path3);
    this.setHeader(path3, stat2);
    this.type(path3);
    if (this.isConditionalGET()) {
      if (this.isPreconditionFailure()) {
        this.error(412);
        return;
      }
      if (this.isCachable() && this.isFresh()) {
        this.notModified();
        return;
      }
    }
    len = Math.max(0, len - offset);
    if (options.end !== void 0) {
      var bytes2 = options.end - offset + 1;
      if (len > bytes2) len = bytes2;
    }
    if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
      ranges = parseRange(len, ranges, {
        combine: true
      });
      if (!this.isRangeFresh()) {
        debug("range stale");
        ranges = -2;
      }
      if (ranges === -1) {
        debug("range unsatisfiable");
        res.setHeader("Content-Range", contentRange("bytes", len));
        return this.error(416, {
          headers: { "Content-Range": res.getHeader("Content-Range") }
        });
      }
      if (ranges !== -2 && ranges.length === 1) {
        debug("range %j", ranges);
        res.statusCode = 206;
        res.setHeader("Content-Range", contentRange("bytes", len, ranges[0]));
        offset += ranges[0].start;
        len = ranges[0].end - ranges[0].start + 1;
      }
    }
    for (var prop in options) {
      opts[prop] = options[prop];
    }
    opts.start = offset;
    opts.end = Math.max(offset, offset + len - 1);
    res.setHeader("Content-Length", len);
    if (req.method === "HEAD") {
      res.end();
      return;
    }
    this.stream(path3, opts);
  };
  SendStream.prototype.sendFile = function sendFile(path3) {
    var i = 0;
    var self2 = this;
    debug('stat "%s"', path3);
    fs2.stat(path3, function onstat(err, stat2) {
      var pathEndsWithSep = path3[path3.length - 1] === sep;
      if (err && err.code === "ENOENT" && !extname(path3) && !pathEndsWithSep) {
        return next(err);
      }
      if (err) return self2.onStatError(err);
      if (stat2.isDirectory()) return self2.redirect(path3);
      if (pathEndsWithSep) return self2.error(404);
      self2.emit("file", path3, stat2);
      self2.send(path3, stat2);
    });
    function next(err) {
      if (self2._extensions.length <= i) {
        return err ? self2.onStatError(err) : self2.error(404);
      }
      var p = path3 + "." + self2._extensions[i++];
      debug('stat "%s"', p);
      fs2.stat(p, function(err2, stat2) {
        if (err2) return next(err2);
        if (stat2.isDirectory()) return next();
        self2.emit("file", p, stat2);
        self2.send(p, stat2);
      });
    }
  };
  SendStream.prototype.sendIndex = function sendIndex(path3) {
    var i = -1;
    var self2 = this;
    function next(err) {
      if (++i >= self2._index.length) {
        if (err) return self2.onStatError(err);
        return self2.error(404);
      }
      var p = join(path3, self2._index[i]);
      debug('stat "%s"', p);
      fs2.stat(p, function(err2, stat2) {
        if (err2) return next(err2);
        if (stat2.isDirectory()) return next();
        self2.emit("file", p, stat2);
        self2.send(p, stat2);
      });
    }
    next();
  };
  SendStream.prototype.stream = function stream(path3, options) {
    var self2 = this;
    var res = this.res;
    var stream2 = fs2.createReadStream(path3, options);
    this.emit("stream", stream2);
    stream2.pipe(res);
    function cleanup() {
      stream2.destroy();
    }
    onFinished2(res, cleanup);
    stream2.on("error", function onerror(err) {
      cleanup();
      self2.onStatError(err);
    });
    stream2.on("end", function onend() {
      self2.emit("end");
    });
  };
  SendStream.prototype.type = function type2(path3) {
    var res = this.res;
    if (res.getHeader("Content-Type")) return;
    var ext = extname(path3);
    var type3 = mime.contentType(ext) || "application/octet-stream";
    debug("content-type %s", type3);
    res.setHeader("Content-Type", type3);
  };
  SendStream.prototype.setHeader = function setHeader(path3, stat2) {
    var res = this.res;
    this.emit("headers", res, path3, stat2);
    if (this._acceptRanges && !res.getHeader("Accept-Ranges")) {
      debug("accept ranges");
      res.setHeader("Accept-Ranges", "bytes");
    }
    if (this._cacheControl && !res.getHeader("Cache-Control")) {
      var cacheControl = "public, max-age=" + Math.floor(this._maxage / 1e3);
      if (this._immutable) {
        cacheControl += ", immutable";
      }
      debug("cache-control %s", cacheControl);
      res.setHeader("Cache-Control", cacheControl);
    }
    if (this._lastModified && !res.getHeader("Last-Modified")) {
      var modified = stat2.mtime.toUTCString();
      debug("modified %s", modified);
      res.setHeader("Last-Modified", modified);
    }
    if (this._etag && !res.getHeader("ETag")) {
      var val = etag(stat2);
      debug("etag %s", val);
      res.setHeader("ETag", val);
    }
  };
  function clearHeaders(res) {
    for (const header of res.getHeaderNames()) {
      res.removeHeader(header);
    }
  }
  function collapseLeadingSlashes(str) {
    for (var i = 0; i < str.length; i++) {
      if (str[i] !== "/") {
        break;
      }
    }
    return i > 1 ? "/" + str.substr(i) : str;
  }
  function containsDotFile(parts) {
    for (var i = 0; i < parts.length; i++) {
      var part = parts[i];
      if (part.length > 1 && part[0] === ".") {
        return true;
      }
    }
    return false;
  }
  function contentRange(type2, size, range2) {
    return type2 + " " + (range2 ? range2.start + "-" + range2.end : "*") + "/" + size;
  }
  function createHtmlDocument(title, body) {
    return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
  }
  function createHttpError(status, err) {
    if (!err) {
      return createError(status);
    }
    return err instanceof Error ? createError(status, err, { expose: false }) : createError(status, err);
  }
  function decode2(path3) {
    try {
      return decodeURIComponent(path3);
    } catch (err) {
      return -1;
    }
  }
  function hasListeners(emitter, type2) {
    var count = typeof emitter.listenerCount !== "function" ? emitter.listeners(type2).length : emitter.listenerCount(type2);
    return count > 0;
  }
  function normalizeList(val, name) {
    var list = [].concat(val || []);
    for (var i = 0; i < list.length; i++) {
      if (typeof list[i] !== "string") {
        throw new TypeError(name + " must be array of strings or false");
      }
    }
    return list;
  }
  function parseHttpDate(date2) {
    var timestamp = date2 && Date.parse(date2);
    return typeof timestamp === "number" ? timestamp : NaN;
  }
  function parseTokenList(str) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = str.length; i < len; i++) {
      switch (str.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          if (start !== end) {
            list.push(str.substring(start, end));
          }
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    if (start !== end) {
      list.push(str.substring(start, end));
    }
    return list;
  }
  function setHeaders(res, headers) {
    var keys = Object.keys(headers);
    for (var i = 0; i < keys.length; i++) {
      var key2 = keys[i];
      res.setHeader(key2, headers[key2]);
    }
  }
  return send_1;
}
var response;
var hasRequiredResponse;
function requireResponse() {
  if (hasRequiredResponse) return response;
  hasRequiredResponse = 1;
  var contentDisposition2 = requireContentDisposition();
  var createError = requireHttpErrors();
  var deprecate = requireBrowser$1()("express");
  var encodeUrl = requireEncodeurl();
  var escapeHtml = requireEscapeHtml();
  var http = require$$2$2;
  var onFinished2 = requireOnFinished();
  var mime = requireMimeTypes$1();
  var path2 = path__default;
  var pathIsAbsolute = path__default.isAbsolute;
  var statuses2 = requireStatuses();
  var sign2 = requireCookieSignature().sign;
  var normalizeType = requireUtils$1().normalizeType;
  var normalizeTypes = requireUtils$1().normalizeTypes;
  var setCharset = requireUtils$1().setCharset;
  var cookie2 = requireCookie();
  var send = requireSend();
  var extname = path2.extname;
  var resolve2 = path2.resolve;
  var vary2 = requireVary();
  const { Buffer: Buffer2 } = require$$7$1;
  var res = Object.create(http.ServerResponse.prototype);
  response = res;
  res.status = function status(code) {
    if (!Number.isInteger(code)) {
      throw new TypeError(`Invalid status code: ${JSON.stringify(code)}. Status code must be an integer.`);
    }
    if (code < 100 || code > 999) {
      throw new RangeError(`Invalid status code: ${JSON.stringify(code)}. Status code must be greater than 99 and less than 1000.`);
    }
    this.statusCode = code;
    return this;
  };
  res.links = function(links) {
    var link = this.get("Link") || "";
    if (link) link += ", ";
    return this.set("Link", link + Object.keys(links).map(function(rel) {
      if (Array.isArray(links[rel])) {
        return links[rel].map(function(singleLink) {
          return `<${singleLink}>; rel="${rel}"`;
        }).join(", ");
      } else {
        return `<${links[rel]}>; rel="${rel}"`;
      }
    }).join(", "));
  };
  res.send = function send2(body) {
    var chunk = body;
    var encoding2;
    var req = this.req;
    var type2;
    var app = this.app;
    switch (typeof chunk) {
      // string defaulting to html
      case "string":
        if (!this.get("Content-Type")) {
          this.type("html");
        }
        break;
      case "boolean":
      case "number":
      case "object":
        if (chunk === null) {
          chunk = "";
        } else if (ArrayBuffer.isView(chunk)) {
          if (!this.get("Content-Type")) {
            this.type("bin");
          }
        } else {
          return this.json(chunk);
        }
        break;
    }
    if (typeof chunk === "string") {
      encoding2 = "utf8";
      type2 = this.get("Content-Type");
      if (typeof type2 === "string") {
        this.set("Content-Type", setCharset(type2, "utf-8"));
      }
    }
    var etagFn = app.get("etag fn");
    var generateETag = !this.get("ETag") && typeof etagFn === "function";
    var len;
    if (chunk !== void 0) {
      if (Buffer2.isBuffer(chunk)) {
        len = chunk.length;
      } else if (!generateETag && chunk.length < 1e3) {
        len = Buffer2.byteLength(chunk, encoding2);
      } else {
        chunk = Buffer2.from(chunk, encoding2);
        encoding2 = void 0;
        len = chunk.length;
      }
      this.set("Content-Length", len);
    }
    var etag;
    if (generateETag && len !== void 0) {
      if (etag = etagFn(chunk, encoding2)) {
        this.set("ETag", etag);
      }
    }
    if (req.fresh) this.status(304);
    if (204 === this.statusCode || 304 === this.statusCode) {
      this.removeHeader("Content-Type");
      this.removeHeader("Content-Length");
      this.removeHeader("Transfer-Encoding");
      chunk = "";
    }
    if (this.statusCode === 205) {
      this.set("Content-Length", "0");
      this.removeHeader("Transfer-Encoding");
      chunk = "";
    }
    if (req.method === "HEAD") {
      this.end();
    } else {
      this.end(chunk, encoding2);
    }
    return this;
  };
  res.json = function json2(obj) {
    var app = this.app;
    var escape2 = app.get("json escape");
    var replacer = app.get("json replacer");
    var spaces = app.get("json spaces");
    var body = stringify3(obj, replacer, spaces, escape2);
    if (!this.get("Content-Type")) {
      this.set("Content-Type", "application/json");
    }
    return this.send(body);
  };
  res.jsonp = function jsonp(obj) {
    var app = this.app;
    var escape2 = app.get("json escape");
    var replacer = app.get("json replacer");
    var spaces = app.get("json spaces");
    var body = stringify3(obj, replacer, spaces, escape2);
    var callback = this.req.query[app.get("jsonp callback name")];
    if (!this.get("Content-Type")) {
      this.set("X-Content-Type-Options", "nosniff");
      this.set("Content-Type", "application/json");
    }
    if (Array.isArray(callback)) {
      callback = callback[0];
    }
    if (typeof callback === "string" && callback.length !== 0) {
      this.set("X-Content-Type-Options", "nosniff");
      this.set("Content-Type", "text/javascript");
      callback = callback.replace(/[^\[\]\w$.]/g, "");
      if (body === void 0) {
        body = "";
      } else if (typeof body === "string") {
        body = body.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      }
      body = "/**/ typeof " + callback + " === 'function' && " + callback + "(" + body + ");";
    }
    return this.send(body);
  };
  res.sendStatus = function sendStatus(statusCode) {
    var body = statuses2.message[statusCode] || String(statusCode);
    this.status(statusCode);
    this.type("txt");
    return this.send(body);
  };
  res.sendFile = function sendFile(path3, options, callback) {
    var done = callback;
    var req = this.req;
    var res2 = this;
    var next = req.next;
    var opts = options || {};
    if (!path3) {
      throw new TypeError("path argument is required to res.sendFile");
    }
    if (typeof path3 !== "string") {
      throw new TypeError("path must be a string to res.sendFile");
    }
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    if (!opts.root && !pathIsAbsolute(path3)) {
      throw new TypeError("path must be absolute or specify root to res.sendFile");
    }
    var pathname = encodeURI(path3);
    opts.etag = this.app.enabled("etag");
    var file2 = send(req, pathname, opts);
    sendfile(res2, file2, opts, function(err) {
      if (done) return done(err);
      if (err && err.code === "EISDIR") return next();
      if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
        next(err);
      }
    });
  };
  res.download = function download2(path3, filename, options, callback) {
    var done = callback;
    var name = filename;
    var opts = options || null;
    if (typeof filename === "function") {
      done = filename;
      name = null;
      opts = null;
    } else if (typeof options === "function") {
      done = options;
      opts = null;
    }
    if (typeof filename === "object" && (typeof options === "function" || options === void 0)) {
      name = null;
      opts = filename;
    }
    var headers = {
      "Content-Disposition": contentDisposition2(name || path3)
    };
    if (opts && opts.headers) {
      var keys = Object.keys(opts.headers);
      for (var i = 0; i < keys.length; i++) {
        var key2 = keys[i];
        if (key2.toLowerCase() !== "content-disposition") {
          headers[key2] = opts.headers[key2];
        }
      }
    }
    opts = Object.create(opts);
    opts.headers = headers;
    var fullPath = !opts.root ? resolve2(path3) : path3;
    return this.sendFile(fullPath, opts, done);
  };
  res.contentType = res.type = function contentType2(type2) {
    var ct = type2.indexOf("/") === -1 ? mime.contentType(type2) || "application/octet-stream" : type2;
    return this.set("Content-Type", ct);
  };
  res.format = function(obj) {
    var req = this.req;
    var next = req.next;
    var keys = Object.keys(obj).filter(function(v) {
      return v !== "default";
    });
    var key2 = keys.length > 0 ? req.accepts(keys) : false;
    this.vary("Accept");
    if (key2) {
      this.set("Content-Type", normalizeType(key2).value);
      obj[key2](req, this, next);
    } else if (obj.default) {
      obj.default(req, this, next);
    } else {
      next(createError(406, {
        types: normalizeTypes(keys).map(function(o) {
          return o.value;
        })
      }));
    }
    return this;
  };
  res.attachment = function attachment(filename) {
    if (filename) {
      this.type(extname(filename));
    }
    this.set("Content-Disposition", contentDisposition2(filename));
    return this;
  };
  res.append = function append(field, val) {
    var prev = this.get(field);
    var value = val;
    if (prev) {
      value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
    }
    return this.set(field, value);
  };
  res.set = res.header = function header(field, val) {
    if (arguments.length === 2) {
      var value = Array.isArray(val) ? val.map(String) : String(val);
      if (field.toLowerCase() === "content-type") {
        if (Array.isArray(value)) {
          throw new TypeError("Content-Type cannot be set to an Array");
        }
        value = mime.contentType(value);
      }
      this.setHeader(field, value);
    } else {
      for (var key2 in field) {
        this.set(key2, field[key2]);
      }
    }
    return this;
  };
  res.get = function(field) {
    return this.getHeader(field);
  };
  res.clearCookie = function clearCookie(name, options) {
    const opts = { path: "/", ...options, expires: /* @__PURE__ */ new Date(1) };
    delete opts.maxAge;
    return this.cookie(name, "", opts);
  };
  res.cookie = function(name, value, options) {
    var opts = { ...options };
    var secret = this.req.secret;
    var signed = opts.signed;
    if (signed && !secret) {
      throw new Error('cookieParser("secret") required for signed cookies');
    }
    var val = typeof value === "object" ? "j:" + JSON.stringify(value) : String(value);
    if (signed) {
      val = "s:" + sign2(val, secret);
    }
    if (opts.maxAge != null) {
      var maxAge = opts.maxAge - 0;
      if (!isNaN(maxAge)) {
        opts.expires = new Date(Date.now() + maxAge);
        opts.maxAge = Math.floor(maxAge / 1e3);
      }
    }
    if (opts.path == null) {
      opts.path = "/";
    }
    this.append("Set-Cookie", cookie2.serialize(name, String(val), opts));
    return this;
  };
  res.location = function location(url2) {
    return this.set("Location", encodeUrl(url2));
  };
  res.redirect = function redirect(url2) {
    var address = url2;
    var body;
    var status = 302;
    if (arguments.length === 2) {
      status = arguments[0];
      address = arguments[1];
    }
    if (!address) {
      deprecate("Provide a url argument");
    }
    if (typeof address !== "string") {
      deprecate("Url must be a string");
    }
    if (typeof status !== "number") {
      deprecate("Status must be a number");
    }
    address = this.location(address).get("Location");
    this.format({
      text: function() {
        body = statuses2.message[status] + ". Redirecting to " + address;
      },
      html: function() {
        var u = escapeHtml(address);
        body = "<p>" + statuses2.message[status] + ". Redirecting to " + u + "</p>";
      },
      default: function() {
        body = "";
      }
    });
    this.status(status);
    this.set("Content-Length", Buffer2.byteLength(body));
    if (this.req.method === "HEAD") {
      this.end();
    } else {
      this.end(body);
    }
  };
  res.vary = function(field) {
    vary2(this, field);
    return this;
  };
  res.render = function render(view2, options, callback) {
    var app = this.req.app;
    var done = callback;
    var opts = options || {};
    var req = this.req;
    var self2 = this;
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    opts._locals = self2.locals;
    done = done || function(err, str) {
      if (err) return req.next(err);
      self2.send(str);
    };
    app.render(view2, opts, done);
  };
  function sendfile(res2, file2, options, callback) {
    var done = false;
    var streaming;
    function onaborted() {
      if (done) return;
      done = true;
      var err = new Error("Request aborted");
      err.code = "ECONNABORTED";
      callback(err);
    }
    function ondirectory() {
      if (done) return;
      done = true;
      var err = new Error("EISDIR, read");
      err.code = "EISDIR";
      callback(err);
    }
    function onerror(err) {
      if (done) return;
      done = true;
      callback(err);
    }
    function onend() {
      if (done) return;
      done = true;
      callback();
    }
    function onfile() {
      streaming = false;
    }
    function onfinish(err) {
      if (err && err.code === "ECONNRESET") return onaborted();
      if (err) return onerror(err);
      if (done) return;
      setImmediate(function() {
        if (streaming !== false && !done) {
          onaborted();
          return;
        }
        if (done) return;
        done = true;
        callback();
      });
    }
    function onstream() {
      streaming = true;
    }
    file2.on("directory", ondirectory);
    file2.on("end", onend);
    file2.on("error", onerror);
    file2.on("file", onfile);
    file2.on("stream", onstream);
    onFinished2(res2, onfinish);
    if (options.headers) {
      file2.on("headers", function headers(res3) {
        var obj = options.headers;
        var keys = Object.keys(obj);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          res3.setHeader(k, obj[k]);
        }
      });
    }
    file2.pipe(res2);
  }
  function stringify3(value, replacer, spaces, escape2) {
    var json2 = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
    if (escape2 && typeof json2 === "string") {
      json2 = json2.replace(/[<>&]/g, function(c2) {
        switch (c2.charCodeAt(0)) {
          case 60:
            return "\\u003c";
          case 62:
            return "\\u003e";
          case 38:
            return "\\u0026";
          /* istanbul ignore next: unreachable default */
          default:
            return c2;
        }
      });
    }
    return json2;
  }
  return response;
}
var serveStatic_1;
var hasRequiredServeStatic;
function requireServeStatic() {
  if (hasRequiredServeStatic) return serveStatic_1;
  hasRequiredServeStatic = 1;
  var encodeUrl = requireEncodeurl();
  var escapeHtml = requireEscapeHtml();
  var parseUrl = requireParseurl();
  var resolve2 = path$1.resolve;
  var send = requireSend();
  var url2 = require$$0$a;
  serveStatic_1 = serveStatic;
  function serveStatic(root2, options) {
    if (!root2) {
      throw new TypeError("root path required");
    }
    if (typeof root2 !== "string") {
      throw new TypeError("root path must be a string");
    }
    var opts = Object.create(options || null);
    var fallthrough = opts.fallthrough !== false;
    var redirect = opts.redirect !== false;
    var setHeaders = opts.setHeaders;
    if (setHeaders && typeof setHeaders !== "function") {
      throw new TypeError("option setHeaders must be function");
    }
    opts.maxage = opts.maxage || opts.maxAge || 0;
    opts.root = resolve2(root2);
    var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
    return function serveStatic2(req, res, next) {
      if (req.method !== "GET" && req.method !== "HEAD") {
        if (fallthrough) {
          return next();
        }
        res.statusCode = 405;
        res.setHeader("Allow", "GET, HEAD");
        res.setHeader("Content-Length", "0");
        res.end();
        return;
      }
      var forwardError = !fallthrough;
      var originalUrl = parseUrl.original(req);
      var path2 = parseUrl(req).pathname;
      if (path2 === "/" && originalUrl.pathname.substr(-1) !== "/") {
        path2 = "";
      }
      var stream = send(req, path2, opts);
      stream.on("directory", onDirectory);
      if (setHeaders) {
        stream.on("headers", setHeaders);
      }
      if (fallthrough) {
        stream.on("file", function onFile() {
          forwardError = true;
        });
      }
      stream.on("error", function error2(err) {
        if (forwardError || !(err.statusCode < 500)) {
          next(err);
          return;
        }
        next();
      });
      stream.pipe(res);
    };
  }
  function collapseLeadingSlashes(str) {
    for (var i = 0; i < str.length; i++) {
      if (str.charCodeAt(i) !== 47) {
        break;
      }
    }
    return i > 1 ? "/" + str.substr(i) : str;
  }
  function createHtmlDocument(title, body) {
    return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
  }
  function createNotFoundDirectoryListener() {
    return function notFound() {
      this.error(404);
    };
  }
  function createRedirectDirectoryListener() {
    return function redirect(res) {
      if (this.hasTrailingSlash()) {
        this.error(404);
        return;
      }
      var originalUrl = parseUrl.original(this.req);
      originalUrl.path = null;
      originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + "/");
      var loc = encodeUrl(url2.format(originalUrl));
      var doc = createHtmlDocument("Redirecting", "Redirecting to " + escapeHtml(loc));
      res.statusCode = 301;
      res.setHeader("Content-Type", "text/html; charset=UTF-8");
      res.setHeader("Content-Length", Buffer.byteLength(doc));
      res.setHeader("Content-Security-Policy", "default-src 'none'");
      res.setHeader("X-Content-Type-Options", "nosniff");
      res.setHeader("Location", loc);
      res.end(doc);
    };
  }
  return serveStatic_1;
}
var hasRequiredExpress$1;
function requireExpress$1() {
  if (hasRequiredExpress$1) return express$2.exports;
  hasRequiredExpress$1 = 1;
  (function(module, exports$1) {
    var bodyParser2 = requireBodyParser();
    var EventEmitter = require$$1$5.EventEmitter;
    var mixin = /* @__PURE__ */ requireMergeDescriptors();
    var proto = requireApplication();
    var Router = requireRouter();
    var req = requireRequest();
    var res = requireResponse();
    exports$1 = module.exports = createApplication;
    function createApplication() {
      var app = function(req2, res2, next) {
        app.handle(req2, res2, next);
      };
      mixin(app, EventEmitter.prototype, false);
      mixin(app, proto, false);
      app.request = Object.create(req, {
        app: { configurable: true, enumerable: true, writable: true, value: app }
      });
      app.response = Object.create(res, {
        app: { configurable: true, enumerable: true, writable: true, value: app }
      });
      app.init();
      return app;
    }
    exports$1.application = proto;
    exports$1.request = req;
    exports$1.response = res;
    exports$1.Route = Router.Route;
    exports$1.Router = Router;
    exports$1.json = bodyParser2.json;
    exports$1.raw = bodyParser2.raw;
    exports$1.static = requireServeStatic();
    exports$1.text = bodyParser2.text;
    exports$1.urlencoded = bodyParser2.urlencoded;
  })(express$2, express$2.exports);
  return express$2.exports;
}
var express$1;
var hasRequiredExpress;
function requireExpress() {
  if (hasRequiredExpress) return express$1;
  hasRequiredExpress = 1;
  express$1 = requireExpress$1();
  return express$1;
}
var expressExports = requireExpress();
const express = /* @__PURE__ */ getDefaultExportFromCjs(expressExports);
const sysface = /* @__PURE__ */ JSON.parse('[{"QSid":"419","QDes":"/","IQLid":"419","AQLid":"419","EMCode":"10419","AniStickerType":3,"AniStickerPackId":"1","AniStickerId":"47"},{"QSid":"424","QDes":"/","IQLid":"424","AQLid":"424","EMCode":"10424","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"52"},{"QSid":"425","QDes":"/","IQLid":"425","AQLid":"425","EMCode":"10425","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"53"},{"QSid":"426","QDes":"/","IQLid":"426","AQLid":"426","EMCode":"10426","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"54"},{"QSid":"427","QDes":"/","IQLid":"427","AQLid":"427","EMCode":"10427","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"55"},{"QSid":"428","QDes":"/","IQLid":"428","AQLid":"428","EMCode":"10428"},{"QSid":"429","QDes":"/","IQLid":"429","AQLid":"429","EMCode":"10429","AniStickerType":3,"AniStickerPackId":"1","AniStickerId":"56"},{"QSid":"364","QDes":"/","IQLid":"364","AQLid":"364","EMCode":"10364","QHide":"1","AniStickerType":1,"AniStickerId":"1","AniStickerPackId":"2","AniStickerPackName":""},{"QSid":"366","QDes":"/","IQLid":"366","AQLid":"366","EMCode":"10366","QHide":"1","AniStickerType":1,"AniStickerId":"2","AniStickerPackId":"2","AniStickerPackName":""},{"QSid":"362","QDes":"/","IQLid":"362","AQLid":"362","EMCode":"10362","QHide":"1","AniStickerType":1,"AniStickerId":"3","AniStickerPackId":"2","AniStickerPackName":""},{"QSid":"397","QDes":"/","IQLid":"397","AQLid":"397","EMCode":"10397","QHide":"1","AniStickerType":1,"AniStickerId":"4","AniStickerPackId":"2","AniStickerPackName":""},{"QSid":"396","QDes":"/","IQLid":"396","AQLid":"396","EMCode":"10396","QHide":"1","AniStickerType":1,"AniStickerId":"5","AniStickerPackId":"2","AniStickerPackName":""},{"QSid":"360","QDes":"/","IQLid":"360","AQLid":"360","EMCode":"10360","QHide":"1","AniStickerType":1,"AniStickerId":"6","AniStickerPackId":"2","AniStickerPackName":""},{"QSid":"361","QDes":"/","IQLid":"361","AQLid":"361","EMCode":"10361","QHide":"1","AniStickerType":1,"AniStickerId":"7","AniStickerPackId":"2","AniStickerPackName":""},{"QSid":"363","QDes":"/","IQLid":"363","AQLid":"363","EMCode":"10363","QHide":"1","AniStickerType":1,"AniStickerId":"8","AniStickerPackId":"2","AniStickerPackName":""},{"QSid":"365","QDes":"/","IQLid":"365","AQLid":"365","EMCode":"10365","QHide":"1","AniStickerType":1,"AniStickerId":"9","AniStickerPackId":"2","AniStickerPackName":""},{"QSid":"367","QDes":"/","IQLid":"367","AQLid":"367","EMCode":"10367","QHide":"1","AniStickerType":1,"AniStickerId":"10","AniStickerPackId":"2","AniStickerPackName":""},{"QSid":"399","QDes":"/tui","IQLid":"399","AQLid":"399","EMCode":"10399","QHide":"1","AniStickerType":1,"AniStickerId":"1","AniStickerPackId":"6","AniStickerPackName":""},{"QSid":"398","QDes":"/ok","IQLid":"398","AQLid":"398","EMCode":"10398","QHide":"1","AniStickerType":1,"AniStickerId":"2","AniStickerPackId":"6","AniStickerPackName":""},{"QSid":"373","QDes":"/","IQLid":"373","AQLid":"373","EMCode":"10373","QHide":"1","AniStickerType":1,"AniStickerId":"3","AniStickerPackId":"6","AniStickerPackName":""},{"QSid":"370","QDes":"/","IQLid":"370","AQLid":"370","EMCode":"10370","QHide":"1","AniStickerType":1,"AniStickerId":"4","AniStickerPackId":"6","AniStickerPackName":""},{"QSid":"375","QDes":"/","IQLid":"375","AQLid":"375","EMCode":"10375","QHide":"1","AniStickerType":1,"AniStickerId":"5","AniStickerPackId":"6","AniStickerPackName":""},{"QSid":"368","QDes":"/","IQLid":"368","AQLid":"368","EMCode":"10368","QHide":"1","AniStickerType":1,"AniStickerId":"6","AniStickerPackId":"6","AniStickerPackName":""},{"QSid":"369","QDes":"/","IQLid":"369","AQLid":"369","EMCode":"10369","QHide":"1","AniStickerType":1,"AniStickerId":"7","AniStickerPackId":"6","AniStickerPackName":""},{"QSid":"371","QDes":"/","IQLid":"371","AQLid":"371","EMCode":"10371","QHide":"1","AniStickerType":1,"AniStickerId":"8","AniStickerPackId":"6","AniStickerPackName":""},{"QSid":"372","QDes":"/","IQLid":"372","AQLid":"372","EMCode":"10372","QHide":"1","AniStickerType":1,"AniStickerId":"9","AniStickerPackId":"6","AniStickerPackName":""},{"QSid":"374","QDes":"/","IQLid":"374","AQLid":"374","EMCode":"10374","QHide":"1","AniStickerType":1,"AniStickerId":"10","AniStickerPackId":"6","AniStickerPackName":""},{"QSid":"382","QDes":"/emo","IQLid":"382","AQLid":"382","EMCode":"10382","QHide":"1","AniStickerType":1,"AniStickerId":"1","AniStickerPackId":"5","AniStickerPackName":""},{"QSid":"383","QDes":"/","IQLid":"383","AQLid":"383","EMCode":"10383","QHide":"1","AniStickerType":1,"AniStickerId":"2","AniStickerPackId":"5","AniStickerPackName":""},{"QSid":"401","QDes":"/","IQLid":"401","AQLid":"401","EMCode":"10401","QHide":"1","AniStickerType":1,"AniStickerId":"3","AniStickerPackId":"5","AniStickerPackName":""},{"QSid":"400","QDes":"/","IQLid":"400","AQLid":"400","EMCode":"10400","QHide":"1","AniStickerType":1,"AniStickerId":"4","AniStickerPackId":"5","AniStickerPackName":""},{"QSid":"380","QDes":"/","IQLid":"380","AQLid":"380","EMCode":"10380","QHide":"1","AniStickerType":1,"AniStickerId":"5","AniStickerPackId":"5","AniStickerPackName":""},{"QSid":"381","QDes":"/","IQLid":"381","AQLid":"381","EMCode":"10381","QHide":"1","AniStickerType":1,"AniStickerId":"6","AniStickerPackId":"5","AniStickerPackName":""},{"QSid":"379","QDes":"/","IQLid":"379","AQLid":"379","EMCode":"10379","QHide":"1","AniStickerType":1,"AniStickerId":"7","AniStickerPackId":"5","AniStickerPackName":""},{"QSid":"376","QDes":"/","IQLid":"376","AQLid":"376","EMCode":"10376","QHide":"1","AniStickerType":1,"AniStickerId":"8","AniStickerPackId":"5","AniStickerPackName":""},{"QSid":"378","QDes":"/","IQLid":"378","AQLid":"378","EMCode":"10378","QHide":"1","AniStickerType":1,"AniStickerId":"9","AniStickerPackId":"5","AniStickerPackName":""},{"QSid":"377","QDes":"/","IQLid":"377","AQLid":"377","EMCode":"10377","QHide":"1","AniStickerType":1,"AniStickerId":"10","AniStickerPackId":"5","AniStickerPackName":""},{"QSid":"403","QDes":"/","IQLid":"403","AQLid":"403","EMCode":"10403","QHide":"1","AniStickerType":1,"AniStickerId":"1","AniStickerPackId":"4","AniStickerPackName":"QQ"},{"QSid":"402","QDes":"/","IQLid":"402","AQLid":"402","EMCode":"10402","QHide":"1","AniStickerType":1,"AniStickerId":"2","AniStickerPackId":"4","AniStickerPackName":"QQ"},{"QSid":"390","QDes":"/","IQLid":"390","AQLid":"390","EMCode":"10390","QHide":"1","AniStickerType":1,"AniStickerId":"3","AniStickerPackId":"4","AniStickerPackName":"QQ"},{"QSid":"391","QDes":"/","IQLid":"391","AQLid":"391","EMCode":"10391","QHide":"1","AniStickerType":1,"AniStickerId":"4","AniStickerPackId":"4","AniStickerPackName":"QQ"},{"QSid":"388","QDes":"/","IQLid":"388","AQLid":"388","EMCode":"10388","QHide":"1","AniStickerType":1,"AniStickerId":"5","AniStickerPackId":"4","AniStickerPackName":"QQ"},{"QSid":"389","QDes":"/","IQLid":"389","AQLid":"389","EMCode":"10389","QHide":"1","AniStickerType":1,"AniStickerId":"6","AniStickerPackId":"4","AniStickerPackName":"QQ"},{"QSid":"386","QDes":"/","IQLid":"386","AQLid":"386","EMCode":"10386","QHide":"1","AniStickerType":1,"AniStickerId":"7","AniStickerPackId":"4","AniStickerPackName":"QQ"},{"QSid":"385","QDes":"/","IQLid":"385","AQLid":"385","EMCode":"10385","QHide":"1","AniStickerType":1,"AniStickerId":"8","AniStickerPackId":"4","AniStickerPackName":"QQ"},{"QSid":"384","QDes":"/","IQLid":"384","AQLid":"384","EMCode":"10384","QHide":"1","AniStickerType":1,"AniStickerId":"9","AniStickerPackId":"4","AniStickerPackName":"QQ"},{"QSid":"387","QDes":"/","IQLid":"387","AQLid":"387","EMCode":"10387","QHide":"1","AniStickerType":1,"AniStickerId":"10","AniStickerPackId":"4","AniStickerPackName":"QQ"},{"QSid":"413","QDes":"/","IQLid":"413","AQLid":"413","EMCode":"10413","QHide":"1","AniStickerType":1,"AniStickerId":"1","AniStickerPackId":"3","AniStickerPackName":""},{"QSid":"405","QDes":"/","IQLid":"405","AQLid":"405","EMCode":"10405","QHide":"1","AniStickerType":1,"AniStickerId":"2","AniStickerPackId":"3","AniStickerPackName":""},{"QSid":"404","QDes":"/","IQLid":"404","AQLid":"404","EMCode":"10404","QHide":"1","AniStickerType":1,"AniStickerId":"3","AniStickerPackId":"3","AniStickerPackName":""},{"QSid":"406","QDes":"/","IQLid":"406","AQLid":"406","EMCode":"10406","QHide":"1","AniStickerType":1,"AniStickerId":"4","AniStickerPackId":"3","AniStickerPackName":""},{"QSid":"410","QDes":"/","IQLid":"410","AQLid":"410","EMCode":"10410","QHide":"1","AniStickerType":1,"AniStickerId":"5","AniStickerPackId":"3","AniStickerPackName":""},{"QSid":"411","QDes":"/","IQLid":"411","AQLid":"411","EMCode":"10411","QHide":"1","AniStickerType":1,"AniStickerId":"6","AniStickerPackId":"3","AniStickerPackName":""},{"QSid":"407","QDes":"/","IQLid":"407","AQLid":"407","EMCode":"10407","QHide":"1","AniStickerType":1,"AniStickerId":"7","AniStickerPackId":"3","AniStickerPackName":""},{"QSid":"408","QDes":"/","IQLid":"408","AQLid":"408","EMCode":"10408","QHide":"1","AniStickerType":1,"AniStickerId":"8","AniStickerPackId":"3","AniStickerPackName":""},{"QSid":"412","QDes":"/","IQLid":"412","AQLid":"412","EMCode":"10412","QHide":"1","AniStickerType":1,"AniStickerId":"9","AniStickerPackId":"3","AniStickerPackName":""},{"QSid":"409","QDes":"/","IQLid":"409","AQLid":"409","EMCode":"10409","QHide":"1","AniStickerType":1,"AniStickerId":"10","AniStickerPackId":"3","AniStickerPackName":""},{"QSid":"14","QDes":"/","IQLid":"23","AQLid":"23","EMCode":"100"},{"QSid":"1","QDes":"/","IQLid":"40","AQLid":"40","EMCode":"101"},{"QSid":"2","QDes":"/","IQLid":"19","AQLid":"19","EMCode":"102"},{"QSid":"3","QDes":"/","IQLid":"43","AQLid":"43","EMCode":"103"},{"QSid":"4","QDes":"/","IQLid":"21","AQLid":"21","EMCode":"104"},{"QSid":"6","QDes":"/","IQLid":"20","AQLid":"20","EMCode":"106"},{"QSid":"7","QDes":"/","IQLid":"104","AQLid":"106","EMCode":"107"},{"QSid":"8","QDes":"/","IQLid":"35","AQLid":"35","EMCode":"108"},{"QSid":"9","QDes":"/","IQLid":"10","AQLid":"10","EMCode":"109"},{"QSid":"5","QDes":"/","IQLid":"9","AQLid":"9","EMCode":"105","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"16"},{"QSid":"10","QDes":"/","IQLid":"25","AQLid":"25","EMCode":"110"},{"QSid":"11","QDes":"/","IQLid":"24","AQLid":"24","EMCode":"111"},{"QSid":"12","QDes":"/","IQLid":"1","AQLid":"1","EMCode":"112"},{"QSid":"13","QDes":"/","IQLid":"0","AQLid":"0","EMCode":"113"},{"QSid":"0","QDes":"/","IQLid":"33","AQLid":"33","EMCode":"114"},{"QSid":"15","QDes":"/","IQLid":"32","AQLid":"32","EMCode":"115"},{"QSid":"16","QDes":"/","IQLid":"12","AQLid":"12","EMCode":"116"},{"QSid":"96","QDes":"/","IQLid":"27","AQLid":"27","EMCode":"117"},{"QSid":"18","QDes":"/","IQLid":"13","AQLid":"13","EMCode":"118"},{"QSid":"19","QDes":"/","IQLid":"22","AQLid":"22","EMCode":"119"},{"QSid":"20","QDes":"/","IQLid":"3","AQLid":"3","EMCode":"120"},{"QSid":"21","QDes":"/","IQLid":"18","AQLid":"18","EMCode":"121"},{"QSid":"22","QDes":"/","IQLid":"30","AQLid":"30","EMCode":"122"},{"QSid":"23","QDes":"/","IQLid":"31","AQLid":"31","EMCode":"123"},{"QSid":"24","QDes":"/","IQLid":"79","AQLid":"81","EMCode":"124"},{"QSid":"25","QDes":"/","IQLid":"80","AQLid":"82","EMCode":"125"},{"QSid":"26","QDes":"/","IQLid":"26","AQLid":"26","EMCode":"126"},{"QSid":"27","QDes":"/","IQLid":"2","AQLid":"2","EMCode":"127"},{"QSid":"28","QDes":"/","IQLid":"37","AQLid":"37","EMCode":"128"},{"QSid":"29","QDes":"/","IQLid":"50","AQLid":"50","EMCode":"129"},{"QSid":"30","QDes":"/","IQLid":"42","AQLid":"42","EMCode":"130"},{"QSid":"31","QDes":"/","IQLid":"81","AQLid":"83","EMCode":"131"},{"QSid":"32","QDes":"/","IQLid":"34","AQLid":"34","EMCode":"132"},{"QSid":"33","QDes":"/","IQLid":"11","AQLid":"11","EMCode":"133"},{"QSid":"34","QDes":"/","IQLid":"49","AQLid":"49","EMCode":"134"},{"QSid":"35","QDes":"/","IQLid":"82","AQLid":"84","EMCode":"135"},{"QSid":"36","QDes":"/","IQLid":"39","AQLid":"39","EMCode":"136"},{"QSid":"37","QDes":"/","isStatic":"1","IQLid":"76","AQLid":"78","EMCode":"137"},{"QSid":"38","QDes":"/","IQLid":"5","AQLid":"5","EMCode":"138"},{"QSid":"39","QDes":"/","IQLid":"4","AQLid":"4","EMCode":"139"},{"QSid":"97","QDes":"/","IQLid":"6","AQLid":"6","EMCode":"140"},{"QSid":"98","QDes":"/","IQLid":"83","AQLid":"85","EMCode":"141"},{"QSid":"99","QDes":"/","IQLid":"84","AQLid":"86","EMCode":"142"},{"QSid":"100","QDes":"/","IQLid":"85","AQLid":"87","EMCode":"143"},{"QSid":"101","QDes":"/","IQLid":"46","AQLid":"46","EMCode":"144"},{"QSid":"102","QDes":"/","IQLid":"86","AQLid":"88","EMCode":"145"},{"QSid":"103","QDes":"/","IQLid":"44","AQLid":"44","EMCode":"146"},{"QSid":"104","QDes":"/","IQLid":"87","AQLid":"89","EMCode":"147"},{"QSid":"105","QDes":"/","IQLid":"48","AQLid":"48","EMCode":"148"},{"QSid":"106","QDes":"/","IQLid":"14","AQLid":"14","EMCode":"149"},{"QSid":"107","QDes":"/","IQLid":"88","AQLid":"90","EMCode":"150"},{"QSid":"108","QDes":"/","IQLid":"41","AQLid":"41","EMCode":"151"},{"QSid":"305","QDes":"/","IQLid":"305","AQLid":"305","EMCode":"10305"},{"QSid":"109","QDes":"/","IQLid":"36","AQLid":"36","EMCode":"152"},{"QSid":"110","QDes":"/","IQLid":"89","AQLid":"91","EMCode":"153"},{"QSid":"111","QDes":"/","IQLid":"51","AQLid":"51","EMCode":"154"},{"QSid":"172","QDes":"/","IQLid":"142","AQLid":"164","EMCode":"242"},{"QSid":"182","QDes":"/","IQLid":"152","AQLid":"174","EMCode":"252"},{"QSid":"179","QDes":"/doge","IQLid":"149","AQLid":"171","EMCode":"249"},{"QSid":"173","QDes":"/","IQLid":"143","AQLid":"165","EMCode":"243"},{"QSid":"174","QDes":"/","IQLid":"144","AQLid":"166","EMCode":"244"},{"QSid":"212","QDes":"/","IQLid":"182","AQLid":"161","EMCode":"282"},{"QSid":"175","QDes":"/","IQLid":"145","AQLid":"167","EMCode":"245"},{"QSid":"178","QDes":"/","IQLid":"148","AQLid":"170","EMCode":"248"},{"QSid":"177","QDes":"/","IQLid":"147","AQLid":"169","EMCode":"247"},{"QSid":"176","QDes":"/","IQLid":"146","AQLid":"168","EMCode":"246"},{"QSid":"183","QDes":"/","IQLid":"153","AQLid":"175","EMCode":"253"},{"QSid":"262","QDes":"/","IQLid":"262","AQLid":"262","EMCode":"10262"},{"QSid":"263","QDes":"/","IQLid":"263","AQLid":"263","EMCode":"10263"},{"QSid":"264","QDes":"/","IQLid":"264","AQLid":"264","EMCode":"10264"},{"QSid":"265","QDes":"/","IQLid":"265","AQLid":"265","EMCode":"10265"},{"QSid":"266","QDes":"/","IQLid":"266","AQLid":"266","EMCode":"10266"},{"QSid":"267","QDes":"/","IQLid":"267","AQLid":"267","EMCode":"10267"},{"QSid":"268","QDes":"/","IQLid":"268","AQLid":"268","EMCode":"10268"},{"QSid":"269","QDes":"/","IQLid":"269","AQLid":"269","EMCode":"10269"},{"QSid":"270","QDes":"/emm","IQLid":"270","AQLid":"270","EMCode":"10270"},{"QSid":"271","QDes":"/","IQLid":"271","AQLid":"271","EMCode":"10271"},{"QSid":"272","QDes":"/","IQLid":"272","AQLid":"272","EMCode":"10272"},{"QSid":"277","QDes":"/","IQLid":"277","AQLid":"277","EMCode":"10277"},{"QSid":"307","QDes":"/","IQLid":"307","AQLid":"307","EMCode":"10307"},{"QSid":"306","QDes":"/","isStatic":"1","IQLid":"306","AQLid":"306","EMCode":"10306"},{"QSid":"281","QDes":"/","IQLid":"281","AQLid":"281","EMCode":"10281"},{"QSid":"282","QDes":"/","IQLid":"282","AQLid":"282","EMCode":"10282"},{"QSid":"283","QDes":"/","IQLid":"283","AQLid":"283","EMCode":"10283"},{"QSid":"284","QDes":"/","IQLid":"284","AQLid":"284","EMCode":"10284"},{"QSid":"285","QDes":"/","IQLid":"285","AQLid":"285","EMCode":"10285"},{"QSid":"293","QDes":"/","IQLid":"293","AQLid":"293","EMCode":"10293"},{"QSid":"286","QDes":"/","IQLid":"286","AQLid":"286","EMCode":"10286"},{"QSid":"287","QDes":"/","IQLid":"287","AQLid":"287","EMCode":"10287"},{"QSid":"289","QDes":"/","IQLid":"289","AQLid":"289","EMCode":"10289"},{"QSid":"294","QDes":"/","IQLid":"294","AQLid":"294","EMCode":"10294"},{"QSid":"297","QDes":"/","IQLid":"297","AQLid":"297","EMCode":"10297"},{"QSid":"298","QDes":"/","IQLid":"298","AQLid":"298","EMCode":"10298"},{"QSid":"299","QDes":"/","IQLid":"299","AQLid":"299","EMCode":"10299"},{"QSid":"300","QDes":"/","IQLid":"300","AQLid":"300","EMCode":"10300"},{"QSid":"323","QDes":"/","IQLid":"323","AQLid":"323","EMCode":"10323"},{"QSid":"332","QDes":"/","IQLid":"332","AQLid":"332","EMCode":"10332"},{"QSid":"336","QDes":"/","IQLid":"336","AQLid":"336","EMCode":"10336"},{"QSid":"353","QDes":"/","IQLid":"353","AQLid":"353","EMCode":"10353"},{"QSid":"355","QDes":"/","IQLid":"355","AQLid":"355","EMCode":"10355"},{"QSid":"356","QDes":"/666","IQLid":"356","AQLid":"356","EMCode":"10356"},{"QSid":"354","QDes":"/","IQLid":"354","AQLid":"354","EMCode":"10354"},{"QSid":"352","QDes":"/","IQLid":"352","AQLid":"352","EMCode":"10352"},{"QSid":"357","QDes":"/","IQLid":"357","AQLid":"357","EMCode":"10357"},{"QSid":"334","QDes":"/","IQLid":"334","AQLid":"334","EMCode":"10334"},{"QSid":"347","QDes":"/","IQLid":"347","AQLid":"347","EMCode":"10347"},{"QSid":"303","QDes":"/","IQLid":"303","AQLid":"303","EMCode":"10303"},{"QSid":"302","QDes":"/","IQLid":"302","AQLid":"302","EMCode":"10302"},{"QSid":"295","QDes":"/","IQLid":"295","AQLid":"295","EMCode":"10295"},{"QSid":"311","QDes":"/call","IQLid":"311","AQLid":"311","EMCode":"10311","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"1"},{"QSid":"312","QDes":"/","IQLid":"312","AQLid":"312","EMCode":"10312","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"2"},{"QSid":"314","QDes":"/","IQLid":"314","AQLid":"314","EMCode":"10314","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"4"},{"QSid":"317","QDes":"/","IQLid":"317","AQLid":"317","EMCode":"10317","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"7"},{"QSid":"318","QDes":"/","IQLid":"318","AQLid":"318","EMCode":"10318","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"8"},{"QSid":"319","QDes":"/","IQLid":"319","AQLid":"319","EMCode":"10319","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"9"},{"QSid":"320","QDes":"/","IQLid":"320","AQLid":"320","EMCode":"10320","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"10"},{"QSid":"324","QDes":"/","IQLid":"324","AQLid":"324","EMCode":"10324","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"12"},{"QSid":"325","QDes":"/","IQLid":"325","AQLid":"325","EMCode":"10325","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"14"},{"QSid":"337","QDes":"/","IQLid":"337","AQLid":"337","EMCode":"10337","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"22"},{"QSid":"338","QDes":"/","IQLid":"338","AQLid":"338","EMCode":"10338","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"20"},{"QSid":"339","QDes":"/","IQLid":"339","AQLid":"339","EMCode":"10339","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"21"},{"QSid":"341","QDes":"/","IQLid":"341","AQLid":"341","EMCode":"10341","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"24"},{"QSid":"342","QDes":"/Q","IQLid":"342","AQLid":"342","EMCode":"10342","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"26"},{"QSid":"343","QDes":"/","IQLid":"343","AQLid":"343","EMCode":"10343","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"27"},{"QSid":"344","QDes":"/","IQLid":"344","AQLid":"344","EMCode":"10344","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"28"},{"QSid":"345","QDes":"/","IQLid":"345","AQLid":"345","EMCode":"10345","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"29"},{"QSid":"346","QDes":"/","IQLid":"346","AQLid":"346","EMCode":"10346","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"25"},{"QSid":"181","QDes":"/","IQLid":"151","AQLid":"173","EMCode":"251","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"37"},{"QSid":"74","QDes":"/","isStatic":"1","IQLid":"73","AQLid":"75","EMCode":"176","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"35"},{"QSid":"75","QDes":"/","isStatic":"1","IQLid":"67","AQLid":"68","EMCode":"175","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"36"},{"QSid":"351","QDes":"/","IQLid":"351","AQLid":"351","EMCode":"10351","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"30"},{"QSid":"349","QDes":"/","IQLid":"349","AQLid":"349","EMCode":"10349","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"32"},{"QSid":"350","QDes":"/","IQLid":"350","AQLid":"350","EMCode":"10350","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"31"},{"QSid":"395","QDes":"/","IQLid":"395","AQLid":"395","EMCode":"10395","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"41"},{"QSid":"114","QDes":"/","IQLid":"90","AQLid":"92","EMCode":"158","AniStickerType":2,"AniStickerPackId":"1","AniStickerId":"13"},{"QSid":"358","QDes":"/","IQLid":"358","AQLid":"358","QHide":"1","EMCode":"10358","AniStickerType":2,"AniStickerPackId":"1","AniStickerId":"33"},{"QSid":"359","QDes":"/","IQLid":"359","AQLid":"359","QHide":"1","EMCode":"10359","AniStickerType":2,"AniStickerPackId":"1","AniStickerId":"34"},{"QSid":"326","QDes":"/","IQLid":"326","AQLid":"326","EMCode":"10326","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"15"},{"QSid":"53","QDes":"/","IQLid":"59","AQLid":"59","EMCode":"168","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"17"},{"QSid":"49","QDes":"/","IQLid":"45","AQLid":"45","EMCode":"178"},{"QSid":"66","QDes":"/","IQLid":"28","AQLid":"28","EMCode":"166"},{"QSid":"63","QDes":"/","IQLid":"8","AQLid":"8","EMCode":"163"},{"QSid":"64","QDes":"/","IQLid":"57","AQLid":"57","EMCode":"164"},{"QSid":"187","QDes":"/","IQLid":"157","AQLid":"179","EMCode":"257"},{"QSid":"146","QDes":"/","IQLid":"116","AQLid":"118","EMCode":"121011"},{"QSid":"116","QDes":"/","IQLid":"29","AQLid":"29","EMCode":"165"},{"QSid":"67","QDes":"/","IQLid":"72","AQLid":"74","EMCode":"167"},{"QSid":"60","QDes":"/","IQLid":"66","AQLid":"66","EMCode":"160"},{"QSid":"185","QDes":"/","IQLid":"155","AQLid":"177","EMCode":"255"},{"QSid":"137","QDes":"/","isStatic":"1","IQLid":"107","AQLid":"109","EMCode":"121002","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"18"},{"QSid":"333","QDes":"/","isStatic":"1","IQLid":"333","AQLid":"333","EMCode":"10333","AniStickerType":1,"AniStickerPackId":"1","AniStickerId":"19"},{"QSid":"415","QDes":"/","IQLid":"415","AQLid":"415","EMCode":"10415","AniStickerType":3,"AniStickerPackId":"1","AniStickerId":"43","AniStickerWidth":192,"AniStickerHeight":76},{"QSid":"416","QDes":"/","IQLid":"416","AQLid":"416","EMCode":"10416","AniStickerType":3,"AniStickerPackId":"1","AniStickerId":"44","AniStickerWidth":192,"AniStickerHeight":76,"QHide":"1"},{"QSid":"417","QDes":"/","IQLid":"417","AQLid":"417","EMCode":"10417","AniStickerType":3,"AniStickerPackId":"1","AniStickerId":"45","AniStickerWidth":192,"AniStickerHeight":96,"QHide":"1"},{"QSid":"392","QDes":"/","IQLid":"392","AQLid":"392","EMCode":"10392","AniStickerType":3,"AniStickerPackId":"1","AniStickerId":"38","AniStickerWidth":129,"AniStickerHeight":57},{"QSid":"393","QDes":"/","IQLid":"393","AQLid":"393","EMCode":"10393","QHide":"1","AniStickerType":3,"AniStickerPackId":"1","AniStickerId":"39","AniStickerWidth":159,"AniStickerHeight":72},{"QSid":"394","QDes":"/","IQLid":"394","AQLid":"394","EMCode":"10394","QHide":"1","AniStickerType":3,"AniStickerPackId":"1","AniStickerId":"40","AniStickerWidth":220,"AniStickerHeight":91},{"QSid":"76","QDes":"/","IQLid":"52","AQLid":"52","EMCode":"179"},{"QSid":"124","QDes":"/OK","IQLid":"64","AQLid":"64","EMCode":"189"},{"QSid":"118","QDes":"/","IQLid":"56","AQLid":"56","EMCode":"183"},{"QSid":"78","QDes":"/","IQLid":"54","AQLid":"54","EMCode":"181"},{"QSid":"119","QDes":"/","IQLid":"63","AQLid":"63","EMCode":"184"},{"QSid":"79","QDes":"/","IQLid":"55","AQLid":"55","EMCode":"182"},{"QSid":"120","QDes":"/","IQLid":"71","AQLid":"73","EMCode":"185"},{"QSid":"121","QDes":"/","IQLid":"70","AQLid":"72","EMCode":"186"},{"QSid":"77","QDes":"/","IQLid":"53","AQLid":"53","EMCode":"180"},{"QSid":"123","QDes":"/NO","IQLid":"92","AQLid":"94","EMCode":"188"},{"QSid":"201","QDes":"/","IQLid":"171","AQLid":"150","EMCode":"271"},{"QSid":"273","QDes":"/","isStatic":"1","IQLid":"273","AQLid":"273","EMCode":"10273"},{"QSid":"46","QDes":"/","isStatic":"1","IQLid":"7","AQLid":"7","EMCode":"162"},{"QSid":"112","QDes":"/","IQLid":"17","AQLid":"17","EMCode":"155"},{"QSid":"56","QDes":"/","IQLid":"68","AQLid":"70","EMCode":"171"},{"QSid":"169","QDes":"/","isStatic":"1","IQLid":"139","AQLid":"141","EMCode":"121034"},{"QSid":"171","QDes":"/","IQLid":"141","AQLid":"163","EMCode":"241"},{"QSid":"59","QDes":"/","IQLid":"15","AQLid":"15","EMCode":"174"},{"QSid":"144","QDes":"/","isStatic":"1","IQLid":"114","AQLid":"116","EMCode":"121009"},{"QSid":"147","QDes":"/","isStatic":"1","IQLid":"117","AQLid":"119","EMCode":"121012"},{"QSid":"89","QDes":"/","isStatic":"1","IQLid":"60","AQLid":"60","EMCode":"156"},{"QSid":"148","QDes":"/","isStatic":"1","IQLid":"118","AQLid":"120","QHide":"1","EMCode":"121013"},{"QSid":"55","QDes":"/","isStatic":"1","IQLid":"16","AQLid":"16","QHide":"1","EMCode":"170"},{"QSid":"41","QDes":"/","isStatic":"1","IQLid":"69","AQLid":"71","EMCode":"193"},{"QSid":"125","QDes":"/","IQLid":"95","AQLid":"97","EMCode":"195"},{"QSid":"42","QDes":"/","IQLid":"38","AQLid":"38","EMCode":"190"},{"QSid":"43","QDes":"/","IQLid":"93","AQLid":"95","EMCode":"192"},{"QSid":"86","QDes":"/","IQLid":"94","AQLid":"96","EMCode":"194"},{"QSid":"129","QDes":"/","IQLid":"77","AQLid":"79","EMCode":"199"},{"QSid":"226","QDes":"/","IQLid":"196","isCMEmoji":"1","AQLid":"198","QHide":"1","EMCode":"297"},{"QSid":"85","QDes":"/","isStatic":"1","IQLid":"47","AQLid":"47","EMCode":"191"},{"QSid":"215","QDes":"/","IQLid":"185","isCMEmoji":"1","AQLid":"187","QHide":"1","EMCode":"285"},{"QSid":"214","QDes":"/","IQLid":"184","isCMEmoji":"1","AQLid":"186","QHide":"1","EMCode":"284"},{"QSid":"222","QDes":"/","IQLid":"192","isCMEmoji":"1","AQLid":"194","QHide":"1","EMCode":"292"},{"QSid":"203","QDes":"/","IQLid":"173","AQLid":"152","QHide":"1","EMCode":"273"},{"QSid":"235","QDes":"/","IQLid":"205","isCMEmoji":"1","AQLid":"207","QHide":"1","EMCode":"305"},{"QSid":"241","QDes":"/","IQLid":"211","isCMEmoji":"1","AQLid":"213","QHide":"1","EMCode":"311"},{"QSid":"237","QDes":"/","IQLid":"207","isCMEmoji":"1","AQLid":"209","QHide":"1","EMCode":"307"},{"QSid":"218","QDes":"/","IQLid":"188","isCMEmoji":"1","AQLid":"190","QHide":"1","EMCode":"288"},{"QSid":"233","QDes":"/","IQLid":"203","isCMEmoji":"1","AQLid":"205","QHide":"1","EMCode":"303"},{"QSid":"232","QDes":"/","IQLid":"202","isCMEmoji":"1","AQLid":"204","QHide":"1","EMCode":"302"},{"QSid":"238","QDes":"/","IQLid":"208","isCMEmoji":"1","AQLid":"210","QHide":"1","EMCode":"308"},{"QSid":"217","QDes":"/","IQLid":"187","isCMEmoji":"1","AQLid":"189","QHide":"1","EMCode":"287"},{"QSid":"225","QDes":"/","IQLid":"195","isCMEmoji":"1","AQLid":"197","QHide":"1","EMCode":"296"},{"QSid":"230","QDes":"/","IQLid":"200","isCMEmoji":"1","AQLid":"202","QHide":"1","EMCode":"300"},{"QSid":"194","QDes":"/","IQLid":"164","AQLid":"143","QHide":"1","EMCode":"264"},{"QSid":"210","QDes":"/","IQLid":"180","AQLid":"159","QHide":"1","EMCode":"280"},{"QSid":"193","QDes":"/","IQLid":"163","AQLid":"185","QHide":"1","EMCode":"263"},{"QSid":"204","QDes":"/","IQLid":"174","AQLid":"153","QHide":"1","EMCode":"274"},{"QSid":"200","QDes":"/","IQLid":"170","AQLid":"149","QHide":"1","EMCode":"270"},{"QSid":"290","QDes":"/","IQLid":"290","isCMEmoji":"1","AQLid":"290","QHide":"1","EMCode":"20240"},{"QSid":"224","QDes":"/","IQLid":"194","isCMEmoji":"1","AQLid":"196","QHide":"1","EMCode":"295"},{"QSid":"229","QDes":"/","IQLid":"199","isCMEmoji":"1","AQLid":"201","QHide":"1","EMCode":"299"},{"QSid":"221","QDes":"/","IQLid":"191","isCMEmoji":"1","AQLid":"193","QHide":"1","EMCode":"291"},{"QSid":"219","QDes":"/","IQLid":"189","isCMEmoji":"1","AQLid":"191","QHide":"1","EMCode":"289"},{"QSid":"227","QDes":"/","IQLid":"197","isCMEmoji":"1","AQLid":"199","QHide":"1","EMCode":"294"},{"QSid":"216","QDes":"/","IQLid":"186","isCMEmoji":"1","AQLid":"188","QHide":"1","EMCode":"286"},{"QSid":"231","QDes":"/","IQLid":"201","isCMEmoji":"1","AQLid":"203","QHide":"1","EMCode":"301"},{"QSid":"244","QDes":"/","IQLid":"214","isCMEmoji":"1","AQLid":"216","QHide":"1","EMCode":"312"},{"QSid":"223","QDes":"/","IQLid":"193","isCMEmoji":"1","AQLid":"195","QHide":"1","EMCode":"293"},{"QSid":"243","QDes":"/","IQLid":"213","isCMEmoji":"1","AQLid":"215","QHide":"1","EMCode":"313"},{"QSid":"211","QDes":"/","IQLid":"181","AQLid":"160","QHide":"1","EMCode":"281"},{"QSid":"292","QDes":"/","IQLid":"292","isCMEmoji":"1","AQLid":"292","QHide":"1","EMCode":"20242"},{"QSid":"240","QDes":"/","IQLid":"210","isCMEmoji":"1","AQLid":"212","QHide":"1","EMCode":"310"},{"QSid":"180","QDes":"/","IQLid":"150","AQLid":"172","QHide":"1","EMCode":"250"},{"QSid":"122","QDes":"/","IQLid":"65","AQLid":"65","QHide":"1","EMCode":"187"},{"QSid":"202","QDes":"/","IQLid":"172","AQLid":"151","QHide":"1","EMCode":"272"},{"QSid":"278","QDes":"/","IQLid":"278","isCMEmoji":"1","AQLid":"278","QHide":"1","EMCode":"20237"},{"QSid":"301","QDes":"/","IQLid":"301","AQLid":"301","QHide":"1","EMCode":"10301"},{"QSid":"288","QDes":"/","IQLid":"288","AQLid":"288","QHide":"1","EMCode":"10288"},{"QSid":"322","QDes":"/","IQLid":"322","AQLid":"322","QHide":"1","EMCode":"10322"},{"QSid":"198","QDes":"/","IQLid":"168","AQLid":"147","QHide":"1","EMCode":"268"},{"QSid":"348","QDes":"/","IQLid":"348","AQLid":"348","QHide":"1","EMCode":"10348"},{"QSid":"206","QDes":"/","IQLid":"176","AQLid":"155","QHide":"1","EMCode":"276"},{"QSid":"239","QDes":"/","IQLid":"209","isCMEmoji":"1","AQLid":"211","QHide":"1","EMCode":"309"}]');
const faceConfig = {
  sysface
};
const decoder = new TextDecoder();
const toUTF8String = (input, start = 0, end = input.length) => decoder.decode(input.slice(start, end));
const toHexString = (input, start = 0, end = input.length) => input.slice(start, end).reduce((memo, i) => memo + `0${i.toString(16)}`.slice(-2), "");
const getView = (input, offset) => new DataView(input.buffer, input.byteOffset + offset);
const readInt16LE = (input, offset = 0) => getView(input, offset).getInt16(0, true);
const readUInt16BE = (input, offset = 0) => getView(input, offset).getUint16(0, false);
const readUInt16LE = (input, offset = 0) => getView(input, offset).getUint16(0, true);
const readUInt24LE = (input, offset = 0) => {
  const view2 = getView(input, offset);
  return view2.getUint16(0, true) + (view2.getUint8(2) << 16);
};
const readInt32LE = (input, offset = 0) => getView(input, offset).getInt32(0, true);
const readUInt32BE = (input, offset = 0) => getView(input, offset).getUint32(0, false);
const readUInt32LE = (input, offset = 0) => getView(input, offset).getUint32(0, true);
const readUInt64 = (input, offset, isBigEndian) => getView(input, offset).getBigUint64(0, !isBigEndian);
const methods = {
  readUInt16BE,
  readUInt16LE,
  readUInt32BE,
  readUInt32LE
};
function readUInt(input, bits, offset = 0, isBigEndian = false) {
  const endian = isBigEndian ? "BE" : "LE";
  const methodName = `readUInt${bits}${endian}`;
  return methods[methodName](input, offset);
}
function readBox(input, offset) {
  if (input.length - offset < 4) return;
  const boxSize = readUInt32BE(input, offset);
  if (input.length - offset < boxSize) return;
  return {
    name: toUTF8String(input, 4 + offset, 8 + offset),
    offset,
    size: boxSize
  };
}
function findBox(input, boxName, currentOffset) {
  while (currentOffset < input.length) {
    const box = readBox(input, currentOffset);
    if (!box) break;
    if (box.name === boxName) return box;
    currentOffset += box.size > 0 ? box.size : 8;
  }
}
const BMP = {
  validate: (input) => toUTF8String(input, 0, 2) === "BM",
  calculate: (input) => ({
    height: Math.abs(readInt32LE(input, 22)),
    width: readUInt32LE(input, 18)
  })
};
const TYPE_ICON = 1;
const SIZE_HEADER$1 = 2 + 2 + 2;
const SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4;
function getSizeFromOffset(input, offset) {
  const value = input[offset];
  return value === 0 ? 256 : value;
}
function getImageSize$2(input, imageIndex) {
  const offset = SIZE_HEADER$1 + imageIndex * SIZE_IMAGE_ENTRY;
  return {
    height: getSizeFromOffset(input, offset + 1),
    width: getSizeFromOffset(input, offset)
  };
}
const ICO = {
  validate(input) {
    const reserved = readUInt16LE(input, 0);
    const imageCount = readUInt16LE(input, 4);
    if (reserved !== 0 || imageCount === 0) return false;
    const imageType = readUInt16LE(input, 2);
    return imageType === TYPE_ICON;
  },
  calculate(input) {
    const nbImages = readUInt16LE(input, 4);
    const imageSize2 = getImageSize$2(input, 0);
    if (nbImages === 1) return imageSize2;
    const images = [];
    for (let imageIndex = 0; imageIndex < nbImages; imageIndex += 1) {
      images.push(getImageSize$2(input, imageIndex));
    }
    return {
      width: imageSize2.width,
      height: imageSize2.height,
      images
    };
  }
};
const TYPE_CURSOR = 2;
const CUR = {
  validate(input) {
    const reserved = readUInt16LE(input, 0);
    const imageCount = readUInt16LE(input, 4);
    if (reserved !== 0 || imageCount === 0) return false;
    const imageType = readUInt16LE(input, 2);
    return imageType === TYPE_CURSOR;
  },
  calculate: (input) => ICO.calculate(input)
};
const DDS = {
  validate: (input) => readUInt32LE(input, 0) === 542327876,
  calculate: (input) => ({
    height: readUInt32LE(input, 12),
    width: readUInt32LE(input, 16)
  })
};
const gifRegexp = /^GIF8[79]a/;
const GIF = {
  validate: (input) => gifRegexp.test(toUTF8String(input, 0, 6)),
  calculate: (input) => ({
    height: readUInt16LE(input, 8),
    width: readUInt16LE(input, 6)
  })
};
const brandMap = {
  avif: "avif",
  mif1: "heif",
  msf1: "heif",
  // heif-sequence
  heic: "heic",
  heix: "heic",
  hevc: "heic",
  // heic-sequence
  hevx: "heic"
  // heic-sequence
};
const HEIF = {
  validate(input) {
    const boxType = toUTF8String(input, 4, 8);
    if (boxType !== "ftyp") return false;
    const ftypBox = findBox(input, "ftyp", 0);
    if (!ftypBox) return false;
    const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
    return brand in brandMap;
  },
  calculate(input) {
    const metaBox = findBox(input, "meta", 0);
    const iprpBox = metaBox && findBox(input, "iprp", metaBox.offset + 12);
    const ipcoBox = iprpBox && findBox(input, "ipco", iprpBox.offset + 8);
    if (!ipcoBox) {
      throw new TypeError("Invalid HEIF, no ipco box found");
    }
    const type2 = toUTF8String(input, 8, 12);
    const images = [];
    let currentOffset = ipcoBox.offset + 8;
    while (currentOffset < ipcoBox.offset + ipcoBox.size) {
      const ispeBox = findBox(input, "ispe", currentOffset);
      if (!ispeBox) break;
      const rawWidth = readUInt32BE(input, ispeBox.offset + 12);
      const rawHeight = readUInt32BE(input, ispeBox.offset + 16);
      const clapBox = findBox(input, "clap", currentOffset);
      let width = rawWidth;
      let height = rawHeight;
      if (clapBox && clapBox.offset < ipcoBox.offset + ipcoBox.size) {
        const cropRight = readUInt32BE(input, clapBox.offset + 12);
        width = rawWidth - cropRight;
      }
      images.push({ height, width });
      currentOffset = ispeBox.offset + ispeBox.size;
    }
    if (images.length === 0) {
      throw new TypeError("Invalid HEIF, no sizes found");
    }
    return {
      width: images[0].width,
      height: images[0].height,
      type: type2,
      ...images.length > 1 ? { images } : {}
    };
  }
};
const SIZE_HEADER = 4 + 4;
const FILE_LENGTH_OFFSET = 4;
const ENTRY_LENGTH_OFFSET = 4;
const ICON_TYPE_SIZE = {
  ICON: 32,
  "ICN#": 32,
  // m => 16 x 16
  "icm#": 16,
  icm4: 16,
  icm8: 16,
  // s => 16 x 16
  "ics#": 16,
  ics4: 16,
  ics8: 16,
  is32: 16,
  s8mk: 16,
  icp4: 16,
  // l => 32 x 32
  icl4: 32,
  icl8: 32,
  il32: 32,
  l8mk: 32,
  icp5: 32,
  ic11: 32,
  // h => 48 x 48
  ich4: 48,
  ich8: 48,
  ih32: 48,
  h8mk: 48,
  // . => 64 x 64
  icp6: 64,
  ic12: 32,
  // t => 128 x 128
  it32: 128,
  t8mk: 128,
  ic07: 128,
  // . => 256 x 256
  ic08: 256,
  ic13: 256,
  // . => 512 x 512
  ic09: 512,
  ic14: 512,
  // . => 1024 x 1024
  ic10: 1024
};
function readImageHeader(input, imageOffset) {
  const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;
  return [
    toUTF8String(input, imageOffset, imageLengthOffset),
    readUInt32BE(input, imageLengthOffset)
  ];
}
function getImageSize$1(type2) {
  const size = ICON_TYPE_SIZE[type2];
  return { width: size, height: size, type: type2 };
}
const ICNS = {
  validate: (input) => toUTF8String(input, 0, 4) === "icns",
  calculate(input) {
    const inputLength = input.length;
    const fileLength = readUInt32BE(input, FILE_LENGTH_OFFSET);
    let imageOffset = SIZE_HEADER;
    const images = [];
    while (imageOffset < fileLength && imageOffset < inputLength) {
      const imageHeader = readImageHeader(input, imageOffset);
      const imageSize2 = getImageSize$1(imageHeader[0]);
      images.push(imageSize2);
      imageOffset += imageHeader[1];
    }
    if (images.length === 0) {
      throw new TypeError("Invalid ICNS, no sizes found");
    }
    return {
      width: images[0].width,
      height: images[0].height,
      ...images.length > 1 ? { images } : {}
    };
  }
};
const J2C = {
  // TODO: this doesn't seem right. SIZ marker doesn't have to be right after the SOC
  validate: (input) => readUInt32BE(input, 0) === 4283432785,
  calculate: (input) => ({
    height: readUInt32BE(input, 12),
    width: readUInt32BE(input, 8)
  })
};
const JP2 = {
  validate(input) {
    const boxType = toUTF8String(input, 4, 8);
    if (boxType !== "jP  ") return false;
    const ftypBox = findBox(input, "ftyp", 0);
    if (!ftypBox) return false;
    const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
    return brand === "jp2 ";
  },
  calculate(input) {
    const jp2hBox = findBox(input, "jp2h", 0);
    const ihdrBox = jp2hBox && findBox(input, "ihdr", jp2hBox.offset + 8);
    if (ihdrBox) {
      return {
        height: readUInt32BE(input, ihdrBox.offset + 8),
        width: readUInt32BE(input, ihdrBox.offset + 12)
      };
    }
    throw new TypeError("Unsupported JPEG 2000 format");
  }
};
const EXIF_MARKER = "45786966";
const APP1_DATA_SIZE_BYTES = 2;
const EXIF_HEADER_BYTES = 6;
const TIFF_BYTE_ALIGN_BYTES = 2;
const BIG_ENDIAN_BYTE_ALIGN = "4d4d";
const LITTLE_ENDIAN_BYTE_ALIGN = "4949";
const IDF_ENTRY_BYTES = 12;
const NUM_DIRECTORY_ENTRIES_BYTES = 2;
function isEXIF(input) {
  return toHexString(input, 2, 6) === EXIF_MARKER;
}
function extractSize(input, index2) {
  return {
    height: readUInt16BE(input, index2),
    width: readUInt16BE(input, index2 + 2)
  };
}
function extractOrientation(exifBlock, isBigEndian) {
  const idfOffset = 8;
  const offset = EXIF_HEADER_BYTES + idfOffset;
  const idfDirectoryEntries = readUInt(exifBlock, 16, offset, isBigEndian);
  for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {
    const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;
    const end = start + IDF_ENTRY_BYTES;
    if (start > exifBlock.length) {
      return;
    }
    const block = exifBlock.slice(start, end);
    const tagNumber = readUInt(block, 16, 0, isBigEndian);
    if (tagNumber === 274) {
      const dataFormat = readUInt(block, 16, 2, isBigEndian);
      if (dataFormat !== 3) {
        return;
      }
      const numberOfComponents = readUInt(block, 32, 4, isBigEndian);
      if (numberOfComponents !== 1) {
        return;
      }
      return readUInt(block, 16, 8, isBigEndian);
    }
  }
}
function validateExifBlock(input, index2) {
  const exifBlock = input.slice(APP1_DATA_SIZE_BYTES, index2);
  const byteAlign = toHexString(
    exifBlock,
    EXIF_HEADER_BYTES,
    EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES
  );
  const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;
  const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;
  if (isBigEndian || isLittleEndian) {
    return extractOrientation(exifBlock, isBigEndian);
  }
}
function validateInput(input, index2) {
  if (index2 > input.length) {
    throw new TypeError("Corrupt JPG, exceeded buffer limits");
  }
}
const JPG = {
  validate: (input) => toHexString(input, 0, 2) === "ffd8",
  calculate(_input) {
    let input = _input.slice(4);
    let orientation;
    let next;
    while (input.length) {
      const i = readUInt16BE(input, 0);
      validateInput(input, i);
      if (input[i] !== 255) {
        input = input.slice(1);
        continue;
      }
      if (isEXIF(input)) {
        orientation = validateExifBlock(input, i);
      }
      next = input[i + 1];
      if (next === 192 || next === 193 || next === 194) {
        const size = extractSize(input, i + 5);
        if (!orientation) {
          return size;
        }
        return {
          height: size.height,
          orientation,
          width: size.width
        };
      }
      input = input.slice(i + 2);
    }
    throw new TypeError("Invalid JPG, no size found");
  }
};
class BitReader {
  constructor(input, endianness) {
    this.input = input;
    this.endianness = endianness;
  }
  // Skip the first 16 bits (2 bytes) of signature
  byteOffset = 2;
  bitOffset = 0;
  /** Reads a specified number of bits, and move the offset */
  getBits(length = 1) {
    let result = 0;
    let bitsRead = 0;
    while (bitsRead < length) {
      if (this.byteOffset >= this.input.length) {
        throw new Error("Reached end of input");
      }
      const currentByte = this.input[this.byteOffset];
      const bitsLeft = 8 - this.bitOffset;
      const bitsToRead = Math.min(length - bitsRead, bitsLeft);
      if (this.endianness === "little-endian") {
        const mask = (1 << bitsToRead) - 1;
        const bits = currentByte >> this.bitOffset & mask;
        result |= bits << bitsRead;
      } else {
        const mask = (1 << bitsToRead) - 1 << 8 - this.bitOffset - bitsToRead;
        const bits = (currentByte & mask) >> 8 - this.bitOffset - bitsToRead;
        result = result << bitsToRead | bits;
      }
      bitsRead += bitsToRead;
      this.bitOffset += bitsToRead;
      if (this.bitOffset === 8) {
        this.byteOffset++;
        this.bitOffset = 0;
      }
    }
    return result;
  }
}
function calculateImageDimension(reader, isSmallImage) {
  if (isSmallImage) {
    return 8 * (1 + reader.getBits(5));
  }
  const sizeClass = reader.getBits(2);
  const extraBits = [9, 13, 18, 30][sizeClass];
  return 1 + reader.getBits(extraBits);
}
function calculateImageWidth(reader, isSmallImage, widthMode, height) {
  if (isSmallImage && widthMode === 0) {
    return 8 * (1 + reader.getBits(5));
  }
  if (widthMode === 0) {
    return calculateImageDimension(reader, false);
  }
  const aspectRatios = [1, 1.2, 4 / 3, 1.5, 16 / 9, 5 / 4, 2];
  return Math.floor(height * aspectRatios[widthMode - 1]);
}
const JXLStream = {
  validate: (input) => {
    return toHexString(input, 0, 2) === "ff0a";
  },
  calculate(input) {
    const reader = new BitReader(input, "little-endian");
    const isSmallImage = reader.getBits(1) === 1;
    const height = calculateImageDimension(reader, isSmallImage);
    const widthMode = reader.getBits(3);
    const width = calculateImageWidth(reader, isSmallImage, widthMode, height);
    return { width, height };
  }
};
function extractCodestream(input) {
  const jxlcBox = findBox(input, "jxlc", 0);
  if (jxlcBox) {
    return input.slice(jxlcBox.offset + 8, jxlcBox.offset + jxlcBox.size);
  }
  const partialStreams = extractPartialStreams(input);
  if (partialStreams.length > 0) {
    return concatenateCodestreams(partialStreams);
  }
  return void 0;
}
function extractPartialStreams(input) {
  const partialStreams = [];
  let offset = 0;
  while (offset < input.length) {
    const jxlpBox = findBox(input, "jxlp", offset);
    if (!jxlpBox) break;
    partialStreams.push(
      input.slice(jxlpBox.offset + 12, jxlpBox.offset + jxlpBox.size)
    );
    offset = jxlpBox.offset + jxlpBox.size;
  }
  return partialStreams;
}
function concatenateCodestreams(partialCodestreams) {
  const totalLength = partialCodestreams.reduce(
    (acc, curr) => acc + curr.length,
    0
  );
  const codestream = new Uint8Array(totalLength);
  let position = 0;
  for (const partial2 of partialCodestreams) {
    codestream.set(partial2, position);
    position += partial2.length;
  }
  return codestream;
}
const JXL = {
  validate: (input) => {
    const boxType = toUTF8String(input, 4, 8);
    if (boxType !== "JXL ") return false;
    const ftypBox = findBox(input, "ftyp", 0);
    if (!ftypBox) return false;
    const brand = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
    return brand === "jxl ";
  },
  calculate(input) {
    const codestream = extractCodestream(input);
    if (codestream) return JXLStream.calculate(codestream);
    throw new Error("No codestream found in JXL container");
  }
};
const KTX = {
  validate: (input) => {
    const signature = toUTF8String(input, 1, 7);
    return ["KTX 11", "KTX 20"].includes(signature);
  },
  calculate: (input) => {
    const type2 = input[5] === 49 ? "ktx" : "ktx2";
    const offset = type2 === "ktx" ? 36 : 20;
    return {
      height: readUInt32LE(input, offset + 4),
      width: readUInt32LE(input, offset),
      type: type2
    };
  }
};
const pngSignature = "PNG\r\n\n";
const pngImageHeaderChunkName = "IHDR";
const pngFriedChunkName = "CgBI";
const PNG = {
  validate(input) {
    if (pngSignature === toUTF8String(input, 1, 8)) {
      let chunkName = toUTF8String(input, 12, 16);
      if (chunkName === pngFriedChunkName) {
        chunkName = toUTF8String(input, 28, 32);
      }
      if (chunkName !== pngImageHeaderChunkName) {
        throw new TypeError("Invalid PNG");
      }
      return true;
    }
    return false;
  },
  calculate(input) {
    if (toUTF8String(input, 12, 16) === pngFriedChunkName) {
      return {
        height: readUInt32BE(input, 36),
        width: readUInt32BE(input, 32)
      };
    }
    return {
      height: readUInt32BE(input, 20),
      width: readUInt32BE(input, 16)
    };
  }
};
const PNMTypes = {
  P1: "pbm/ascii",
  P2: "pgm/ascii",
  P3: "ppm/ascii",
  P4: "pbm",
  P5: "pgm",
  P6: "ppm",
  P7: "pam",
  PF: "pfm"
};
const handlers$1 = {
  default: (lines) => {
    let dimensions = [];
    while (lines.length > 0) {
      const line2 = lines.shift();
      if (line2[0] === "#") {
        continue;
      }
      dimensions = line2.split(" ");
      break;
    }
    if (dimensions.length === 2) {
      return {
        height: Number.parseInt(dimensions[1], 10),
        width: Number.parseInt(dimensions[0], 10)
      };
    }
    throw new TypeError("Invalid PNM");
  },
  pam: (lines) => {
    const size = {};
    while (lines.length > 0) {
      const line2 = lines.shift();
      if (line2.length > 16 || line2.charCodeAt(0) > 128) {
        continue;
      }
      const [key2, value] = line2.split(" ");
      if (key2 && value) {
        size[key2.toLowerCase()] = Number.parseInt(value, 10);
      }
      if (size.height && size.width) {
        break;
      }
    }
    if (size.height && size.width) {
      return {
        height: size.height,
        width: size.width
      };
    }
    throw new TypeError("Invalid PAM");
  }
};
const PNM = {
  validate: (input) => toUTF8String(input, 0, 2) in PNMTypes,
  calculate(input) {
    const signature = toUTF8String(input, 0, 2);
    const type2 = PNMTypes[signature];
    const lines = toUTF8String(input, 3).split(/[\r\n]+/);
    const handler = handlers$1[type2] || handlers$1.default;
    return handler(lines);
  }
};
const PSD = {
  validate: (input) => toUTF8String(input, 0, 4) === "8BPS",
  calculate: (input) => ({
    height: readUInt32BE(input, 14),
    width: readUInt32BE(input, 18)
  })
};
const svgReg = /<svg\s([^>"']|"[^"]*"|'[^']*')*>/;
const extractorRegExps = {
  height: /\sheight=(['"])([^%]+?)\1/,
  root: svgReg,
  viewbox: /\sviewBox=(['"])(.+?)\1/i,
  width: /\swidth=(['"])([^%]+?)\1/
};
const INCH_CM = 2.54;
const units = {
  in: 96,
  cm: 96 / INCH_CM,
  em: 16,
  ex: 8,
  m: 96 / INCH_CM * 100,
  mm: 96 / INCH_CM / 10,
  pc: 96 / 72 / 12,
  pt: 96 / 72,
  px: 1
};
const unitsReg = new RegExp(
  `^([0-9.]+(?:e\\d+)?)(${Object.keys(units).join("|")})?$`
);
function parseLength(len) {
  const m = unitsReg.exec(len);
  if (!m) {
    return void 0;
  }
  return Math.round(Number(m[1]) * (units[m[2]] || 1));
}
function parseViewbox(viewbox) {
  const bounds = viewbox.split(" ");
  return {
    height: parseLength(bounds[3]),
    width: parseLength(bounds[2])
  };
}
function parseAttributes(root2) {
  const width = root2.match(extractorRegExps.width);
  const height = root2.match(extractorRegExps.height);
  const viewbox = root2.match(extractorRegExps.viewbox);
  return {
    height: height && parseLength(height[2]),
    viewbox: viewbox && parseViewbox(viewbox[2]),
    width: width && parseLength(width[2])
  };
}
function calculateByDimensions(attrs) {
  return {
    height: attrs.height,
    width: attrs.width
  };
}
function calculateByViewbox(attrs, viewbox) {
  const ratio = viewbox.width / viewbox.height;
  if (attrs.width) {
    return {
      height: Math.floor(attrs.width / ratio),
      width: attrs.width
    };
  }
  if (attrs.height) {
    return {
      height: attrs.height,
      width: Math.floor(attrs.height * ratio)
    };
  }
  return {
    height: viewbox.height,
    width: viewbox.width
  };
}
const SVG = {
  // Scan only the first kilo-byte to speed up the check on larger files
  validate: (input) => svgReg.test(toUTF8String(input, 0, 1e3)),
  calculate(input) {
    const root2 = toUTF8String(input).match(extractorRegExps.root);
    if (root2) {
      const attrs = parseAttributes(root2[0]);
      if (attrs.width && attrs.height) {
        return calculateByDimensions(attrs);
      }
      if (attrs.viewbox) {
        return calculateByViewbox(attrs, attrs.viewbox);
      }
    }
    throw new TypeError("Invalid SVG");
  }
};
const TGA = {
  validate(input) {
    return readUInt16LE(input, 0) === 0 && readUInt16LE(input, 4) === 0;
  },
  calculate(input) {
    return {
      height: readUInt16LE(input, 14),
      width: readUInt16LE(input, 12)
    };
  }
};
const CONSTANTS = {
  TAG: {
    WIDTH: 256,
    HEIGHT: 257,
    COMPRESSION: 259
  },
  TYPE: {
    SHORT: 3,
    LONG: 4,
    LONG8: 16
  },
  ENTRY_SIZE: {
    STANDARD: 12,
    BIG: 20
  },
  COUNT_SIZE: {
    STANDARD: 2,
    BIG: 8
  }
};
function readIFD(input, { isBigEndian, isBigTiff }) {
  const ifdOffset = isBigTiff ? Number(readUInt64(input, 8, isBigEndian)) : readUInt(input, 32, 4, isBigEndian);
  const entryCountSize = isBigTiff ? CONSTANTS.COUNT_SIZE.BIG : CONSTANTS.COUNT_SIZE.STANDARD;
  return input.slice(ifdOffset + entryCountSize);
}
function readTagValue(input, type2, offset, isBigEndian) {
  switch (type2) {
    case CONSTANTS.TYPE.SHORT:
      return readUInt(input, 16, offset, isBigEndian);
    case CONSTANTS.TYPE.LONG:
      return readUInt(input, 32, offset, isBigEndian);
    case CONSTANTS.TYPE.LONG8: {
      const value = Number(readUInt64(input, offset, isBigEndian));
      if (value > Number.MAX_SAFE_INTEGER) {
        throw new TypeError("Value too large");
      }
      return value;
    }
    default:
      return 0;
  }
}
function nextTag(input, isBigTiff) {
  const entrySize = isBigTiff ? CONSTANTS.ENTRY_SIZE.BIG : CONSTANTS.ENTRY_SIZE.STANDARD;
  if (input.length > entrySize) {
    return input.slice(entrySize);
  }
}
function extractTags(input, { isBigEndian, isBigTiff }) {
  const tags = {};
  let temp = input;
  while (temp?.length) {
    const code = readUInt(temp, 16, 0, isBigEndian);
    const type2 = readUInt(temp, 16, 2, isBigEndian);
    const length = isBigTiff ? Number(readUInt64(temp, 4, isBigEndian)) : readUInt(temp, 32, 4, isBigEndian);
    if (code === 0) break;
    if (length === 1 && (type2 === CONSTANTS.TYPE.SHORT || type2 === CONSTANTS.TYPE.LONG || isBigTiff && type2 === CONSTANTS.TYPE.LONG8)) {
      const valueOffset = isBigTiff ? 12 : 8;
      tags[code] = readTagValue(temp, type2, valueOffset, isBigEndian);
    }
    temp = nextTag(temp, isBigTiff);
  }
  return tags;
}
function determineFormat(input) {
  const signature = toUTF8String(input, 0, 2);
  const version2 = readUInt(input, 16, 2, signature === "MM");
  return {
    isBigEndian: signature === "MM",
    isBigTiff: version2 === 43
  };
}
function validateBigTIFFHeader(input, isBigEndian) {
  const byteSize = readUInt(input, 16, 4, isBigEndian);
  const reserved = readUInt(input, 16, 6, isBigEndian);
  if (byteSize !== 8 || reserved !== 0) {
    throw new TypeError("Invalid BigTIFF header");
  }
}
const signatures = /* @__PURE__ */ new Set([
  "49492a00",
  // Little Endian
  "4d4d002a",
  // Big Endian
  "49492b00",
  // BigTIFF Little Endian
  "4d4d002b"
  // BigTIFF Big Endian
]);
const TIFF = {
  validate: (input) => {
    const signature = toHexString(input, 0, 4);
    return signatures.has(signature);
  },
  calculate(input) {
    const format = determineFormat(input);
    if (format.isBigTiff) {
      validateBigTIFFHeader(input, format.isBigEndian);
    }
    const ifdBuffer = readIFD(input, format);
    const tags = extractTags(ifdBuffer, format);
    const info = {
      height: tags[CONSTANTS.TAG.HEIGHT],
      width: tags[CONSTANTS.TAG.WIDTH],
      type: format.isBigTiff ? "bigtiff" : "tiff"
    };
    if (tags[CONSTANTS.TAG.COMPRESSION]) {
      info.compression = tags[CONSTANTS.TAG.COMPRESSION];
    }
    if (!info.width || !info.height) {
      throw new TypeError("Invalid Tiff. Missing tags");
    }
    return info;
  }
};
function calculateExtended(input) {
  return {
    height: 1 + readUInt24LE(input, 7),
    width: 1 + readUInt24LE(input, 4)
  };
}
function calculateLossless(input) {
  return {
    height: 1 + ((input[4] & 15) << 10 | input[3] << 2 | (input[2] & 192) >> 6),
    width: 1 + ((input[2] & 63) << 8 | input[1])
  };
}
function calculateLossy(input) {
  return {
    height: readInt16LE(input, 8) & 16383,
    width: readInt16LE(input, 6) & 16383
  };
}
const WEBP = {
  validate(input) {
    const riffHeader = "RIFF" === toUTF8String(input, 0, 4);
    const webpHeader = "WEBP" === toUTF8String(input, 8, 12);
    const vp8Header = "VP8" === toUTF8String(input, 12, 15);
    return riffHeader && webpHeader && vp8Header;
  },
  calculate(_input) {
    const chunkHeader = toUTF8String(_input, 12, 16);
    const input = _input.slice(20, 30);
    if (chunkHeader === "VP8X") {
      const extendedHeader = input[0];
      const validStart = (extendedHeader & 192) === 0;
      const validEnd = (extendedHeader & 1) === 0;
      if (validStart && validEnd) {
        return calculateExtended(input);
      }
      throw new TypeError("Invalid WebP");
    }
    if (chunkHeader === "VP8 " && input[0] !== 47) {
      return calculateLossy(input);
    }
    const signature = toHexString(input, 3, 6);
    if (chunkHeader === "VP8L" && signature !== "9d012a") {
      return calculateLossless(input);
    }
    throw new TypeError("Invalid WebP");
  }
};
const typeHandlers = /* @__PURE__ */ new Map([
  ["bmp", BMP],
  ["cur", CUR],
  ["dds", DDS],
  ["gif", GIF],
  ["heif", HEIF],
  ["icns", ICNS],
  ["ico", ICO],
  ["j2c", J2C],
  ["jp2", JP2],
  ["jpg", JPG],
  ["jxl", JXL],
  ["jxl-stream", JXLStream],
  ["ktx", KTX],
  ["png", PNG],
  ["pnm", PNM],
  ["psd", PSD],
  ["svg", SVG],
  ["tga", TGA],
  ["tiff", TIFF],
  ["webp", WEBP]
]);
const types = Array.from(typeHandlers.keys());
const firstBytes = /* @__PURE__ */ new Map([
  [0, "heif"],
  [56, "psd"],
  [66, "bmp"],
  [68, "dds"],
  [71, "gif"],
  [73, "tiff"],
  [77, "tiff"],
  [82, "webp"],
  [105, "icns"],
  [137, "png"],
  [255, "jpg"]
]);
function detector(input) {
  const byte = input[0];
  const type2 = firstBytes.get(byte);
  if (type2 && typeHandlers.get(type2).validate(input)) {
    return type2;
  }
  return types.find((type22) => typeHandlers.get(type22).validate(input));
}
const globalOptions = {
  disabledTypes: []
};
function imageSize(input) {
  const type2 = detector(input);
  if (typeof type2 !== "undefined") {
    if (globalOptions.disabledTypes.indexOf(type2) > -1) {
      throw new TypeError(`disabled file type: ${type2}`);
    }
    const size = typeHandlers.get(type2).calculate(input);
    if (size !== void 0) {
      size.type = size.type ?? type2;
      if (size.images && size.images.length > 1) {
        const largestImage = size.images.reduce((largest, current) => {
          return current.width * current.height > largest.width * largest.height ? current : largest;
        }, size.images[0]);
        size.width = largestImage.width;
        size.height = largestImage.height;
      }
      return size;
    }
  }
  throw new TypeError(`unsupported file type: ${type2}`);
}
const MaxInputSize = 1024 * 1024;
const queue = [];
let concurrency = 100;
const processQueue = async () => {
  const jobs = queue.splice(0, concurrency);
  const promises2 = jobs.map(async ({ filePath, resolve: resolve2, reject }) => {
    let handle;
    try {
      handle = await fs.promises.open(path.resolve(filePath), "r");
    } catch (err) {
      return reject(err);
    }
    try {
      const { size } = await handle.stat();
      if (size <= 0) {
        throw new Error("Empty file");
      }
      const inputSize = Math.min(size, MaxInputSize);
      const input = new Uint8Array(inputSize);
      await handle.read(input, 0, inputSize, 0);
      resolve2(imageSize(input));
    } catch (err) {
      reject(err);
    } finally {
      await handle.close();
    }
  });
  await Promise.allSettled(promises2);
  if (queue.length) setTimeout(processQueue, 100);
};
const imageSizeFromFile = async (filePath) => new Promise((resolve2, reject) => {
  queue.push({ filePath, resolve: resolve2, reject });
  processQueue();
});
function calculateFileMD5(filePath) {
  return new Promise((resolve2, reject) => {
    const hash2 = createHash("md5");
    const stream = fs__default.createReadStream(filePath);
    stream.on("data", (data) => {
      hash2.update(data);
    });
    stream.on("end", () => {
      const md5 = hash2.digest("hex");
      resolve2(md5);
    });
    stream.on("error", (err) => {
      reject(err);
    });
  });
}
function checkUriType(uri2) {
  if (uri2.startsWith("base64://")) {
    return {
      type: 3
      /* OneBotBase64 */
    };
  }
  if (uri2.startsWith("data:")) {
    return {
      type: 4
      /* DataURL */
    };
  }
  if (uri2.startsWith("http://") || uri2.startsWith("https://")) {
    return {
      type: 2
      /* RemoteURL */
    };
  }
  if (uri2.startsWith("file://")) {
    return {
      type: 1
      /* FileURL */
    };
  }
  try {
    if (fs__default.existsSync(uri2)) return {
      type: 5
      /* Path */
    };
  } catch {
  }
  return {
    type: 0
    /* Unknown */
  };
}
async function fetchFile(url2, headersInit) {
  const headers = new Headers({
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.71 Safari/537.36",
    "Host": new URL(url2).hostname,
    ...headersInit
  });
  let raw = await fetch(url2, { headers }).catch((err) => {
    if (err.cause) {
      throw err.cause;
    }
    throw err;
  });
  if (raw.status === 403 && !headers.has("Referer")) {
    headers.set("Referer", url2);
    raw = await fetch(url2, { headers }).catch((err) => {
      if (err.cause) {
        throw err.cause;
      }
      throw err;
    });
  }
  if (!raw.ok) throw new Error(`statusText: ${raw.statusText}`);
  return {
    data: Buffer.from(await raw.arrayBuffer()),
    url: raw.url
  };
}
async function uri2local(ctx, uri2, needExt) {
  const { type: type2 } = checkUriType(uri2);
  if (type2 === 1) {
    const filePath = fileURLToPath(uri2);
    if (!fs__default.existsSync(filePath)) {
      return { success: false, errMsg: "", fileName: "", path: "", isLocal: false };
    }
    const fileName = path__default.basename(filePath);
    return { success: true, errMsg: "", fileName, path: filePath, isLocal: true };
  }
  if (type2 === 5) {
    const fileName = path__default.basename(uri2);
    return { success: true, errMsg: "", fileName, path: uri2, isLocal: true };
  }
  if (type2 === 2) {
    try {
      const res = await fetchFile(uri2);
      let fileName = randomUUID();
      let filePath = path__default.join(TEMP_DIR, fileName);
      await fsPromise.writeFile(filePath, res.data);
      if (needExt) {
        const ext = (await ctx.ntFileApi.getFileType(filePath)).ext;
        fileName += `.${ext}`;
        const newPath = `${filePath}.${ext}`;
        await fsPromise.rename(filePath, newPath);
        filePath = newPath;
      }
      return { success: true, errMsg: "", fileName, path: filePath, isLocal: false };
    } catch (e) {
      const errMsg = `${uri2} , ${e.message}`;
      return { success: false, errMsg, fileName: "", path: "", isLocal: false };
    }
  }
  if (type2 === 3) {
    let filename = randomUUID();
    let filePath = path__default.join(TEMP_DIR, filename);
    const base642 = uri2.replace(/^base64:\/\//, "");
    await fsPromise.writeFile(filePath, base642, "base64");
    if (needExt) {
      const ext = (await ctx.ntFileApi.getFileType(filePath)).ext;
      filename += `.${ext}`;
      await fsPromise.rename(filePath, `${filePath}.${ext}`);
      filePath = `${filePath}.${ext}`;
    }
    return { success: true, errMsg: "", fileName: filename, path: filePath, isLocal: false };
  }
  if (type2 === 4) {
    const capture = /^data:([\w/.+-]+);base64,(.*)$/.exec(uri2);
    if (capture) {
      let filename = randomUUID();
      const [, _type, base642] = capture;
      let filePath = path__default.join(TEMP_DIR, filename);
      await fsPromise.writeFile(filePath, base642, "base64");
      if (needExt) {
        const ext = (await ctx.ntFileApi.getFileType(filePath)).ext;
        filename += `.${ext}`;
        await fsPromise.rename(filePath, `${filePath}.${ext}`);
        filePath = `${filePath}.${ext}`;
      }
      return { success: true, errMsg: "", fileName: filename, path: filePath, isLocal: false };
    }
  }
  if (type2 === 0) {
    let fileCache = await ctx.store.getFileCacheById(uri2);
    if (!fileCache?.length) {
      fileCache = await ctx.store.getFileCacheByName(uri2);
    }
    if (fileCache?.length) {
      const downloadPath = await ctx.ntFileApi.downloadMedia(
        fileCache[0].msgId,
        fileCache[0].chatType,
        fileCache[0].peerUid,
        fileCache[0].elementId,
        "",
        ""
      );
      return { success: true, errMsg: "", fileName: fileCache[0].fileName, path: downloadPath, isLocal: true };
    }
  }
  return { success: false, errMsg: "", fileName: "", path: "", isLocal: false };
}
async function getFileType(filePath) {
  try {
    const type2 = await fileType.fileTypeFromFile(filePath);
    if (!type2) {
      return {
        mime: "application/octet-stream",
        ext: path__default.extname(filePath).slice(0) || ""
      };
    }
    return {
      mime: type2.mime,
      ext: type2.ext
    };
  } catch (error2) {
    console.error("Error detecting file type:", error2);
    return {
      mime: "",
      ext: ""
    };
  }
}
async function getImageSize(path2) {
  return await imageSizeFromFile(path2);
}
const logFileName = `llbot-${(/* @__PURE__ */ new Date()).toLocaleString("zh-CN")}.log`.replace(/\//g, "-").replace(/:/g, "-");
const defaultVideoThumbB64 = "/9j/4AAQSkZJRgABAQAAAQABAAD//gAXR2VuZXJhdGVkIGJ5IFNuaXBhc3Rl/9sAhAAKBwcIBwYKCAgICwoKCw4YEA4NDQ4dFRYRGCMfJSQiHyIhJis3LyYpNCkhIjBBMTQ5Oz4+PiUuRElDPEg3PT47AQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wAARCAF/APADAREAAhEBAxEB/8QBogAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoLEAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+foBAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKCxEAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDiAayNxwagBwNAC5oAM0xBmgBM0ANJoAjY0AQsaBkTGgCM0DEpAFAC0AFMBaACgAoEJTASgQlACUwCgQ4UAOFADhQA4UAOFADxQIkBqDQUGgBwagBQaBC5pgGaAELUAMLUARs1AETGgBhNAxhoASkAUALQIKYxaBBQAUwEoAQ0CEoASmAUAOoEKKAHCgBwoAeKAHigQ7NZmoZpgLmgBd1Ahd1ABupgNLUAMLUAMY0AMJoAYaAENACUCCgAoAWgAoAWgBKYCUAJQISgApgLQAooEOFACigB4oAeKBDxQAVmaiZpgGaAFzQAbqAE3UAIWpgNJoAYTQIaaAEoAQ0CEoASgBaACgBaACmAUAJQAlAgoAKYC0AKKBCigB4FADgKBDwKAHigBuazNRM0DEzTAM0AJmgAzQAhNAhpNACGmA2gQlACUCEoAKACgBaAFpgFACUAJQAUCCmAUALQIcBQA4CgB4FADgKBDhQA4UAMzWZqNzTGJQAZoATNABmgBKAEoEIaYCUCEoASgQlABQAtABQAtMBKACgAoEFABimAYoEKBQA4CgB4FADwKBDgKAFFADhQBCazNhKAEpgFACUAFACUAFAhDTAbQISgAoEJQAUALQAtMAoAKADFABigQYoAMUALimIUCgBwFAh4FADgKAHUALQAtAENZmwlACUwEoAKAEoAKACgQlMBpoEJQAUCCgBcUAFABTAXFAC4oAMUAGKBBigAxQIKYCigQ8UAOFADhQAtAC0ALQBDWZqJQMSgBKYBQAlABQISgBKYCGgQlAC0CCgBcUAFABTAUCkA7FMAxQAYoEJQAUCCmAooEOFADxQA4UAFAC0ALQBDWZqJQAlACUxhQAlABQIKAEoASmISgBcUCCgBaACgBcUAKBQAuKYC0CEoAQ0AJQISmAooEPFADhQA4UALQAtAC0AQ1maiUAFACUAJTAKAEoAKAEoAMUxBigAxQIWgAoAKAFAoAWgBaYBQIQ0ANNACUCCmIUUAOFADxQA4UALQAtABQBFWZqFACUAFACYpgFACUAFACUAFAgxTEFABQAUALQAooAWgAoAKYDTQIaaAEpiCgQ4UAOFAh4oGOFAC0ALSAKYEdZmglABQAUDDFACUwEoASgAoAKBBQIKYBQAUALQAtAC0AJQAhpgNJoENJoATNMQCgQ8UCHigB4oAWgYtABQAUAMrM0CgAoAKADFACUxiUAJQAlAgoAKYgoAKACgYtAC0AFAhDTAQmgBhNAhpNACZpiFBoEPFAEi0CHigB1ABQAUDEoAbWZoFABQAtABTAQ0ANNAxDQAlAhaAEpiCgAoGFAC0AFABmgBCaYhpNADCaBDSaBBmgABpiJFNAEimgB4NADqAFzQAlACE0AJWZoFAC0AFAC0wEIoAaaAG0AJQAUCCgApjCgAoAKADNABmgBpNMQ0mgBpNAhhNAgzQAoNADwaAHqaAJAaBDgaYC5oATNACZoAWszQKACgBaBDqYCGgBpoAYaBiUCCgBKYBQMKACgAoAM0AITQIaTQA0mmA0mgQ3NAhKAHCgBwNADwaAHg0AOBpiFzQAZoATNAD6zNAoAKAFoEOpgBoAaaAGGmAw0AJmgAzQMM0AGaADNABmgBM0AITQIaTQAhNMQw0AJQIKAFFADhQA4GgBwNADs0xC5oAM0CDNAEtZmoUCCgBaAHUwCgBppgRtQAw0ANzQAZoAM0AGaADNABmgBKAEoAQ0ANNMQhoEJQAlMBaQDgaAFBoAcDTAdmgQuaADNAgzQBPWZqFAgoAWgBaYC0CGmmBG1AyM0ANJoATNACZoAXNABmgAzQAUAJQAhoAQ0xDTQISmAUALQAUgHA0AKDTAdmgQuaBBQAtAFiszQKACgBaAFFMAoEIaYEbUDI2oAYaAEoASgAzQAuaACgAoAKAENMQ00AJTEFAhKACgAoAXNACg0AOBoAWgQtAC0AWazNAoAKACgBaYBQIQ0AMNMYw0AMIoAbQAlMAoAKACgAzSAKYhKAENACUxBQIKACgBKACgBaAHCgQ4UALQAUAWqzNAoAKACgApgFACGgQ00xjTQAwigBCKAG4pgJQAlABQAUCCgBKACgBKYgoEFABQISgAoAWgBRQA4UALQAUCLdZmoUAFABQAlMAoASgBDQA00wENACYoATFMBpFADSKAEoEJQAUAFABQAlMQtAgoASgQUAJQAUAKKAHCgBaBBQBbrM1CgAoAKACmAUAJQAlADaYBQAlACYpgIRQA0igBpFAhtABQAUAFMAoEFABQIKAEoASgQUALQAooAWgQUAW81mbC0CCgApgFACUAIaAEpgJQAUAFABQAhFMBpFADSKAGkUCExQAYoAMUAGKADFMQYoAMUCExSATFABQIKYBQAtABQIt5qDYM0ALmgQtIApgIaAENADaACmAlAC0ALQAUwGkUANIoAaRQAmKBBigAxQAYoAMUAGKBBigBMUAJigQmKAExTAKBC0AFAFnNQaig0AKDQAtAgoASgBDQAlMBKACgAFADhQAtMBCKAGkUAIRQAmKADFABigQmKADFACYoAXFABigQmKAExQAmKBCYpgJigAoAnzUGgZoAcDQAuaBC0AJQAhoASmAlABQAtADhQAtMAoATFACEUAJigAxQAYoATFAhMUAFABQAuKADFABigBpWgBCKBCYpgJigB+ag0DNADgaBDgaAFzQITNACUAJTAKACgBRQAopgOoAWgBKAEoAKACgAoASgBpoEJQAooAWgBaBhigBMUCEIoAQigBMUAJSLCgBQaBDgaQC5oEFACUwCgBKACmAtADhQA4UALQAUAJQAUAJQAUAJQAhoENoAWgBRQAooGLQAUAGKAGkUAIRQIZSKEoGKKBDhQAUCCgAoAKBBQAUwFoGKKAHCgBaACgAoASgAoASgBCaAEoEJmgAoAUGgBQaAHZoGFABQAUANoAjpDEoAWgBaAFoEFACUALQAUCCmAUAOFAxRQAtAC0AJQAUAJQAmaBDSaAEzQAmaYBmgBQaAHA0gFzQAuaBhmgAzQAlAEdIYUALQAtAgoAKAEoEFAC0AFMAoAUUDFFAC0ALQAUAJQAhoENNACE0wEoATNABmgBc0ALmgBc0gDNAC5oATNABmgBKRQlACigB1AgoASgQlABTAWgBKACgBaBi0ALQAZoAM0AFACGgQ00wENACUAJQAUCFzQMM0ALmgAzQAZoAM0AGaQC0igoAUUALQIWgBDQISmAUAFACUAFABQAuaBi5oAM0AGaBBmgBKAEpgIaAG0AJQAUCFoAM0DDNAC5oATNABmgAzQBJUlBQAooAWgQtACGmIaaACgAoASgBKACgBc0DCgQUAGaADNABTASgBDQAlACUAFAgoAKBhQAUAFABQAlAE1SUFAxRQIWgQtMBDQIQ0AJQAlAhKBiUAFABmgBc0AGaADNABTAKACgBKAEoASgQlABQAUAFAC0AFACUAFAE1SaBQAUCHCgQtMBKBCUAJQISgBDQA00DEzQAuaADNMBc0AGaADNABQAUAJQAlABQISgAoAKACgBaACgBKAEoAnqTQSgBRQIcKBC0xCUAJQISgBKAENADDQAmaYwzQAuaADNAC0AFABQAUAFAhKACgBKACgAoAWgAoELQAlAxKAJqk0EoAWgQooELTEFADaBCUABoENNMY00ANNAwzQAZoAXNAC0AFAC0CFoASgAoASgBKACgAoAWgQtABQAUANNAyWpNAoAKBCimIWgQUCEoASmIQ0ANNADTQMaaAEoGLmgAzQAtADhQIWgBaACgQhoASgYlACUALQIWgBaACgBKAENAyWpNBKYBQIcKBC0CEoEJTAKBCUANNADDQMQ0ANoGFAC5oAUGgBwNAhRQIWgBaAENACGgBtAwoAKAFzQIXNABmgAoAQ0DJKRoJQAtAhRQSLQIKYCUCCgBDQA00AMNAxpoGNoAM0AGaAFBoAcDQIcKBDqACgBDQAhoAQ0DEoAKADNAC5oEGaBhmgAoAkpGgUCCgQooELQIKYhKACgBKAGmgBpoGMNAxDQAlAwzQIUUAOFAhwoAcKBC0AJQAhoGNNACUAFABQAZoAXNABQAUAS0ixKACgQoNAhaYgoEFACUABoAaaAGmgYw0DENAxtABQAooEOFADhQIcKAFoASgBDQAhoGJQAUAFACUALQIKBi0CJDSLEoATNAhc0CHZpiCgQUAJQIKBjTQAhoGNNAxpoATFABigBQKAHCgBwoAWgAoAKACgBKAEoASgAoASgBaAAUAOoEONIoaTQAZoAUGmIUGgQtAgzQISgAoAQ0DGmgYlAxKACgAxQAtACigBRQAtAxaACgAoATFABigBCKAG0CEoAWgBRTAUUAf//Z";
const defaultVideoThumb = Buffer.from(defaultVideoThumbB64, "base64");
async function getVideoInfo(filePath) {
  const size = fs__default.statSync(filePath).size;
  return new Promise((resolve2, reject) => {
    ffmpeg(filePath).ffprobe((err, metadata) => {
      if (err) {
        reject(err);
      } else {
        const videoStream = metadata.streams.find((s) => s.codec_type === "video");
        resolve2({
          width: videoStream?.width,
          height: videoStream?.height,
          time: parseInt(videoStream?.duration),
          format: metadata.format.format_name,
          size,
          filePath
        });
      }
    });
  });
}
function convert(ctx, input, options, outputPath) {
  return new Promise((resolve2, reject) => {
    const chunks = [];
    let command = ffmpeg(input).on("error", (err) => {
      ctx.logger.error(`FFmpeg: `, err.message);
      reject(err);
    }).on("end", () => {
      if (!outputPath) {
        resolve2(Buffer.concat(chunks));
      } else {
        resolve2(outputPath);
      }
    });
    if (options.input) {
      command = command.inputOptions(options.input);
    }
    if (options.output) {
      command = command.outputOptions(options.output);
    }
    if (!outputPath) {
      const stream = command.pipe();
      stream.on("data", (chunk) => {
        chunks.push(chunk);
      });
    } else {
      command.save(outputPath);
    }
  });
}
async function encodeSilk(ctx, filePath) {
  const file2 = await fsPromise.readFile(filePath);
  if (!isSilk(file2)) {
    ctx.logger.info(`${filePath}silk`);
    let result;
    const allowSampleRate = [8e3, 12e3, 16e3, 24e3, 32e3, 44100, 48e3];
    if (isWav(file2) && allowSampleRate.includes(getWavFileInfo(file2).fmt.sampleRate)) {
      result = await encode$2(file2, 0);
    } else {
      const input = await convert(ctx, filePath, {
        output: [
          "-ar 24000",
          "-ac 1",
          "-f s16le"
        ]
      });
      result = await encode$2(input, 24e3);
    }
    const pttPath = path__default.join(TEMP_DIR, randomUUID());
    await fsPromise.writeFile(pttPath, result.data);
    ctx.logger.info(`${filePath}!`, pttPath, `:`, result.duration);
    return {
      converted: true,
      path: pttPath,
      duration: result.duration / 1e3
    };
  } else {
    const silk = file2;
    let duration2 = 1;
    try {
      duration2 = getDuration(silk) / 1e3;
    } catch (e) {
      ctx.logger.warn(", 1", filePath, e.stack);
    }
    return {
      converted: false,
      path: filePath,
      duration: duration2
    };
  }
}
async function decodeSilk(ctx, inputFilePath, outFormat) {
  const silk = await fsPromise.readFile(inputFilePath);
  const { data } = await decode$2(silk, 24e3);
  const tmpPath = path__default.join(TEMP_DIR, path__default.basename(inputFilePath));
  const outFilePath = tmpPath + `.${outFormat}`;
  const pcmFilePath = tmpPath + ".pcm";
  await fsPromise.writeFile(pcmFilePath, data);
  return convert(ctx, pcmFilePath, {
    input: [
      "-f s16le",
      "-ar 24000",
      "-ac 1"
    ]
  }, outFilePath);
}
const audio = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decodeSilk,
  encodeSilk
}, Symbol.toStringTag, { value: "Module" }));
var SendElement;
((SendElement2) => {
  function text(content) {
    return {
      elementType: ElementType.Text,
      elementId: "",
      textElement: {
        content,
        atType: AtType.Unknown,
        atUid: "",
        atTinyId: "",
        atNtUid: ""
      }
    };
  }
  SendElement2.text = text;
  function at(atUid, atNtUid, atType, display) {
    return {
      elementType: ElementType.Text,
      elementId: "",
      textElement: {
        content: display,
        atType,
        atUid,
        atTinyId: "",
        atNtUid
      }
    };
  }
  SendElement2.at = at;
  function reply(msgSeq, msgId, senderUid) {
    return {
      elementType: ElementType.Reply,
      elementId: "",
      replyElement: {
        replayMsgId: msgId,
        replayMsgSeq: msgSeq,
        senderUid,
        senderUidStr: senderUid
      }
    };
  }
  SendElement2.reply = reply;
  async function pic(ctx, picPath, summary = "", subType = 0, isFlashPic) {
    const { md5, fileName, path: path2, fileSize } = await ctx.ntFileApi.uploadFile(picPath, ElementType.Pic, subType);
    if (fileSize === 0) {
      throw new Error(" 0");
    }
    const imageSize2 = await ctx.ntFileApi.getImageSize(picPath);
    const picElement = {
      md5HexStr: md5,
      fileSize: fileSize.toString(),
      picWidth: imageSize2.width,
      picHeight: imageSize2.height,
      fileName,
      sourcePath: path2,
      original: true,
      picType: imageSize2.type === "gif" ? PicType.GIF : PicType.JPEG,
      picSubType: subType,
      fileUuid: "",
      fileSubId: "",
      thumbFileSize: 0,
      summary,
      isFlashPic
    };
    ctx.logger.info("", picElement);
    return {
      elementType: ElementType.Pic,
      elementId: "",
      picElement
    };
  }
  SendElement2.pic = pic;
  async function file2(ctx, filePath, fileName, folderId) {
    const fileSize = (await stat(filePath)).size.toString();
    if (fileSize === "0") {
      ctx.logger.warn(`${fileName} 0`);
      throw new Error(" 0");
    }
    const element = {
      elementType: ElementType.File,
      elementId: "",
      fileElement: {
        fileName,
        folderId,
        fileBizId: void 0,
        filePath,
        fileSize
      }
    };
    return element;
  }
  SendElement2.file = file2;
  async function video2(ctx, filePath, diyThumbPath = "") {
    await access(filePath);
    const { fileName, path: path2, fileSize, md5 } = await ctx.ntFileApi.uploadFile(filePath, ElementType.Video);
    if (fileSize === 0) {
      throw new Error(" 0");
    }
    const maxMB = 100;
    if (fileSize > 1024 * 1024 * maxMB) {
      throw new Error(`${maxMB}MB${fileSize}B`);
    }
    const thumbDir = path__default.dirname(path2.replaceAll("\\", "/").replace(`/Ori/`, `/Thumb/`));
    let videoInfo = {
      width: 1920,
      height: 1080,
      time: 15,
      format: "mp4",
      size: fileSize,
      filePath
    };
    try {
      videoInfo = await getVideoInfo(path2);
      ctx.logger.info("", videoInfo);
    } catch (e) {
      ctx.logger.info("", e);
    }
    const createThumb = new Promise((resolve2, reject) => {
      const thumbFileName = `${md5}_0.png`;
      const thumbPath2 = path__default.join(thumbDir, thumbFileName);
      ctx.logger.info("", filePath);
      let completed = false;
      function useDefaultThumb() {
        if (completed) return;
        ctx.logger.info("");
        writeFile(thumbPath2, defaultVideoThumb).then(() => {
          resolve2(thumbPath2);
        }).catch(reject);
      }
      setTimeout(useDefaultThumb, 5e3);
      ffmpeg(filePath).on("error", () => {
        if (diyThumbPath) {
          copyFile(diyThumbPath, thumbPath2).then(() => {
            completed = true;
            resolve2(thumbPath2);
          }).catch(reject);
        } else {
          useDefaultThumb();
        }
      }).screenshots({
        timestamps: [0],
        filename: thumbFileName,
        folder: thumbDir,
        size: videoInfo.width + "x" + videoInfo.height
      }).on("end", () => {
        completed = true;
        resolve2(thumbPath2);
      });
    });
    const thumbPath = /* @__PURE__ */ new Map();
    const _thumbPath = await createThumb;
    ctx.logger.info("", _thumbPath);
    const thumbSize = (await stat(_thumbPath)).size;
    thumbPath.set(0, _thumbPath);
    const thumbMd5 = await calculateFileMD5(_thumbPath);
    const element = {
      elementType: ElementType.Video,
      elementId: "",
      videoElement: {
        fileName,
        filePath: path2,
        videoMd5: md5,
        thumbMd5,
        fileTime: videoInfo.time,
        thumbPath,
        thumbSize,
        thumbWidth: videoInfo.width,
        thumbHeight: videoInfo.height,
        fileSize: String(fileSize)
      }
    };
    ctx.logger.info("videoElement", element);
    return element;
  }
  SendElement2.video = video2;
  async function ptt(ctx, pttPath) {
    const { converted, path: silkPath, duration: duration2 } = await encodeSilk(ctx, pttPath);
    const { md5, fileName, path: path2, fileSize } = await ctx.ntFileApi.uploadFile(silkPath, ElementType.Ptt);
    if (fileSize === 0) {
      throw new Error(" 0");
    }
    if (converted) {
      unlink(silkPath).then().catch((e) => {
      });
    }
    return {
      elementType: ElementType.Ptt,
      elementId: "",
      pttElement: {
        fileName,
        filePath: path2,
        md5HexStr: md5,
        fileSize: String(fileSize),
        duration: duration2,
        formatType: 1,
        voiceType: 1,
        voiceChangeType: 0,
        canConvert2Text: true,
        waveAmplitudes: [0, 18, 9, 23, 16, 17, 16, 15, 44, 17, 24, 20, 14, 15, 17],
        fileSubId: "",
        playState: 1,
        autoConvertText: 0,
        storeID: 0,
        otherBusinessInfo: {
          aiVoiceType: 0
        }
      }
    };
  }
  SendElement2.ptt = ptt;
  function face(faceId, faceType) {
    const sysFaces = faceConfig.sysface;
    const face2 = sysFaces.find((face3) => face3.QSid === String(faceId));
    if (!faceType) {
      if (faceId < 222) {
        faceType = 1;
      } else if (faceId < 1e5) {
        faceType = 2;
      } else {
        faceType = 4;
      }
      if (face2?.AniStickerType) {
        faceType = 3;
      }
    }
    return {
      elementType: ElementType.Face,
      elementId: "",
      faceElement: {
        faceIndex: faceId,
        faceType,
        faceText: face2?.QDes,
        stickerId: face2?.AniStickerId,
        stickerType: face2?.AniStickerType,
        packId: face2?.AniStickerPackId,
        sourceType: 1
      }
    };
  }
  SendElement2.face = face;
  function mface(emojiPackageId, emojiId, key2, summary) {
    return {
      elementType: ElementType.MarketFace,
      elementId: "",
      marketFaceElement: {
        imageWidth: 300,
        imageHeight: 300,
        emojiPackageId,
        emojiId,
        key: key2,
        faceName: summary || "[]"
      }
    };
  }
  SendElement2.mface = mface;
  function dice(resultId) {
    if (isNullable(resultId)) resultId = Math.floor(Math.random() * 6) + 1;
    return {
      elementType: ElementType.Face,
      elementId: "",
      faceElement: {
        faceIndex: FaceIndex.Dice,
        faceType: 3,
        faceText: "[]",
        packId: "1",
        stickerId: "33",
        sourceType: 1,
        stickerType: 2,
        resultId: resultId.toString(),
        surpriseId: ""
        // "randomType": 1,
      }
    };
  }
  SendElement2.dice = dice;
  function rps(resultId) {
    if (isNullable(resultId)) resultId = Math.floor(Math.random() * 3) + 1;
    return {
      elementType: ElementType.Face,
      elementId: "",
      faceElement: {
        faceIndex: FaceIndex.RPS,
        faceText: "[]",
        faceType: 3,
        packId: "1",
        stickerId: "34",
        sourceType: 1,
        stickerType: 2,
        resultId: resultId.toString(),
        surpriseId: ""
        // "randomType": 1,
      }
    };
  }
  SendElement2.rps = rps;
  function ark(data) {
    return {
      elementType: ElementType.Ark,
      elementId: "",
      arkElement: {
        bytesData: data,
        linkInfo: null,
        subElementType: null
      }
    };
  }
  SendElement2.ark = ark;
  function shake() {
    return {
      elementType: ElementType.Face,
      elementId: "",
      faceElement: {
        faceIndex: 1,
        faceType: 5,
        pokeType: 1
      }
    };
  }
  SendElement2.shake = shake;
})(SendElement || (SendElement = {}));
async function sleep(ms2) {
  return new Promise((resolve2) => setTimeout(resolve2, ms2));
}
class MusicSign {
  constructor(ctx, url2) {
    this.ctx = ctx;
    this.url = url2;
  }
  url;
  async sign(postData) {
    const resp = await fetch(this.url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(postData)
    });
    if (!resp.ok) throw new Error(resp.statusText);
    const data = await resp.text();
    this.ctx.logger.info("", data);
    return data;
  }
}
async function createSendElements(ctx, messageData, peer, ignoreTypes = []) {
  const sendElements = [];
  const deleteAfterSentFiles = [];
  for (const segment of messageData) {
    if (ignoreTypes.includes(segment.type)) {
      continue;
    }
    switch (segment.type) {
      case OB11MessageDataType.Text:
        {
          const text = segment.data?.text;
          if (text) {
            sendElements.push(SendElement.text(segment.data.text));
          }
        }
        break;
      case OB11MessageDataType.At:
        {
          if (!peer) {
            continue;
          }
          if (segment.data?.qq) {
            const atQQ = String(segment.data.qq);
            if (atQQ === "all") {
              const groupCode = peer.peerUid;
              let remainAtAllCount = 1;
              let isAdmin = true;
              if (groupCode) {
                try {
                  remainAtAllCount = (await ctx.ntGroupApi.getGroupRemainAtTimes(groupCode)).atInfo.RemainAtAllCountForUin;
                  ctx.logger.info(`${groupCode}at`, remainAtAllCount);
                  const self2 = await ctx.ntGroupApi.getGroupMember(groupCode, selfInfo.uid);
                  isAdmin = self2?.role === GroupMemberRole.Admin || self2?.role === GroupMemberRole.Owner;
                } catch (e) {
                }
              }
              if (isAdmin && remainAtAllCount > 0) {
                sendElements.push(SendElement.at(atQQ, atQQ, AtType.All, "@"));
              }
            } else if (peer.chatType === ChatType.Group) {
              const uid = await ctx.ntUserApi.getUidByUin(atQQ, peer.peerUid) ?? "";
              let display = "";
              if (segment.data.name) {
                display = `@${segment.data.name}`;
              }
              sendElements.push(SendElement.at(atQQ, uid, AtType.One, display));
            }
          }
        }
        break;
      case OB11MessageDataType.Reply:
        {
          if (segment.data?.id) {
            const info = await ctx.store.getMsgInfoByShortId(+segment.data.id);
            if (!info) {
              ctx.logger.warn("", info);
              continue;
            }
            const source2 = (await ctx.ntMsgApi.getMsgsByMsgId(info.peer, [info.msgId])).msgList[0];
            if (source2) {
              sendElements.push(SendElement.reply(source2.msgSeq, source2.msgId, source2.senderUid));
            }
          }
        }
        break;
      case OB11MessageDataType.Face:
        {
          const faceId = segment.data?.id;
          const faceType = segment.data?.sub_type;
          if (faceId) {
            sendElements.push(SendElement.face(parseInt(faceId), faceType));
          }
        }
        break;
      case OB11MessageDataType.Mface:
        {
          sendElements.push(
            SendElement.mface(
              +segment.data.emoji_package_id,
              segment.data.emoji_id,
              segment.data.key,
              segment.data.summary
            )
          );
        }
        break;
      case OB11MessageDataType.Image:
        {
          const res = await SendElement.pic(
            ctx,
            (await handleOb11RichMedia(ctx, segment, deleteAfterSentFiles)).path,
            segment.data.summary || "",
            segment.data.subType || 0,
            segment.data.type === "flash"
          );
          deleteAfterSentFiles.push(res.picElement.sourcePath);
          sendElements.push(res);
        }
        break;
      case OB11MessageDataType.File:
        {
          const { path: path2, fileName } = await handleOb11RichMedia(ctx, segment, deleteAfterSentFiles);
          sendElements.push(await SendElement.file(ctx, path2, fileName));
        }
        break;
      case OB11MessageDataType.Video:
        {
          const { path: path2 } = await handleOb11RichMedia(ctx, segment, deleteAfterSentFiles);
          let thumb = segment.data.thumb;
          if (thumb) {
            const uri2LocalRes = await uri2local(ctx, thumb);
            if (uri2LocalRes.success) thumb = uri2LocalRes.path;
          }
          const res = await SendElement.video(ctx, path2, thumb);
          deleteAfterSentFiles.push(res.videoElement.filePath);
          sendElements.push(res);
        }
        break;
      case OB11MessageDataType.Record:
        {
          const { path: path2 } = await handleOb11RichMedia(ctx, segment, deleteAfterSentFiles);
          sendElements.push(await SendElement.ptt(ctx, path2));
        }
        break;
      case OB11MessageDataType.Json:
        {
          sendElements.push(SendElement.ark(segment.data.data));
        }
        break;
      case OB11MessageDataType.Dice:
        {
          const resultId = segment.data?.result;
          sendElements.push(SendElement.dice(resultId));
        }
        break;
      case OB11MessageDataType.Rps:
        {
          const resultId = segment.data?.result;
          sendElements.push(SendElement.rps(resultId));
        }
        break;
      case OB11MessageDataType.Contact:
        {
          const { type: type2, id: id2 } = segment.data;
          const data = type2 === "qq" ? ctx.ntFriendApi.getBuddyRecommendContact(id2) : ctx.ntGroupApi.getGroupRecommendContact(id2);
          sendElements.push(SendElement.ark(await data));
        }
        break;
      case OB11MessageDataType.Shake:
        {
          sendElements.push(SendElement.shake());
        }
        break;
      case OB11MessageDataType.Music:
        {
          const { musicSignUrl } = ctx.config;
          if (!musicSignUrl) {
            throw new Error("");
          }
          const { type: type2 } = segment.data;
          if (!["qq", "163", "kugou", "kuwo", "migu", "custom"].includes(type2)) {
            throw new Error(` type ${type2}`);
          }
          if (type2 === "custom") {
            if (!segment.data.url) {
              throw new Error("url");
            }
            if (!segment.data.title) {
              throw new Error("title");
            }
          } else {
            if (!segment.data.id) {
              throw new Error("id");
            }
          }
          let postData;
          if (type2 === "custom" && segment.data.content) {
            const { content, ...others } = segment.data;
            postData = { singer: content, ...others };
          } else {
            postData = segment.data;
          }
          try {
            const content = await new MusicSign(ctx, musicSignUrl).sign(postData);
            if (!content) {
              throw new Error("");
            }
            sendElements.push(SendElement.ark(content));
          } catch (e) {
            throw new Error(`${e}`);
          }
        }
        break;
      case OB11MessageDataType.Forward:
        {
          let resid;
          let filename;
          let source2 = "";
          let news = [{
            text: ""
          }];
          let summary = "";
          if (isNumeric(segment.data.id)) {
            const shortId = await ctx.store.getShortIdByMsgId(segment.data.id);
            if (!shortId) {
              throw new Error("msg not found");
            }
            const rootMsg = await ctx.store.getMsgInfoByShortId(shortId);
            if (!rootMsg) {
              throw new Error("msg not found");
            }
            const msg = await ctx.ntMsgApi.getMsgsByMsgId(rootMsg.peer, [rootMsg.msgId]);
            const { multiForwardMsgElement } = msg.msgList[0].elements[0];
            resid = multiForwardMsgElement.resId;
            filename = multiForwardMsgElement.fileName;
            const { xmlContent } = multiForwardMsgElement;
            const titles = Array.from(xmlContent.matchAll(/<title[^>]*>([^<]*)<\/title>/g));
            source2 = titles[0][1];
            news = titles.slice(1).map((e) => {
              return { text: e[1] };
            });
            summary = xmlContent.match(/<summary[^>]*>([^<]*)<\/summary>/)[1];
          }
          resid ??= segment.data.id;
          filename ??= randomUUID();
          const content = JSON.stringify({
            app: "com.tencent.multimsg",
            config: {
              autosize: 1,
              forward: 1,
              round: 1,
              type: "normal",
              width: 300
            },
            desc: "[]",
            extra: JSON.stringify({
              filename,
              tsum: 0
            }),
            meta: {
              detail: {
                news,
                resid,
                source: source2,
                summary,
                uniseq: filename
              }
            },
            prompt: "[]",
            ver: "0.0.0.5",
            view: "contact"
          });
          sendElements.push(SendElement.ark(content));
        }
        break;
    }
  }
  return {
    sendElements,
    deleteAfterSentFiles
  };
}
function message2List(message, autoEscape = false) {
  if (typeof message === "string") {
    if (autoEscape === true) {
      return [
        {
          type: OB11MessageDataType.Text,
          data: {
            text: message
          }
        }
      ];
    } else {
      return decodeCQCode(message);
    }
  } else if (!Array.isArray(message)) {
    return [message];
  }
  return message;
}
var CreatePeerMode = /* @__PURE__ */ ((CreatePeerMode2) => {
  CreatePeerMode2[CreatePeerMode2["Normal"] = 0] = "Normal";
  CreatePeerMode2[CreatePeerMode2["Private"] = 1] = "Private";
  CreatePeerMode2[CreatePeerMode2["Group"] = 2] = "Group";
  return CreatePeerMode2;
})(CreatePeerMode || {});
async function createPeer(ctx, payload, mode2 = 0) {
  if ((mode2 === 2 || mode2 === 0) && payload.group_id) {
    return {
      chatType: ChatType.Group,
      peerUid: payload.group_id.toString(),
      guildId: ""
    };
  }
  if ((mode2 === 1 || mode2 === 0) && payload.user_id) {
    const uid = await ctx.ntUserApi.getUidByUin(payload.user_id.toString(), payload.group_id?.toString());
    if (!uid) throw new Error("");
    const isBuddy = await ctx.ntFriendApi.isBuddy(uid);
    if (!isBuddy) {
      const res = await ctx.ntMsgApi.getTempChatInfo(ChatType.TempC2CFromGroup, uid);
      if (res.tmpChatInfo.groupCode) {
        return {
          chatType: ChatType.TempC2CFromGroup,
          peerUid: uid,
          guildId: ""
        };
      }
    }
    return {
      chatType: ChatType.C2C,
      peerUid: uid,
      guildId: ""
    };
  }
  throw new Error(" group_id  user_id");
}
async function handleOb11RichMedia(ctx, segment, deleteAfterSentFiles) {
  const res = await uri2local(ctx, segment.data.url || segment.data.file);
  if (!res.success) {
    ctx.logger.error(res.errMsg);
    throw new Error(res.errMsg);
  }
  if (!res.isLocal) {
    deleteAfterSentFiles.push(res.path);
  }
  return { path: res.path, fileName: segment.data.name || res.fileName };
}
async function handleQuickOperation(ctx, event, quickAction) {
  if (event.post_type === "message") {
    handleMsg(ctx, event, quickAction).then().catch((e) => ctx.logger.error(e));
  }
  if (event.post_type === "request") {
    const friendRequest = event;
    const groupRequest = event;
    if (friendRequest.request_type === "friend") {
      handleFriendRequest$1(ctx, friendRequest, quickAction).then().catch((e) => ctx.logger.error(e));
    } else if (groupRequest.request_type === "group") {
      handleGroupRequest(ctx, groupRequest, quickAction).then().catch((e) => ctx.logger.error(e));
    }
  }
}
async function handleMsg(ctx, msg, quickAction) {
  const reply = quickAction.reply;
  let contextMode = CreatePeerMode.Normal;
  if (msg.message_type === "group") {
    contextMode = CreatePeerMode.Group;
  } else if (msg.message_type === "private") {
    contextMode = CreatePeerMode.Private;
  }
  const peer = await createPeer(ctx, msg, contextMode);
  if (reply) {
    let replyMessage = [];
    replyMessage.push({
      type: OB11MessageDataType.Reply,
      data: {
        id: msg.message_id.toString()
      }
    });
    if (msg.message_type == "group") {
      if (quickAction.at_sender) {
        replyMessage.push({
          type: OB11MessageDataType.At,
          data: {
            qq: msg.user_id.toString()
          }
        });
      }
    }
    replyMessage = replyMessage.concat(message2List(reply, quickAction.auto_escape));
    const { sendElements, deleteAfterSentFiles } = await createSendElements(ctx, replyMessage, peer);
    ctx.app.sendMessage(ctx, peer, sendElements, deleteAfterSentFiles).catch((e) => ctx.logger.error(e));
  }
  if (msg.message_type === "group") {
    const groupMsgQuickAction = quickAction;
    const rawMessage = await ctx.store.getMsgInfoByShortId(+(msg.message_id ?? 0));
    if (!rawMessage) return;
    if (groupMsgQuickAction.delete) {
      ctx.ntMsgApi.recallMsg(peer, [rawMessage.msgId]).catch((e) => ctx.logger.error(e));
    }
    if (groupMsgQuickAction.kick) {
      const { msgList } = await ctx.ntMsgApi.getMsgsByMsgId(peer, [rawMessage.msgId]);
      ctx.ntGroupApi.kickMember(peer.peerUid, [msgList[0].senderUid]).catch((e) => ctx.logger.error(e));
    }
    if (groupMsgQuickAction.ban) {
      const { msgList } = await ctx.ntMsgApi.getMsgsByMsgId(peer, [rawMessage.msgId]);
      ctx.ntGroupApi.banMember(peer.peerUid, [
        {
          uid: msgList[0].senderUid,
          timeStamp: groupMsgQuickAction.ban_duration || 60 * 30
        }
      ]).catch((e) => ctx.logger.error(e));
    }
  }
}
async function handleFriendRequest$1(ctx, request2, quickAction) {
  if (!isNullable(quickAction.approve)) {
    const data = request2.flag.split("|");
    if (data.length < 2) {
      return;
    }
    const uid = data[0];
    const reqTime = data[1];
    await ctx.ntFriendApi.handleFriendRequest(uid, reqTime, quickAction.approve).catch((e) => ctx.logger.error(e));
    if (!isNullable(quickAction.remark)) {
      ctx.ntFriendApi.setBuddyRemark(uid, quickAction.remark).catch((e) => ctx.logger.error(e));
    }
  }
}
async function handleGroupRequest(ctx, request2, quickAction) {
  if (!isNullable(quickAction.approve)) {
    ctx.ntGroupApi.handleGroupRequest(
      request2.flag,
      quickAction.approve ? GroupRequestOperateTypes.Approve : GroupRequestOperateTypes.Reject,
      quickAction.reason
    ).catch((e) => ctx.logger.error(e));
  }
}
let curentSeq = 0;
const eventList = [];
const httpUser = {};
function postHttpEvent(event) {
  curentSeq += 1;
  eventList.push({
    seq: curentSeq,
    event
  });
  while (eventList.length > 100) {
    eventList.shift();
  }
}
async function getHttpEvent(userKey, timeout2 = 0) {
  if (typeof userKey !== "string" || userKey === "__proto__" || userKey === "constructor" || userKey === "prototype") {
    throw new Error("Invalid user key");
  }
  const toRetEvent = [];
  const now = Date.now();
  for (const key2 in httpUser) {
    const user2 = httpUser[key2];
    if (now - user2.lastAccessTime > 1e3 * 60 * 5) {
      delete httpUser[key2];
    }
  }
  const userKeys = Object.keys(httpUser);
  if (userKeys.length > 100) {
    const oldestKey = userKeys.reduce(
      (oldest, current) => httpUser[current].lastAccessTime < httpUser[oldest].lastAccessTime ? current : oldest
    );
    delete httpUser[oldestKey];
  }
  if (!httpUser[userKey]) {
    httpUser[userKey] = {
      lastAccessTime: now,
      userSeq: curentSeq
    };
  }
  const user = httpUser[userKey];
  while (curentSeq == user.userSeq && Date.now() - now < timeout2) {
    await new Promise((resolve2) => setTimeout(resolve2, 10));
  }
  for (let i = 0; i < eventList.length; i++) {
    const evt = eventList[i];
    if (evt.seq > user.userSeq) {
      toRetEvent.push(evt.event);
    }
  }
  user.lastAccessTime = Date.now();
  user.userSeq = curentSeq;
  return toRetEvent;
}
class OB11Http {
  constructor(ctx, config2) {
    this.ctx = ctx;
    this.config = config2;
    this.expressAPP = express();
  }
  expressAPP;
  server;
  sseClients = [];
  sockets = /* @__PURE__ */ new Set();
  activated = false;
  start() {
    if (this.server || !this.config.enable) {
      return;
    }
    try {
      this.expressAPP.use(cors());
      this.expressAPP.use(express.urlencoded({ extended: true, limit: "5000mb" }));
      this.expressAPP.use((req, res, next) => {
        req.headers["content-type"] = "application/json";
        const originalJson = express.json({ limit: "5000mb" });
        originalJson(req, res, (err) => {
          if (err) {
            this.ctx.logger.error("Error parsing JSON:", err);
            return res.status(400).send("Invalid JSON");
          }
          next();
        });
      });
      this.expressAPP.use((req, res, next) => this.authorize(req, res, next));
      this.expressAPP.use((req, res, next) => this.handleRequest(req, res, next));
      this.expressAPP.get("/", (req, res) => {
        res.send(`ok`);
      });
      const host = this.config.onlyLocalhost ? "127.0.0.1" : "";
      this.expressAPP.get("/_events", (req, res) => {
        res.setHeader("Content-Type", "text/event-stream; charset=utf-8");
        res.setHeader("Cache-Control", "no-cache");
        res.setHeader("Connection", "keep-alive");
        res.setHeader("X-Accel-Buffering", "no");
        res.flushHeaders();
        this.sseClients.push(res);
        req.on("close", () => {
          const index2 = this.sseClients.indexOf(res);
          if (index2 > -1) {
            this.sseClients.splice(index2, 1);
          }
        });
        req.on("error", () => {
          const index2 = this.sseClients.indexOf(res);
          if (index2 > -1) {
            this.sseClients.splice(index2, 1);
          }
        });
      });
      this.ctx.logger.info(`OneBot V11 HTTP SSE started ${host}:${this.config.port}/_events`);
      try {
        this.server = this.expressAPP.listen(this.config.port, host, (err) => {
          if (err) {
            this.ctx.logger.error("OneBot V11 HTTP server start error:", err);
          }
          this.ctx.logger.info(`OneBot V11 HTTP server started ${host}:${this.config.port}`);
        });
        this.server.on("connection", (socket) => {
          this.sockets.add(socket);
          socket.on("close", () => this.sockets.delete(socket));
        });
      } catch (e) {
        this.ctx.logger.error(`OneBot V11 HTTP server error ${host}:${this.config.port}`, e);
      }
      this.activated = true;
    } catch (e) {
      this.ctx.logger.error("OneBot V11 HTTP", e);
    }
  }
  stop() {
    return new Promise((resolve2) => {
      if (this.server) {
        this.ctx.logger.info("OneBot V11 HTTP Server closing...");
        for (const socket of this.sockets) {
          socket.destroy();
        }
        this.sockets.clear();
        this.server.close((err) => {
          if (err) {
            this.ctx.logger.error(`OneBot V11 HTTP Server closing ${err}`);
            this.server = void 0;
            return resolve2(false);
          }
          this.ctx.logger.info("OneBot V11 HTTP Server closed");
          this.server = void 0;
          resolve2(true);
        });
      } else {
        resolve2(true);
      }
      this.activated = false;
    });
  }
  async emitEvent(event) {
    postHttpEvent(event);
    if (!this.activated) return;
    if (this.sseClients.length === 0) {
      return;
    }
    const data = `data: ${JSON.stringify(event)}

`;
    for (const client of this.sseClients) {
      if (!client.closed) {
        client.write(data);
        if ("post_type" in event) {
          const eventName = event.getSummaryEventName();
          this.ctx.logger.info("OneBot V11 HTTP SSE ", eventName);
        }
      }
    }
  }
  async emitMessageLikeEvent(event, self2, offline) {
    if (self2 && !this.config.reportSelfMessage) {
      return;
    }
    if (offline && !this.config.reportOfflineMessage) {
      return;
    }
    if (event.post_type === "message" || event.post_type === "message_sent") {
      const msg = event;
      if (!this.config.debug && msg.message.length === 0) {
        return;
      }
      if (!this.config.debug) {
        delete msg.raw;
      }
      if (this.config.messageFormat === "string") {
        msg.message = msg.raw_message;
        msg.message_format = "string";
      }
    }
    await this.emitEvent(event);
  }
  updateConfig(config2) {
    Object.assign(this.config, config2);
  }
  authorize(req, res, next) {
    const serverToken = this.config.token;
    if (!serverToken) return next();
    let clientToken = "";
    const authHeader = req.get("authorization");
    if (authHeader) {
      clientToken = authHeader.split("Bearer ").pop();
      this.ctx.logger.info("receive http header token", clientToken);
    } else if (req.query.access_token) {
      if (Array.isArray(req.query.access_token)) {
        clientToken = req.query.access_token[0].toString();
      } else {
        clientToken = req.query.access_token.toString();
      }
      this.ctx.logger.info("receive http url token", clientToken);
    }
    if (clientToken !== serverToken) {
      res.status(403).json({ message: "403" });
    } else {
      next();
    }
  }
  async handleRequest(req, res, next) {
    if (req.path === "/") {
      return next();
    }
    if (req.path === "/_events") {
      return next();
    }
    let payload = req.body;
    if (req.method === "GET") {
      payload = req.query;
    } else if (req.query) {
      payload = { ...req.query, ...req.body };
    }
    this.ctx.logger.info(" HTTP ", req.url, payload);
    const actionName = req.path.replaceAll("/", "");
    const action = this.config.actionMap.get(actionName);
    if (action) {
      res.json(await action.handle(payload, {
        messageFormat: this.config.messageFormat,
        debug: this.config.debug
      }));
    } else {
      res.status(404).json(OB11Response.error(`${actionName} API `, 404));
    }
  }
}
class OB11HttpPost {
  constructor(ctx, config2) {
    this.ctx = ctx;
    this.config = config2;
  }
  disposeInterval;
  activated = false;
  start() {
    this.activated = this.config.enable;
    if (this.config.enableHeart && !this.disposeInterval) {
      this.disposeInterval = this.ctx.setInterval(() => {
        this.emitEvent(new OB11HeartbeatEvent(selfInfo.online, true, this.config.heartInterval));
      }, this.config.heartInterval);
    }
  }
  stop() {
    this.activated = false;
    this.disposeInterval?.();
  }
  async emitEvent(event) {
    if (!this.activated || !this.config.url) {
      return;
    }
    const msgStr = JSON.stringify(event);
    const headers = {
      "Content-Type": "application/json",
      "x-self-id": selfInfo.uin
    };
    if (this.config.token) {
      const hmac = crypto$1.createHmac("sha1", this.config.token);
      hmac.update(msgStr);
      const sig = hmac.digest("hex");
      headers["x-signature"] = "sha1=" + sig;
    }
    const host = this.config.url;
    fetch(host, {
      method: "POST",
      headers,
      body: msgStr
    }).then(
      async (res) => {
        if (event.post_type) {
          const eventName = event.post_type + "." + event[event.post_type + "_type"];
          this.ctx.logger.info(`HTTP : ${host}`, eventName, res.status);
        }
        try {
          const resJson = await res.json();
          this.ctx.logger.info(`HTTP :`, JSON.stringify(resJson));
          handleQuickOperation(this.ctx, event, resJson).catch((e) => this.ctx.logger.error(e));
        } catch (e) {
        }
      },
      (err) => {
        this.ctx.logger.error(`HTTP : ${host}`, err, event);
      }
    ).catch((e) => {
      this.ctx.logger.error(`HTTP : ${host}`, e);
    });
  }
  async emitMessageLikeEvent(event, self2, offline) {
    if (self2 && !this.config.reportSelfMessage) {
      return;
    }
    if (offline && !this.config.reportOfflineMessage) {
      return;
    }
    if (event.post_type === "message" || event.post_type === "message_sent") {
      const msg = event;
      if (!this.config.debug && msg.message.length === 0) {
        return;
      }
      if (!this.config.debug) {
        delete msg.raw;
      }
      if (this.config.messageFormat === "string") {
        msg.message = msg.raw_message;
        msg.message_format = "string";
      }
    }
    await this.emitEvent(event);
  }
  updateConfig(config2) {
    Object.assign(this.config, config2);
  }
}
class BaseAction {
  constructor(adapter) {
    this.adapter = adapter;
    this.ctx = adapter.ctx;
  }
  ctx;
  payloadSchema;
  async handle(payload, config2) {
    let params;
    try {
      params = this.payloadSchema ? new this.payloadSchema(payload) : payload;
    } catch (e) {
      return OB11Response.error(e.message, 400);
    }
    try {
      const resData = await this._handle(params, config2);
      return OB11Response.ok(resData);
    } catch (e) {
      this.ctx.logger.error("", e);
      return OB11Response.error(e.message, 200);
    }
  }
  async websocketHandle(payload, echo, config2) {
    let params;
    try {
      params = this.payloadSchema ? new this.payloadSchema(payload) : payload;
    } catch (e) {
      return OB11Response.error(e.message, 1400);
    }
    try {
      const resData = await this._handle(params, config2);
      return OB11Response.ok(resData, echo);
    } catch (e) {
      this.ctx.logger.error("", e);
      return OB11Response.error(e.message, 1200, echo);
    }
  }
}
var ActionName = /* @__PURE__ */ ((ActionName2) => {
  ActionName2["ScanQRCode"] = "scan_qrcode";
  ActionName2["GetGroupAlbumList"] = "get_group_album_list";
  ActionName2["CreateGroupAlbum"] = "create_group_album";
  ActionName2["DeleteGroupAlbum"] = "delete_group_album";
  ActionName2["UploadGroupAlbum"] = "upload_group_album";
  ActionName2["BatchDeleteGroupMember"] = "batch_delete_group_member";
  ActionName2["GetFlashFileInfo"] = "get_flash_file_info";
  ActionName2["DownloadFlashFile"] = "download_flash_file";
  ActionName2["UploadFlashFile"] = "upload_flash_file";
  ActionName2["GetRKey"] = "get_rkey";
  ActionName2["SendPB"] = "send_pb";
  ActionName2["VoiceMsg2Text"] = "voice_msg_to_text";
  ActionName2["GetGroupIgnoreAddRequest"] = "get_group_ignore_add_request";
  ActionName2["SetQQAvatar"] = "set_qq_avatar";
  ActionName2["GetQQAvatar"] = "get_qq_avatar";
  ActionName2["GetConfig"] = "get_config";
  ActionName2["SetConfig"] = "set_config";
  ActionName2["Debug"] = "llonebot_debug";
  ActionName2["GetFile"] = "get_file";
  ActionName2["GetFriendsWithCategory"] = "get_friends_with_category";
  ActionName2["GetEvent"] = "get_event";
  ActionName2["SetOnlineStatus"] = "set_online_status";
  ActionName2["GetProfileLike"] = "get_profile_like";
  ActionName2["GetProfileLikeMe"] = "get_profile_like_me";
  ActionName2["FetchEmojiLike"] = "fetch_emoji_like";
  ActionName2["FetchCustomFace"] = "fetch_custom_face";
  ActionName2["GetFriendMsgHistory"] = "get_friend_msg_history";
  ActionName2["SendForwardMsg"] = "send_forward_msg";
  ActionName2["SetMsgEmojiLike"] = "set_msg_emoji_like";
  ActionName2["UnSetMsgEmojiLike"] = "unset_msg_emoji_like";
  ActionName2["GetRobotUinRange"] = "get_robot_uin_range";
  ActionName2["GroupPoke"] = "group_poke";
  ActionName2["FriendPoke"] = "friend_poke";
  ActionName2["SetFriendRemark"] = "set_friend_remark";
  ActionName2["SetFriendCategory"] = "set_friend_category";
  ActionName2["SetGroupMsgMask"] = "set_group_msg_mask";
  ActionName2["SetGroupRemark"] = "set_group_remark";
  ActionName2["MoveGroupFile"] = "move_group_file";
  ActionName2["SetGroupFileForever"] = "set_group_file_forever";
  ActionName2["GetGroupShutList"] = "get_group_shut_list";
  ActionName2["RenameGroupFileFolder"] = "rename_group_file_folder";
  ActionName2["GetRecommendFace"] = "get_recommend_face";
  ActionName2["GetAiCharacters"] = "get_ai_characters";
  ActionName2["SendGroupAiRecord"] = "send_group_ai_record";
  ActionName2["GetPrivateFileUrl"] = "get_private_file_url";
  ActionName2["GetDoubtFriendsAddRequest"] = "get_doubt_friends_add_request";
  ActionName2["SetDoubtFriendsAddRequest"] = "set_doubt_friends_add_request";
  ActionName2["DeleteGroupNotice"] = "_delete_group_notice";
  ActionName2["SendLike"] = "send_like";
  ActionName2["GetLoginInfo"] = "get_login_info";
  ActionName2["GetFriendList"] = "get_friend_list";
  ActionName2["GetGroupInfo"] = "get_group_info";
  ActionName2["GetGroupList"] = "get_group_list";
  ActionName2["GetGroupMemberInfo"] = "get_group_member_info";
  ActionName2["GetGroupMemberList"] = "get_group_member_list";
  ActionName2["GetMsg"] = "get_msg";
  ActionName2["SendMsg"] = "send_msg";
  ActionName2["SendGroupMsg"] = "send_group_msg";
  ActionName2["SendPrivateMsg"] = "send_private_msg";
  ActionName2["DeleteMsg"] = "delete_msg";
  ActionName2["SetGroupAddRequest"] = "set_group_add_request";
  ActionName2["SetFriendAddRequest"] = "set_friend_add_request";
  ActionName2["SetGroupLeave"] = "set_group_leave";
  ActionName2["GetVersionInfo"] = "get_version_info";
  ActionName2["GetStatus"] = "get_status";
  ActionName2["SetRestart"] = "set_restart";
  ActionName2["CanSendRecord"] = "can_send_record";
  ActionName2["CanSendImage"] = "can_send_image";
  ActionName2["SetGroupKick"] = "set_group_kick";
  ActionName2["SetGroupBan"] = "set_group_ban";
  ActionName2["SetGroupWholeBan"] = "set_group_whole_ban";
  ActionName2["SetGroupAdmin"] = "set_group_admin";
  ActionName2["SetGroupCard"] = "set_group_card";
  ActionName2["SetGroupName"] = "set_group_name";
  ActionName2["GetImage"] = "get_image";
  ActionName2["GetRecord"] = "get_record";
  ActionName2["CleanCache"] = "clean_cache";
  ActionName2["GetCookies"] = "get_cookies";
  ActionName2["ForwardFriendSingleMsg"] = "forward_friend_single_msg";
  ActionName2["ForwardGroupSingleMsg"] = "forward_group_single_msg";
  ActionName2["GetCredentials"] = "get_credentials";
  ActionName2["GetCsrfToken"] = "get_csrf_token";
  ActionName2["GoCQHTTP_SendGroupForwardMsg"] = "send_group_forward_msg";
  ActionName2["GoCQHTTP_SendPrivateForwardMsg"] = "send_private_forward_msg";
  ActionName2["GoCQHTTP_GetStrangerInfo"] = "get_stranger_info";
  ActionName2["GetGuildList"] = "get_guild_list";
  ActionName2["GoCQHTTP_MarkMsgAsRead"] = "mark_msg_as_read";
  ActionName2["GoCQHTTP_UploadGroupFile"] = "upload_group_file";
  ActionName2["GoCQHTTP_UploadPrivateFile"] = "upload_private_file";
  ActionName2["GoCQHTTP_DownloadFile"] = "download_file";
  ActionName2["GoCQHTTP_GetGroupMsgHistory"] = "get_group_msg_history";
  ActionName2["GoCQHTTP_GetForwardMsg"] = "get_forward_msg";
  ActionName2["GoCQHTTP_GetEssenceMsgList"] = "get_essence_msg_list";
  ActionName2["GoCQHTTP_HandleQuickOperation"] = ".handle_quick_operation";
  ActionName2["GetGroupHonorInfo"] = "get_group_honor_info";
  ActionName2["GoCQHTTP_SetEssenceMsg"] = "set_essence_msg";
  ActionName2["GoCQHTTP_DeleteEssenceMsg"] = "delete_essence_msg";
  ActionName2["GoCQHTTP_DeleteGroupFile"] = "delete_group_file";
  ActionName2["GoCQHTTP_GetGroupSystemMsg"] = "get_group_system_msg";
  ActionName2["GoCQHTTP_CreateGroupFileFolder"] = "create_group_file_folder";
  ActionName2["GoCQHTTP_DeleteGroupFolder"] = "delete_group_folder";
  ActionName2["GoCQHTTP_GetGroupAtAllRemain"] = "get_group_at_all_remain";
  ActionName2["GoCQHTTP_GetGroupRootFiles"] = "get_group_root_files";
  ActionName2["GoCQHTTP_SendGroupNotice"] = "_send_group_notice";
  ActionName2["GoCQHTTP_GetGroupFilesByFolder"] = "get_group_files_by_folder";
  ActionName2["GoCQHTTP_GetGroupFileUrl"] = "get_group_file_url";
  ActionName2["GoCQHTTP_GetGroupNotice"] = "_get_group_notice";
  ActionName2["GoCQHTTP_DeleteFriend"] = "delete_friend";
  ActionName2["GoCQHTTP_OCRImage"] = "ocr_image";
  ActionName2["GoCQHTTP_GetGroupFileSystemInfo"] = "get_group_file_system_info";
  ActionName2["GoCQHTTP_SetGroupSpecialTitle"] = "set_group_special_title";
  ActionName2["GoCQHTTP_SendGroupSign"] = "send_group_sign";
  ActionName2["GoCQHTTP_SetQQProfile"] = "set_qq_profile";
  ActionName2["GoCQHTTP_SetGroupPortrait"] = "set_group_portrait";
  return ActionName2;
})(ActionName || {});
class GetMsg extends BaseAction {
  actionName = ActionName.GetMsg;
  payloadSchema = z$2.object({
    message_id: z$2.union([Number, String]).required()
  });
  async _handle(payload, config2) {
    const msgInfo = await this.ctx.store.getMsgInfoByShortId(+payload.message_id);
    if (!msgInfo) {
      throw new Error("");
    }
    let msg = this.ctx.store.getMsgCache(msgInfo.msgId);
    if (!msg) {
      const res = await this.ctx.ntMsgApi.getMsgsByMsgId(msgInfo.peer, [msgInfo.msgId]);
      if (res.msgList.length === 0) {
        throw new Error("");
      }
      msg = res.msgList[0];
    }
    const retMsg = await OB11Entities.message(this.ctx, msg, void 0, void 0, config2);
    if (!retMsg) {
      throw new Error("");
    }
    retMsg.real_id = retMsg.message_seq;
    return retMsg;
  }
}
let GetLoginInfo$1 = class GetLoginInfo extends BaseAction {
  actionName = ActionName.GetLoginInfo;
  async _handle() {
    for (let i = 0; i < 5; i++) {
      try {
        await this.ctx.ntUserApi.getSelfNick(true);
        break;
      } catch {
        await sleep(500);
      }
    }
    return {
      user_id: parseInt(selfInfo.uin),
      nickname: selfInfo.nick
    };
  }
};
let GetFriendList$1 = class GetFriendList extends BaseAction {
  actionName = ActionName.GetFriendList;
  async _handle() {
    const buddyList = await this.ctx.ntFriendApi.getBuddyList();
    return OB11Entities.friends(buddyList);
  }
};
let GetGroupList$1 = class GetGroupList extends BaseAction {
  actionName = ActionName.GetGroupList;
  payloadSchema = z$2.object({
    no_cache: z$2.union([Boolean, z$2.transform(String, parseBool)]).default(false)
  });
  async _handle(payload) {
    const groupList = await this.ctx.ntGroupApi.getGroups(payload.no_cache);
    return OB11Entities.groups(groupList);
  }
};
let GetGroupInfo$1 = class GetGroupInfo extends BaseAction {
  actionName = ActionName.GetGroupInfo;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    const groupCode = payload.group_id.toString();
    const groupAll = await this.ctx.ntGroupApi.getGroupAllInfo(groupCode);
    const data = {
      group_id: +groupAll.groupCode,
      group_name: groupAll.groupName,
      group_memo: groupAll.richFingerMemo,
      group_create_time: 0,
      member_count: groupAll.memberNum,
      max_member_count: groupAll.maxMemberNum,
      remark_name: groupAll.remarkName,
      avatar_url: `https://p.qlogo.cn/gh/${groupAll.groupCode}/${groupAll.groupCode}/0`,
      groupAll
    };
    const group = (await this.ctx.ntGroupApi.getGroups()).find((e) => e.groupCode === groupCode);
    if (group) {
      data.group_create_time = +group.createTime;
    }
    return data;
  }
};
let GetGroupMemberList$1 = class GetGroupMemberList extends BaseAction {
  actionName = ActionName.GetGroupMemberList;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    const groupCode = payload.group_id.toString();
    const res = await this.ctx.ntGroupApi.getGroupMembers(groupCode);
    if (res.errCode !== 0) {
      throw new Error(res.errMsg);
    }
    const groupId = Number(payload.group_id);
    return res.result.infos.values().map((e) => OB11Entities.groupMember(groupId, e)).toArray();
  }
};
let GetGroupMemberInfo$1 = class GetGroupMemberInfo extends BaseAction {
  actionName = ActionName.GetGroupMemberInfo;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    user_id: z$2.union([Number, String]).required(),
    no_cache: z$2.union([Boolean, z$2.transform(String, parseBool)]).default(false)
  });
  async _handle(payload) {
    const groupCode = payload.group_id.toString();
    const uid = await this.ctx.ntUserApi.getUidByUin(payload.user_id.toString(), groupCode);
    if (!uid) throw new Error("");
    const member = await this.ctx.ntGroupApi.getGroupMember(groupCode, uid, payload.no_cache);
    const ret = OB11Entities.groupMember(+groupCode, member);
    let info;
    try {
      info = await this.ctx.ntUserApi.getUserDetailInfoWithBizInfo(member.uid);
    } catch (e) {
      try {
        const fetchInfo = await this.ctx.ntUserApi.fetchUserDetailInfo(member.uid);
        if (fetchInfo) {
          info = fetchInfo.detail.get(member.uid);
        }
      } catch (e2) {
      }
    }
    if (info) {
      ret.sex = OB11Entities.sex(info.simpleInfo.baseInfo.sex);
      ret.qq_level = info.commonExt?.qqLevel && calcQQLevel(info.commonExt.qqLevel) || 0;
      ret.age = info.simpleInfo.baseInfo.age ?? 0;
    }
    if (ret.qq_level === 0) {
      ret.qq_level = await this.ctx.app.pmhq.fetchUserLevel(+payload.user_id);
    }
    return ret;
  }
};
class SendMsg extends BaseAction {
  actionName = ActionName.SendMsg;
  payloadSchema = z$2.object({
    message_type: z$2.union(["private", "group"]),
    user_id: z$2.union([Number, String]),
    group_id: z$2.union([Number, String]),
    message: z$2.any().required(),
    auto_escape: z$2.union([Boolean, z$2.transform(String, parseBool)]).default(false)
  });
  async _handle(payload) {
    let contextMode = CreatePeerMode.Normal;
    if (payload.message_type === "group") {
      contextMode = CreatePeerMode.Group;
    } else if (payload.message_type === "private") {
      contextMode = CreatePeerMode.Private;
    }
    const peer = await createPeer(this.ctx, payload, contextMode);
    const messages = message2List(payload.message, payload.auto_escape);
    if (messages.some((e) => e.type === OB11MessageDataType.Node)) {
      throw new Error(" /send_group_forward_msg  /send_private_forward_msg ");
    }
    const { sendElements, deleteAfterSentFiles } = await createSendElements(this.ctx, messages, peer);
    if (sendElements.length === 1) {
      if (sendElements[0] === null) {
        return { message_id: 0 };
      }
    }
    const returnMsg = await this.ctx.app.sendMessage(this.ctx, peer, sendElements, deleteAfterSentFiles);
    if (!returnMsg) {
      throw new Error("");
    }
    const msgShortId = this.ctx.store.createMsgShortId(returnMsg);
    return { message_id: msgShortId };
  }
}
class SendGroupMsg extends SendMsg {
  actionName = ActionName.SendGroupMsg;
  _handle(payload) {
    payload.message_type = "group";
    return super._handle(payload);
  }
}
class SendPrivateMsg extends SendMsg {
  actionName = ActionName.SendPrivateMsg;
  _handle(payload) {
    payload.message_type = "private";
    return super._handle(payload);
  }
}
class DeleteMsg extends BaseAction {
  actionName = ActionName.DeleteMsg;
  payloadSchema = z$2.object({
    message_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    const msg = await this.ctx.store.getMsgInfoByShortId(+payload.message_id);
    if (!msg) {
      throw new Error(`${payload.message_id}`);
    }
    const data = await this.ctx.ntMsgApi.recallMsg(msg.peer, [msg.msgId]);
    if (data.result !== 0) {
      throw new Error(data.errMsg);
    }
    return null;
  }
}
class GetVersionInfo extends BaseAction {
  actionName = ActionName.GetVersionInfo;
  async _handle() {
    return {
      app_name: "LLOneBot",
      protocol_version: "v11",
      app_version: version$2
    };
  }
}
class CanSendRecord extends BaseAction {
  actionName = ActionName.CanSendRecord;
  async _handle() {
    return {
      yes: true
    };
  }
}
class CanSendImage extends CanSendRecord {
  actionName = ActionName.CanSendImage;
}
class GetStatus extends BaseAction {
  actionName = ActionName.GetStatus;
  async _handle() {
    return {
      online: selfInfo.online,
      good: true,
      stat: {
        message_received: this.ctx.app.messageReceivedCount,
        message_sent: this.ctx.app.messageSentCount,
        last_message_time: this.ctx.app.lastMessageTime,
        startup_time: this.ctx.app.startupTime
      }
    };
  }
}
let MessageEncoder$1 = class MessageEncoder {
  constructor(ctx, peer) {
    this.ctx = ctx;
    this.peer = peer;
    this.results = [];
    this.children = [];
    this.deleteAfterSentFiles = [];
    this.isGroup = peer.chatType === 2;
    this.seq = Math.trunc(Math.random() * 65430);
    this.tsum = 0;
    this.preview = "";
    this.news = [];
  }
  static support = ["text", "face", "image", "markdown", "forward"];
  results;
  children;
  deleteAfterSentFiles;
  isGroup;
  seq;
  tsum;
  preview;
  news;
  name;
  uin;
  async flush() {
    if (this.children.length === 0) return;
    const nick = this.name || selfInfo.nick || "QQ";
    if (this.news.length < 4) {
      this.news.push({
        text: `${nick}: ${this.preview}`
      });
    }
    this.results.push({
      routingHead: {
        fromUin: this.uin ?? +selfInfo.uin,
        //  1094950020
        c2c: this.isGroup ? void 0 : {
          friendName: nick
        },
        group: this.isGroup ? {
          groupCode: 284840486,
          groupCard: nick
        } : void 0
      },
      contentHead: {
        msgType: this.isGroup ? 82 : 9,
        random: Math.floor(Math.random() * 4294967290),
        msgSeq: this.seq,
        msgTime: Math.trunc(Date.now() / 1e3),
        pkgNum: 1,
        pkgIndex: 0,
        divSeq: 0,
        forward: {
          field1: 0,
          field2: 0,
          field3: 0,
          field4: "",
          avatar: ""
        }
      },
      body: {
        richText: {
          elems: this.children
        }
      }
    });
    this.seq++;
    this.tsum++;
    this.children = [];
    this.preview = "";
  }
  async packImage(data, busiType) {
    const imageSize2 = await this.ctx.ntFileApi.getImageSize(data.filePath);
    return {
      commonElem: {
        serviceType: 48,
        pbElem: Media.MsgInfo.encode({
          msgInfoBody: [{
            index: {
              info: {
                fileSize: +data.commonFileInfo.fileSize,
                md5HexStr: data.commonFileInfo.md5,
                sha1HexStr: data.commonFileInfo.sha,
                fileName: data.commonFileInfo.fileName,
                fileType: {
                  type: 1,
                  picFormat: imageSize2.type === "gif" ? 2e3 : 1e3
                },
                width: imageSize2.width,
                height: imageSize2.height,
                time: 0,
                original: 1
              },
              fileUuid: data.fileId,
              storeID: 1,
              expire: this.isGroup ? 2678400 : 15768e4
            },
            pic: {
              urlPath: `/download?appid=${this.isGroup ? 1407 : 1406}&fileid=${data.fileId}`,
              ext: {
                originalParam: "&spec=0",
                bigParam: "&spec=720",
                thumbParam: "&spec=198"
              },
              domain: "multimedia.nt.qq.com.cn"
            },
            fileExist: true
          }],
          extBizInfo: {
            pic: {
              bizType: 0,
              summary: "",
              fromScene: this.isGroup ? 2 : 1,
              //  PCQQ 
              toScene: this.isGroup ? 2 : 1,
              //  PCQQ 
              oldFileId: this.isGroup ? 574859779 : void 0
              //  PCQQ 
            },
            busiType
          }
        }),
        businessType: this.isGroup ? 20 : 10
      }
    };
  }
  packForwardMessage(resid) {
    const uuid2 = crypto.randomUUID();
    const content = JSON.stringify({
      app: "com.tencent.multimsg",
      config: {
        autosize: 1,
        forward: 1,
        round: 1,
        type: "normal",
        width: 300
      },
      desc: "[]",
      extra: JSON.stringify({
        filename: uuid2,
        tsum: 0
      }),
      meta: {
        detail: {
          news: [{
            text: ""
          }],
          resid,
          source: "",
          summary: "",
          uniseq: uuid2
        }
      },
      prompt: "[]",
      ver: "0.0.0.5",
      view: "contact"
    });
    return {
      lightApp: {
        data: Buffer.concat([Buffer.from([1]), deflateSync(Buffer.from(content, "utf-8"))])
      }
    };
  }
  async visit(segment) {
    const { type: type2, data } = segment;
    if (type2 === OB11MessageDataType.Node) {
      await this.render(data.content);
      const id2 = data.uin ?? data.user_id;
      this.uin = id2 ? +id2 : void 0;
      this.name = data.name ?? data.nickname;
      await this.flush();
    } else if (type2 === OB11MessageDataType.Text) {
      this.children.push({
        text: {
          str: data.text
        }
      });
      this.preview += data.text;
    } else if (type2 === OB11MessageDataType.Face) {
      this.children.push({
        face: {
          index: +data.id
        }
      });
      const face = faceConfig.sysface.find((e) => e.QSid === String(data.id));
      if (face) {
        this.preview += face.QDes;
      }
    } else if (type2 === OB11MessageDataType.Image) {
      const busiType = Number(segment.data.subType) ?? 0;
      const { path: picPath } = await handleOb11RichMedia(this.ctx, segment, this.deleteAfterSentFiles);
      const { path: path2, fileSize } = await this.ctx.ntFileApi.uploadFile(picPath, ElementType.Pic, busiType);
      if (fileSize === 0) {
        throw new Error(" 0");
      }
      const data2 = await this.ctx.ntFileApi.uploadRMFileWithoutMsg(path2, this.isGroup ? 4 : 3, this.isGroup ? this.peer.peerUid : selfInfo.uid);
      this.children.push(await this.packImage(data2, busiType));
      this.preview += busiType === 1 ? "[]" : "[]";
      this.deleteAfterSentFiles.push(path2);
    } else if (type2 === OB11MessageDataType.Forward) {
      this.children.push(this.packForwardMessage(data.id));
      this.preview += "[]";
    }
  }
  async render(segments) {
    for (const segment of segments) {
      await this.visit(segment);
    }
  }
  async generate(content) {
    await this.render(content);
    return {
      multiMsgItems: [{
        fileName: "MultiMsg",
        buffer: {
          msg: this.results
        }
      }],
      tsum: this.tsum,
      source: this.isGroup ? "" : "",
      summary: `${this.tsum}`,
      news: this.news
    };
  }
};
class SendForwardMsg extends BaseAction {
  actionName = ActionName.SendForwardMsg;
  payloadSchema = z$2.object({
    user_id: z$2.union([Number, String]),
    group_id: z$2.union([Number, String]),
    messages: z$2.array(z$2.any()),
    message: z$2.array(z$2.any()),
    message_type: z$2.union(["group", "private"])
  });
  async _handle(payload) {
    const messages = payload.messages ?? payload.message;
    if (!messages) {
      throw new Error("");
    }
    let contextMode = CreatePeerMode.Normal;
    if (payload.message_type === "group") {
      contextMode = CreatePeerMode.Group;
    } else if (payload.message_type === "private") {
      contextMode = CreatePeerMode.Private;
    }
    const peer = await createPeer(this.ctx, payload, contextMode);
    let nodes = this.parseNodeContent(messages);
    let fake = true;
    let msgInfos;
    if (nodes.every((e) => e.data.id)) {
      msgInfos = [];
      for (const node of nodes) {
        const msgInfo = await this.ctx.store.getMsgInfoByShortId(+node.data.id);
        if (!msgInfo) {
          this.ctx.logger.warn(` ${node.data.id} `);
          continue;
        }
        msgInfos.push(msgInfo);
      }
      let srcPeer;
      let needSendSelf = false;
      for (const { peer: peer2 } of msgInfos) {
        srcPeer ??= peer2;
        if (srcPeer.peerUid !== peer2.peerUid) {
          needSendSelf = true;
        }
      }
      if (needSendSelf) {
        const convertedNodes = [];
        for (const msgInfo of msgInfos) {
          const node = await this.getMessageNode(msgInfo);
          convertedNodes.push(node);
        }
        nodes = convertedNodes;
        msgInfos = void 0;
      } else {
        fake = false;
      }
    } else if (nodes.some((e) => e.data.id)) {
      const convertedNodes = [];
      for (const item of nodes) {
        if (item.data.id) {
          const msgInfo = await this.ctx.store.getMsgInfoByShortId(+item.data.id);
          if (!msgInfo) {
            this.ctx.logger.warn(` ${item.data.id} `);
            continue;
          }
          const node = await this.getMessageNode(msgInfo);
          convertedNodes.push(node);
        } else {
          convertedNodes.push(item);
        }
      }
      nodes = convertedNodes;
    }
    for (const node of nodes) {
      if (node.data.content?.some((e) => {
        return !MessageEncoder$1.support.includes(e.type);
      })) {
        fake = false;
        break;
      }
    }
    return fake ? await this.handleFakeForwardNode(peer, nodes) : await this.handleForwardNode(peer, nodes, msgInfos);
  }
  async getMessageNode(msgInfo) {
    let msg = this.ctx.store.getMsgCache(msgInfo.msgId);
    if (!msg) {
      const res = await this.ctx.ntMsgApi.getMsgsByMsgId(msgInfo.peer, [msgInfo.msgId]);
      if (res.msgList.length === 0) {
        const shortId = await this.ctx.store.getShortIdByMsgId(msgInfo.msgId);
        throw new Error(` ${shortId ?? ""}`);
      }
      msg = res.msgList[0];
    }
    const obMsg = await OB11Entities.message(this.ctx, msg);
    if (!obMsg) {
      const shortId = this.ctx.store.createMsgShortId(msg);
      throw new Error(` ${shortId} `);
    }
    return {
      type: OB11MessageDataType.Node,
      data: {
        name: obMsg.sender.nickname,
        uin: obMsg.sender.user_id,
        content: obMsg.message
      }
    };
  }
  parseNodeContent(nodes) {
    return nodes.map((e) => {
      return {
        type: e.type,
        data: {
          ...e.data,
          content: e.data.content ? message2List(e.data.content) : void 0
        }
      };
    });
  }
  async handleFakeForwardNode(peer, nodes) {
    const encoder = new MessageEncoder$1(this.ctx, peer);
    const raw = await encoder.generate(nodes);
    const resid = await this.ctx.app.pmhq.uploadForward(peer, raw.multiMsgItems);
    const uuid2 = randomUUID();
    try {
      const msg = await this.ctx.app.sendMessage(this.ctx, peer, [{
        elementType: 10,
        elementId: "",
        arkElement: {
          bytesData: JSON.stringify({
            app: "com.tencent.multimsg",
            config: {
              autosize: 1,
              forward: 1,
              round: 1,
              type: "normal",
              width: 300
            },
            desc: "[]",
            extra: JSON.stringify({
              filename: uuid2,
              tsum: raw.tsum
            }),
            meta: {
              detail: {
                news: raw.news,
                resid,
                source: raw.source,
                summary: raw.summary,
                uniseq: uuid2
              }
            },
            prompt: "[]",
            ver: "0.0.0.5",
            view: "contact"
          })
        }
      }], encoder.deleteAfterSentFiles);
      const msgShortId = this.ctx.store.createMsgShortId(msg);
      return { message_id: msgShortId, forward_id: resid };
    } catch (e) {
      this.ctx.logger.error("", e);
      throw new Error(` (res_id: ${resid})`);
    }
  }
  // id
  async handleForwardNode(destPeer, messageNodes, msgInfos) {
    let srcPeer;
    let msgIds = [];
    if (msgInfos) {
      srcPeer = msgInfos[0]?.peer;
      msgIds = msgInfos.map((e) => e.msgId);
    } else {
      srcPeer = {
        chatType: ChatType.C2C,
        peerUid: selfInfo.uid,
        guildId: ""
      };
      for (const messageNode of messageNodes) {
        if (messageNode.data.content) {
          try {
            const { sendElements, deleteAfterSentFiles } = await createSendElements(
              this.ctx,
              messageNode.data.content,
              destPeer
            );
            this.ctx.logger.info("", sendElements);
            const sendElementsSplit = [];
            let splitIndex = 0;
            for (const ele of sendElements) {
              if (!sendElementsSplit[splitIndex]) {
                sendElementsSplit[splitIndex] = [];
              }
              if (ele.elementType === ElementType.File || ele.elementType === ElementType.Video) {
                if (sendElementsSplit[splitIndex].length > 0) {
                  splitIndex++;
                }
                sendElementsSplit[splitIndex] = [ele];
                splitIndex++;
              } else {
                sendElementsSplit[splitIndex].push(ele);
              }
            }
            this.ctx.logger.info("", sendElementsSplit);
            for (const eles of sendElementsSplit) {
              const nodeMsg = await this.ctx.app.sendMessage(this.ctx, srcPeer, eles, []);
              if (!nodeMsg) {
                this.ctx.logger.warn("", eles);
                continue;
              }
              msgIds.push(nodeMsg.msgId);
            }
            deleteAfterSentFiles.map((path2) => unlink(path2).then().catch((e) => {
            }));
          } catch (e) {
            this.ctx.logger.error("", e);
          }
        }
      }
    }
    if (msgIds.length === 0) {
      throw new Error("");
    }
    const msg = await this.ctx.ntMsgApi.multiForwardMsg(srcPeer, destPeer, msgIds);
    const resid = JSON.parse(msg.elements[0].arkElement.bytesData).meta.detail.resid;
    const msgShortId = this.ctx.store.createMsgShortId(msg);
    return { message_id: msgShortId, forward_id: resid };
  }
}
class SendPrivateForwardMsg extends SendForwardMsg {
  actionName = ActionName.GoCQHTTP_SendPrivateForwardMsg;
  _handle(payload) {
    payload.message_type = "private";
    return super._handle(payload);
  }
}
class SendGroupForwardMsg extends SendForwardMsg {
  actionName = ActionName.GoCQHTTP_SendGroupForwardMsg;
  _handle(payload) {
    payload.message_type = "group";
    return super._handle(payload);
  }
}
class GetStrangerInfo extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetStrangerInfo;
  payloadSchema = z$2.object({
    user_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    const uin = payload.user_id.toString();
    const data = await this.ctx.ntUserApi.getUserDetailInfoByUin(uin);
    if (data.result !== 0) {
      throw new Error(data.errMsg);
    }
    const loginDays = await this.ctx.app.pmhq.fetchUserLoginDays(+uin);
    const resp = {
      user_id: parseInt(data.detail.uin) || 0,
      nickname: data.detail.simpleInfo.coreInfo.nick,
      sex: OB11Entities.sex(data.detail.simpleInfo.baseInfo.sex),
      age: data.detail.simpleInfo.baseInfo.age,
      qid: data.detail.simpleInfo.baseInfo.qid,
      level: data.detail.commonExt?.qqLevel && calcQQLevel(data.detail.commonExt.qqLevel) || 0,
      login_days: loginDays,
      reg_time: data.detail.commonExt?.regTime ?? 0,
      long_nick: data.detail.simpleInfo.baseInfo.longNick,
      city: data.detail.commonExt?.city ?? "",
      country: data.detail.commonExt?.country ?? "",
      birthday_year: data.detail.simpleInfo.baseInfo.birthday_year,
      birthday_month: data.detail.simpleInfo.baseInfo.birthday_month,
      birthday_day: data.detail.simpleInfo.baseInfo.birthday_day
    };
    if (resp.level === 0) {
      resp.level = await this.ctx.app.pmhq.fetchUserLevel(+payload.user_id);
    }
    return resp;
  }
}
class SendLike extends BaseAction {
  actionName = ActionName.SendLike;
  payloadSchema = z$2.object({
    user_id: z$2.union([Number, String]).required(),
    times: z$2.union([Number, String]).default(1)
  });
  async _handle(payload) {
    const uin = payload.user_id.toString();
    const uid = await this.ctx.ntUserApi.getUidByUin(uin);
    if (!uid) throw new Error("");
    const result = await this.ctx.ntUserApi.like(uid, +payload.times);
    if (result.result !== 0) {
      throw new Error(result.errMsg);
    }
    return null;
  }
}
class SetGroupAddRequest extends BaseAction {
  actionName = ActionName.SetGroupAddRequest;
  payloadSchema = z$2.object({
    flag: z$2.string().required(),
    approve: z$2.union([Boolean, z$2.transform(String, parseBool)]).default(true),
    reason: z$2.string()
  });
  async _handle(payload) {
    let flag = payload.flag;
    if (isNumeric(flag)) {
      const res2 = await this.ctx.ntGroupApi.getGroupRequest();
      const normalEnd = res2.normalCount - 1;
      for (const [i, v] of res2.notifies.entries()) {
        if (flag === v.seq) {
          flag = `${v.group.groupCode}|${v.seq}|${v.type}|${i > normalEnd ? "1" : "0"}`;
          break;
        }
      }
      if (flag === payload.flag) {
        throw new Error("flag ");
      }
    }
    const res = await this.ctx.ntGroupApi.handleGroupRequest(
      flag,
      payload.approve ? GroupRequestOperateTypes.Approve : GroupRequestOperateTypes.Reject,
      payload.reason
    );
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class SetGroupLeave extends BaseAction {
  actionName = ActionName.SetGroupLeave;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    const res = await this.ctx.ntGroupApi.quitGroup(payload.group_id.toString());
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class GetGuildList extends BaseAction {
  actionName = ActionName.GetGuildList;
  async _handle() {
    return null;
  }
}
class Debug extends BaseAction {
  actionName = ActionName.Debug;
  payloadSchema = z$2.object({
    apiClass: z$2.string().required(),
    method: z$2.string().required(),
    args: z$2.array(z$2.any()).default([])
  });
  async _handle(payload) {
    this.ctx.logger.info("debug call ntqq api", payload);
    const api = this.ctx.get(payload.apiClass);
    return await api[payload.method](...payload.args);
  }
}
class SetFriendAddRequest extends BaseAction {
  actionName = ActionName.SetFriendAddRequest;
  payloadSchema = z$2.object({
    flag: z$2.string().required(),
    approve: z$2.union([Boolean, z$2.transform(String, parseBool)]).default(true),
    remark: z$2.string()
  });
  async _handle(payload) {
    const data = payload.flag.split("|");
    if (data.length < 2) {
      throw new Error("flag");
    }
    const uid = data[0];
    const reqTime = data[1];
    const res = await this.ctx.ntFriendApi.handleFriendRequest(uid, reqTime, payload.approve);
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    if (payload.remark) {
      const res2 = await this.ctx.ntFriendApi.setBuddyRemark(uid, payload.remark);
      if (res2.result !== 0) {
        throw new Error(res2.errMsg);
      }
    }
    return null;
  }
}
class SetGroupWholeBan extends BaseAction {
  actionName = ActionName.SetGroupWholeBan;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    enable: z$2.union([Boolean, z$2.transform(String, parseBool)]).default(true)
  });
  async _handle(payload) {
    const res = await this.ctx.ntGroupApi.banGroup(payload.group_id.toString(), payload.enable);
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
let SetGroupName$1 = class SetGroupName extends BaseAction {
  actionName = ActionName.SetGroupName;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    group_name: z$2.string().required()
  });
  async _handle(payload) {
    const res = await this.ctx.ntGroupApi.setGroupName(payload.group_id.toString(), payload.group_name);
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
};
class SetGroupBan extends BaseAction {
  actionName = ActionName.SetGroupBan;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    user_id: z$2.union([Number, String]).required(),
    duration: z$2.union([Number, String]).default(30 * 60)
  });
  async _handle(payload) {
    const groupCode = payload.group_id.toString();
    const uin = payload.user_id.toString();
    const uid = await this.ctx.ntUserApi.getUidByUin(uin, groupCode);
    if (!uid) throw new Error("");
    const res = await this.ctx.ntGroupApi.banMember(groupCode, [
      { uid, timeStamp: +payload.duration }
    ]);
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class SetGroupKick extends BaseAction {
  actionName = ActionName.SetGroupKick;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    user_id: z$2.union([Number, String]).required(),
    reject_add_request: z$2.union([Boolean, z$2.transform(String, parseBool)]).default(false)
  });
  async _handle(payload) {
    const groupCode = payload.group_id.toString();
    const uin = payload.user_id.toString();
    const uid = await this.ctx.ntUserApi.getUidByUin(uin, groupCode);
    if (!uid) throw new Error("");
    const res = await this.ctx.ntGroupApi.kickMember(groupCode, [uid], payload.reject_add_request);
    if (res.errCode !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class SetGroupAdmin extends BaseAction {
  actionName = ActionName.SetGroupAdmin;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    user_id: z$2.union([Number, String]).required(),
    enable: z$2.union([Boolean, z$2.transform(String, parseBool)]).default(true)
  });
  async _handle(payload) {
    const groupCode = payload.group_id.toString();
    const uin = payload.user_id.toString();
    const uid = await this.ctx.ntUserApi.getUidByUin(uin, groupCode);
    if (!uid) throw new Error("");
    const res = await this.ctx.ntGroupApi.setMemberRole(
      groupCode,
      uid,
      payload.enable ? GroupMemberRole.Admin : GroupMemberRole.Normal
    );
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class SetGroupCard extends BaseAction {
  actionName = ActionName.SetGroupCard;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    user_id: z$2.union([Number, String]).required(),
    card: z$2.string().default("")
  });
  async _handle(payload) {
    const groupCode = payload.group_id.toString();
    const uin = payload.user_id.toString();
    const uid = await this.ctx.ntUserApi.getUidByUin(uin, groupCode);
    if (!uid) throw new Error("");
    const res = await this.ctx.ntGroupApi.setMemberCard(groupCode, uid, payload.card);
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class GetFileBase extends BaseAction {
  payloadSchema = z$2.object({
    file: z$2.string().required()
  });
  async _handle(payload) {
    const { enableLocalFile2Url } = this.adapter.config;
    let fileCache = await this.ctx.store.getFileCacheById(payload.file);
    if (!fileCache?.length) {
      fileCache = await this.ctx.store.getFileCacheByName(payload.file);
    }
    if (fileCache?.length) {
      const downloadPath = await this.ctx.ntFileApi.downloadMedia(
        fileCache[0].msgId,
        fileCache[0].chatType,
        fileCache[0].peerUid,
        fileCache[0].elementId,
        "",
        ""
      );
      const res = {
        file: downloadPath,
        url: downloadPath,
        file_size: fileCache[0].fileSize,
        file_name: fileCache[0].fileName
      };
      const peer = {
        chatType: fileCache[0].chatType,
        peerUid: fileCache[0].peerUid,
        guildId: ""
      };
      if (fileCache[0].elementType === ElementType.Pic) {
        const msgList = await this.ctx.ntMsgApi.getMsgsByMsgId(peer, [fileCache[0].msgId]);
        if (msgList.msgList.length === 0) {
          throw new Error("msg not found");
        }
        const msg = msgList.msgList[0];
        const findEle = msg.elements.find((e) => e.elementId === fileCache[0].elementId);
        if (!findEle) {
          throw new Error("element not found");
        }
        res.url = await this.ctx.ntFileApi.getImageUrl(findEle.picElement);
      } else if (fileCache[0].elementType === ElementType.Video) {
        res.url = await this.ctx.ntFileApi.getVideoUrl(peer, fileCache[0].msgId, fileCache[0].elementId);
      } else if (fileCache[0].elementType === ElementType.Ptt) {
        res.url = await this.ctx.ntFileApi.getPttUrl(fileCache[0].fileUuid, peer.chatType === 2);
      }
      if (enableLocalFile2Url && downloadPath && (res.file === res.url || res.url === void 0)) {
        try {
          res.base64 = await readFile(downloadPath, "base64");
        } catch (e) {
          throw new Error(". " + e);
        }
      }
      return res;
    }
    throw new Error("file not found");
  }
}
class GetFile extends GetFileBase {
  actionName = ActionName.GetFile;
  payloadSchema = z$2.object({
    file: z$2.string().required(false),
    file_id: z$2.string().required(false)
  });
  async _handle(payload) {
    payload.file = payload.file || payload.file_id;
    return super._handle(payload);
  }
}
class GetImage extends GetFileBase {
  actionName = ActionName.GetImage;
}
class GetRecord extends GetFileBase {
  actionName = ActionName.GetRecord;
  payloadSchema = z$2.object({
    file: z$2.string().required(),
    out_format: z$2.string().default("mp3")
  });
  async _handle(payload) {
    const res = await super._handle(payload);
    res.file = await decodeSilk(this.ctx, res.file, payload.out_format);
    res.file_name = path__default.basename(res.file);
    res.file_size = (await stat(res.file)).size.toString();
    if (this.adapter.config.enableLocalFile2Url) {
      res.base64 = await readFile(res.file, "base64");
    }
    return res;
  }
}
class MarkMsgAsRead extends BaseAction {
  actionName = ActionName.GoCQHTTP_MarkMsgAsRead;
  payloadSchema = z$2.object({
    message_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    const msg = await this.ctx.store.getMsgInfoByShortId(+payload.message_id);
    if (!msg) {
      throw new Error("msg not found");
    }
    const res = await this.ctx.ntMsgApi.setMsgRead(msg.peer);
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class CleanCache extends BaseAction {
  actionName = ActionName.CleanCache;
  async _handle() {
    return null;
  }
}
class GetConfigAction extends BaseAction {
  actionName = ActionName.GetConfig;
  async _handle() {
    return getConfigUtil().getConfig();
  }
}
class SetConfigAction extends BaseAction {
  actionName = ActionName.SetConfig;
  payloadSchema = z$2.object({
    milky: z$2.any(),
    satori: z$2.any(),
    ob11: z$2.any(),
    webui: z$2.any(),
    onlyLocalhost: z$2.boolean(),
    enableLocalFile2Url: z$2.boolean(),
    log: z$2.boolean(),
    autoDeleteFile: z$2.boolean(),
    autoDeleteFileSecond: z$2.number(),
    ffmpeg: z$2.string(),
    musicSignUrl: z$2.string(),
    msgCacheExpire: z$2.number(),
    rawMsgPB: z$2.boolean()
  });
  async _handle(payload) {
    getConfigUtil().setConfig(payload);
    await this.ctx.parallel("llob/config-updated", payload);
    return null;
  }
}
class GetGroupAddRequest extends BaseAction {
  actionName = ActionName.GetGroupIgnoreAddRequest;
  async _handle() {
    throw new Error(" get_group_system_msg API, ");
  }
}
class SetQQAvatar extends BaseAction {
  actionName = ActionName.SetQQAvatar;
  payloadSchema = z$2.object({
    file: z$2.string().required()
  });
  async _handle(payload) {
    const { path: path2, isLocal, errMsg } = await uri2local(this.ctx, payload.file);
    if (errMsg) {
      throw new Error(errMsg);
    }
    const ret = await this.ctx.ntUserApi.setSelfAvatar(path2);
    if (!isLocal) {
      unlink(path2).then().catch((err) => {
      });
    }
    if (ret.result !== 0) {
      throw new Error(ret.errMsg);
    }
    return null;
  }
}
class DownloadFile extends BaseAction {
  actionName = ActionName.GoCQHTTP_DownloadFile;
  payloadSchema = z$2.object({
    url: z$2.string(),
    base64: z$2.string(),
    headers: z$2.union([String, z$2.array(String)])
  });
  async _handle(payload) {
    const isRandomName = !payload.name;
    const name = payload.name ? path__default.basename(payload.name) : randomUUID();
    const filePath = path__default.join(TEMP_DIR, name);
    if (payload.base64) {
      await fsPromise$1.writeFile(filePath, payload.base64, "base64");
    } else if (payload.url) {
      const headers = this.getHeaders(payload.headers);
      const res = await fetchFile(payload.url, headers);
      await fsPromise$1.writeFile(filePath, res.data);
    } else {
      throw new Error(", ");
    }
    if (require$$0$4.existsSync(filePath)) {
      if (isRandomName) {
        const md5 = await calculateFileMD5(filePath);
        const newPath = path__default.join(TEMP_DIR, md5);
        await fsPromise$1.rename(filePath, newPath);
        return { file: newPath };
      }
      return { file: filePath };
    } else {
      throw new Error(", ");
    }
  }
  getHeaders(headersIn) {
    const headers = {};
    if (typeof headersIn == "string") {
      headersIn = headersIn.split("[\\r\\n]");
    }
    if (Array.isArray(headersIn)) {
      for (const headerItem of headersIn) {
        const spilt = headerItem.indexOf("=");
        if (spilt < 0) {
          headers[headerItem] = "";
        } else {
          const key2 = headerItem.substring(0, spilt);
          headers[key2] = headerItem.substring(0, spilt + 1);
        }
      }
    }
    if (!headers["Content-Type"]) {
      headers["Content-Type"] = "application/octet-stream";
    }
    return headers;
  }
}
class GetGroupMsgHistory extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupMsgHistory;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    message_seq: z$2.union([Number, String]),
    count: z$2.union([Number, String]).default(20),
    reverseOrder: z$2.union([Boolean, z$2.transform(String, parseBool)]).default(false)
  });
  async getMessage(config2, peer, count, seq) {
    let msgList;
    if (!seq || +seq === 0) {
      msgList = (await this.ctx.ntMsgApi.getAioFirstViewLatestMsgs(peer, count)).msgList;
    } else {
      msgList = (await this.ctx.ntMsgApi.getMsgsBySeqAndCount(peer, String(seq), count, true, true)).msgList;
    }
    if (!msgList?.length) return;
    const ob11MsgList = await Promise.all(msgList.map((msg) => {
      let rawMsg = msg;
      if (rawMsg.recallTime !== "0") {
        let msg2 = this.ctx.store.getMsgCache(rawMsg.msgId);
        if (msg2) {
          rawMsg = msg2;
        }
      }
      return OB11Entities.message(this.ctx, rawMsg, void 0, void 0, config2);
    }));
    return { list: filterNullable(ob11MsgList), seq: +msgList[0].msgSeq };
  }
  async _handle(payload, config2) {
    const peer = {
      chatType: ChatType.Group,
      peerUid: payload.group_id.toString(),
      guildId: ""
    };
    const messages = [];
    let seq = payload.message_seq;
    let count = +payload.count;
    while (count > 0) {
      const res = await this.getMessage(config2, peer, count, seq);
      if (!res) break;
      seq = res.seq - 1;
      count -= res.list.length;
      messages.unshift(...res.list);
    }
    if (payload.reverseOrder) messages.reverse();
    return { messages };
  }
}
async function decodeMultiMessage(ctx, items, messageFormat) {
  return await Promise.all(items[0].buffer.msg.map(async (msg) => {
    const { body, contentHead, routingHead } = msg;
    let content = messageFormat === "string" ? "" : [];
    for (const element of body.richText.elems) {
      let segment;
      if (element.text) {
        segment = {
          type: OB11MessageDataType.Text,
          data: {
            text: element.text.str
          }
        };
      } else if (element.commonElem && element.commonElem.serviceType === 48) {
        const richMediaInfo = Media.MsgInfo.decode(element.commonElem.pbElem);
        const infoBody = richMediaInfo.msgInfoBody[0];
        const parsedUrl = new URL("https://" + infoBody.pic.domain + infoBody.pic.urlPath + infoBody.pic.ext.originalParam);
        const imageAppid = parsedUrl.searchParams.get("appid");
        const rkeyData = await ctx.ntFileApi.rkeyManager.getRkey();
        const url2 = parsedUrl.href + (imageAppid === "1406" ? rkeyData.private_rkey : rkeyData.group_rkey);
        const { info } = richMediaInfo.msgInfoBody[0].index;
        const { pic } = richMediaInfo.extBizInfo;
        segment = {
          type: OB11MessageDataType.Image,
          data: {
            file: info.fileName,
            subType: pic.bizType,
            url: url2,
            file_size: info.fileSize.toString()
          }
        };
      }
      if (segment) {
        if (typeof content === "string") {
          content += encodeCQCode(segment);
        } else {
          content.push(segment);
        }
      }
    }
    return {
      content,
      sender: {
        nickname: routingHead?.group ? routingHead.group.groupCard : routingHead.c2c.friendName,
        user_id: routingHead.fromUin
      },
      time: contentHead.msgTime,
      message_format: messageFormat === "string" ? "string" : "array",
      message_type: routingHead?.group ? "group" : "private"
    };
  }));
}
class GetForwardMsg extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetForwardMsg;
  payloadSchema = z$2.object({
    message_id: z$2.string(),
    id: z$2.string()
  });
  async _handle(payload, config2) {
    const msgId = payload.id || payload.message_id;
    if (!msgId) {
      throw Error("message_id");
    }
    const shortId = await this.ctx.store.getShortIdByMsgId(msgId);
    const msgInfo = await this.ctx.store.getMsgInfoByShortId(shortId || +msgId);
    if (!msgInfo) {
      throw Error("msg not found");
    }
    const multiMsgInfo = await this.ctx.store.getMultiMsgInfo(msgInfo.msgId);
    const rootMsgId = multiMsgInfo[0]?.rootMsgId ?? msgInfo.msgId;
    const peer = multiMsgInfo[0]?.peerUid ? {
      ...msgInfo.peer,
      chatType: multiMsgInfo[0].chatType,
      peerUid: multiMsgInfo[0].peerUid
    } : msgInfo.peer;
    const data = await this.ctx.ntMsgApi.getMultiMsg(peer, rootMsgId, msgInfo.msgId);
    if (data.result !== 0) {
      if (data.result === 2) {
        const res = await this.ctx.ntMsgApi.getMsgsByMsgId(msgInfo.peer, [msgInfo.msgId]);
        if (res.msgList.length === 0) {
          throw new Error("");
        }
        const msg = res.msgList[0];
        if (msg.elements[0].arkElement) {
          const { arkElement } = msg.elements[0];
          const data2 = JSON.parse(arkElement.bytesData);
          if (data2.app === "com.tencent.multimsg") {
            const resId = data2.meta.detail.resid;
            const res2 = await this.ctx.app.pmhq.getMultiMsg(resId);
            return { messages: await decodeMultiMessage(this.ctx, res2, config2.messageFormat) };
          }
        }
      }
      throw new Error(data.errMsg);
    }
    const messages = await Promise.all(
      data.msgList.map(async (msg) => {
        const res = await OB11Entities.message(this.ctx, msg, rootMsgId, peer, config2);
        if (res) {
          const segments = message2List(res.message);
          for (const item of segments) {
            if (item.type === OB11MessageDataType.Forward) {
              this.ctx.store.addMultiMsgInfo(rootMsgId, item.data.id, peer);
            }
          }
          return {
            content: res.message,
            sender: {
              nickname: res.sender.nickname,
              user_id: res.sender.user_id
            },
            time: res.time,
            message_format: res.message_format,
            message_type: res.message_type
          };
        }
      })
    );
    return { messages: filterNullable(messages) };
  }
}
let GetCookies$1 = class GetCookies extends BaseAction {
  actionName = ActionName.GetCookies;
  payloadSchema = z$2.object({
    domain: z$2.string().required()
  });
  async _handle(payload) {
    const blackList = ["pay.qq.com"];
    if (blackList.includes(payload.domain)) {
      throw new Error("cookie");
    }
    const cookiesObject = await this.ctx.ntUserApi.getCookies(payload.domain);
    if (!cookiesObject.p_skey) {
      const pSkey = (await this.ctx.ntUserApi.getPSkey([payload.domain])).domainPskeyMap.get(payload.domain);
      if (pSkey) {
        cookiesObject.p_skey = pSkey;
      }
    }
    const cookies = Object.entries(cookiesObject).map(([key2, value]) => `${key2}=${value}`).join("; ");
    const bkn = cookiesObject.skey ? this.ctx.ntWebApi.genBkn(cookiesObject.skey) : "";
    return { cookies, bkn };
  }
};
class SetMsgEmojiLike extends BaseAction {
  actionName = ActionName.SetMsgEmojiLike;
  payloadSchema = z$2.object({
    message_id: z$2.union([Number, String]).required(),
    emoji_id: z$2.union([Number, String]).required()
  });
  set = true;
  async _handle(payload) {
    const msg = await this.ctx.store.getMsgInfoByShortId(+payload.message_id);
    if (!msg) {
      throw new Error("msg not found");
    }
    const msgData = (await this.ctx.ntMsgApi.getMsgsByMsgId(msg.peer, [msg.msgId])).msgList;
    if (!msgData || msgData.length == 0 || !msgData[0].msgSeq) {
      throw new Error("find msg by msgid error");
    }
    const res = await this.ctx.ntMsgApi.setEmojiLike(
      msg.peer,
      msgData[0].msgSeq,
      payload.emoji_id.toString(),
      this.set
    );
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class UnSetMsgEmojiLike extends SetMsgEmojiLike {
  actionName = ActionName.UnSetMsgEmojiLike;
  set = false;
}
class ForwardSingleMsg extends BaseAction {
  payloadSchema = z$2.object({
    message_id: z$2.union([Number, String]).required(),
    group_id: z$2.union([Number, String]),
    user_id: z$2.union([Number, String])
  });
  async _handle(payload) {
    if (!(+payload.message_id >= -2147483648 && +payload.message_id <= 2147483647)) {
      const short_msg_id = await this.ctx.store.getShortIdByMsgId(String(payload.message_id));
      if (!short_msg_id) {
        throw new Error(`id${payload.message_id}`);
      }
      payload.message_id = short_msg_id;
    }
    const msg = await this.ctx.store.getMsgInfoByShortId(+payload.message_id);
    if (!msg) {
      throw new Error(`${payload.message_id}`);
    }
    const srcMsg = await this.ctx.ntMsgApi.getMsgsByMsgId(msg.peer, [msg.msgId]);
    if (srcMsg.msgList.length === 0) {
      throw new Error(`${payload.message_id}`);
    }
    const peer = await createPeer(this.ctx, payload);
    let ret;
    if (srcMsg.msgList[0].msgType === 8) {
      ret = await this.ctx.ntMsgApi.forwardMultiMsg(msg.peer, peer, [msg.msgId]);
    } else {
      ret = await this.ctx.ntMsgApi.forwardMsg(msg.peer, peer, [msg.msgId]);
    }
    const msgShortId = this.ctx.store.createMsgShortId(ret);
    return { message_id: msgShortId };
  }
}
class ForwardFriendSingleMsg extends ForwardSingleMsg {
  actionName = ActionName.ForwardFriendSingleMsg;
}
class ForwardGroupSingleMsg extends ForwardSingleMsg {
  actionName = ActionName.ForwardGroupSingleMsg;
}
class GetEssenceMsgList extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetEssenceMsgList;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    const groupCode = payload.group_id.toString();
    const peer = {
      guildId: "",
      chatType: ChatType.Group,
      peerUid: groupCode
    };
    const essence = await this.ctx.ntGroupApi.queryCachedEssenceMsg(groupCode);
    const data = [];
    for (const item of essence.items) {
      const { msgList } = await this.ctx.ntMsgApi.queryMsgsWithFilterExBySeq(peer, String(item.msgSeq), String(0), [await this.ctx.ntUserApi.getUidByUin(item.msgSenderUin, groupCode)]);
      const sourceMsg = msgList.find((e) => e.msgRandom === String(item.msgRandom));
      if (!sourceMsg) continue;
      data.push({
        sender_id: +item.msgSenderUin,
        sender_nick: item.msgSenderNick,
        sender_time: +sourceMsg.msgTime,
        operator_id: +item.opUin,
        operator_nick: item.opNick,
        operator_time: item.opTime,
        message_id: this.ctx.store.createMsgShortId(sourceMsg)
      });
    }
    return data;
  }
}
class GetGroupHonorInfo extends BaseAction {
  actionName = ActionName.GetGroupHonorInfo;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    type: z$2.union(["talkative", "performer", "legend", "strong_newbie", "emotion", "all"]).default("all")
  });
  async _handle(payload) {
    return await this.ctx.ntWebApi.getGroupHonorInfo(payload.group_id.toString(), payload.type);
  }
}
class HandleQuickOperation extends BaseAction {
  actionName = ActionName.GoCQHTTP_HandleQuickOperation;
  payloadSchema = z$2.object({
    context: z$2.any().required(),
    operation: z$2.any().required()
  });
  async _handle(payload) {
    handleQuickOperation(this.ctx, payload.context, payload.operation).catch((e) => this.ctx.logger.error(e));
    return null;
  }
}
class SetEssenceMsg extends BaseAction {
  actionName = ActionName.GoCQHTTP_SetEssenceMsg;
  payloadSchema = z$2.object({
    message_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    const msg = await this.ctx.store.getMsgInfoByShortId(+payload.message_id);
    if (!msg) {
      throw new Error("msg not found");
    }
    const res = await this.ctx.ntGroupApi.addGroupEssence(msg.peer.peerUid, msg.msgId);
    if (res.errCode !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class DeleteEssenceMsg extends BaseAction {
  actionName = ActionName.GoCQHTTP_DeleteEssenceMsg;
  payloadSchema = z$2.object({
    message_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    const msg = await this.ctx.store.getMsgInfoByShortId(+payload.message_id);
    if (!msg) {
      throw new Error("msg not found");
    }
    const res = await this.ctx.ntGroupApi.removeGroupEssence(
      msg.peer.peerUid,
      msg.msgId
    );
    if (res.errCode !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class GetEvent extends BaseAction {
  actionName = ActionName.GetEvent;
  payloadSchema = z$2.object({
    key: z$2.string(),
    timeout: z$2.union([Number, String])
  });
  async _handle(payload) {
    let key2 = "";
    if (payload.key) {
      key2 = payload.key;
    }
    const timeout2 = parseInt(payload.timeout?.toString()) || 0;
    const evts = await getHttpEvent(key2, timeout2);
    return evts;
  }
}
let DeleteGroupFile$1 = class DeleteGroupFile extends BaseAction {
  actionName = ActionName.GoCQHTTP_DeleteGroupFile;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    file_id: z$2.string().required(),
    busid: z$2.union([Number, String]).default(102)
  });
  async _handle(payload) {
    const res = await this.ctx.ntGroupApi.deleteGroupFile(payload.group_id.toString(), [payload.file_id], [+payload.busid]);
    if (res.transGroupFileResult.result.retCode !== 0) {
      throw new Error(res.transGroupFileResult.result.clientWording);
    }
    return null;
  }
};
class GetGroupSystemMsg extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupSystemMsg;
  async parse(notifies) {
    const data = { invited_requests: [], join_requests: [] };
    for (const notify of notifies) {
      if (notify.type === GroupNotifyType.InvitedByMember) {
        data.invited_requests.push({
          request_id: +notify.seq,
          invitor_uin: Number(await this.ctx.ntUserApi.getUinByUid(notify.user1.uid)),
          invitor_nick: notify.user1.nickName,
          group_id: +notify.group.groupCode,
          group_name: notify.group.groupName,
          checked: notify.status !== GroupNotifyStatus.Unhandle,
          actor: notify.user2?.uid ? Number(await this.ctx.ntUserApi.getUinByUid(notify.user2.uid)) : 0
        });
      } else if (notify.type === GroupNotifyType.RequestJoinNeedAdminiStratorPass) {
        data.join_requests.push({
          request_id: +notify.seq,
          requester_uin: Number(await this.ctx.ntUserApi.getUinByUid(notify.user1.uid)),
          requester_nick: notify.user1.nickName,
          message: notify.postscript,
          group_id: +notify.group.groupCode,
          group_name: notify.group.groupName,
          checked: notify.status !== GroupNotifyStatus.Unhandle,
          actor: notify.user2?.uid ? Number(await this.ctx.ntUserApi.getUinByUid(notify.user2.uid)) : 0
        });
      }
    }
    return data;
  }
  async _handle() {
    const res = await this.ctx.ntGroupApi.getGroupRequest();
    return await this.parse(res.notifies);
  }
}
class CreateGroupFileFolder extends BaseAction {
  actionName = ActionName.GoCQHTTP_CreateGroupFileFolder;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    name: z$2.string().required()
  });
  async _handle(payload) {
    const res = await this.ctx.ntGroupApi.createGroupFileFolder(payload.group_id.toString(), payload.name);
    if (res.resultWithGroupItem.result.retCode !== 0) {
      throw new Error(res.resultWithGroupItem.result.clientWording);
    }
    return {
      folder_id: res.resultWithGroupItem.groupItem.folderInfo.folderId
    };
  }
}
let DeleteGroupFolder$1 = class DeleteGroupFolder extends BaseAction {
  actionName = ActionName.GoCQHTTP_DeleteGroupFolder;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    folder_id: z$2.string().required()
  });
  async _handle(payload) {
    const res = await this.ctx.ntGroupApi.deleteGroupFileFolder(payload.group_id.toString(), payload.folder_id);
    if (res.groupFileCommonResult.retCode !== 0) {
      throw new Error(res.groupFileCommonResult.clientWording);
    }
    return null;
  }
};
class GetGroupAtAllRemain extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupAtAllRemain;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    const data = await this.ctx.ntGroupApi.getGroupRemainAtTimes(payload.group_id.toString());
    if (data.errCode !== 0) {
      throw new Error(data.errMsg);
    }
    return {
      can_at_all: data.atInfo.canAtAll,
      remain_at_all_count_for_group: data.atInfo.RemainAtAllCountForGroup,
      remain_at_all_count_for_uin: data.atInfo.RemainAtAllCountForUin
    };
  }
}
class GetGroupRootFiles extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupRootFiles;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    const groupId = payload.group_id.toString();
    const data = [];
    let nextIndex;
    while (nextIndex !== 0) {
      const res = await this.ctx.ntGroupApi.getGroupFileList(groupId, {
        sortType: 1,
        fileCount: 100,
        startIndex: nextIndex ?? 0,
        sortOrder: 2,
        showOnlinedocFolder: 0
      });
      data.push(...res.item);
      nextIndex = res.nextIndex;
    }
    return {
      files: data.filter((item) => item.fileInfo).map((item) => {
        const file2 = item.fileInfo;
        return {
          group_id: +item.peerId,
          file_id: file2.fileId,
          file_name: file2.fileName,
          busid: file2.busId,
          file_size: +file2.fileSize,
          upload_time: file2.uploadTime,
          dead_time: file2.deadTime,
          modify_time: file2.modifyTime,
          download_times: file2.downloadTimes,
          uploader: +file2.uploaderUin,
          uploader_name: file2.uploaderName
        };
      }),
      folders: data.filter((item) => item.folderInfo).map((item) => {
        const folder = item.folderInfo;
        return {
          group_id: +item.peerId,
          folder_id: folder.folderId,
          folder_name: folder.folderName,
          create_time: folder.createTime,
          creator: +folder.createUin,
          creator_name: folder.creatorName,
          total_file_count: folder.totalFileCount
        };
      })
    };
  }
}
class SetOnlineStatus extends BaseAction {
  actionName = ActionName.SetOnlineStatus;
  payloadSchema = z$2.object({
    status: z$2.union([Number, String]).required(),
    ext_status: z$2.union([Number, String]).required(),
    battery_status: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    const ret = await this.ctx.ntUserApi.setSelfStatus(
      Number(payload.status),
      Number(payload.ext_status),
      Number(payload.battery_status)
    );
    if (ret.result !== 0) {
      throw new Error(ret.errMsg);
    }
    return null;
  }
}
class SendGroupNotice extends BaseAction {
  actionName = ActionName.GoCQHTTP_SendGroupNotice;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    content: z$2.string().required(),
    image: z$2.string(),
    pinned: z$2.union([Number, String]).default(0),
    confirm_required: z$2.union([Number, String]).default(1)
  });
  async _handle(payload) {
    const groupCode = payload.group_id.toString();
    const pinned = +payload.pinned;
    const confirmRequired = +payload.confirm_required;
    let picInfo;
    if (payload.image) {
      const { path: path2, isLocal, success: success2, errMsg } = await uri2local(this.ctx, payload.image, true);
      if (!success2) {
        throw new Error(`, : ${errMsg}`);
      }
      const result = await this.ctx.ntGroupApi.uploadGroupBulletinPic(groupCode, path2);
      if (result.errCode !== 0) {
        throw new Error(`, : ${result.errMsg}`);
      }
      if (!isLocal) {
        unlink$1(path2).then().catch((e) => {
        });
      }
      picInfo = result.picInfo;
    }
    const res = await this.ctx.ntGroupApi.publishGroupBulletin(groupCode, {
      text: encodeURIComponent(payload.content),
      oldFeedsId: "",
      pinned,
      confirmRequired,
      picInfo
    });
    if (res.result !== 0) {
      throw new Error(`, : ${res.errMsg}`);
    }
    return null;
  }
}
class GetProfileLikeMe extends BaseAction {
  actionName = ActionName.GetProfileLikeMe;
  payloadSchema = z$2.object({
    start: z$2.union([Number, String]).default(0),
    // 0-1
    count: z$2.union([Number, String]).default(20)
    // 30
  });
  async _handle(payload) {
    const ret = await this.ctx.ntUserApi.getProfileLikeMe(selfInfo.uid, +payload.start, +payload.count);
    if (ret.result !== 0) {
      throw new Error(ret.errMsg);
    }
    const users = ret.info.userLikeInfos[0].voteInfo.userInfos;
    for (const item of users) {
      try {
        item.uin = Number(await this.ctx.ntUserApi.getUinByUid(item.uid)) || 0;
      } catch (e) {
        item.uin = 0;
      }
    }
    return { users, nextStart: ret.info.start };
  }
}
class FetchEmojiLike extends BaseAction {
  actionName = ActionName.FetchEmojiLike;
  payloadSchema = z$2.object({
    emoji_id: z$2.string().required(),
    message_id: z$2.union([Number, String]).required(),
    count: z$2.union([Number, String]).default(20)
  });
  async _handle(payload) {
    const msgInfo = await this.ctx.store.getMsgInfoByShortId(+payload.message_id);
    if (!msgInfo) throw new Error("");
    const { msgSeq } = (await this.ctx.ntMsgApi.getMsgsByMsgId(msgInfo.peer, [msgInfo.msgId])).msgList[0];
    return await this.ctx.ntMsgApi.getMsgEmojiLikesList(msgInfo.peer, msgSeq, payload.emoji_id, +payload.count);
  }
}
class FetchCustomFace extends BaseAction {
  actionName = ActionName.FetchCustomFace;
  payloadSchema = z$2.object({
    count: z$2.union([Number, String]).default(48)
  });
  async _handle(payload) {
    const ret = await this.ctx.ntMsgApi.fetchFavEmojiList(+payload.count);
    if (ret.result !== 0) {
      throw new Error(ret.errMsg);
    }
    return ret.emojiInfoList.map((e) => e.url);
  }
}
class GetFriendMsgHistory extends BaseAction {
  actionName = ActionName.GetFriendMsgHistory;
  payloadSchema = z$2.object({
    user_id: z$2.union([Number, String]).required(),
    message_seq: z$2.union([Number, String]),
    count: z$2.union([Number, String]).default(20),
    reverseOrder: z$2.union([Boolean, z$2.transform(String, parseBool)]).default(false)
  });
  async getMessage(config2, peer, count, seq) {
    let msgList;
    if (!seq || +seq === 0) {
      msgList = (await this.ctx.ntMsgApi.getAioFirstViewLatestMsgs(peer, count)).msgList;
    } else {
      msgList = (await this.ctx.ntMsgApi.getMsgsBySeqAndCount(peer, String(seq), count, true, true)).msgList;
    }
    if (!msgList?.length) return;
    const ob11MsgList = await Promise.all(msgList.map((msg) => {
      let rawMsg = msg;
      if (rawMsg.recallTime !== "0") {
        let msg2 = this.ctx.store.getMsgCache(rawMsg.msgId);
        if (msg2) {
          rawMsg = msg2;
        }
      }
      return OB11Entities.message(this.ctx, rawMsg, void 0, void 0, config2);
    }));
    return { list: filterNullable(ob11MsgList), seq: +msgList[0].msgSeq };
  }
  async _handle(payload, config2) {
    const uid = await this.ctx.ntUserApi.getUidByUin(payload.user_id.toString());
    if (!uid) throw new Error(``);
    const isBuddy = await this.ctx.ntFriendApi.isBuddy(uid);
    const peer = {
      chatType: isBuddy ? ChatType.C2C : ChatType.TempC2CFromGroup,
      peerUid: uid,
      guildId: ""
    };
    const messages = [];
    let seq = payload.message_seq;
    let count = +payload.count;
    while (count > 0) {
      const res = await this.getMessage(config2, peer, count, seq);
      if (!res) break;
      seq = res.seq - 1;
      count -= res.list.length;
      messages.unshift(...res.list);
    }
    if (payload.reverseOrder) messages.reverse();
    return { messages };
  }
}
class GetGroupFilesByFolder extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupFilesByFolder;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    folder_id: z$2.string().required()
  });
  async _handle(payload) {
    const groupId = payload.group_id.toString();
    const data = [];
    let nextIndex;
    while (nextIndex !== 0) {
      const res = await this.ctx.ntGroupApi.getGroupFileList(groupId, {
        sortType: 1,
        fileCount: 100,
        startIndex: nextIndex ?? 0,
        sortOrder: 2,
        showOnlinedocFolder: 0,
        folderId: payload.folder_id
      });
      data.push(...res.item);
      nextIndex = res.nextIndex;
    }
    return {
      files: data.filter((item) => item.fileInfo).map((item) => {
        const file2 = item.fileInfo;
        return {
          group_id: +item.peerId,
          file_id: file2.fileId,
          file_name: file2.fileName,
          busid: file2.busId,
          file_size: +file2.fileSize,
          upload_time: file2.uploadTime,
          dead_time: file2.deadTime,
          modify_time: file2.modifyTime,
          download_times: file2.downloadTimes,
          uploader: +file2.uploaderUin,
          uploader_name: file2.uploaderName
        };
      }),
      folders: []
    };
  }
}
class GetFriendWithCategory extends BaseAction {
  actionName = ActionName.GetFriendsWithCategory;
  async _handle() {
    const res = await this.ctx.ntFriendApi.getBuddyV2(true);
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    const buddyList = await this.ctx.ntFriendApi.getBuddyList();
    const buddyMap = /* @__PURE__ */ new Map();
    for (const buddy of buddyList) {
      buddyMap.set(buddy.uid, buddy);
    }
    const category = [];
    for (const item of res.data) {
      const buddyList2 = [];
      for (const uid of item.buddyUids) {
        buddyList2.push(buddyMap.get(uid));
      }
      category.push({
        ...item,
        buddyList: buddyList2
      });
    }
    return category.map((item) => {
      return {
        categoryId: item.categoryId,
        categorySortId: item.categorySortId,
        categoryName: item.categroyName,
        categoryMbCount: item.categroyMbCount,
        onlineCount: item.onlineCount,
        buddyList: item.buddyList.map((buddy) => {
          return OB11Entities.friend(buddy);
        })
      };
    });
  }
}
let UploadGroupFile$1 = class UploadGroupFile extends BaseAction {
  actionName = ActionName.GoCQHTTP_UploadGroupFile;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    file: z$2.string().required(),
    name: z$2.string(),
    folder: z$2.string(),
    folder_id: z$2.string()
  });
  async _handle(payload) {
    const { success: success2, errMsg, path: path2, fileName } = await uri2local(this.ctx, payload.file);
    if (!success2) {
      throw new Error(errMsg);
    }
    const name = payload.name || fileName;
    if (name.includes("/") || name.includes("\\")) {
      throw new Error(` ${name} `);
    }
    const file2 = await SendElement.file(this.ctx, path2, name, payload.folder ?? payload.folder_id);
    const peer = await createPeer(this.ctx, payload, CreatePeerMode.Group);
    const msg = await this.ctx.app.sendMessage(this.ctx, peer, [file2], []);
    return {
      file_id: msg.elements[0].fileElement.fileUuid
    };
  }
};
let UploadPrivateFile$1 = class UploadPrivateFile extends BaseAction {
  actionName = ActionName.GoCQHTTP_UploadPrivateFile;
  payloadSchema = z$2.object({
    user_id: z$2.union([Number, String]).required(),
    file: z$2.string().required(),
    name: z$2.string()
  });
  async _handle(payload) {
    const { success: success2, errMsg, path: path2, fileName } = await uri2local(this.ctx, payload.file);
    if (!success2) {
      throw new Error(errMsg);
    }
    const name = payload.name || fileName;
    if (name.includes("/") || name.includes("\\")) {
      throw new Error(` ${name} `);
    }
    const sendFileEle = await SendElement.file(this.ctx, path2, name);
    const peer = await createPeer(this.ctx, payload, CreatePeerMode.Private);
    const msg = await this.ctx.app.sendMessage(this.ctx, peer, [sendFileEle], []);
    return {
      file_id: msg.elements[0].fileElement.fileUuid
    };
  }
};
class GetGroupFileUrl extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupFileUrl;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    file_id: z$2.string().required()
  });
  async _handle(payload) {
    const file2 = await this.ctx.store.getFileCacheById(payload.file_id);
    const url2 = await this.ctx.app.pmhq.getGroupFileUrl(+payload.group_id, payload.file_id);
    if (file2.length > 0) {
      return { url: url2 + encodeURIComponent(file2[0].fileName) };
    } else {
      const groupId = payload.group_id.toString();
      const fileName = await this.search(groupId, payload.file_id);
      if (fileName) {
        return { url: url2 + encodeURIComponent(fileName) };
      } else {
        return { url: url2 };
      }
    }
  }
  async search(groupId, fileId, folderId) {
    let fileName;
    let nextIndex;
    const folders = [];
    while (nextIndex !== 0) {
      const res = await this.ctx.ntGroupApi.getGroupFileList(groupId, {
        sortType: 1,
        fileCount: 100,
        startIndex: nextIndex ?? 0,
        sortOrder: 2,
        showOnlinedocFolder: 0,
        folderId
      });
      const file2 = res.item.find((item) => item.fileInfo?.fileId === fileId);
      if (file2) {
        fileName = file2.fileInfo?.fileName;
        break;
      }
      folders.push(...res.item.filter((item) => item.folderInfo?.totalFileCount));
      nextIndex = res.nextIndex;
    }
    if (!fileName) {
      for (const item of folders) {
        const res = await this.search(groupId, fileId, item.folderInfo?.folderId);
        if (res) {
          fileName = res;
          break;
        }
      }
    }
    return fileName;
  }
}
class GetGroupNotice extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupNotice;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    const data = await this.ctx.ntGroupApi.getGroupBulletinList(payload.group_id.toString());
    const result = [];
    for (const feed of data.feeds) {
      result.push({
        notice_id: feed.feedId,
        sender_id: +feed.uin,
        publish_time: +feed.publishTime,
        message: {
          text: feed.msg.text,
          images: feed.msg.pics.map((image) => {
            return {
              height: String(image.height),
              width: String(image.width),
              id: image.id
            };
          })
        }
      });
    }
    return result;
  }
}
class GetRobotUinRange extends BaseAction {
  actionName = ActionName.GetRobotUinRange;
  async _handle() {
    const res = await this.ctx.ntUserApi.getRobotUinRange();
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return res.response.robotUinRanges;
  }
}
let DeleteFriend$1 = class DeleteFriend extends BaseAction {
  actionName = ActionName.GoCQHTTP_DeleteFriend;
  payloadSchema = z$2.object({
    user_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    const uin = payload.user_id.toString();
    const uid = await this.ctx.ntUserApi.getUidByUin(uin);
    if (!uid) throw new Error("");
    const res = await this.ctx.ntFriendApi.delBuddy(uid);
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
};
class OCRImage extends BaseAction {
  actionName = ActionName.GoCQHTTP_OCRImage;
  payloadSchema = z$2.object({
    image: z$2.string().required()
  });
  async _handle(payload) {
    const { errMsg, isLocal, path: path2, success: success2 } = await uri2local(this.ctx, payload.image, true);
    if (!success2) {
      throw new Error(errMsg);
    }
    await access(path2);
    const data = await this.ctx.ntFileApi.ocrImage(path2);
    if (!isLocal) {
      unlink(path2).then().catch((e) => {
      });
    }
    if (data.code !== 0) {
      throw new Error(data.errMsg);
    }
    const texts = data.result.map((item) => {
      const ret = {
        text: item.text,
        confidence: 1,
        coordinates: []
      };
      for (let i = 0; i < 4; i++) {
        const pt2 = item[`pt${i + 1}`];
        ret.coordinates.push({
          x: parseInt(pt2.x),
          y: parseInt(pt2.y)
        });
      }
      return ret;
    });
    return {
      texts,
      language: ""
    };
  }
}
class GroupPoke extends BaseAction {
  actionName = ActionName.GroupPoke;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    user_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    await this.ctx.app.pmhq.sendGroupPoke(+payload.group_id, +payload.user_id);
    return null;
  }
}
class FriendPoke extends BaseAction {
  actionName = ActionName.FriendPoke;
  payloadSchema = z$2.object({
    user_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    await this.ctx.app.pmhq.sendFriendPoke(+payload.user_id);
    return null;
  }
}
class GetGroupFileSystemInfo extends BaseAction {
  actionName = ActionName.GoCQHTTP_GetGroupFileSystemInfo;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    const groupId = payload.group_id.toString();
    const fileCount = await this.ctx.ntGroupApi.getGroupFileCount(groupId);
    if (fileCount.result !== 0) {
      throw new Error(fileCount.errMsg);
    }
    const fileSpace = await this.ctx.ntGroupApi.getGroupFileSpace(groupId);
    if (fileSpace.result !== 0) {
      throw new Error(fileSpace.errMsg);
    }
    return {
      file_count: fileCount.groupFileCounts[0],
      limit_count: 1e4,
      used_space: +fileSpace.groupSpaceResult.usedSpace,
      total_space: +fileSpace.groupSpaceResult.totalSpace
    };
  }
}
class GetCredentials extends BaseAction {
  actionName = ActionName.GetCredentials;
  payloadSchema = z$2.object({
    domain: z$2.string().required()
  });
  async _handle(payload) {
    const cookiesObject = await this.ctx.ntUserApi.getCookies(payload.domain);
    const cookies = Object.entries(cookiesObject).map(([key2, value]) => `${key2}=${value}`).join("; ");
    const bkn = cookiesObject.skey ? this.ctx.ntWebApi.genBkn(cookiesObject.skey) : "";
    return { cookies, csrf_token: +bkn };
  }
}
class SetGroupSpecialTitle extends BaseAction {
  actionName = ActionName.GoCQHTTP_SetGroupSpecialTitle;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    user_id: z$2.union([Number, String]).required(),
    special_title: z$2.string().default("")
  });
  async _handle(payload) {
    const groupCode = payload.group_id.toString();
    const uin = payload.user_id.toString();
    const uid = await this.ctx.ntUserApi.getUidByUin(uin, groupCode);
    if (!uid) throw new Error(`${uin}uid`);
    const self2 = await this.ctx.ntGroupApi.getGroupMember(groupCode, selfInfo.uid, false);
    if (self2.role !== GroupMemberRole.Owner) {
      throw new Error(`${groupCode}`);
    }
    await this.ctx.app.pmhq.setSpecialTitle(+payload.group_id, uid, payload.special_title);
    return null;
  }
}
class SendGroupSign extends BaseAction {
  actionName = ActionName.GoCQHTTP_SendGroupSign;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    await this.ctx.app.pmhq.groupClockIn(String(payload.group_id));
    return null;
  }
}
class SetRestart extends BaseAction {
  actionName = ActionName.SetRestart;
  async _handle() {
    await this.ctx.ntSystemApi.restart();
    return null;
  }
}
class SetFriendCategory extends BaseAction {
  actionName = ActionName.SetFriendCategory;
  payloadSchema = z$2.object({
    user_id: z$2.union([Number, String]).required(),
    category_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    const uid = await this.ctx.ntUserApi.getUidByUin(payload.user_id.toString());
    if (!uid) throw new Error("");
    const res = await this.ctx.ntFriendApi.setBuddyCategory(uid, +payload.category_id);
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class SetFriendRemark extends BaseAction {
  actionName = ActionName.SetFriendRemark;
  payloadSchema = z$2.object({
    user_id: z$2.union([Number, String]).required(),
    remark: z$2.string().default("")
  });
  async _handle(payload) {
    const uid = await this.ctx.ntUserApi.getUidByUin(payload.user_id.toString());
    if (!uid) throw new Error("");
    const res = await this.ctx.ntFriendApi.setBuddyRemark(uid, payload.remark);
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class SetGroupMsgMask extends BaseAction {
  actionName = ActionName.SetGroupMsgMask;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    mask: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    const res = await this.ctx.ntGroupApi.setGroupMsgMask(payload.group_id.toString(), +payload.mask);
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class SetGroupRemark extends BaseAction {
  actionName = ActionName.SetGroupRemark;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    remark: z$2.string()
  });
  async _handle(payload) {
    const res = await this.ctx.ntGroupApi.setGroupRemark(payload.group_id.toString(), payload.remark);
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class SetQQProfile extends BaseAction {
  actionName = ActionName.GoCQHTTP_SetQQProfile;
  payloadSchema = z$2.object({
    nickname: z$2.string(),
    personal_note: z$2.string()
  });
  async _handle(payload) {
    const old = (await this.ctx.ntUserApi.getUserDetailInfoWithBizInfo(selfInfo.uid)).simpleInfo;
    const res = await this.ctx.ntUserApi.modifySelfProfile({
      nick: payload.nickname ?? old.coreInfo.nick,
      longNick: payload.personal_note ?? old.baseInfo.longNick,
      sex: old.baseInfo.sex,
      birthday: {
        birthday_year: old.baseInfo.birthday_year,
        birthday_month: old.baseInfo.birthday_month,
        birthday_day: old.baseInfo.birthday_day
      },
      location: {
        country: "",
        province: "",
        city: "",
        zone: ""
      }
    });
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class GetProfileLike extends BaseAction {
  actionName = ActionName.GetProfileLike;
  payloadSchema = z$2.object({
    start: z$2.union([Number, String]).default(0),
    // 0-1
    count: z$2.union([Number, String]).default(20)
    // 30
  });
  async _handle(payload) {
    const ret = await this.ctx.ntUserApi.getProfileLike(selfInfo.uid, +payload.start, +payload.count);
    if (ret.result !== 0) {
      throw new Error(ret.errMsg);
    }
    const users = ret.info.userLikeInfos[0].favoriteInfo.userInfos;
    for (const item of users) {
      try {
        item.uin = Number(await this.ctx.ntUserApi.getUinByUid(item.uid)) || 0;
      } catch (e) {
        item.uin = 0;
      }
    }
    return { users, nextStart: ret.info.start };
  }
}
class GetCsrfToken extends BaseAction {
  actionName = ActionName.GetCsrfToken;
  async _handle() {
    const cookiesObject = await this.ctx.ntUserApi.getCookies("h5.qzone.qq.com");
    const bkn = this.ctx.ntWebApi.genBkn(cookiesObject.skey);
    return { token: +bkn };
  }
}
class SetGroupPortrait extends BaseAction {
  actionName = ActionName.GoCQHTTP_SetGroupPortrait;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    file: z$2.string().required()
  });
  async _handle(payload) {
    const { path: path2, isLocal, errMsg } = await uri2local(this.ctx, payload.file);
    if (errMsg) {
      throw new Error(errMsg);
    }
    const groupCode = payload.group_id.toString();
    const res = await this.ctx.ntGroupApi.setGroupAvatar(groupCode, path2);
    if (!isLocal) {
      unlink(path2).then().catch((e) => {
      });
    }
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
let MoveGroupFile$1 = class MoveGroupFile extends BaseAction {
  actionName = ActionName.MoveGroupFile;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    file_id: z$2.string().required(),
    parent_directory: z$2.string().required(),
    target_directory: z$2.string().required()
  });
  async _handle(payload) {
    const groupId = payload.group_id.toString();
    const res = await this.ctx.ntGroupApi.moveGroupFile(groupId, [payload.file_id], payload.parent_directory, payload.target_directory);
    if (res.moveGroupFileResult.result.retCode !== 0) {
      throw new Error(res.moveGroupFileResult.result.clientWording);
    }
    return null;
  }
};
class GetGroupShutList extends BaseAction {
  actionName = ActionName.GetGroupShutList;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    try {
      const groupCode = payload.group_id.toString();
      return await this.ctx.ntGroupApi.getGroupShutUpMemberList(groupCode);
    } catch (e) {
      if (e instanceof DetailedError) {
        if (e.data.result === 120271006) {
          return [];
        } else {
          throw new Error(e.data.errMsg);
        }
      }
      throw e;
    }
  }
}
class RenameGroupFileFolder extends BaseAction {
  actionName = ActionName.RenameGroupFileFolder;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    folder_id: z$2.string().required(),
    new_folder_name: z$2.string().required()
  });
  async _handle(payload) {
    const groupId = payload.group_id.toString();
    const res = await this.ctx.ntGroupApi.renameGroupFolder(groupId, payload.folder_id, payload.new_folder_name);
    if (res.resultWithGroupItem.result.retCode !== 0) {
      throw new Error(res.resultWithGroupItem.result.clientWording);
    }
    return null;
  }
}
class VoiceMsg2Text extends BaseAction {
  actionName = ActionName.VoiceMsg2Text;
  payloadSchema = z$2.object({
    message_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    const msgInfo = await this.ctx.store.getMsgInfoByShortId(+payload.message_id);
    if (!msgInfo) {
      throw new Error("");
    }
    let msg = this.ctx.store.getMsgCache(msgInfo.msgId);
    if (!msg) {
      const res = await this.ctx.ntMsgApi.getMsgsByMsgId(msgInfo.peer, [msgInfo.msgId]);
      if (res.msgList.length === 0) {
        throw new Error("");
      }
      msg = res.msgList[0];
    }
    const voiceElement = msg.elements.find((e) => e.elementType === ElementType.Ptt);
    if (!voiceElement) {
      throw new Error("");
    }
    const text = await this.ctx.ntMsgApi.translatePtt2Text(msgInfo.msgId, msgInfo.peer, voiceElement);
    if (!text) {
      throw new Error("");
    }
    return { text };
  }
}
class SendPB extends BaseAction {
  actionName = ActionName.SendPB;
  payloadSchema = z$2.object({
    cmd: z$2.string().required(),
    hex: z$2.string().required()
  });
  async _handle(payload) {
    try {
      const result = await this.ctx.app.pmhq.sendPB(payload.cmd, payload.hex);
      return {
        cmd: result.cmd,
        hex: result.pb,
        ...result.echo !== void 0 ? { echo: result.echo } : {}
      };
    } catch (e) {
      this.ctx.logger.error("pmhq ", e);
      throw new Error(`pmhq : ${e}`, { cause: e });
    }
  }
}
class GetRKey extends BaseAction {
  actionName = ActionName.GetRKey;
  async _handle() {
    const rkey = await this.ctx.app.pmhq.getRKey();
    const now = /* @__PURE__ */ new Date();
    const updatedTime = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}-${String(now.getDate()).padStart(2, "0")} ${String(now.getHours()).padStart(2, "0")}:${String(now.getMinutes()).padStart(2, "0")}:${String(now.getSeconds()).padStart(2, "0")}`;
    return {
      private_key: rkey.privateRKey,
      group_key: rkey.groupRKey,
      expired_time: rkey.expiredTime,
      updated_time: updatedTime
    };
  }
}
class UploadFlashFile extends BaseAction {
  actionName = ActionName.UploadFlashFile;
  payloadSchema = z$2.object({
    title: z$2.string(),
    paths: z$2.array(String).required()
  });
  async _handle(payload) {
    const { title, paths } = payload;
    const localPaths = await Promise.all(
      paths.map(async (path2) => {
        const { fileName, path: localPath, isLocal, errMsg } = await uri2local(this.ctx, path2);
        if (errMsg) {
          throw new Error(errMsg);
        }
        if (localPath) {
          return localPath;
        } else {
          throw new Error(`${path2}`);
        }
      })
    );
    const res = await this.ctx.ntFileApi.uploadFlashFile(title, localPaths);
    if (res.result !== 0) {
      throw new Error(res.result);
    }
    if (!res.createFlashTransferResult) {
      const oldFlashFileInfo = await this.ctx.ntFileApi.getFlashFileInfo(res.fileSetId);
      return {
        file_set_id: oldFlashFileInfo.fileSetId,
        share_link: oldFlashFileInfo.shareInfo.shareLink,
        expire_time: parseInt(oldFlashFileInfo.expireTime)
      };
    }
    return {
      file_set_id: res.createFlashTransferResult.fileSetId,
      share_link: res.createFlashTransferResult.shareLink,
      expire_time: parseInt(res.createFlashTransferResult.expireTime)
    };
  }
}
class GetQQAvatar extends BaseAction {
  actionName = ActionName.GetQQAvatar;
  payloadSchema = z$2.object({
    user_id: z$2.union([Number, String]),
    group_id: z$2.union([Number, String])
  });
  async _handle(payload) {
    if (payload.user_id) {
      return { url: `https://thirdqq.qlogo.cn/g?b=qq&nk=${payload.user_id}&s=640` };
    } else if (payload.group_id) {
      return { url: `https://p.qlogo.cn/gh/${payload.group_id}/${payload.group_id}/0` };
    } else {
      throw new Error(" user_id  group_id");
    }
  }
}
class GetFlashFileInfoBase extends BaseAction {
  actionName = ActionName.GetFlashFileInfo;
  payloadSchema = z$2.object({
    share_link: z$2.string(),
    file_set_id: z$2.string()
  });
  async get_file_set_id(payload) {
    let { share_link, file_set_id } = payload;
    if (share_link) {
      const match = share_link.match(/qfile.qq.com\/q\/([\w\d]+)/);
      if (!match) {
        throw new Error("");
      }
      const code = match[1];
      const res = await this.ctx.ntFileApi.getFlashFileSetIdByCode(code);
      if (res.result !== 0) {
        throw new Error(` fileSetId : ${res.errMsg}`);
      }
      file_set_id = res.fileSetId;
    }
    if (!file_set_id) {
      throw new Error(" share_link  file_set_id");
    }
    return file_set_id;
  }
  async _handle(payload) {
    throw new Error("Method not implemented.");
  }
}
class GetFlashFileInfo extends GetFlashFileInfoBase {
  actionName = ActionName.GetFlashFileInfo;
  async _handle(payload) {
    const file_set_id = await this.get_file_set_id(payload);
    const fileInfo = await this.ctx.ntFileApi.getFlashFileInfo(file_set_id);
    const fileList = await this.ctx.ntFileApi.getFlashFileList(file_set_id);
    const files = [];
    for (const file2 of fileList) {
      for (const file22 of file2.fileList) {
        files.push({
          name: file22.name,
          size: parseInt(file22.fileSize)
        });
      }
    }
    return {
      file_set_id,
      title: fileInfo.name,
      share_link: fileInfo.shareInfo.shareLink,
      total_file_size: parseInt(fileInfo.totalFileSize),
      files
    };
  }
}
class DownloadFlashFile extends GetFlashFileInfoBase {
  actionName = ActionName.DownloadFlashFile;
  async _handle(payload) {
    const file_set_id = await this.get_file_set_id(payload);
    const res = await this.ctx.ntFileApi.downloadFlashFile(file_set_id);
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class GetRecommendFace extends BaseAction {
  actionName = ActionName.GetRecommendFace;
  payloadSchema = z$2.object({
    word: z$2.string().required()
  });
  async _handle(payload) {
    const res = await this.ctx.app.pmhq.pullPics(payload.word);
    return { url: res.info.map((e) => e.url) };
  }
}
class BatchDeleteGroupMember extends BaseAction {
  actionName = ActionName.BatchDeleteGroupMember;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    user_ids: z$2.array(z$2.union([Number, String])).required()
  });
  async _handle(payload) {
    const groupCode = payload.group_id.toString();
    const memberUinList = payload.user_ids.map((id2) => id2.toString());
    const memberUids = await Promise.all(memberUinList.map(async (uin) => {
      return await this.ctx.ntUserApi.getUidByUin(uin, groupCode);
    }));
    const res = await this.ctx.ntGroupApi.kickMember(groupCode, memberUids);
    if (res.errCode !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
var lib$1 = {};
var caseConvert = {};
var hasRequiredCaseConvert;
function requireCaseConvert() {
  if (hasRequiredCaseConvert) return caseConvert;
  hasRequiredCaseConvert = 1;
  Object.defineProperty(caseConvert, "__esModule", { value: true });
  caseConvert.objectToPascal = caseConvert.toPascal = caseConvert.objectToSnake = caseConvert.toSnake = caseConvert.objectToCamel = caseConvert.toCamel = void 0;
  function convertObject(obj, keyConverter) {
    if (obj === null || typeof obj === "undefined" || typeof obj !== "object") {
      return obj;
    }
    const out = Array.isArray(obj) ? [] : {};
    for (const [k, v] of Object.entries(obj)) {
      out[keyConverter(k)] = Array.isArray(v) ? v.map((item) => typeof item === "object" && !(item instanceof Uint8Array) && !(item instanceof Date) ? convertObject(item, keyConverter) : item) : v instanceof Uint8Array || v instanceof Date ? v : typeof v === "object" ? convertObject(v, keyConverter) : v;
    }
    return out;
  }
  function toCamel(term) {
    return term.length === 1 ? term.toLowerCase() : term.replace(/^([A-Z])/, (m) => m[0].toLowerCase()).replace(/[_-]([a-z0-9])/g, (m) => m[1].toUpperCase());
  }
  caseConvert.toCamel = toCamel;
  function objectToCamel(obj) {
    return convertObject(obj, toCamel);
  }
  caseConvert.objectToCamel = objectToCamel;
  function toSnake(term) {
    var _a2, _b;
    let result = term;
    let circuitBreaker = 0;
    while ((((_a2 = /([a-z])([0-9])/.exec(result)) === null || _a2 === void 0 ? void 0 : _a2.length) || 0) > 2 && circuitBreaker < 10) {
      result = result.replace(/([a-z])([0-9])/, (_all, $1, $2) => `${$1.toLowerCase()}_${$2.toLowerCase()}`);
      circuitBreaker += 1;
    }
    while ((((_b = /(.+?)([A-Z])/.exec(result)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 2 && circuitBreaker < 10) {
      result = result.replace(/(.+?)([A-Z])/, (_all, $1, $2) => `${$1.toLowerCase()}_${$2.toLowerCase()}`);
      circuitBreaker += 1;
    }
    return result.toLowerCase();
  }
  caseConvert.toSnake = toSnake;
  function objectToSnake(obj) {
    return convertObject(obj, toSnake);
  }
  caseConvert.objectToSnake = objectToSnake;
  function toPascal(term) {
    return toCamel(term).replace(/^([a-z])/, (m) => m[0].toUpperCase());
  }
  caseConvert.toPascal = toPascal;
  function objectToPascal(obj) {
    return convertObject(obj, toPascal);
  }
  caseConvert.objectToPascal = objectToPascal;
  return caseConvert;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$1;
  hasRequiredLib$1 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.objectToPascal = exports$1.toPascal = exports$1.toCamel = exports$1.toSnake = exports$1.objectToSnake = exports$1.objectToCamel = void 0;
    var caseConvert_1 = requireCaseConvert();
    Object.defineProperty(exports$1, "objectToCamel", { enumerable: true, get: function() {
      return caseConvert_1.objectToCamel;
    } });
    Object.defineProperty(exports$1, "objectToSnake", { enumerable: true, get: function() {
      return caseConvert_1.objectToSnake;
    } });
    Object.defineProperty(exports$1, "toSnake", { enumerable: true, get: function() {
      return caseConvert_1.toSnake;
    } });
    Object.defineProperty(exports$1, "toCamel", { enumerable: true, get: function() {
      return caseConvert_1.toCamel;
    } });
    Object.defineProperty(exports$1, "toPascal", { enumerable: true, get: function() {
      return caseConvert_1.toPascal;
    } });
    Object.defineProperty(exports$1, "objectToPascal", { enumerable: true, get: function() {
      return caseConvert_1.objectToPascal;
    } });
  })(lib$1);
  return lib$1;
}
var libExports = requireLib$1();
class GetAiCharacters extends BaseAction {
  actionName = ActionName.GetAiCharacters;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).default(42),
    chat_type: z$2.union([Number, String]).default(1)
  });
  async _handle(payload) {
    const res = await this.ctx.app.pmhq.fetchAiCharacterList(+payload.group_id, +payload.chat_type);
    return libExports.objectToSnake(res.property);
  }
}
class SendGroupAiRecord extends BaseAction {
  actionName = ActionName.SendGroupAiRecord;
  payloadSchema = z$2.object({
    character: z$2.string().required(),
    group_id: z$2.union([Number, String]).required(),
    text: z$2.string().required(),
    chat_type: z$2.union([Number, String]).default(1)
  });
  async _handle(payload) {
    await this.ctx.app.pmhq.getGroupGenerateAiRecord(+payload.group_id, payload.character, payload.text, +payload.chat_type);
    return { message_id: 0 };
  }
}
class GetPrivateFileUrl extends BaseAction {
  actionName = ActionName.GetPrivateFileUrl;
  payloadSchema = z$2.object({
    file_id: z$2.string().required()
  });
  async _handle(payload) {
    const url2 = await this.ctx.app.pmhq.getPrivateFileUrl(selfInfo.uid, payload.file_id);
    return { url: url2 };
  }
}
class GetDoubtFriendsAddRequest extends BaseAction {
  actionName = ActionName.GetDoubtFriendsAddRequest;
  payloadSchema = z$2.object({
    count: z$2.union([Number, String]).default(50)
  });
  async _handle(payload) {
    const res = await this.ctx.ntFriendApi.getDoubtBuddyReq(+payload.count);
    return await Promise.all(res.doubtList.map(async (e) => {
      return {
        flag: e.uid,
        uin: await this.ctx.ntUserApi.getUinByUid(e.uid),
        nick: e.nick,
        source: e.source,
        reason: e.reason,
        msg: e.msg,
        group_code: e.groupCode,
        time: e.reqTime,
        type: "doubt"
      };
    }));
  }
}
class SetDoubtFriendsAddRequest extends BaseAction {
  actionName = ActionName.SetDoubtFriendsAddRequest;
  payloadSchema = z$2.object({
    flag: z$2.string().required()
  });
  async _handle(payload) {
    const res = await this.ctx.ntFriendApi.approvalDoubtBuddyReq(payload.flag);
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class SetGroupFileForever extends BaseAction {
  actionName = ActionName.SetGroupFileForever;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    file_id: z$2.string().required()
  });
  async _handle(payload) {
    const groupId = payload.group_id.toString();
    const res = await this.ctx.ntGroupApi.setGroupFileForever(groupId, payload.file_id);
    if (res.transGroupFileResult.result.retCode !== 0) {
      throw new Error(res.transGroupFileResult.result.clientWording);
    }
    return null;
  }
}
class UploadGroupAlbum extends BaseAction {
  actionName = ActionName.UploadGroupAlbum;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    album_id: z$2.string().required(),
    files: z$2.array(String).required()
  });
  async _handle(payload) {
    const filePathList = await Promise.all(
      payload.files.map(async (uri2) => (await uri2local(this.ctx, uri2)).path || uri2)
    );
    return this.ctx.ntWebApi.uploadGroupAlbum(payload.group_id.toString(), filePathList, payload.album_id);
  }
}
class GetGroupAlbumList extends BaseAction {
  actionName = ActionName.GetGroupAlbumList;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required()
  });
  async _handle(payload) {
    const res = await this.ctx.ntGroupApi.getGroupAlbumList(payload.group_id.toString());
    if (res.response.result !== 0) {
      throw new Error(res.response.errMs);
    }
    return res.response.album_list;
  }
}
class CreateGroupAlbum extends BaseAction {
  actionName = ActionName.CreateGroupAlbum;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    name: z$2.string().required(),
    desc: z$2.string()
  });
  async _handle(payload) {
    const res = await this.ctx.ntGroupApi.createGroupAlbum(
      payload.group_id.toString(),
      payload.name,
      payload.desc
    );
    if (res.result !== 0) {
      throw new Error(res.errMs);
    }
    return res.album_info;
  }
}
class DeleteGroupNotice extends BaseAction {
  actionName = ActionName.DeleteGroupNotice;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    notice_id: z$2.string().required()
  });
  async _handle(payload) {
    const res = await this.ctx.ntGroupApi.deleteGroupBulletin(payload.group_id.toString(), payload.notice_id);
    if (res.result !== 0) {
      throw new Error(res.errMsg);
    }
    return null;
  }
}
class DeleteGroupAlbum extends BaseAction {
  actionName = ActionName.DeleteGroupAlbum;
  payloadSchema = z$2.object({
    group_id: z$2.union([Number, String]).required(),
    album_id: z$2.string().required()
  });
  async _handle(payload) {
    const res = await this.ctx.ntGroupApi.deleteGroupAlbum(payload.group_id.toString(), payload.album_id);
    if (res.result !== 0) {
      throw new Error(res.errMs);
    }
    return null;
  }
}
class ScanQRCode extends BaseAction {
  actionName = ActionName.ScanQRCode;
  payloadSchema = z$2.object({
    file: z$2.string().required()
  });
  async _handle(payload) {
    const { path: localPath, errMsg } = await uri2local(this.ctx, payload.file);
    if (errMsg) {
      throw new Error(errMsg);
    }
    const scanResult = await this.ctx.ntSystemApi.scanQRCode(localPath);
    return scanResult.infos.map((i) => {
      return { text: i.text };
    });
  }
}
function initActionMap(adapter) {
  const actionHandlers = [
    // llbot
    new ScanQRCode(adapter),
    new CreateGroupAlbum(adapter),
    new DeleteGroupAlbum(adapter),
    new GetGroupAlbumList(adapter),
    new UploadGroupAlbum(adapter),
    new SetGroupFileForever(adapter),
    new BatchDeleteGroupMember(adapter),
    new GetFlashFileInfo(adapter),
    new DownloadFlashFile(adapter),
    new UploadFlashFile(adapter),
    new GetRKey(adapter),
    new SendPB(adapter),
    new VoiceMsg2Text(adapter),
    new GetFile(adapter),
    new Debug(adapter),
    new GetConfigAction(adapter),
    new SetConfigAction(adapter),
    new GetGroupAddRequest(adapter),
    new SetQQAvatar(adapter),
    new GetQQAvatar(adapter),
    new GetFriendWithCategory(adapter),
    new GetEvent(adapter),
    new SetOnlineStatus(adapter),
    new GetProfileLike(adapter),
    new GetProfileLikeMe(adapter),
    new GetFriendMsgHistory(adapter),
    new FetchEmojiLike(adapter),
    new FetchCustomFace(adapter),
    new SetMsgEmojiLike(adapter),
    new UnSetMsgEmojiLike(adapter),
    new GetRobotUinRange(adapter),
    new GroupPoke(adapter),
    new FriendPoke(adapter),
    new SetFriendCategory(adapter),
    new SetFriendRemark(adapter),
    new SetGroupMsgMask(adapter),
    new SetGroupRemark(adapter),
    new MoveGroupFile$1(adapter),
    new GetGroupShutList(adapter),
    new RenameGroupFileFolder(adapter),
    new GetRecommendFace(adapter),
    new GetAiCharacters(adapter),
    new SendGroupAiRecord(adapter),
    new GetPrivateFileUrl(adapter),
    new GetDoubtFriendsAddRequest(adapter),
    new SetDoubtFriendsAddRequest(adapter),
    new DeleteGroupNotice(adapter),
    // onebot11
    new SendLike(adapter),
    new GetMsg(adapter),
    new GetLoginInfo$1(adapter),
    new GetFriendList$1(adapter),
    new GetGroupList$1(adapter),
    new GetGroupInfo$1(adapter),
    new GetGroupMemberList$1(adapter),
    new GetGroupMemberInfo$1(adapter),
    new SendGroupMsg(adapter),
    new SendPrivateMsg(adapter),
    new SendMsg(adapter),
    new DeleteMsg(adapter),
    new SetGroupAddRequest(adapter),
    new SetFriendAddRequest(adapter),
    new SetGroupLeave(adapter),
    new GetVersionInfo(adapter),
    new CanSendRecord(adapter),
    new CanSendImage(adapter),
    new GetStatus(adapter),
    new SetGroupWholeBan(adapter),
    new SetGroupBan(adapter),
    new SetGroupKick(adapter),
    new SetGroupAdmin(adapter),
    new SetGroupName$1(adapter),
    new SetGroupCard(adapter),
    new GetImage(adapter),
    new GetRecord(adapter),
    new CleanCache(adapter),
    new GetCookies$1(adapter),
    new ForwardFriendSingleMsg(adapter),
    new ForwardGroupSingleMsg(adapter),
    new GetCredentials(adapter),
    new SetRestart(adapter),
    new GetCsrfToken(adapter),
    // go-cqhttp
    new GetEssenceMsgList(adapter),
    new GetGroupHonorInfo(adapter),
    new SendForwardMsg(adapter),
    new SendGroupForwardMsg(adapter),
    new SendPrivateForwardMsg(adapter),
    new GetStrangerInfo(adapter),
    new DownloadFile(adapter),
    new GetGuildList(adapter),
    new MarkMsgAsRead(adapter),
    new UploadGroupFile$1(adapter),
    new UploadPrivateFile$1(adapter),
    new GetGroupMsgHistory(adapter),
    new GetForwardMsg(adapter),
    new HandleQuickOperation(adapter),
    new SetEssenceMsg(adapter),
    new DeleteEssenceMsg(adapter),
    new DeleteGroupFile$1(adapter),
    new GetGroupSystemMsg(adapter),
    new CreateGroupFileFolder(adapter),
    new DeleteGroupFolder$1(adapter),
    new GetGroupAtAllRemain(adapter),
    new GetGroupRootFiles(adapter),
    new SendGroupNotice(adapter),
    new GetGroupFilesByFolder(adapter),
    new GetGroupFileUrl(adapter),
    new GetGroupNotice(adapter),
    new DeleteFriend$1(adapter),
    new OCRImage(adapter),
    new GetGroupFileSystemInfo(adapter),
    new SetGroupSpecialTitle(adapter),
    new SendGroupSign(adapter),
    new SetQQProfile(adapter),
    new SetGroupPortrait(adapter)
  ];
  const actionMap = /* @__PURE__ */ new Map();
  for (const action of actionHandlers) {
    actionMap.set(action.actionName, action);
    actionMap.set(action.actionName + "_async", action);
    actionMap.set(action.actionName + "_rate_limited", action);
  }
  return actionMap;
}
class OB11GroupAdminNoticeEvent extends OB11GroupNoticeEvent {
  notice_type = "group_admin";
  sub_type;
  group_id;
  user_id;
  constructor(subType, groupId, userId) {
    super();
    this.sub_type = subType;
    this.group_id = groupId;
    this.user_id = userId;
  }
}
class OB11ProfileLikeEvent extends OB11BaseNoticeEvent {
  notice_type = "notify";
  sub_type = "profile_like";
  operator_id;
  operator_nick;
  times;
  constructor(operatorId, operatorNick, times) {
    super();
    this.operator_id = operatorId;
    this.operator_nick = operatorNick;
    this.times = times;
  }
}
class OB11FlashFileEvent extends OB11BaseNoticeEvent {
  notice_type = "flash_file";
  sub_type;
  title = "";
  share_link = "";
  file_set_id = "";
  files = [];
  constructor(title, share_link, file_set_id, files) {
    super();
    this.title = title;
    this.share_link = share_link;
    this.file_set_id = file_set_id;
    this.files = [];
  }
}
class OB11FlashFileDownloadingEvent extends OB11FlashFileEvent {
  downloaded_size;
  total_size;
  speed;
  remain_seconds;
  constructor(title, share_link, file_set_id, downloaded_size, total_size, speed, remain_seconds, files) {
    super(title, share_link, file_set_id, files);
    this.sub_type = "downloading";
    this.downloaded_size = downloaded_size;
    this.total_size = total_size;
    this.speed = speed;
    this.remain_seconds = remain_seconds;
    this.files = files;
  }
}
class OB11FlashFileDownloadedEvent extends OB11FlashFileEvent {
  constructor(title, share_link, file_set_id, files) {
    super(title, share_link, file_set_id, files);
    this.sub_type = "downloaded";
  }
}
class OB11FlashFileUploadingEvent extends OB11FlashFileEvent {
  uploaded_size;
  total_size;
  speed;
  remain_seconds;
  constructor(title, share_link, file_set_id, uploaded_size, total_size, speed, remain_seconds, files = []) {
    super(title, share_link, file_set_id, files);
    this.sub_type = "uploading";
    this.uploaded_size = uploaded_size;
    this.total_size = total_size;
    this.speed = speed;
    this.remain_seconds = remain_seconds;
    this.files = files;
  }
}
class OB11FlashFileUploadedEvent extends OB11FlashFileEvent {
  constructor(title, share_link, file_set_id, files = []) {
    super(title, share_link, file_set_id, files);
    this.sub_type = "uploaded";
  }
}
class OB11GroupDismissEvent extends OB11GroupNoticeEvent {
  notice_type = "group_dismiss";
  user_id;
  group_id;
  constructor(groupId, user_id) {
    super();
    this.group_id = groupId;
    this.user_id = user_id;
  }
}
class OB11GroupMsgEmojiLikeEvent extends OB11GroupNoticeEvent {
  notice_type = "group_msg_emoji_like";
  message_id;
  likes;
  group_id;
  user_id;
  is_add;
  constructor(groupId, userId, messageId, likes, isAdd) {
    super();
    this.group_id = groupId;
    this.user_id = userId;
    this.message_id = messageId;
    this.likes = likes;
    this.is_add = isAdd;
  }
}
class GroupEssenceEvent extends OB11GroupNoticeEvent {
  notice_type = "essence";
  message_id;
  sender_id;
  sub_type;
  group_id;
  user_id;
  operator_id;
  constructor(groupId, messageId, senderId, operatorId, subType) {
    super();
    this.group_id = groupId;
    this.user_id = senderId;
    this.message_id = messageId;
    this.sender_id = senderId;
    this.operator_id = operatorId;
    this.sub_type = subType;
  }
}
class OneBot11Adapter extends Service2 {
  constructor(ctx, config2) {
    super(ctx, "onebot", true);
    this.ctx = ctx;
    this.config = config2;
    this.actionMap = initActionMap(this);
    this.connect = config2.connect.map((item) => {
      if (item.type === "http") {
        return new OB11Http(ctx, {
          ...item,
          actionMap: this.actionMap,
          onlyLocalhost: config2.onlyLocalhost
        });
      } else if (item.type === "http-post") {
        return new OB11HttpPost(ctx, item);
      } else if (item.type === "ws") {
        return new OB11WebSocket(ctx, {
          ...item,
          actionMap: this.actionMap,
          onlyLocalhost: config2.onlyLocalhost
        });
      } else if (item.type === "ws-reverse") {
        return new OB11WebSocketReverse(ctx, {
          ...item,
          actionMap: this.actionMap
        });
      } else {
        throw new Error("incorrect ob11 connect type");
      }
    });
  }
  static inject = [
    "ntMsgApi",
    "ntFileApi",
    "ntFileCacheApi",
    "ntFriendApi",
    "ntGroupApi",
    "ntUserApi",
    "ntWebApi",
    "ntSystemApi",
    "store",
    "app"
  ];
  connect;
  actionMap;
  dispatch(event) {
    for (const item of this.connect) {
      item.emitEvent(event);
    }
  }
  dispatchMessageLike(event, self2, offline) {
    for (const item of this.connect) {
      item.emitMessageLikeEvent(cloneObj(event), self2, offline);
    }
  }
  async handleGroupNotify(notify, doubt) {
    try {
      const flag = `${notify.group.groupCode}|${notify.seq}|${notify.type}|${doubt ? "1" : "0"}`;
      if (notify.type === GroupNotifyType.RequestJoinNeedAdminiStratorPass && notify.status === GroupNotifyStatus.Unhandle) {
        this.ctx.logger.info("");
        const requestUin = await this.ctx.ntUserApi.getUinByUid(notify.user1.uid);
        const event = new OB11GroupRequestAddEvent(
          parseInt(notify.group.groupCode),
          parseInt(requestUin) || 0,
          flag,
          notify.postscript
        );
        this.dispatch(event);
      } else if (notify.type === GroupNotifyType.InvitedByMember && notify.status === GroupNotifyStatus.Unhandle) {
        this.ctx.logger.info(", uid:", notify.user2.uid);
        const userId = await this.ctx.ntUserApi.getUinByUid(notify.user2.uid);
        this.ctx.logger.info(", uin:", userId);
        const event = new OB11GroupRequestInviteBotEvent(
          parseInt(notify.group.groupCode),
          parseInt(userId) || 0,
          flag,
          notify.postscript
        );
        this.dispatch(event);
      } else if (notify.type === GroupNotifyType.InvitedNeedAdminiStratorPass && notify.status === GroupNotifyStatus.Unhandle) {
        this.ctx.logger.info("");
        const userId = await this.ctx.ntUserApi.getUinByUid(notify.user1.uid);
        const invitorId = await this.ctx.ntUserApi.getUinByUid(notify.user2.uid);
        const event = new OB11GroupRequestAddEvent(
          parseInt(notify.group.groupCode),
          parseInt(userId) || 0,
          flag,
          notify.postscript,
          parseInt(invitorId) || 0
        );
        this.dispatch(event);
      }
    } catch (e) {
      this.ctx.logger.error("", e.stack);
    }
  }
  handleMsg(message, self2, offline) {
    OB11Entities.message(this.ctx, message).then((msg) => {
      if (!msg) {
        return;
      }
      const isSelfMsg = msg.user_id.toString() === selfInfo.uin;
      if (isSelfMsg) {
        msg.target_id = parseInt(message.peerUin);
      }
      this.dispatchMessageLike(msg, self2, offline);
    }).catch((e) => this.ctx.logger.error("handling incoming messages", e));
    OB11Entities.groupEvent(this.ctx, message).then((groupEvent) => {
      if (groupEvent) {
        if (Array.isArray(groupEvent)) {
          for (const item of groupEvent) {
            this.dispatchMessageLike(item, self2, offline);
          }
        } else {
          this.dispatchMessageLike(groupEvent, self2, offline);
        }
      }
    }).catch((e) => this.ctx.logger.error("handling incoming group events", e));
    OB11Entities.privateEvent(this.ctx, message).then((privateEvent) => {
      if (privateEvent) {
        this.dispatchMessageLike(privateEvent, self2, offline);
      }
    }).catch((e) => this.ctx.logger.error("handling incoming buddy events", e));
  }
  handleRecallMsg(message) {
    const peer = {
      peerUid: message.peerUid,
      chatType: message.chatType
    };
    const grayTipElement = message.elements.find((el) => el.grayTipElement)?.grayTipElement;
    if (grayTipElement && grayTipElement.jsonGrayTipElement?.busiId == JsonGrayTipBusId.Poke) {
      const json2 = JSON.parse(grayTipElement.jsonGrayTipElement.jsonStr);
      const templateParams = grayTipElement.jsonGrayTipElement?.xmlToJsonParam?.templParam;
      const fromUserUin = templateParams?.get("uin_str1") || "0";
      const toUserUin = templateParams?.get("uin_str2") || "0";
      let recallEvent;
      if (peer.chatType === ChatType.Group) {
        recallEvent = new OB11GroupPokeRecallEvent(parseInt(message.peerUid), parseInt(fromUserUin), parseInt(toUserUin), json2);
      } else {
        recallEvent = new OB11FriendPokeRecallEvent(parseInt(fromUserUin), parseInt(toUserUin), json2);
      }
      return this.dispatch(recallEvent);
    }
    const shortId = this.ctx.store.createMsgShortId(message);
    OB11Entities.recallEvent(this.ctx, message, shortId).then((recallEvent) => {
      this.dispatch(recallEvent);
    }).catch((e) => this.ctx.logger.error("handling recall events", e));
  }
  async handleFriendRequest(req) {
    let userId = 0;
    try {
      const requesterUin = await this.ctx.ntUserApi.getUinByUid(req.friendUid);
      userId = parseInt(requesterUin);
    } catch (e) {
      this.ctx.logger.error("QQ", e);
    }
    const flag = req.friendUid + "|" + req.reqTime;
    const comment = req.extWords;
    const friendRequestEvent = new OB11FriendRequestEvent(
      userId,
      comment,
      flag
    );
    this.dispatch(friendRequestEvent);
  }
  async handleConfigUpdated(config2) {
    for (const item of this.connect) {
      if (item.config.enable) {
        await item.stop();
      }
    }
    if (config2.ob11.enable) {
      this.connect = config2.ob11.connect.map((item) => {
        if (item.type === "http") {
          return new OB11Http(this.ctx, {
            ...item,
            actionMap: this.actionMap,
            onlyLocalhost: config2.onlyLocalhost
          });
        } else if (item.type === "http-post") {
          return new OB11HttpPost(this.ctx, item);
        } else if (item.type === "ws") {
          return new OB11WebSocket(this.ctx, {
            ...item,
            actionMap: this.actionMap,
            onlyLocalhost: config2.onlyLocalhost
          });
        } else if (item.type === "ws-reverse") {
          return new OB11WebSocketReverse(this.ctx, {
            ...item,
            actionMap: this.actionMap
          });
        } else {
          throw new Error("incorrect ob11 connect type");
        }
      });
      for (const item of this.connect) {
        if (item.config.enable) {
          item.start();
        }
      }
    }
    Object.assign(this.config, {
      ...config2.ob11,
      msgCacheExpire: config2.msgCacheExpire,
      musicSignUrl: config2.musicSignUrl,
      enableLocalFile2Url: config2.enableLocalFile2Url,
      ffmpeg: config2.ffmpeg
    });
  }
  start() {
    if (this.config.enable) {
      for (const item of this.connect) {
        if (item.config.enable) {
          item.start();
        }
      }
    }
    this.ctx.on("llob/config-updated", (input) => {
      this.handleConfigUpdated(input).catch((e) => {
      });
    });
    this.ctx.on("nt/message-created", (input) => {
      if (input.senderUid === selfInfo.uid) {
        this.handleMsg(input, true, false);
      } else {
        this.handleMsg(input, false, false);
      }
    });
    this.ctx.on("nt/offline-message-created", (input) => {
      if (input.senderUid === selfInfo.uid) {
        this.handleMsg(input, true, true);
      } else {
        this.handleMsg(input, false, true);
      }
    });
    this.ctx.on("nt/message-deleted", (input) => {
      this.handleRecallMsg(input);
    });
    this.ctx.on("nt/message-sent", (input) => {
      this.handleMsg(input, true, false);
    });
    this.ctx.on("nt/group-notify", (input) => {
      const { doubt, notify } = input;
      this.handleGroupNotify(notify, doubt);
    });
    this.ctx.on("nt/friend-request", (input) => {
      this.handleFriendRequest(input);
    });
    this.ctx.on("nt/system-message-created", async (input) => {
      const sysMsg = Msg.Message.decode(input);
      const { msgType, subType } = sysMsg.contentHead ?? {};
      if (msgType === 528 && subType === 39) {
        const tip = Notify.ProfileLike.decode(sysMsg.body.msgContent);
        if (tip.msgType !== 0 || tip.subType !== 203) return;
        const detail = tip.content?.msg?.detail;
        if (!detail) return;
        const [times] = detail.txt?.match(/\d+/) ?? ["0"];
        const event = new OB11ProfileLikeEvent(detail.uin, detail.nickname, +times);
        this.dispatch(event);
      } else if (msgType === 33) {
        const tip = Notify.GroupMemberChange.decode(sysMsg.body.msgContent);
        if (tip.type !== 130) return;
        this.ctx.logger.info("", tip);
        const memberUin = await this.ctx.ntUserApi.getUinByUid(tip.memberUid);
        const operatorUin = await this.ctx.ntUserApi.getUinByUid(tip.adminUid);
        const event = new OB11GroupIncreaseEvent(tip.groupCode, +memberUin, +operatorUin);
        this.dispatch(event);
      } else if (msgType === 34) {
        const tip = Notify.GroupMemberChange.decode(sysMsg.body.msgContent);
        if (tip.type === 130) {
          this.ctx.logger.info("", tip);
          const memberUin = await this.ctx.ntUserApi.getUinByUid(tip.memberUid);
          const userId = Number(memberUin);
          const event = new OB11GroupDecreaseEvent(tip.groupCode, userId, userId);
          this.dispatch(event);
        } else if (tip.type === 131) {
          if (tip.memberUid === selfInfo.uid) return;
          this.ctx.logger.info("", tip);
          const memberUin = await this.ctx.ntUserApi.getUinByUid(tip.memberUid);
          let adminUin = "0";
          let adminUid = tip.adminUid;
          if (adminUid) {
            const adminUidMatch = tip.adminUid.match(/\x18([^\x18\x10]+)\x10/);
            if (adminUidMatch) {
              adminUid = adminUidMatch[1];
            }
            adminUin = await this.ctx.ntUserApi.getUinByUid(adminUid);
          }
          const event = new OB11GroupDecreaseEvent(tip.groupCode, +memberUin, +adminUin, "kick");
          this.dispatch(event);
        }
      } else if (msgType === 528 && subType === 321) ;
      else if (msgType === 732 && subType === 21) ;
      else if (msgType === 44) {
        const tip = Notify.GroupAdminChange.decode(sysMsg.body.msgContent);
        this.ctx.logger.info("", tip);
        const uid = tip.isPromote ? tip.body.extraEnable?.adminUid : tip.body.extraDisable?.adminUid;
        if (!uid) return null;
        const uin = await this.ctx.ntUserApi.getUinByUid(uid);
        const event = new OB11GroupAdminNoticeEvent(
          tip.isPromote ? "set" : "unset",
          tip.groupCode,
          +uin
        );
        this.dispatch(event);
      }
    });
    this.ctx.on("nt/flash-file-download-status", (input) => {
      if (input.status === FlashFileDownloadStatus.DOWNLOADED) {
        const files = [];
        this.ctx.ntFileApi.getFlashFileList(input.info.fileSetId).then((res) => {
          for (const file2 of res) {
            for (const file22 of file2.fileList) {
              files.push({
                name: file22.name,
                size: parseInt(file22.filePhysicalSize),
                path: file22.saveFilePath
              });
            }
          }
          const event = new OB11FlashFileDownloadedEvent(
            input.info.name,
            input.info.shareInfo.shareLink,
            input.info.fileSetId,
            files
          );
          this.dispatch(event);
        }).catch((err) => {
          this.ctx.logger.error(err, { fileSetId: input.info.fileSetId });
        });
      }
    });
    this.ctx.on("nt/flash-file-upload-status", (fileSetInfo) => {
      if (fileSetInfo.uploadStatus === FlashFileUploadStatus.UPLOADED) {
        const event = new OB11FlashFileUploadedEvent(
          fileSetInfo.name,
          fileSetInfo.shareInfo.shareLink,
          fileSetInfo.fileSetId
        );
        this.dispatch(event);
      }
    });
    this.ctx.on("nt/flash-file-downloading", (input) => {
      const [fileSetId, downloadingInfo] = input;
      this.ctx.ntFileApi.getFlashFileInfo(fileSetId, false).then((res) => {
        this.ctx.ntFileApi.getFlashFileList(fileSetId, false).then((fileList) => {
          const files = [];
          for (const file2 of fileList) {
            for (const file22 of file2.fileList) {
              files.push({
                name: file22.name,
                size: parseInt(file22.filePhysicalSize),
                path: file22.saveFilePath
              });
            }
          }
          const event = new OB11FlashFileDownloadingEvent(
            res.name,
            res.shareInfo.shareLink,
            fileSetId,
            parseInt(downloadingInfo.curDownLoadedBytes),
            parseInt(downloadingInfo.totalDownLoadedBytes),
            downloadingInfo.curSpeedBps,
            downloadingInfo.remainDownLoadSeconds,
            files
          );
          this.dispatch(event);
        }).catch((err) => {
          this.ctx.logger.error(err);
        });
      }).catch((err) => {
        this.ctx.logger.error(err);
      });
    });
    this.ctx.on("nt/flash-file-uploading", (info) => {
      this.ctx.ntFileApi.getFlashFileList(info.fileSet.fileSetId, false).then((fileList) => {
        const files = [];
        for (const file2 of fileList) {
          for (const file22 of file2.fileList) {
            files.push({
              name: file22.name,
              size: parseInt(file22.filePhysicalSize),
              path: file22.physical.localPath
            });
          }
        }
        const event = new OB11FlashFileUploadingEvent(
          info.fileSet.name,
          info.fileSet.shareInfo.shareLink,
          info.fileSet.fileSetId,
          parseInt(info.uploadedFileSize),
          parseInt(info.fileSet.totalFileSize),
          parseInt(info.uploadSpeed),
          parseInt(info.timeRemain),
          files
        );
        this.dispatch(event);
      });
    });
    this.ctx.on("nt/group-dismiss", async (group) => {
      const groupInfo = await this.ctx.ntGroupApi.getGroupAllInfo(group.groupCode);
      const ownerUin = await this.ctx.ntUserApi.getUinByUid(groupInfo.ownerUid);
      const event = new OB11GroupDismissEvent(
        parseInt(group.groupCode),
        parseInt(ownerUin)
      );
      this.dispatch(event);
    });
    this.ctx.on("nt/group-quit", async (group) => {
      const event = new OB11GroupDecreaseEvent(
        Number(group.groupCode),
        Number(selfInfo.uin),
        Number(selfInfo.uin)
      );
      this.dispatch(event);
    });
    this.ctx.app.pmhq.addResListener(async (data) => {
      try {
        if (data.type === "recv" && data.data.cmd === "trpc.msg.olpush.OlPushService.MsgPush") {
          const pushMsg = Msg.PushMsg.decode(Buffer.from(data.data.pb, "hex"));
          if (!pushMsg.message.body) {
            return null;
          }
          const { msgType, subType } = pushMsg.message?.contentHead ?? {};
          if (msgType === 732 && subType === 16) {
            const notify = Msg.NotifyMessageBody.decode(pushMsg.message.body.msgContent.subarray(7));
            if (notify.field13 === 35) {
              this.ctx.logger.info("", notify.reaction.data.body);
              const info = notify.reaction.data.body.info;
              const target = notify.reaction.data.body.target;
              const userId = Number(await this.ctx.ntUserApi.getUinByUid(info.operatorUid));
              const peer = {
                chatType: 2,
                peerUid: String(notify.groupCode),
                guildId: ""
              };
              const targetMsg = await this.ctx.ntMsgApi.getMsgsBySeqAndCount(peer, String(target.sequence), 1, true, true);
              if (targetMsg.msgList.length === 0) {
                this.ctx.logger.error("");
                return;
              }
              const messageId = this.ctx.store.createMsgShortId(targetMsg.msgList[0]);
              const event = new OB11GroupMsgEmojiLikeEvent(
                notify.groupCode,
                userId,
                messageId,
                [{
                  emoji_id: info.code,
                  count: 1
                }],
                info.type === 1
              );
              this.dispatch(event);
            }
          } else if (msgType === 732 && subType === 21) {
            const notify = Msg.NotifyMessageBody.decode(pushMsg.message.body.msgContent.subarray(7));
            if (notify.type === 27) {
              this.ctx.logger.info("", notify);
              const peer = {
                chatType: ChatType.Group,
                peerUid: notify.groupCode.toString(),
                guildId: ""
              };
              const msg = await this.ctx.ntMsgApi.queryFirstMsgBySeq(peer, notify.essenceMessage.msgSequence.toString());
              if (msg.msgList.length === 0) {
                return;
              }
              const event = new GroupEssenceEvent(
                notify.groupCode,
                this.ctx.store.createMsgShortId(msg.msgList[0]),
                notify.essenceMessage.memberUin,
                notify.essenceMessage.operatorUin,
                notify.essenceMessage.setFlag === 1 ? "add" : "delete"
              );
              this.dispatch(event);
            }
          }
        }
      } catch (e) {
        this.ctx.logger.error("handling incoming olpush events", e);
      }
    });
  }
}
var __defProp$4 = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __name$4 = (target, value) => __defProp$4(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_index = __commonJS({
  "src/index.ts"(exports$1, module) {
    var kElement = /* @__PURE__ */ Symbol.for("satori.element");
    var ElementConstructor = class {
      static {
        __name$4(this, "ElementConstructor");
      }
      get data() {
        return this.attrs;
      }
      getTagName() {
        if (this.type === "component") {
          return this.attrs.is?.name ?? "component";
        } else {
          return this.type;
        }
      }
      toAttrString() {
        return Object.entries(this.attrs).map(([key2, value]) => {
          if (isNullable(value)) return "";
          key2 = hyphenate(key2);
          if (value === true) return ` ${key2}`;
          if (value === false) return ` no-${key2}`;
          return ` ${key2}="${Element.escape("" + value, true)}"`;
        }).join("");
      }
      toString(strip = false) {
        if (this.type === "text" && "content" in this.attrs) {
          return strip ? this.attrs.content : Element.escape(this.attrs.content);
        }
        const inner = this.children.map((child) => child.toString(strip)).join("");
        if (strip) return inner;
        const attrs = this.toAttrString();
        const tag = this.getTagName();
        if (!this.children.length) return `<${tag}${attrs}/>`;
        return `<${tag}${attrs}>${inner}</${tag}>`;
      }
    };
    defineProperty(ElementConstructor, "name", "Element");
    defineProperty(ElementConstructor.prototype, kElement, true);
    function Element(type2, ...args) {
      const el = Object.create(ElementConstructor.prototype);
      const attrs = {}, children = [];
      if (args[0] && typeof args[0] === "object" && !Element.isElement(args[0]) && !Array.isArray(args[0])) {
        const props = args.shift();
        for (const [key2, value] of Object.entries(props)) {
          if (isNullable(value)) continue;
          if (key2 === "children") {
            args.push(...makeArray(value));
          } else {
            attrs[camelize(key2)] = value;
          }
        }
      }
      for (const child of args) {
        children.push(...Element.toElementArray(child));
      }
      if (typeof type2 === "function") {
        attrs.is = type2;
        type2 = "component";
      }
      return Object.assign(el, { type: type2, attrs, children });
    }
    __name$4(Element, "Element");
    var evaluate = new Function("expr", "context", `
  try {
    with (context) {
      return eval(expr)
    }
  } catch {}
`);
    ((Element2) => {
      Element2.jsx = Element2;
      Element2.jsxs = Element2;
      Element2.jsxDEV = Element2;
      Element2.Fragment = "template";
      function isElement(source2) {
        return source2 && typeof source2 === "object" && source2[kElement];
      }
      Element2.isElement = isElement;
      __name$4(isElement, "isElement");
      function toElement(content) {
        if (typeof content === "string" || typeof content === "number" || typeof content === "boolean") {
          content = "" + content;
          if (content) return Element2("text", { content });
        } else if (isElement(content)) {
          return content;
        } else if (!isNullable(content)) {
          throw new TypeError(`Invalid content: ${content}`);
        }
      }
      Element2.toElement = toElement;
      __name$4(toElement, "toElement");
      function toElementArray(content) {
        if (Array.isArray(content)) {
          return content.map(toElement).filter(isNonNullable);
        } else {
          return [toElement(content)].filter(isNonNullable);
        }
      }
      Element2.toElementArray = toElementArray;
      __name$4(toElementArray, "toElementArray");
      function normalize(source2, context) {
        return typeof source2 === "string" ? parse3(source2, context) : toElementArray(source2);
      }
      Element2.normalize = normalize;
      __name$4(normalize, "normalize");
      function escape2(source2, inline = false) {
        const result = (source2 ?? "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        return inline ? result.replace(/"/g, "&quot;") : result;
      }
      Element2.escape = escape2;
      __name$4(escape2, "escape");
      function unescape2(source2) {
        return source2.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#(\d+);/g, (_, code) => code === "38" ? _ : String.fromCharCode(+code)).replace(/&#x([0-9a-f]+);/gi, (_, code) => code === "26" ? _ : String.fromCharCode(parseInt(code, 16))).replace(/&(amp|#38|#x26);/g, "&");
      }
      Element2.unescape = unescape2;
      __name$4(unescape2, "unescape");
      function from2(source2, options = {}) {
        const elements = parse3(source2);
        if (options.caret) {
          if (options.type && elements[0]?.type !== options.type) return;
          return elements[0];
        }
        return select(elements, options.type || "*")[0];
      }
      Element2.from = from2;
      __name$4(from2, "from");
      const combRegExp = / *([ >+~]) */g;
      function parseSelector(input) {
        return input.split(",").map((query) => {
          const selectors = [];
          query = query.trim();
          let combCap, combinator = " ";
          while (combCap = combRegExp.exec(query)) {
            selectors.push({ type: query.slice(0, combCap.index), combinator });
            combinator = combCap[1];
            query = query.slice(combCap.index + combCap[0].length);
          }
          selectors.push({ type: query, combinator });
          return selectors;
        });
      }
      Element2.parseSelector = parseSelector;
      __name$4(parseSelector, "parseSelector");
      function select(source2, query) {
        if (!source2 || !query) return [];
        if (typeof source2 === "string") source2 = parse3(source2);
        if (typeof query === "string") query = parseSelector(query);
        if (!query.length) return [];
        let adjacent = [];
        const results = [];
        for (const [index2, element] of source2.entries()) {
          const inner = [];
          const local = [...query, ...adjacent];
          adjacent = [];
          let matched = false;
          for (const group of local) {
            const { type: type2, combinator } = group[0];
            if (type2 === element.type || type2 === "*") {
              if (group.length === 1) {
                matched = true;
              } else if ([" ", ">"].includes(group[1].combinator)) {
                inner.push(group.slice(1));
              } else if (group[1].combinator === "+") {
                adjacent.push(group.slice(1));
              } else {
                query.push(group.slice(1));
              }
            }
            if (combinator === " ") {
              inner.push(group);
            }
          }
          if (matched) results.push(source2[index2]);
          results.push(...select(element.children, inner));
        }
        return results;
      }
      Element2.select = select;
      __name$4(select, "select");
      function interpolate(expr, context) {
        expr = expr.trim();
        if (!/^[\w.]+$/.test(expr)) {
          return evaluate(expr, context) ?? "";
        }
        let value = context;
        for (const part of expr.split(".")) {
          value = value[part];
          if (isNullable(value)) return "";
        }
        return value ?? "";
      }
      Element2.interpolate = interpolate;
      __name$4(interpolate, "interpolate");
      const tagRegExp1 = /(?<comment><!--[\s\S]*?-->)|(?<tag><(\/?)([^!\s>/]*)([^>]*?)\s*(\/?)>)/;
      const tagRegExp2 = /(?<comment><!--[\s\S]*?-->)|(?<tag><(\/?)([^!\s>/]*)([^>]*?)\s*(\/?)>)|(?<curly>\{(?<derivative>[@:/#][^\s}]*)?[\s\S]*?\})/;
      const attrRegExp1 = /([^\s=]+)(?:="(?<value1>[^"]*)"|='(?<value2>[^']*)')?/g;
      const attrRegExp2 = /([^\s=]+)(?:="(?<value1>[^"]*)"|='(?<value2>[^']*)'|=\{(?<curly>[^}]+)\})?/g;
      let Position;
      ((Position2) => {
        Position2[Position2["OPEN"] = 0] = "OPEN";
        Position2[Position2["CLOSE"] = 1] = "CLOSE";
        Position2[Position2["EMPTY"] = 2] = "EMPTY";
        Position2[Position2["CONTINUE"] = 3] = "CONTINUE";
      })(Position || (Position = {}));
      function parse3(source2, context) {
        const tokens = [];
        function pushText(content) {
          if (content) tokens.push(content);
        }
        __name$4(pushText, "pushText");
        const tagRegExp = context ? tagRegExp2 : tagRegExp1;
        let tagCap;
        let trimStart = true;
        while (tagCap = tagRegExp.exec(source2)) {
          const { curly, comment, derivative } = tagCap.groups;
          const trimEnd = !curly;
          parseContent(source2.slice(0, tagCap.index), trimStart, trimEnd);
          trimStart = trimEnd;
          source2 = source2.slice(tagCap.index + tagCap[0].length);
          const [_, , , close, type2, extra, empty] = tagCap;
          if (comment) continue;
          if (curly) {
            let name = "", position = 2;
            if (derivative) {
              name = derivative.slice(1);
              position = {
                "@": 2,
                "#": 0,
                "/": 1,
                ":": 3
                /* CONTINUE */
              }[derivative[0]];
            }
            tokens.push({
              type: "curly",
              name,
              position,
              source: curly,
              extra: curly.slice(1 + (derivative ?? "").length, -1)
            });
            continue;
          }
          tokens.push({
            type: "angle",
            source: _,
            name: type2 || Element2.Fragment,
            position: close ? 1 : empty ? 2 : 0,
            extra
          });
        }
        parseContent(source2, trimStart, true);
        function parseContent(source22, trimStart2, trimEnd) {
          source22 = unescape2(source22);
          if (trimStart2) source22 = source22.replace(/^\s*\n\s*/, "");
          if (trimEnd) source22 = source22.replace(/\s*\n\s*$/, "");
          pushText(source22);
        }
        __name$4(parseContent, "parseContent");
        return parseTokens(foldTokens(tokens), context);
      }
      Element2.parse = parse3;
      __name$4(parse3, "parse");
      function foldTokens(tokens) {
        const stack2 = [[{
          type: "angle",
          name: Element2.Fragment,
          position: 0,
          source: "",
          extra: "",
          children: { default: [] }
        }, "default"]];
        function pushToken(...tokens2) {
          const [token2, slot] = stack2[0];
          token2.children[slot].push(...tokens2);
        }
        __name$4(pushToken, "pushToken");
        for (const token2 of tokens) {
          if (typeof token2 === "string") {
            pushToken(token2);
            continue;
          }
          const { name, position } = token2;
          if (position === 1) {
            if (stack2[0][0].name === name) {
              stack2.shift();
            }
          } else if (position === 3) {
            stack2[0][0].children[name] = [];
            stack2[0][1] = name;
          } else if (position === 0) {
            pushToken(token2);
            token2.children = { default: [] };
            stack2.unshift([token2, "default"]);
          } else {
            pushToken(token2);
          }
        }
        return stack2[stack2.length - 1][0].children.default;
      }
      __name$4(foldTokens, "foldTokens");
      function parseTokens(tokens, context) {
        const result = [];
        for (const token2 of tokens) {
          if (typeof token2 === "string") {
            result.push(Element2("text", { content: token2 }));
          } else if (token2.type === "angle") {
            const attrs = {};
            const attrRegExp = context ? attrRegExp2 : attrRegExp1;
            let attrCap;
            while (attrCap = attrRegExp.exec(token2.extra)) {
              const [, key2, v1, v2 = v1, v3] = attrCap;
              if (v3) {
                attrs[key2] = interpolate(v3, context);
              } else if (!isNullable(v2)) {
                attrs[key2] = unescape2(v2);
              } else if (key2.startsWith("no-")) {
                attrs[key2.slice(3)] = false;
              } else {
                attrs[key2] = true;
              }
            }
            result.push(Element2(token2.name, attrs, token2.children && parseTokens(token2.children.default, context)));
          } else if (!token2.name) {
            result.push(...toElementArray(interpolate(token2.extra, context)));
          } else if (token2.name === "if") {
            if (evaluate(token2.extra, context)) {
              result.push(...parseTokens(token2.children.default, context));
            } else {
              result.push(...parseTokens(token2.children.else || [], context));
            }
          } else if (token2.name === "each") {
            const [expr, ident] = token2.extra.split(/\s+as\s+/);
            const items = interpolate(expr, context);
            if (!items || !items[Symbol.iterator]) continue;
            for (const item of items) {
              result.push(...parseTokens(token2.children.default, { ...context, [ident]: item }));
            }
          }
        }
        return result;
      }
      __name$4(parseTokens, "parseTokens");
      function visit(element, rules, session) {
        const { type: type2, attrs, children } = element;
        if (typeof rules === "function") {
          return rules(element, session);
        } else {
          let result = rules[typeof type2 === "string" ? type2 : ""] ?? rules.default ?? true;
          if (typeof result === "function") {
            result = result(attrs, children, session);
          }
          return result;
        }
      }
      __name$4(visit, "visit");
      function transform2(source2, rules, session) {
        const elements = typeof source2 === "string" ? parse3(source2) : source2;
        const output2 = [];
        elements.forEach((element) => {
          const { type: type2, attrs, children } = element;
          const result = visit(element, rules, session);
          if (result === true) {
            output2.push(Element2(type2, attrs, transform2(children, rules, session)));
          } else if (result !== false) {
            output2.push(...toElementArray(result));
          }
        });
        return typeof source2 === "string" ? output2.join("") : output2;
      }
      Element2.transform = transform2;
      __name$4(transform2, "transform");
      async function transformAsync(source2, rules, session) {
        const elements = typeof source2 === "string" ? parse3(source2) : source2;
        const children = (await Promise.all(elements.map(async (element) => {
          const { type: type2, attrs, children: children2 } = element;
          const result = await visit(element, rules, session);
          if (result === true) {
            return [Element2(type2, attrs, await transformAsync(children2, rules, session))];
          } else if (result !== false) {
            return toElementArray(result);
          } else {
            return [];
          }
        }))).flat(1);
        return typeof source2 === "string" ? children.join("") : children;
      }
      Element2.transformAsync = transformAsync;
      __name$4(transformAsync, "transformAsync");
      function createFactory(type2, ...keys) {
        return (...args) => {
          const element = Element2(type2);
          keys.forEach((key2, index2) => {
            if (!isNullable(args[index2])) {
              element.attrs[key2] = args[index2];
            }
          });
          if (args[keys.length]) {
            Object.assign(element.attrs, args[keys.length]);
          }
          return element;
        };
      }
      __name$4(createFactory, "createFactory");
      Element2.warn = /* @__PURE__ */ __name$4(() => {
      }, "warn");
      function createAssetFactory(type2) {
        return (src, ...args) => {
          let prefix = "base64://";
          if (typeof args[0] === "string") {
            prefix = `data:${args.shift()};base64,`;
          }
          if (is$1("Buffer", src)) {
            src = prefix + src.toString("base64");
          } else if (is$1("ArrayBuffer", src)) {
            src = prefix + Binary.toBase64(src);
          } else if (ArrayBuffer.isView(src)) {
            src = prefix + Binary.toBase64(src.buffer);
          }
          if (src.startsWith("base64://")) {
            (0, Element2.warn)(`protocol "base64:" is deprecated and will be removed in the future, please use "data:" instead`);
          }
          return Element2(type2, { ...args[0], src });
        };
      }
      __name$4(createAssetFactory, "createAssetFactory");
      Element2.text = createFactory("text", "content");
      Element2.at = createFactory("at", "id");
      Element2.sharp = createFactory("sharp", "id");
      Element2.quote = createFactory("quote", "id");
      Element2.image = createAssetFactory("img");
      Element2.img = createAssetFactory("img");
      Element2.video = createAssetFactory("video");
      Element2.audio = createAssetFactory("audio");
      Element2.file = createAssetFactory("file");
      function i18n(path2, children) {
        return Element2("i18n", typeof path2 === "string" ? { path: path2 } : path2, children);
      }
      Element2.i18n = i18n;
      __name$4(i18n, "i18n");
    })(Element || (Element = {}));
    module.exports = Element;
  }
});
const h = require_index();
var __defProp$3 = Object.defineProperty;
var __name$3 = (target, value) => __defProp$3(target, "name", { value, configurable: true });
function Field$1(name) {
  return { name };
}
__name$3(Field$1, "Field");
function Method(name, fields, isForm = false) {
  return { name, fields: fields.map(Field$1), isForm };
}
__name$3(Method, "Method");
var Methods = {
  "channel.get": Method("getChannel", ["channel_id", "guild_id"]),
  "channel.list": Method("getChannelList", ["guild_id", "next"]),
  "channel.create": Method("createChannel", ["guild_id", "data"]),
  "channel.update": Method("updateChannel", ["channel_id", "data"]),
  "channel.delete": Method("deleteChannel", ["channel_id"]),
  "channel.mute": Method("muteChannel", ["channel_id", "guild_id", "enable"]),
  "message.create": Method("createMessage", ["channel_id", "content", "referrer"]),
  "message.update": Method("editMessage", ["channel_id", "message_id", "content"]),
  "message.delete": Method("deleteMessage", ["channel_id", "message_id"]),
  "message.get": Method("getMessage", ["channel_id", "message_id"]),
  "message.list": Method("getMessageList", ["channel_id", "next", "direction", "limit", "order"]),
  "reaction.create": Method("createReaction", ["channel_id", "message_id", "emoji"]),
  "reaction.delete": Method("deleteReaction", ["channel_id", "message_id", "emoji", "user_id"]),
  "reaction.clear": Method("clearReaction", ["channel_id", "message_id", "emoji"]),
  "reaction.list": Method("getReactionList", ["channel_id", "message_id", "emoji", "next"]),
  "upload.create": Method("createUpload", [], true),
  "guild.get": Method("getGuild", ["guild_id"]),
  "guild.list": Method("getGuildList", ["next"]),
  "guild.member.get": Method("getGuildMember", ["guild_id", "user_id"]),
  "guild.member.list": Method("getGuildMemberList", ["guild_id", "next"]),
  "guild.member.kick": Method("kickGuildMember", ["guild_id", "user_id", "permanent"]),
  "guild.member.mute": Method("muteGuildMember", ["guild_id", "user_id", "duration", "reason"]),
  "guild.member.role.set": Method("setGuildMemberRole", ["guild_id", "user_id", "role_id"]),
  "guild.member.role.unset": Method("unsetGuildMemberRole", ["guild_id", "user_id", "role_id"]),
  "guild.member.role.list": Method("getGuildMemberRoleList", ["guild_id", "user_id", "next"]),
  "guild.role.list": Method("getGuildRoleList", ["guild_id", "next"]),
  "guild.role.create": Method("createGuildRole", ["guild_id", "data"]),
  "guild.role.update": Method("updateGuildRole", ["guild_id", "role_id", "data"]),
  "guild.role.delete": Method("deleteGuildRole", ["guild_id", "role_id"]),
  "login.get": Method("getLogin", []),
  "user.get": Method("getUser", ["user_id"]),
  "user.channel.create": Method("createDirectChannel", ["user_id", "guild_id"]),
  "friend.list": Method("getFriendList", ["next"]),
  "friend.delete": Method("deleteFriend", ["user_id"]),
  "friend.approve": Method("handleFriendRequest", ["message_id", "approve", "comment"]),
  "guild.approve": Method("handleGuildRequest", ["message_id", "approve", "comment"]),
  "guild.member.approve": Method("handleGuildMemberRequest", ["message_id", "approve", "comment"])
};
var Channel;
((Channel2) => {
  ((Type2) => {
    Type2[Type2["TEXT"] = 0] = "TEXT";
    Type2[Type2["DIRECT"] = 1] = "DIRECT";
    Type2[Type2["CATEGORY"] = 2] = "CATEGORY";
    Type2[Type2["VOICE"] = 3] = "VOICE";
  })(Channel2.Type || (Channel2.Type = {}));
})(Channel || (Channel = {}));
function Resource(attrs = [], children = [], content) {
  return { attrs, children, content };
}
__name$3(Resource, "Resource");
((Resource2) => {
  const Definitions = {
    user: Resource2(["id", "name", "nick", "avatar", "isBot"]),
    member: Resource2(["name", "nick", "avatar"]),
    channel: Resource2(["id", "type", "name"]),
    guild: Resource2(["id", "name", "avatar"]),
    quote: Resource2(["id"], ["quote", "user", "member", "channel"], "content")
  };
  function encode2(type2, data) {
    const resource = Definitions[type2];
    const element = h(type2, pick$1(data, resource.attrs));
    for (const key2 of resource.children) {
      if (isNullable(data[key2])) continue;
      element.children.push(encode2(key2, data[key2]));
    }
    if (resource.content && !isNullable(data[resource.content])) {
      element.children.push(...h.parse(data[resource.content]));
    }
    return element;
  }
  Resource2.encode = encode2;
  __name$3(encode2, "encode");
  function decode2(element) {
    const data = element.attrs;
    const resource = Definitions[element.type];
    for (const key2 of resource.children) {
      const index2 = element.children.findIndex((el) => el.type === key2);
      if (index2 === -1) continue;
      const [child] = element.children.splice(index2, 1);
      data[key2] = decode2(child);
    }
    if (resource.content && element.children.length) {
      data[resource.content] = element.children.join("");
    }
    return data;
  }
  Resource2.decode = decode2;
  __name$3(decode2, "decode");
})(Resource || (Resource = {}));
function transformKey(source2, callback) {
  if (!source2 || typeof source2 !== "object") return source2;
  if (Array.isArray(source2)) return source2.map((value) => transformKey(value, callback));
  return Object.fromEntries(Object.entries(source2).map(([key2, value]) => {
    if (key2.startsWith("_") || key2 === "referrer") return [key2, value];
    return [callback(key2), transformKey(value, callback)];
  }));
}
__name$3(transformKey, "transformKey");
var Status = /* @__PURE__ */ ((Status2) => {
  Status2[Status2["OFFLINE"] = 0] = "OFFLINE";
  Status2[Status2["ONLINE"] = 1] = "ONLINE";
  Status2[Status2["CONNECT"] = 2] = "CONNECT";
  Status2[Status2["DISCONNECT"] = 3] = "DISCONNECT";
  Status2[Status2["RECONNECT"] = 4] = "RECONNECT";
  return Status2;
})(Status || {});
var Opcode = /* @__PURE__ */ ((Opcode2) => {
  Opcode2[Opcode2["EVENT"] = 0] = "EVENT";
  Opcode2[Opcode2["PING"] = 1] = "PING";
  Opcode2[Opcode2["PONG"] = 2] = "PONG";
  Opcode2[Opcode2["IDENTIFY"] = 3] = "IDENTIFY";
  Opcode2[Opcode2["READY"] = 4] = "READY";
  Opcode2[Opcode2["META"] = 5] = "META";
  return Opcode2;
})(Opcode || {});
var WebSocket$1;
((WebSocket2) => {
  WebSocket2.CONNECTING = 0;
  WebSocket2.OPEN = 1;
  WebSocket2.CLOSING = 2;
  WebSocket2.CLOSED = 3;
})(WebSocket$1 || (WebSocket$1 = {}));
const getChannel = async (ctx, payload) => {
  const info = await ctx.ntGroupApi.getGroupAllInfo(payload.channel_id);
  return {
    id: payload.channel_id,
    type: Channel.Type.TEXT,
    name: info.groupName
  };
};
const getChannelList = async (ctx, payload) => {
  const info = await ctx.ntGroupApi.getGroupAllInfo(payload.guild_id);
  return {
    data: [{
      id: payload.guild_id,
      type: Channel.Type.TEXT,
      name: info.groupName
    }]
  };
};
const updateChannel = async (ctx, payload) => {
  if (payload.data.name) {
    await ctx.ntGroupApi.setGroupName(payload.channel_id, payload.data.name);
  }
  return {};
};
const deleteChannel = async (ctx, payload) => {
  await ctx.ntGroupApi.quitGroup(payload.channel_id);
  return {};
};
const muteChannel = async (ctx, payload) => {
  await ctx.ntGroupApi.banGroup(payload.channel_id, payload.duration !== 0);
  return {};
};
const createDirectChannel = async (ctx, payload) => {
  return {
    id: "private:" + payload.user_id,
    type: Channel.Type.DIRECT
  };
};
function decodeUser(user) {
  return {
    id: user.uin,
    name: user.nick,
    nick: user.remark || user.nick,
    avatar: `http://q.qlogo.cn/headimg_dl?dst_uin=${user.uin}&spec=640`,
    is_bot: false
  };
}
function decodeGuildChannelId(data) {
  if (data.chatType === ChatType.Group) {
    return [data.peerUin, data.peerUin];
  } else {
    return [void 0, "private:" + data.peerUin];
  }
}
function decodeMessageUser(data) {
  return {
    id: data.senderUin,
    name: data.sendNickName,
    nick: data.sendRemarkName || data.sendNickName,
    avatar: `http://q.qlogo.cn/headimg_dl?dst_uin=${data.senderUin}&spec=640`
  };
}
async function decodeElement(ctx, data, quoted = false) {
  const buffer2 = [];
  for (const v of data.elements) {
    if (v.textElement && v.textElement.atType !== AtType.Unknown) {
      const { atNtUid, atUid, atType, content } = v.textElement;
      if (atType === AtType.All) {
        buffer2.push(h.at(void 0, { type: "all" }));
      } else if (atType === AtType.One) {
        let id2;
        if (atUid && atUid !== "0") {
          id2 = atUid;
        } else {
          id2 = await ctx.ntUserApi.getUinByUid(atNtUid);
        }
        buffer2.push(h.at(id2, { name: content.replace("@", "") }));
      }
    } else if (v.textElement && v.textElement.content) {
      buffer2.push(h.text(v.textElement.content));
    } else if (v.replyElement && !quoted) {
      const peer = {
        chatType: data.chatType,
        peerUid: data.peerUid,
        guildId: ""
      };
      const { replayMsgSeq, replyMsgTime, sourceMsgIdInRecords } = v.replyElement;
      const records = data.records.find((msgRecord) => msgRecord.msgId === sourceMsgIdInRecords);
      const senderUid = v.replyElement.senderUidStr || records?.senderUid;
      if (!records || !replyMsgTime || !senderUid) {
        ctx.logger.error("", v.replyElement);
        continue;
      }
      if (data.multiTransInfo) {
        buffer2.push(h.quote(records.msgId));
        continue;
      }
      try {
        const { msgList } = await ctx.ntMsgApi.getMsgsBySeqAndCount(peer, replayMsgSeq, 1, true, true);
        let replyMsg;
        if (records.msgRandom !== "0") {
          replyMsg = msgList.find((msg) => msg.msgRandom === records.msgRandom);
        } else {
          ctx.logger.info("msgRandom is missing", v.replyElement, records);
          replyMsg = msgList[0];
        }
        if (!replyMsg) {
          ctx.logger.warn("", v.replyElement, records);
          continue;
        }
        const elements = await decodeElement(ctx, replyMsg, true);
        buffer2.push(h("quote", { id: replyMsg.msgId }, elements));
      } catch (e) {
        ctx.logger.error("", e, v.replyElement, e.stack);
      }
    } else if (v.picElement) {
      const src = await ctx.ntFileApi.getImageUrl(v.picElement);
      buffer2.push(h.img(src, {
        width: v.picElement.picWidth,
        height: v.picElement.picHeight,
        subType: v.picElement.picSubType
      }));
    } else if (v.pttElement) {
      const src = pathToFileURL(v.pttElement.filePath).href;
      buffer2.push(h.audio(src, { duration: v.pttElement.duration }));
    } else if (v.videoElement) {
      const src = await ctx.ntFileApi.getVideoUrl({
        chatType: data.chatType,
        peerUid: data.peerUid,
        guildId: ""
      }, data.msgId, v.elementId) || pathToFileURL(v.videoElement.filePath).href;
      buffer2.push(h.video(src));
    } else if (v.marketFaceElement) {
      const { emojiId, supportSize } = v.marketFaceElement;
      const { width = 300, height = 300 } = supportSize?.[0] ?? {};
      const dir = emojiId.substring(0, 2);
      const src = `https://gxh.vip.qq.com/club/item/parcel/item/${dir}/${emojiId}/raw${width}.gif`;
      buffer2.push(h("mface", {
        emojiPackageId: v.marketFaceElement.emojiPackageId,
        emojiId,
        key: v.marketFaceElement.key,
        summary: v.marketFaceElement.faceName
      }, [h.image(src, { width, height })]));
    } else if (v.faceElement) {
      const { faceIndex, faceType } = v.faceElement;
      buffer2.push(h("face", {
        id: String(faceIndex),
        type: String(faceType),
        platform: "llonebot"
      }));
    } else if (v.arkElement) {
      buffer2.push(h("llonebot:ark", {
        data: v.arkElement.bytesData
      }));
    }
  }
  return buffer2;
}
async function decodeMessage(ctx, data, message = {}) {
  if (!data.senderUin || data.senderUin === "0") return;
  const [guildId, channelId] = decodeGuildChannelId(data);
  const elements = await decodeElement(ctx, data);
  if (elements.length === 0) return;
  message.id = data.msgId;
  message.content = elements.join("");
  message.channel = {
    id: channelId,
    name: data.peerName,
    type: guildId ? Channel.Type.TEXT : Channel.Type.DIRECT
  };
  message.user = decodeMessageUser(data);
  message.created_at = +data.msgTime * 1e3;
  if (!message.user.name) {
    const info = (await ctx.ntUserApi.getUserSimpleInfo(data.senderUid)).coreInfo;
    message.user.name = info.nick;
    message.user.nick = info.remark || info.nick;
    if (message.channel.type === Channel.Type.DIRECT) {
      message.channel.name = info.nick;
    }
  }
  if (guildId) {
    message.guild = {
      id: guildId,
      name: data.peerName,
      avatar: `https://p.qlogo.cn/gh/${guildId}/${guildId}/640`
    };
    message.member = {
      user: message.user,
      nick: data.sendMemberName || message.user.name
    };
  }
  return message;
}
function decodeGuildMember(data) {
  return {
    user: {
      ...decodeUser(data),
      is_bot: data.isRobot
    },
    nick: data.cardName || data.nick,
    avatar: `http://q.qlogo.cn/headimg_dl?dst_uin=${data.uin}&spec=640`,
    joined_at: data.joinTime * 1e3
  };
}
function decodeGuild(data) {
  return {
    id: data.groupCode,
    name: data.groupName,
    avatar: `https://p.qlogo.cn/gh/${data.groupCode}/${data.groupCode}/640`
  };
}
async function getPeer(ctx, channelId) {
  let peerUid = channelId;
  let chatType = ChatType.Group;
  if (peerUid.includes("private:")) {
    const uin = channelId.replace("private:", "");
    const uid = await ctx.ntUserApi.getUidByUin(uin);
    if (!uid) throw new Error("");
    const isBuddy = await ctx.ntFriendApi.isBuddy(uid);
    chatType = isBuddy ? ChatType.C2C : ChatType.TempC2CFromGroup;
    peerUid = uid;
  }
  return {
    chatType,
    peerUid,
    guildId: ""
  };
}
const getGuild = async (ctx, payload) => {
  const info = await ctx.ntGroupApi.getGroupAllInfo(payload.guild_id);
  return decodeGuild(info);
};
const getGuildList = async (ctx) => {
  const groups = await ctx.ntGroupApi.getGroups();
  return {
    data: groups.map(decodeGuild)
  };
};
const handleGuildRequest = async (ctx, payload) => {
  await ctx.ntGroupApi.handleGroupRequest(
    payload.message_id,
    payload.approve ? GroupRequestOperateTypes.Approve : GroupRequestOperateTypes.Reject,
    payload.comment
  );
  return {};
};
const getLogin = async (ctx) => {
  const features = [];
  for (const [feature, info] of Object.entries(Methods)) {
    if (info.name in handlers) {
      features.push(feature);
    }
  }
  features.push("guild.plain");
  await ctx.ntUserApi.getSelfNick();
  return {
    sn: ctx.get("satori")._loginSeq,
    user: decodeUser(selfInfo),
    adapter: "llonebot",
    platform: "llonebot",
    status: selfInfo.online ? Status.ONLINE : Status.OFFLINE,
    features,
    proxy_urls: []
  };
};
const getGuildMember = async (ctx, payload) => {
  const uid = await ctx.ntUserApi.getUidByUin(payload.user_id, payload.guild_id);
  if (!uid) throw new Error("");
  const info = await ctx.ntGroupApi.getGroupMember(payload.guild_id, uid);
  if (!info) {
    throw new Error(`${payload.user_id}`);
  }
  return decodeGuildMember(info);
};
const getGuildMemberList = async (ctx, payload) => {
  const res = await ctx.ntGroupApi.getGroupMembers(payload.guild_id);
  if (res.errCode !== 0) {
    throw new Error(res.errMsg);
  }
  return {
    data: res.result.infos.values().map(decodeGuildMember).toArray()
  };
};
const kickGuildMember = async (ctx, payload) => {
  const uid = await ctx.ntUserApi.getUidByUin(payload.user_id, payload.guild_id);
  if (!uid) throw new Error("");
  await ctx.ntGroupApi.kickMember(payload.guild_id, [uid], Boolean(payload.permanent));
  return {};
};
const muteGuildMember = async (ctx, payload) => {
  const uid = await ctx.ntUserApi.getUidByUin(payload.user_id, payload.guild_id);
  if (!uid) throw new Error("");
  await ctx.ntGroupApi.banMember(payload.guild_id, [
    { uid, timeStamp: payload.duration / 1e3 }
  ]);
  return {};
};
const handleGuildMemberRequest = async (ctx, payload) => {
  await ctx.ntGroupApi.handleGroupRequest(
    payload.message_id,
    payload.approve ? GroupRequestOperateTypes.Approve : GroupRequestOperateTypes.Reject,
    payload.comment
  );
  return {};
};
class State {
  constructor(type2) {
    this.type = type2;
  }
  children = [];
}
class MessageEncoder2 {
  constructor(ctx, channelId) {
    this.ctx = ctx;
    this.channelId = channelId;
  }
  errors = [];
  results = [];
  elements = [];
  deleteAfterSentFiles = [];
  stack = [new State("message")];
  peer;
  async flush() {
    if (this.elements.length === 0) return;
    if (this.stack[0].type === "multiForward") {
      this.stack[0].children.push(...this.elements);
      this.elements = [];
      return;
    }
    this.peer ??= await getPeer(this.ctx, this.channelId);
    const sent = await this.ctx.ntMsgApi.sendMsg(this.peer, this.elements);
    if (sent) {
      this.ctx.logger.info("", this.peer);
      const result = await decodeMessage(this.ctx, sent);
      if (result) {
        this.results.push(result);
      }
    }
    this.deleteAfterSentFiles.forEach((path2) => {
      try {
        unlink(path2).then().catch((e) => {
        });
      } catch (e) {
      }
    });
    this.deleteAfterSentFiles = [];
    this.elements = [];
  }
  async fetchFile(url2) {
    const res = await uri2local(this.ctx, url2);
    if (!res.success) {
      this.ctx.logger.error(res.errMsg);
      throw Error(res.errMsg);
    }
    if (!res.isLocal) {
      this.deleteAfterSentFiles.push(res.path);
    }
    return res.path;
  }
  async getPeerFromMsgId(msgId) {
    this.peer ??= await getPeer(this.ctx, this.channelId);
    const msg = (await this.ctx.ntMsgApi.getMsgsByMsgId(this.peer, [msgId])).msgList;
    if (msg.length > 0) {
      return this.peer;
    } else {
      const cacheMsg = this.ctx.store.getMsgCache(msgId);
      if (cacheMsg) {
        return {
          peerUid: cacheMsg.peerUid,
          chatType: cacheMsg.chatType,
          guildId: ""
        };
      }
      const c2cMsg = await this.ctx.ntMsgApi.queryMsgsById(ChatType.C2C, msgId);
      if (c2cMsg.msgList.length) {
        return {
          peerUid: c2cMsg.msgList[0].peerUid,
          chatType: c2cMsg.msgList[0].chatType,
          guildId: ""
        };
      }
      const groupMsg = await this.ctx.ntMsgApi.queryMsgsById(ChatType.Group, msgId);
      if (groupMsg.msgList.length) {
        return {
          peerUid: groupMsg.msgList[0].peerUid,
          chatType: groupMsg.msgList[0].chatType,
          guildId: ""
        };
      }
    }
  }
  async forward(msgId, srcPeer, destPeer) {
    const msg = await this.ctx.ntMsgApi.forwardMsg(srcPeer, destPeer, [msgId]);
    return msg;
  }
  async multiForward() {
    if (!this.stack[0].children.length) return;
    const selfPeer = {
      chatType: ChatType.C2C,
      peerUid: selfInfo.uid,
      guildId: ""
    };
    const nodeMsgIds = [];
    for (const node of this.stack[0].children) {
      if (typeof node === "string") {
        if (node.length !== 19) {
          this.ctx.logger.warn(" ID ", node);
          continue;
        }
        const peer = await this.getPeerFromMsgId(node);
        if (!peer) {
          this.ctx.logger.warn("", node);
          continue;
        }
        nodeMsgIds.push({ msgId: node, peer });
      } else {
        try {
          const sent = await this.ctx.ntMsgApi.sendMsg(selfPeer, [node]);
          if (!sent) {
            this.ctx.logger.warn("", node);
            continue;
          }
          nodeMsgIds.push({ msgId: sent.msgId, peer: selfPeer });
          await this.ctx.sleep(100);
        } catch (e) {
          this.ctx.logger.error("", e);
        }
      }
    }
    let srcPeer;
    let needSendSelf = false;
    for (const { peer } of nodeMsgIds) {
      srcPeer ??= {
        chatType: peer.chatType,
        peerUid: peer.peerUid,
        guildId: ""
      };
      if (srcPeer.peerUid !== peer.peerUid) {
        needSendSelf = true;
        break;
      }
    }
    let retMsgIds = [];
    if (needSendSelf) {
      for (const { msgId, peer } of nodeMsgIds) {
        const srcPeer2 = {
          peerUid: peer.peerUid,
          chatType: peer.chatType,
          guildId: ""
        };
        const clonedMsg = await this.forward(msgId, srcPeer2, selfPeer);
        if (clonedMsg) {
          retMsgIds.push(clonedMsg.msgId);
        }
        await this.ctx.sleep(100);
      }
      srcPeer = selfPeer;
    } else {
      retMsgIds = nodeMsgIds.map((e) => e.msgId);
    }
    if (retMsgIds.length === 0) {
      throw Error("");
    }
    if (this.stack[1].type === "multiForward") {
      this.peer ??= await getPeer(this.ctx, this.channelId);
      const msg = await this.ctx.ntMsgApi.multiForwardMsg(srcPeer, selfPeer, retMsgIds);
      this.stack[1].children.push(...msg.elements);
    } else {
      this.peer ??= await getPeer(this.ctx, this.channelId);
      await this.ctx.ntMsgApi.multiForwardMsg(srcPeer, this.peer, retMsgIds);
      this.ctx.logger.info("", this.peer);
    }
  }
  async visit(element) {
    const { type: type2, attrs, children } = element;
    if (type2 === "text") {
      this.elements.push(SendElement.text(attrs.content));
    } else if (type2 === "at") {
      this.peer ??= await getPeer(this.ctx, this.channelId);
      if (this.peer.chatType !== ChatType.Group) {
        return;
      }
      if (attrs.type === "all") {
        this.elements.push(SendElement.at("", "", AtType.All, "@"));
      } else {
        const uid = await this.ctx.ntUserApi.getUidByUin(attrs.id, this.peer.peerUid) ?? "";
        const display = attrs.name ? "@" + attrs.name : "";
        this.elements.push(SendElement.at(attrs.id, uid, AtType.One, display));
      }
    } else if (type2 === "a") {
      await this.render(children);
      const prev = this.elements.at(-1);
      if (prev?.elementType === 1 && prev.textElement.atType === 0) {
        prev.textElement.content += ` ( ${attrs.href} )`;
      }
    } else if (type2 === "img" || type2 === "image") {
      const url2 = attrs.src ?? attrs.url;
      const path2 = await this.fetchFile(url2);
      const element2 = await SendElement.pic(this.ctx, path2);
      this.deleteAfterSentFiles.push(element2.picElement.sourcePath);
      this.elements.push(element2);
    } else if (type2 === "audio") {
      await this.flush();
      const url2 = attrs.src ?? attrs.url;
      const path2 = await this.fetchFile(url2);
      this.elements.push(await SendElement.ptt(this.ctx, path2));
      await this.flush();
    } else if (type2 === "video") {
      await this.flush();
      const url2 = attrs.src ?? attrs.url;
      const path2 = await this.fetchFile(url2);
      let thumb;
      if (attrs.poster) {
        thumb = await this.fetchFile(attrs.poster);
      }
      const element2 = await SendElement.video(this.ctx, path2, thumb);
      this.deleteAfterSentFiles.push(element2.videoElement.filePath);
      this.elements.push(element2);
      await this.flush();
    } else if (type2 === "file") {
      await this.flush();
      const url2 = attrs.src ?? attrs.url;
      const path2 = await this.fetchFile(url2);
      const fileName = attrs.title ?? path__default.basename(path2);
      this.elements.push(await SendElement.file(this.ctx, path2, fileName));
      await this.flush();
    } else if (type2 === "br") {
      this.elements.push(SendElement.text("\n"));
    } else if (type2 === "p") {
      const prev = this.elements.at(-1);
      if (prev?.elementType === 1 && prev.textElement.atType === 0) {
        if (!prev.textElement.content.endsWith("\n")) {
          prev.textElement.content += "\n";
        }
      } else if (prev) {
        this.elements.push(SendElement.text("\n"));
      }
      await this.render(children);
      const last = this.elements.at(-1);
      if (last?.elementType === 1 && last.textElement.atType === 0) {
        if (!last.textElement.content.endsWith("\n")) {
          last.textElement.content += "\n";
        }
      } else {
        this.elements.push(SendElement.text("\n"));
      }
    } else if (type2 === "message") {
      if (attrs.id && attrs.forward) {
        await this.flush();
        const srcPeer = await this.getPeerFromMsgId(attrs.id);
        if (srcPeer) {
          this.peer ??= await getPeer(this.ctx, this.channelId);
          const sent = await this.forward(attrs.id, srcPeer, this.peer);
          if (sent) {
            this.ctx.logger.info("", this.peer);
            const result = await decodeMessage(this.ctx, sent);
            if (result) {
              this.results.push(result);
            }
          }
        }
      } else if (attrs.forward) {
        await this.flush();
        this.stack.unshift(new State("multiForward"));
        await this.render(children);
        await this.flush();
        await this.multiForward();
        this.stack.shift();
      } else if (attrs.id && this.stack[0].type === "multiForward") {
        this.stack[0].children.push(attrs.id);
      } else {
        await this.render(children);
        await this.flush();
      }
    } else if (type2 === "quote") {
      this.peer ??= await getPeer(this.ctx, this.channelId);
      const source2 = (await this.ctx.ntMsgApi.getMsgsByMsgId(this.peer, [attrs.id])).msgList[0];
      if (source2) {
        this.elements.push(SendElement.reply(source2.msgSeq, source2.msgId, source2.senderUid));
      }
    } else if (type2 === "face") {
      this.elements.push(SendElement.face(+attrs.id, +attrs.type));
    } else if (type2 === "mface") {
      this.elements.push(SendElement.mface(
        +attrs.emojiPackageId,
        attrs.emojiId,
        attrs.key,
        attrs.summary
      ));
    } else {
      await this.render(children);
    }
  }
  async render(elements, flush) {
    for (const element of elements) {
      await this.visit(element);
    }
    if (flush) {
      await this.flush();
    }
  }
  async send(content) {
    const elements = h.normalize(content);
    await this.render(elements);
    await this.flush();
    if (this.errors.length) {
      throw new AggregateError(this.errors);
    } else {
      return this.results;
    }
  }
}
const createMessage = (ctx, payload) => {
  const encoder = new MessageEncoder2(ctx, payload.channel_id);
  return encoder.send(payload.content);
};
const getMessage = async (ctx, payload) => {
  const peer = await getPeer(ctx, payload.channel_id);
  const raw = ctx.store.getMsgCache(payload.message_id) ?? (await ctx.ntMsgApi.getMsgsByMsgId(peer, [payload.message_id])).msgList[0];
  const result = await decodeMessage(ctx, raw);
  if (!result) {
    throw new Error("");
  }
  return result;
};
const deleteMessage = async (ctx, payload) => {
  const peer = await getPeer(ctx, payload.channel_id);
  const data = await ctx.ntMsgApi.recallMsg(peer, [payload.message_id]);
  if (data.result !== 0) {
    ctx.logger.error("message.delete", payload.message_id, data);
    throw new Error(``);
  }
  return {};
};
const getMessageList = async (ctx, payload) => {
  const count = payload.limit ?? 50;
  const peer = await getPeer(ctx, payload.channel_id);
  let msgList;
  if (!payload.next) {
    msgList = (await ctx.ntMsgApi.getAioFirstViewLatestMsgs(peer, count)).msgList;
  } else {
    msgList = (await ctx.ntMsgApi.getMsgHistory(peer, payload.next, count)).msgList;
  }
  const data = filterNullable(await Promise.all(msgList.map((e) => decodeMessage(ctx, e))));
  if (payload.order === "desc") data.reverse();
  return {
    data,
    next: msgList.at(-1)?.msgId
  };
};
const createReaction = async (ctx, payload) => {
  const peer = await getPeer(ctx, payload.channel_id);
  const { msgList } = await ctx.ntMsgApi.getMsgsByMsgId(peer, [payload.message_id]);
  if (!msgList.length || !msgList[0].msgSeq) {
    throw new Error("");
  }
  await ctx.ntMsgApi.setEmojiLike(peer, msgList[0].msgSeq, payload.emoji, true);
  return {};
};
const deleteReaction = async (ctx, payload) => {
  const peer = await getPeer(ctx, payload.channel_id);
  const { msgList } = await ctx.ntMsgApi.getMsgsByMsgId(peer, [payload.message_id]);
  if (!msgList.length || !msgList[0].msgSeq) {
    throw new Error("");
  }
  await ctx.ntMsgApi.setEmojiLike(peer, msgList[0].msgSeq, payload.emoji, false);
  return {};
};
const getReactionList = async (ctx, payload) => {
  const peer = await getPeer(ctx, payload.channel_id);
  const { msgList } = await ctx.ntMsgApi.getMsgsByMsgId(peer, [payload.message_id]);
  if (!msgList.length || !msgList[0].msgSeq) {
    throw new Error("");
  }
  const count = msgList[0].emojiLikesList.find((e) => e.emojiId === payload.emoji)?.likesCnt ?? "50";
  const data = await ctx.ntMsgApi.getMsgEmojiLikesList(peer, msgList[0].msgSeq, payload.emoji, +count);
  const uids = await Promise.all(data.emojiLikesList.map((e) => ctx.ntUserApi.getUidByUin(e.tinyId, peer.chatType === 2 ? peer.peerUid : void 0)));
  const raw = await ctx.ntUserApi.getCoreAndBaseInfo(filterNullable(uids));
  return {
    data: Array.from(raw.values()).map((e) => decodeUser(e.coreInfo))
  };
};
const setGuildMemberRole = async (ctx, payload) => {
  const uid = await ctx.ntUserApi.getUidByUin(payload.user_id, payload.guild_id);
  if (!uid) {
    throw new Error("");
  }
  if (payload.role_id !== "2" && payload.role_id !== "3") {
    throw new Error("role_id  2  3");
  }
  await ctx.ntGroupApi.setMemberRole(payload.guild_id, uid, +payload.role_id);
  return {};
};
const getGuildRoleList = () => {
  return {
    data: [
      {
        id: "4",
        name: "owner"
      },
      {
        id: "3",
        name: "admin"
      },
      {
        id: "2",
        name: "member"
      }
    ]
  };
};
const getUser = async (ctx, payload) => {
  const uin = payload.user_id;
  const uid = await ctx.ntUserApi.getUidByUin(uin);
  if (!uid) throw new Error("");
  const data = await ctx.ntUserApi.getUserSimpleInfo(uid);
  const range2 = await ctx.ntUserApi.getRobotUinRange();
  if (range2.result !== 0) {
    throw new Error(range2.errMsg);
  }
  return {
    ...decodeUser(data.coreInfo),
    is_bot: range2.response.robotUinRanges.some((e) => uin >= e.minUin && uin <= e.maxUin)
  };
};
const getFriendList = async (ctx) => {
  const friends = await ctx.ntFriendApi.getBuddyList();
  return {
    data: friends.map((e) => decodeUser(e.coreInfo))
  };
};
const handleFriendRequest = async (ctx, payload) => {
  const data = payload.message_id.split("|");
  if (data.length < 2) {
    throw new Error(" message_id");
  }
  const uid = data[0];
  const reqTime = data[1];
  await ctx.ntFriendApi.handleFriendRequest(uid, reqTime, payload.approve);
  return {};
};
const handlers = {
  //  (Channel)
  getChannel,
  getChannelList,
  updateChannel,
  deleteChannel,
  muteChannel,
  createDirectChannel,
  //  (Guild)
  getGuild,
  getGuildList,
  handleGuildRequest,
  //  (Login)
  getLogin,
  //  (GuildMember)
  getGuildMember,
  getGuildMemberList,
  kickGuildMember,
  muteGuildMember,
  handleGuildMemberRequest,
  //  (Message)
  createMessage,
  getMessage,
  deleteMessage,
  getMessageList,
  //  (Reaction)
  createReaction,
  deleteReaction,
  getReactionList,
  //  (GuildRole)
  setGuildMemberRole,
  getGuildRoleList,
  //  (User)
  getUser,
  getFriendList,
  handleFriendRequest
};
class Locked extends Error {
  constructor(port) {
    super(`${port} is locked`);
  }
}
const lockedPorts = {
  old: /* @__PURE__ */ new Set(),
  young: /* @__PURE__ */ new Set()
};
const releaseOldLockedPortsIntervalMs = 1e3 * 15;
let timeout;
const getLocalHosts = () => {
  const interfaces = os__default.networkInterfaces();
  const results = /* @__PURE__ */ new Set([void 0, "0.0.0.0"]);
  for (const _interface of Object.values(interfaces)) {
    for (const config2 of _interface) {
      results.add(config2.address);
    }
  }
  return results;
};
const checkAvailablePort = (options) => new Promise((resolve2, reject) => {
  const server = require$$1$4.createServer();
  server.unref();
  server.on("error", reject);
  server.listen(options, () => {
    const { port } = server.address();
    server.close(() => {
      resolve2(port);
    });
  });
});
const getAvailablePort$1 = async (options, hosts) => {
  if (options.host || options.port === 0) {
    return checkAvailablePort(options);
  }
  for (const host of hosts) {
    try {
      await checkAvailablePort({ port: options.port, host });
    } catch (error2) {
      if (!["EADDRNOTAVAIL", "EINVAL"].includes(error2.code)) {
        throw error2;
      }
    }
  }
  return options.port;
};
const portCheckSequence = function* (ports) {
  if (ports) {
    yield* ports;
  }
  yield 0;
};
async function getPorts(options) {
  let ports;
  let exclude = /* @__PURE__ */ new Set();
  if (options) {
    if (options.port) {
      ports = typeof options.port === "number" ? [options.port] : options.port;
    }
    if (options.exclude) {
      const excludeIterable = options.exclude;
      if (typeof excludeIterable[Symbol.iterator] !== "function") {
        throw new TypeError("The `exclude` option must be an iterable.");
      }
      for (const element of excludeIterable) {
        if (typeof element !== "number") {
          throw new TypeError("Each item in the `exclude` option must be a number corresponding to the port you want excluded.");
        }
        if (!Number.isSafeInteger(element)) {
          throw new TypeError(`Number ${element} in the exclude option is not a safe integer and can't be used`);
        }
      }
      exclude = new Set(excludeIterable);
    }
  }
  if (timeout === void 0) {
    timeout = setTimeout(() => {
      timeout = void 0;
      lockedPorts.old = lockedPorts.young;
      lockedPorts.young = /* @__PURE__ */ new Set();
    }, releaseOldLockedPortsIntervalMs);
    if (timeout.unref) {
      timeout.unref();
    }
  }
  const hosts = getLocalHosts();
  for (const port of portCheckSequence(ports)) {
    try {
      if (exclude.has(port)) {
        continue;
      }
      let availablePort = await getAvailablePort$1({ ...options, port }, hosts);
      while (lockedPorts.old.has(availablePort) || lockedPorts.young.has(availablePort)) {
        if (port !== 0) {
          throw new Locked(port);
        }
        availablePort = await getAvailablePort$1({ ...options, port }, hosts);
      }
      lockedPorts.young.add(availablePort);
      return availablePort;
    } catch (error2) {
      if (!["EADDRINUSE", "EACCES"].includes(error2.code) && !(error2 instanceof Locked)) {
        throw error2;
      }
    }
  }
  throw new Error("No available ports found");
}
async function getAvailablePort(startPort, range2 = 100) {
  const ports = Array.from({ length: range2 }, (_, i) => startPort + i);
  return await getPorts({ port: ports });
}
class SatoriServer {
  constructor(ctx, config2) {
    this.ctx = ctx;
    this.config = config2;
    this.express = express();
    this.express.use(express.json({ limit: "50mb" }));
    this.actionMap = initActionMap(this);
  }
  express;
  httpServer;
  wsServer;
  wsClients = [];
  actionMap;
  async CallOneBot11API(action, params) {
    const handler = this.actionMap.get(action);
    if (!handler) {
      throw new Error(`Unsupported OB11 action: ${action}`);
    }
    return handler.handle(params, {
      messageFormat: "array",
      debug: false
    });
  }
  async handleOneBotRequest(req, res) {
    if (this.checkAuth(req, res)) return;
    const action = req.params.action;
    const params = req.method === "POST" ? req.body : req.query;
    let result;
    try {
      result = await this.CallOneBot11API(action, params);
    } catch (e) {
      result = OB11Response.error(e?.toString() ?? String(e), 200);
    }
    res.json(result);
  }
  start() {
    this.express.route("/v1/internal/onebot11/:action").post(this.handleOneBotRequest.bind(this)).get(this.handleOneBotRequest.bind(this));
    this.express.get("/v1/:name", async (req, res) => {
      res.status(405).send("Please use POST method to send requests.");
    });
    this.express.post("/v1/:name", async (req, res) => {
      const method = Methods[req.params.name];
      if (!method) {
        res.status(404).send("method not found");
        return;
      }
      if (this.checkAuth(req, res)) return;
      const selfId = req.headers["satori-user-id"] ?? req.headers["x-self-id"];
      const platform = req.headers["satori-platform"] ?? req.headers["x-platform"];
      if (selfId !== selfInfo.uin || !platform) {
        res.status(403).send("login not found");
        return;
      }
      const handle = handlers[method.name];
      if (!handle) {
        res.status(404).send("method not found");
        return;
      }
      try {
        const result = await handle(this.ctx, req.body);
        res.json(result);
      } catch (e) {
        this.ctx.logger.error(e);
        throw e;
      }
    });
    let { onlyLocalhost, port } = this.config;
    let host = onlyLocalhost ? "127.0.0.1" : "";
    getAvailablePort(port).then((availablePort) => {
      if (availablePort !== port) {
        return this.ctx.logger.warn(` ${port} `);
      }
      this.httpServer = this.express.listen(port, host, (error2) => {
        this.ctx.logger.info(`Satori server started ${host}:${port}`);
        if (error2) {
          this.ctx.logger.error("Failed to start Satori server:", error2);
        }
      });
      this.wsServer = new WebSocketServer({
        server: this.httpServer
      });
      this.wsServer.on("connection", (socket, req) => {
        const url2 = req.url?.split("?").shift();
        if (!["/v1/events", "/v1/events/"].includes(url2)) {
          return socket.close(1008, "invalid address");
        }
        socket.addEventListener("message", async (event) => {
          let payload;
          try {
            payload = JSON.parse(event.data.toString());
          } catch (error2) {
            return socket.close(4e3, "invalid message");
          }
          if (payload.op === Opcode.IDENTIFY) {
            if (this.config.token && payload.body?.token !== this.config.token) {
              return socket.close(4004, "invalid token");
            }
            this.ctx.logger.info("ws connect", url2);
            socket.send(JSON.stringify({
              op: Opcode.READY,
              body: {
                logins: [await handlers.getLogin(this.ctx, {})],
                proxy_urls: []
              }
            }));
            this.wsClients.push(socket);
          } else if (payload.op === Opcode.PING) {
            socket.send(JSON.stringify({
              op: Opcode.PONG,
              body: {}
            }));
          }
        });
      });
    });
  }
  async stop() {
    if (this.wsClients.length > 0) {
      for (const socket of this.wsClients) {
        try {
          if (socket.readyState === WebSocket$2.OPEN) {
            socket.close(1e3);
          }
        } catch {
        }
      }
    }
    if (this.wsServer) {
      const close = promisify(this.wsServer.close);
      await close.call(this.wsServer);
      this.wsServer = void 0;
    }
    if (this.httpServer) {
      const close = promisify(this.httpServer.close);
      await close.call(this.httpServer);
      this.httpServer = void 0;
    }
  }
  checkAuth(req, res) {
    if (!this.config.token) return;
    if (req.headers.authorization !== `Bearer ${this.config.token}`) {
      res.status(403).send("invalid token");
      return true;
    }
  }
  async dispatch(body) {
    this.wsClients.forEach((socket) => {
      if (socket.readyState === WebSocket$2.OPEN) {
        socket.send(JSON.stringify({
          op: Opcode.EVENT,
          body
        }));
        this.ctx.logger.info("WebSocket ", socket.url ?? "", body.type);
      }
    });
  }
  updateConfig(config2) {
    Object.assign(this.config, config2);
  }
}
async function parseMessageCreated(bot, input) {
  const message = await decodeMessage(bot.ctx, input);
  if (!message) return;
  return bot.event("message-created", {
    message: omit$1(message, ["member", "user", "channel", "guild"]),
    member: message.member,
    user: message.user,
    channel: message.channel,
    guild: message.guild
  });
}
async function parseMessageDeleted(bot, input) {
  const origin = bot.ctx.store.getMsgCache(input.msgId);
  if (!origin) return;
  const message = await decodeMessage(bot.ctx, origin);
  if (!message) return;
  const operatorUid = input.elements[0].grayTipElement.revokeElement.operatorUid;
  const user = await bot.ctx.ntUserApi.getUserSimpleInfo(operatorUid);
  return bot.event("message-deleted", {
    message: omit$1(message, ["member", "user", "channel", "guild"]),
    member: message.member,
    user: message.user,
    channel: message.channel,
    guild: message.guild,
    operator: omit$1(decodeUser(user.coreInfo), ["is_bot"])
  });
}
async function parseGuildAdded(bot, input) {
  const groupAll = await bot.ctx.ntGroupApi.getGroupAllInfo(input.peerUid);
  return bot.event("guild-added", {
    guild: decodeGuild(groupAll)
  });
}
async function parseGuildRemoved(bot, input) {
  const groupAll = await bot.ctx.ntGroupApi.getGroupAllInfo(input.peerUid);
  return bot.event("guild-removed", {
    guild: decodeGuild(groupAll)
  });
}
async function parseGuildRequest(bot, notify) {
  const groupCode = notify.group.groupCode;
  const flag = groupCode + "|" + notify.seq + "|" + notify.type;
  return bot.event("guild-request", {
    guild: decodeGuild(notify.group),
    message: {
      id: flag,
      content: notify.postscript
    }
  });
}
async function parseGuildMemberAdded(bot, input, isBot = false) {
  const groupAll = await bot.ctx.ntGroupApi.getGroupAllInfo(input.peerUid);
  let memberUid;
  if (input.elements[0].grayTipElement?.groupElement) {
    memberUid = input.elements[0].grayTipElement.groupElement.memberUid;
  } else if (input.elements[0].grayTipElement?.jsonGrayTipElement) {
    const json2 = JSON.parse(input.elements[0].grayTipElement.jsonGrayTipElement.jsonStr);
    const uin = new URL(json2.items[2].jp).searchParams.get("robot_uin");
    if (!uin) return;
    memberUid = await bot.ctx.ntUserApi.getUidByUin(uin, input.peerUid);
  } else {
    const iterator = input.elements[0].grayTipElement?.xmlElement?.members.keys();
    iterator?.next();
    memberUid = iterator?.next().value;
  }
  if (!memberUid) return;
  const user = decodeUser((await bot.ctx.ntUserApi.getUserSimpleInfo(memberUid)).coreInfo);
  user.is_bot = isBot;
  return bot.event("guild-member-added", {
    guild: decodeGuild(groupAll),
    user,
    member: {
      user,
      nick: user.name
    }
  });
}
async function parseGuildMemberRemoved(bot, input) {
  const user = decodeUser((await bot.ctx.ntUserApi.getUserSimpleInfo(input.user1.uid)).coreInfo);
  return bot.event("guild-member-removed", {
    guild: decodeGuild(input.group),
    user,
    member: {
      user,
      nick: user.name
    }
  });
}
async function parseGuildMemberRequest(bot, input, doubt) {
  const groupCode = input.group.groupCode;
  const flag = `${groupCode}|${input.seq}|${input.type}|${doubt === true ? "1" : "0"}`;
  return bot.event("guild-member-request", {
    guild: decodeGuild(input.group),
    message: {
      id: flag,
      content: input.postscript
    }
  });
}
async function parseFriendRequest(bot, input) {
  const flag = input.friendUid + "|" + input.reqTime;
  const user = await bot.ctx.ntUserApi.getUserSimpleInfo(input.friendUid);
  return bot.event("friend-request", {
    user: decodeUser(user.coreInfo),
    message: {
      id: flag,
      content: input.extWords
    }
  });
}
class SatoriAdapter extends Service2 {
  constructor(ctx, config2) {
    super(ctx, "satori", true);
    this.ctx = ctx;
    this.config = config2;
    this.selfId = selfInfo.uin;
    this.server = new SatoriServer(ctx, config2);
    this._eventSeq = 0;
    this._loginSeq = 1;
  }
  static inject = [
    "ntMsgApi",
    "ntFileApi",
    "ntFileCacheApi",
    "ntFriendApi",
    "ntGroupApi",
    "ntUserApi",
    "ntWebApi",
    "store"
  ];
  selfId;
  server;
  _eventSeq;
  _loginSeq;
  listenedEvent = false;
  async handleMessage(input) {
    if (input.msgType === 5 && input.subMsgType === 8 && input.elements[0]?.grayTipElement?.groupElement?.type === 1 && input.elements[0].grayTipElement.groupElement.memberUid === selfInfo.uid) {
      return await parseGuildAdded(this, input);
    } else if (input.msgType === 5 && input.subMsgType === 12 && input.elements[0]?.grayTipElement?.xmlElement?.templId === "10179" && input.elements[0].grayTipElement.xmlElement.templParam.get("invitee") === selfInfo.uin) {
      return await parseGuildAdded(this, input);
    } else if (input.msgType === 5 && input.subMsgType === 8 && input.elements[0]?.grayTipElement?.groupElement?.type === 3) {
      return await parseGuildRemoved(this, input);
    } else if (input.msgType === 5 && input.subMsgType === 8 && input.elements[0]?.grayTipElement?.groupElement?.type === 1) {
      return await parseGuildMemberAdded(this, input);
    } else if (input.msgType === 5 && input.subMsgType === 12 && input.elements[0]?.grayTipElement?.xmlElement?.templId === "10179") {
      return await parseGuildMemberAdded(this, input);
    } else if (input.msgType === 5 && input.subMsgType === 12 && input.elements[0]?.grayTipElement?.jsonGrayTipElement?.busiId === "19217") {
      return await parseGuildMemberAdded(this, input, true);
    } else if (input.msgType === 5 && input.subMsgType === 12 && input.elements[0]?.grayTipElement?.xmlElement?.templId === "10382") ;
    else {
      return await parseMessageCreated(this, input);
    }
  }
  async handleGroupNotify(input, doubt) {
    if (input.type === GroupNotifyType.InvitedByMember && input.status === GroupNotifyStatus.Unhandle) {
      return await parseGuildRequest(this, input);
    } else if (input.type === GroupNotifyType.MemberLeaveNotifyAdmin || input.type === GroupNotifyType.KickMemberNotifyAdmin) {
      return await parseGuildMemberRemoved(this, input);
    } else if (input.type === GroupNotifyType.RequestJoinNeedAdminiStratorPass && input.status === GroupNotifyStatus.Unhandle) {
      return await parseGuildMemberRequest(this, input, doubt);
    } else if (input.type === GroupNotifyType.InvitedNeedAdminiStratorPass && input.status === GroupNotifyStatus.Unhandle) {
      return await parseGuildMemberRequest(this, input, doubt);
    }
  }
  start() {
    this.ctx.on("llob/config-updated", async (input) => {
      const old = omit$1(this.config, ["ffmpeg"]);
      const inputSatoriConfig = {
        ...input.satori,
        onlyLocalhost: input.onlyLocalhost
      };
      if (!isDeepStrictEqual(old, inputSatoriConfig)) {
        await this.server.stop();
        this.server.updateConfig(inputSatoriConfig);
        if (inputSatoriConfig.enable) {
          this.server.start();
          this.listenEvent();
        }
      }
      Object.assign(this.config, { ...inputSatoriConfig, ffmpeg: input.ffmpeg });
    });
    if (this.config.enable) {
      this.server.start();
    } else {
      return;
    }
    this.listenEvent();
  }
  listenEvent() {
    if (this.listenedEvent) return;
    this.listenedEvent = true;
    this.ctx.on("nt/message-created", async (input) => {
      const event = await this.handleMessage(input).catch((e) => this.ctx.logger.error(e));
      if (event) {
        this.server.dispatch(event);
      }
    });
    this.ctx.on("nt/group-notify", async (input) => {
      const { doubt, notify } = input;
      const event = await this.handleGroupNotify(notify, doubt).catch((e) => this.ctx.logger.error(e));
      if (event) {
        this.server.dispatch(event);
      }
    });
    this.ctx.on("nt/message-deleted", async (input) => {
      const event = await parseMessageDeleted(this, input).catch((e) => this.ctx.logger.error(e));
      if (event) {
        this.server.dispatch(event);
      }
    });
    this.ctx.on("nt/friend-request", async (input) => {
      const event = await parseFriendRequest(this, input).catch((e) => this.ctx.logger.error(e));
      if (event) {
        this.server.dispatch(event);
      }
    });
  }
  event(type2, data) {
    const sn = ++this._eventSeq;
    return {
      // @ts-expect-error: For backward compatibility
      id: sn,
      sn,
      type: type2,
      self_id: this.selfId,
      platform: "llonebot",
      timestamp: Date.now(),
      ...data
    };
  }
}
const NEVER = Object.freeze({
  status: "aborted"
});
function $constructor(name, initializer2, params) {
  function init2(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: /* @__PURE__ */ new Set()
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer2(inst, def);
    const proto = _.prototype;
    const keys = Object.keys(proto);
    for (let i = 0; i < keys.length; i++) {
      const k = keys[i];
      if (!(k in inst)) {
        inst[k] = proto[k].bind(inst);
      }
    }
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    const inst = params?.Parent ? new Definition() : this;
    init2(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init2 });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
const $brand = /* @__PURE__ */ Symbol("zod_brand");
class $ZodAsyncError extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
}
class $ZodEncodeError extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
}
const globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
function assert(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  return {
    get value() {
      {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
    }
  };
}
function nullish$1(input) {
  return input === null || input === void 0;
}
function cleanRegex(source2) {
  const start = source2.startsWith("^") ? 1 : 0;
  const end = source2.endsWith("$") ? source2.length - 1 : source2.length;
  return source2.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
const EVALUATING = /* @__PURE__ */ Symbol("evaluating");
function defineLazy(object2, key2, getter) {
  let value = void 0;
  Object.defineProperty(object2, key2, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object2, key2, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path2) {
  if (!path2)
    return obj;
  return path2.reduce((acc, key2) => acc?.[key2], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises2 = keys.map((key2) => promisesObj[key2]);
  return Promise.all(promises2).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
const captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
const allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key2 in data) {
    if (Object.prototype.hasOwnProperty.call(data, key2)) {
      keyCount++;
    }
  }
  return keyCount;
}
const getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
const propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
const primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
const NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
const BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key2 in mask) {
        if (!(key2 in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key2}"`);
        }
        if (!mask[key2])
          continue;
        newShape[key2] = currDef.shape[key2];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key2 in mask) {
        if (!(key2 in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key2}"`);
        }
        if (!mask[key2])
          continue;
        delete newShape[key2];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    const existingShape = schema._zod.def.shape;
    for (const key2 in shape) {
      if (Object.getOwnPropertyDescriptor(existingShape, key2) !== void 0) {
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
      }
    }
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a, def);
}
function partial(Class2, schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key2 in mask) {
          if (!(key2 in oldShape)) {
            throw new Error(`Unrecognized key: "${key2}"`);
          }
          if (!mask[key2])
            continue;
          shape[key2] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key2]
          }) : oldShape[key2];
        }
      } else {
        for (const key2 in oldShape) {
          shape[key2] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key2]
          }) : oldShape[key2];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key2 in mask) {
          if (!(key2 in shape)) {
            throw new Error(`Unrecognized key: "${key2}"`);
          }
          if (!mask[key2])
            continue;
          shape[key2] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key2]
          });
        }
      } else {
        for (const key2 in oldShape) {
          shape[key2] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key2]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    }
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path2, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path2);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function parsedType(data) {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "nan" : "number";
    }
    case "object": {
      if (data === null) {
        return "null";
      }
      if (Array.isArray(data)) {
        return "array";
      }
      const obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
        return obj.constructor.name;
      }
    }
  }
  return t;
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base642) {
  const binaryString = atob(base642);
  const bytes2 = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes2[i] = binaryString.charCodeAt(i);
  }
  return bytes2;
}
function uint8ArrayToBase64(bytes2) {
  let binaryString = "";
  for (let i = 0; i < bytes2.length; i++) {
    binaryString += String.fromCharCode(bytes2[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url2) {
  const base642 = base64url2.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base642.length % 4) % 4);
  return base64ToUint8Array(base642 + padding);
}
function uint8ArrayToBase64url(bytes2) {
  return uint8ArrayToBase64(bytes2).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex2) {
  const cleanHex = hex2.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes2 = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes2[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes2;
}
function uint8ArrayToHex(bytes2) {
  return Array.from(bytes2).map((b) => b.toString(16).padStart(2, "0")).join("");
}
class Class {
  constructor(..._args) {
  }
}
const util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BIGINT_FORMAT_RANGES,
  Class,
  NUMBER_FORMAT_RANGES,
  aborted,
  allowsEval,
  assert,
  assertEqual,
  assertIs,
  assertNever,
  assertNotEqual,
  assignProp,
  base64ToUint8Array,
  base64urlToUint8Array,
  cached,
  captureStackTrace,
  cleanEnum,
  cleanRegex,
  clone,
  cloneDef,
  createTransparentProxy,
  defineLazy,
  esc,
  escapeRegex,
  extend,
  finalizeIssue,
  floatSafeRemainder,
  getElementAtPath,
  getEnumValues,
  getLengthableOrigin,
  getParsedType,
  getSizableOrigin,
  hexToUint8Array,
  isObject,
  isPlainObject,
  issue,
  joinValues,
  jsonStringifyReplacer,
  merge,
  mergeDefs,
  normalizeParams,
  nullish: nullish$1,
  numKeys,
  objectClone,
  omit,
  optionalKeys,
  parsedType,
  partial,
  pick,
  prefixIssues,
  primitiveTypes,
  promiseAllObject,
  propertyKeyTypes,
  randomString,
  required,
  safeExtend,
  shallowClone,
  slugify,
  stringifyPrimitive,
  uint8ArrayToBase64,
  uint8ArrayToBase64url,
  uint8ArrayToHex,
  unwrapMessage
}, Symbol.toStringTag, { value: "Module" }));
const initializer$1 = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
const $ZodError = $constructor("$ZodError", initializer$1);
const $ZodRealError = $constructor("$ZodError", initializer$1, { Parent: Error });
function flattenError(error2, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error2.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error2, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error3) => {
    for (const issue2 of error3.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error2);
  return fieldErrors;
}
function treeifyError(error2, mapper = (issue2) => issue2.message) {
  const result = { errors: [] };
  const processError = (error3, path2 = []) => {
    var _a2, _b;
    for (const issue2 of error3.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path2, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a2 = curr.properties)[el] ?? (_a2[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error2);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path2 = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path2) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error2) {
  const lines = [];
  const issues = [...error2.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(` ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`   at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}
const _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
const parse$1 = /* @__PURE__ */ _parse($ZodRealError);
const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
const parseAsync$1 = /* @__PURE__ */ _parseAsync($ZodRealError);
const _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
const safeParse$1 = /* @__PURE__ */ _safeParse($ZodRealError);
const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
const safeParseAsync$1 = /* @__PURE__ */ _safeParseAsync($ZodRealError);
const _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
const encode$1 = /* @__PURE__ */ _encode($ZodRealError);
const _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
};
const decode$1 = /* @__PURE__ */ _decode($ZodRealError);
const _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
const encodeAsync$1 = /* @__PURE__ */ _encodeAsync($ZodRealError);
const _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
};
const decodeAsync$1 = /* @__PURE__ */ _decodeAsync($ZodRealError);
const _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
const safeEncode$1 = /* @__PURE__ */ _safeEncode($ZodRealError);
const _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
};
const safeDecode$1 = /* @__PURE__ */ _safeDecode($ZodRealError);
const _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
const safeEncodeAsync$1 = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
const _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
};
const safeDecodeAsync$1 = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);
const cuid$1 = /^[cC][^\s-]{8,}$/;
const cuid2$1 = /^[0-9a-z]+$/;
const ulid$1 = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
const xid$1 = /^[0-9a-vA-V]{20}$/;
const ksuid$1 = /^[A-Za-z0-9]{27}$/;
const nanoid$1 = /^[a-zA-Z0-9_-]{21}$/;
const duration$1 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
const extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const guid$1 = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
const uuid$1 = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
const uuid4 = /* @__PURE__ */ uuid$1(4);
const uuid6 = /* @__PURE__ */ uuid$1(6);
const uuid7 = /* @__PURE__ */ uuid$1(7);
const email$1 = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
const html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
const rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
const unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
const idnEmail = unicodeEmail;
const browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
const _emoji$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji$1() {
  return new RegExp(_emoji$1, "u");
}
const ipv4$1 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6$1 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
const mac$1 = (delimiter) => {
  const escapedDelim = escapeRegex(delimiter ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
};
const cidrv4$1 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
const cidrv6$1 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64$1 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
const base64url$1 = /^[A-Za-z0-9_-]*$/;
const hostname$1 = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
const domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
const e164$1 = /^\+[1-9]\d{6,14}$/;
const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
const date$3 = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time$1(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime$1(args) {
  const time2 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time2}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
const string$2 = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
const bigint$2 = /^-?\d+n?$/;
const integer = /^-?\d+$/;
const number$2 = /^-?\d+(?:\.\d+)?$/;
const boolean$2 = /^(?:true|false)$/i;
const _null$2 = /^null$/i;
const _undefined$2 = /^undefined$/i;
const lowercase = /^[^A-Z]*$/;
const uppercase = /^[^a-z]*$/;
const hex$1 = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
const md5_hex = /^[0-9a-fA-F]{32}$/;
const md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
const md5_base64url = /* @__PURE__ */ fixedBase64url(22);
const sha1_hex = /^[0-9a-fA-F]{40}$/;
const sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
const sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
const sha256_hex = /^[0-9a-fA-F]{64}$/;
const sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
const sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
const sha384_hex = /^[0-9a-fA-F]{96}$/;
const sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
const sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
const sha512_hex = /^[0-9a-fA-F]{128}$/;
const sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
const sha512_base64url = /* @__PURE__ */ fixedBase64url(86);
const regexes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: base64$1,
  base64url: base64url$1,
  bigint: bigint$2,
  boolean: boolean$2,
  browserEmail,
  cidrv4: cidrv4$1,
  cidrv6: cidrv6$1,
  cuid: cuid$1,
  cuid2: cuid2$1,
  date: date$3,
  datetime: datetime$1,
  domain,
  duration: duration$1,
  e164: e164$1,
  email: email$1,
  emoji: emoji$1,
  extendedDuration,
  guid: guid$1,
  hex: hex$1,
  hostname: hostname$1,
  html5Email,
  idnEmail,
  integer,
  ipv4: ipv4$1,
  ipv6: ipv6$1,
  ksuid: ksuid$1,
  lowercase,
  mac: mac$1,
  md5_base64,
  md5_base64url,
  md5_hex,
  nanoid: nanoid$1,
  null: _null$2,
  number: number$2,
  rfc5322Email,
  sha1_base64,
  sha1_base64url,
  sha1_hex,
  sha256_base64,
  sha256_base64url,
  sha256_hex,
  sha384_base64,
  sha384_base64url,
  sha384_hex,
  sha512_base64,
  sha512_base64url,
  sha512_hex,
  string: string$2,
  time: time$1,
  ulid: ulid$1,
  undefined: _undefined$2,
  unicodeEmail,
  uppercase,
  uuid: uuid$1,
  uuid4,
  uuid6,
  uuid7,
  xid: xid$1
}, Symbol.toStringTag, { value: "Module" }));
const $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
});
const numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
const $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
const $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
const $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish$1(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish$1(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish$1(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish$1(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish$1(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish$1(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
const $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern2 = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern2;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern2);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern2 = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern2);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern2);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern2 = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern2);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern2);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
const $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
const $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});
class Doc {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line2 of dedented) {
      this.content.push(line2);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
}
const version$1 = {
  major: 4,
  minor: 3,
  patch: 4
};
const $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a2;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version$1;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  defineLazy(inst, "~standard", () => ({
    validate: (value) => {
      try {
        const r = safeParse$1(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync$1(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
});
const $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string$2(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
const $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
const $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid$1);
  $ZodStringFormat.init(inst, def);
});
const $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid$1(v));
  } else
    def.pattern ?? (def.pattern = uuid$1());
  $ZodStringFormat.init(inst, def);
});
const $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email$1);
  $ZodStringFormat.init(inst, def);
});
const $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url2 = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url2.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: def.hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url2.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
const $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji$1());
  $ZodStringFormat.init(inst, def);
});
const $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid$1);
  $ZodStringFormat.init(inst, def);
});
const $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid$1);
  $ZodStringFormat.init(inst, def);
});
const $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2$1);
  $ZodStringFormat.init(inst, def);
});
const $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid$1);
  $ZodStringFormat.init(inst, def);
});
const $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid$1);
  $ZodStringFormat.init(inst, def);
});
const $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid$1);
  $ZodStringFormat.init(inst, def);
});
const $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime$1(def));
  $ZodStringFormat.init(inst, def);
});
const $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date$3);
  $ZodStringFormat.init(inst, def);
});
const $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time$1(def));
  $ZodStringFormat.init(inst, def);
});
const $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration$1);
  $ZodStringFormat.init(inst, def);
});
const $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4$1);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv4`;
});
const $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6$1);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv6`;
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
const $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
  def.pattern ?? (def.pattern = mac$1(def.delimiter));
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `mac`;
});
const $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4$1);
  $ZodStringFormat.init(inst, def);
});
const $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6$1);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error();
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
const $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64$1);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64";
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url$1.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c2) => c2 === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
const $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url$1);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64url";
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164$1);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token2, algorithm = null) {
  try {
    const tokensParts = token2.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
const $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
const $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number$2;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
const $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
const $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean$2;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
const $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint$2;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
const $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
const $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
const $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined$2;
  inst._zod.values = /* @__PURE__ */ new Set([void 0]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
const $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null$2;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
const $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
const $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
const $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
const $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
const $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index2) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index2, result.issues));
  }
  final.value[index2] = result.value;
}
const $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key2, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key2 in input)) {
      return;
    }
    final.issues.push(...prefixIssues(key2, result.issues));
  }
  if (result.value === void 0) {
    if (key2 in input) {
      final.value[key2] = void 0;
    }
  } else {
    final.value[key2] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  const isOptionalOut = _catchall.optout === "optional";
  for (const key2 in input) {
    if (keySet.has(key2))
      continue;
    if (t === "never") {
      unrecognized.push(key2);
      continue;
    }
    const r = _catchall.run({ value: input[key2], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key2, input, isOptionalOut)));
    } else {
      handlePropertyResult(r, payload, key2, input, isOptionalOut);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
const $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!desc?.get) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }
    });
  }
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key2 in shape) {
      const field = shape[key2]._zod;
      if (field.values) {
        propValues[key2] ?? (propValues[key2] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key2].add(v);
      }
    }
    return propValues;
  });
  const isObject$12 = isObject;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject$12(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key2 of value.keys) {
      const el = shape[key2];
      const isOptionalOut = el._zod.optout === "optional";
      const r = el._zod.run({ value: input[key2], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key2, input, isOptionalOut)));
      } else {
        handlePropertyResult(r, payload, key2, input, isOptionalOut);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
const $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key2) => {
      const k = esc(key2);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter2 = 0;
    for (const key2 of normalized.keys) {
      ids[key2] = `key_${counter2++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key2 of normalized.keys) {
      const id2 = ids[key2];
      const k = esc(key2);
      const schema = shape[key2];
      const isOptionalOut = schema?._zod?.optout === "optional";
      doc.write(`const ${id2} = ${parseStr(key2)};`);
      if (isOptionalOut) {
        doc.write(`
        if (${id2}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id2}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id2}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id2}.value;
        }
        
      `);
      } else {
        doc.write(`
        if (${id2}.issues.length) {
          payload.issues = payload.issues.concat(${id2}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id2}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id2}.value;
        }
        
      `);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject$12 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval$1 = allowsEval;
  const fastEnabled = jit && allowsEval$1.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject$12(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
const $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async2 = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async2 = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async2)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
function handleExclusiveUnionResults(results, final, inst, ctx) {
  const successes = results.filter((r) => r.issues.length === 0);
  if (successes.length === 1) {
    final.value = successes[0].value;
    return final;
  }
  if (successes.length === 0) {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    });
  } else {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: [],
      inclusive: false
    });
  }
  return final;
}
const $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
  $ZodUnion.init(inst, def);
  def.inclusive = false;
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async2 = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async2 = true;
      } else {
        results.push(result);
      }
    }
    if (!async2)
      return handleExclusiveUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleExclusiveUnionResults(results2, payload, inst, ctx);
    });
  };
});
const $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  def.inclusive = false;
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map2 = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map2.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map2.set(v, o);
      }
    }
    return map2;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
const $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async2 = left instanceof Promise || right instanceof Promise;
    if (async2) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key2) => bKeys.indexOf(key2) !== -1);
    const newObj = { ...a, ...b };
    for (const key2 of sharedKeys) {
      const sharedValue = mergeValues(a[key2], b[key2]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key2, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key2] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a.length; index2++) {
      const itemA = a[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index2, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  const unrecKeys = /* @__PURE__ */ new Map();
  let unrecIssue;
  for (const iss of left.issues) {
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).l = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  for (const iss of right.issues) {
    if (iss.code === "unrecognized_keys") {
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).r = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue) {
    result.issues.push({ ...unrecIssue, keys: bothKeys });
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
const $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
    const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index2) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index2, result.issues));
  }
  final.value[index2] = result.value;
}
const $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    const values = def.keyType._zod.values;
    if (values) {
      payload.value = {};
      const recordKeys = /* @__PURE__ */ new Set();
      for (const key2 of values) {
        if (typeof key2 === "string" || typeof key2 === "number" || typeof key2 === "symbol") {
          recordKeys.add(typeof key2 === "number" ? key2.toString() : key2);
          const result = def.valueType._zod.run({ value: input[key2], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key2, result2.issues));
              }
              payload.value[key2] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key2, result.issues));
            }
            payload.value[key2] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key2 in input) {
        if (!recordKeys.has(key2)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key2);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key2 of Reflect.ownKeys(input)) {
        if (key2 === "__proto__")
          continue;
        let keyResult = def.keyType._zod.run({ value: key2, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        const checkNumericKey = typeof key2 === "string" && number$2.test(key2) && keyResult.issues.length && keyResult.issues.some((iss) => iss.code === "invalid_type" && iss.expected === "number");
        if (checkNumericKey) {
          const retryResult = def.keyType._zod.run({ value: Number(key2), issues: [] }, ctx);
          if (retryResult instanceof Promise) {
            throw new Error("Async schemas not supported in object keys currently");
          }
          if (retryResult.issues.length === 0) {
            keyResult = retryResult;
          }
        }
        if (keyResult.issues.length) {
          if (def.mode === "loose") {
            payload.value[key2] = input[key2];
          } else {
            payload.issues.push({
              code: "invalid_key",
              origin: "record",
              issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
              input: key2,
              path: [key2],
              inst
            });
          }
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key2], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key2, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key2, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
const $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key2, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key2, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key2, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key2, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key2, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key2)) {
      final.issues.push(...prefixIssues(key2, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key2)) {
      final.issues.push(...prefixIssues(key2, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key: key2,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
const $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
const $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
const $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  const values = new Set(def.values);
  inst._zod.values = values;
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
const $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
const $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output2 = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output2.then((output3) => {
        payload.value = output3;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
const $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern2 = def.innerType._zod.pattern;
    return pattern2 ? new RegExp(`^(${cleanRegex(pattern2.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
  inst._zod.parse = (payload, ctx) => {
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern2 = def.innerType._zod.pattern;
    return pattern2 ? new RegExp(`^(${cleanRegex(pattern2.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
const $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
const $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
const $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
const $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
const $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
const $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult(left2, def, ctx));
      }
      return handleCodecAResult(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult(right2, def, ctx));
      }
      return handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
const $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
  defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
const $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source2 = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source2)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source2.startsWith("^") ? 1 : 0;
      const end = source2.endsWith("$") ? source2.length - 1 : source2.length;
      regexParts.push(source2.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "string",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
const $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
  $ZodType.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args) {
      const parsedArgs = inst._def.input ? parse$1(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse$1(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args) {
      const parsedArgs = inst._def.input ? await parseAsync$1(inst._def.input, args) : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync$1(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  };
  inst.output = (output2) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output: output2
    });
  };
  return inst;
});
const $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
const $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
const $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
const error$K = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: " ",
    url: "",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ISO",
    date: "  ISO",
    time: "  ISO",
    duration: "  ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: "   IPv4",
    cidrv6: "   IPv6",
    base64: "  base64-encoded",
    base64url: "  base64url-encoded",
    json_string: "   JSON",
    e164: "   E.164",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `  :   instanceof ${issue2.expected}    ${received}`;
        }
        return `  :   ${expected}    ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  :   ${stringifyPrimitive(issue2.values[0])}`;
        return `  :     : ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `   :    ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `  :    ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `  :   ${issue2.origin}   ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `  :   ${issue2.origin}   ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `  :     "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `  :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `  :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `  :     ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format}  `;
      }
      case "not_multiple_of":
        return `  :      ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, " ")}`;
      case "invalid_key":
        return `    ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `    ${issue2.origin}`;
      default:
        return "  ";
    }
  };
};
function ar() {
  return {
    localeError: error$K()
  };
}
const error$J = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmaldr" },
    file: { unit: "bayt", verb: "olmaldr" },
    array: { unit: "element", verb: "olmaldr" },
    set: { unit: "element", verb: "olmaldr" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Yanl dyr: gzlniln instanceof ${issue2.expected}, daxil olan ${received}`;
        }
        return `Yanl dyr: gzlniln ${expected}, daxil olan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl dyr: gzlniln ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl seim: aadaklardan biri olmaldr: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ox byk: gzlniln ${issue2.origin ?? "dyr"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `ox byk: gzlniln ${issue2.origin ?? "dyr"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ox kiik: gzlniln ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `ox kiik: gzlniln ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl mtn: "${_issue.prefix}" il balamaldr`;
        if (_issue.format === "ends_with")
          return `Yanl mtn: "${_issue.suffix}" il bitmlidir`;
        if (_issue.format === "includes")
          return `Yanl mtn: "${_issue.includes}" daxil olmaldr`;
        if (_issue.format === "regex")
          return `Yanl mtn: ${_issue.pattern} ablonuna uyun olmaldr`;
        return `Yanl ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl dd: ${issue2.divisor} il bln biln olmaldr`;
      case "unrecognized_keys":
        return `Tannmayan aar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind yanl aar`;
      case "invalid_union":
        return "Yanl dyr";
      case "invalid_element":
        return `${issue2.origin} daxilind yanl dyr`;
      default:
        return `Yanl dyr`;
    }
  };
};
function az() {
  return {
    localeError: error$J()
  };
}
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
const error$I = () => {
  const Sizable = {
    string: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "email ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "   base64",
    base64url: "   base64url",
    json_string: "JSON ",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` :  instanceof ${issue2.expected},  ${received}`;
        }
        return ` :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return ` : ,  ${issue2.origin ?? ""}  ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return ` : ,  ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return ` : ,  ${issue2.origin}  ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return ` : ,  ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function be() {
  return {
    localeError: error$I()
  };
}
const error$H = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64- ",
    base64url: "base64url- ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` :  instanceof ${issue2.expected},  ${received}`;
        }
        return ` :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :     "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return ` :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :     ${_issue.pattern}`;
        let invalid_adj = "";
        if (_issue.format === "emoji")
          invalid_adj = "";
        if (_issue.format === "datetime")
          invalid_adj = "";
        if (_issue.format === "date")
          invalid_adj = "";
        if (_issue.format === "time")
          invalid_adj = "";
        if (_issue.format === "duration")
          invalid_adj = "";
        return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :      ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function bg() {
  return {
    localeError: error$H()
  };
}
const error$G = () => {
  const Sizable = {
    string: { unit: "carcters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "adrea electrnica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adrea IPv4",
    ipv6: "adrea IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipus invlid: s'esperava instanceof ${issue2.expected}, s'ha rebut ${received}`;
        }
        return `Tipus invlid: s'esperava ${expected}, s'ha rebut ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor invlid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci invlida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a mxim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingus ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a mnim" : "ms de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingus ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format invlid: ha de comenar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format invlid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format invlid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format invlid: ha de coincidir amb el patr ${_issue.pattern}`;
        return `Format invlid per a ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlid: ha de ser mltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau invlida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
      case "invalid_element":
        return `Element invlid a ${issue2.origin}`;
      default:
        return `Entrada invlida`;
    }
  };
};
function ca() {
  return {
    localeError: error$G()
  };
}
const error$F = () => {
  const Sizable = {
    string: { unit: "znak", verb: "mt" },
    file: { unit: "bajt", verb: "mt" },
    array: { unit: "prvk", verb: "mt" },
    set: { unit: "prvk", verb: "mt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "regulrn vraz",
    email: "e-mailov adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a as ve formtu ISO",
    date: "datum ve formtu ISO",
    time: "as ve formtu ISO",
    duration: "doba trvn ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "etzec zakdovan ve formtu base64",
    base64url: "etzec zakdovan ve formtu base64url",
    json_string: "etzec ve formtu JSON",
    e164: "slo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "slo",
    string: "etzec",
    function: "funkce",
    array: "pole"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neplatn vstup: oekvno instanceof ${issue2.expected}, obdreno ${received}`;
        }
        return `Neplatn vstup: oekvno ${expected}, obdreno ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn vstup: oekvno ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn monost: oekvna jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je pli velk: ${issue2.origin ?? "hodnota"} mus mt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk"}`;
        }
        return `Hodnota je pli velk: ${issue2.origin ?? "hodnota"} mus bt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je pli mal: ${issue2.origin ?? "hodnota"} mus mt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk"}`;
        }
        return `Hodnota je pli mal: ${issue2.origin ?? "hodnota"} mus bt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn etzec: mus zanat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn etzec: mus konit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn etzec: mus obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn etzec: mus odpovdat vzoru ${_issue.pattern}`;
        return `Neplatn formt ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn slo: mus bt nsobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neznm kle: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn kl v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn vstup";
      case "invalid_element":
        return `Neplatn hodnota v ${issue2.origin}`;
      default:
        return `Neplatn vstup`;
    }
  };
};
function cs() {
  return {
    localeError: error$F()
  };
}
const error$E = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslt",
    date: "ISO-dato",
    time: "ISO-klokkeslt",
    duration: "ISO-varighed",
    ipv4: "IPv4-omrde",
    ipv6: "IPv6-omrde",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "st",
    file: "fil"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldigt input: forventede instanceof ${issue2.expected}, fik ${received}`;
        }
        return `Ugyldigt input: forventede ${expected}, fik ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig vrdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldigt valg: forventede en af flgende ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche mnsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal vre deleligt med ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukendte ngler" : "Ukendt ngle"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig ngle i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig vrdi i ${issue2.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
function da() {
  return {
    localeError: error$E()
  };
}
const error$D = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "Zahl",
    array: "Array"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ungltige Eingabe: erwartet instanceof ${issue2.expected}, erhalten ${received}`;
        }
        return `Ungltige Eingabe: erwartet ${expected}, erhalten ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ungltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ungltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ungltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ungltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ungltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ungltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ungltig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ungltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schlssel" : "Unbekannter Schlssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ungltiger Schlssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ungltige Eingabe";
      case "invalid_element":
        return `Ungltiger Wert in ${issue2.origin}`;
      default:
        return `Ungltige Eingabe`;
    }
  };
};
function de() {
  return {
    localeError: error$D()
  };
}
const error$C = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" },
    map: { unit: "entries", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    // Compatibility: "nan" -> "NaN" for display
    nan: "NaN"
    // All other type names omitted - they fall back to raw values via ?? operator
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        return `Invalid input: expected ${expected}, received ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en() {
  return {
    localeError: error$C()
  };
}
const error$B = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emoio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-daro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombro",
    array: "tabelo",
    null: "senvalora"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nevalida enigo: atendiis instanceof ${issue2.expected}, riceviis ${received}`;
        }
        return `Nevalida enigo: atendiis ${expected}, riceviis ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendiis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendiis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendiis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendiis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendiis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendiis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komencii per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas finii per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} losilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida losilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo() {
  return {
    localeError: error$B()
  };
}
const error$A = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "direccin de correo electrnico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duracin ISO",
    ipv4: "direccin IPv4",
    ipv6: "direccin IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "texto",
    number: "nmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "nmero grande",
    symbol: "smbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funcin",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeracin",
    union: "unin",
    literal: "literal",
    promise: "promesa",
    void: "vaco",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entrada invlida: se esperaba instanceof ${issue2.expected}, recibido ${received}`;
        }
        return `Entrada invlida: se esperaba ${expected}, recibido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada invlida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opcin invlida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `Demasiado pequeo: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado pequeo: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena invlida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena invlida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena invlida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena invlida: debe coincidir con el patrn ${_issue.pattern}`;
        return `Invlido ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlido: debe ser mltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave invlida en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      default:
        return `Entrada invlida`;
    }
  };
};
function es() {
  return {
    localeError: error$A()
  };
}
const error$z = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ",
    date: " ",
    time: " ",
    duration: "  ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` :  instanceof ${issue2.expected}  ${received}  `;
        }
        return ` :  ${expected}  ${received}  `;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return ` :  ${stringifyPrimitive(issue2.values[0])} `;
        }
        return ` :    ${joinValues(issue2.values, "|")} `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""} `;
        }
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit} `;
        }
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :   "${_issue.prefix}"  `;
        }
        if (_issue.format === "ends_with") {
          return ` :   "${_issue.suffix}"  `;
        }
        if (_issue.format === "includes") {
          return ` :   "${_issue.includes}" `;
        }
        if (_issue.format === "regex") {
          return ` :    ${_issue.pattern}   `;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format} `;
      }
      case "not_multiple_of":
        return ` :   ${issue2.divisor} `;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function fa() {
  return {
    localeError: error$z()
  };
}
const error$y = () => {
  const Sizable = {
    string: { unit: "merkki", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "pivmrn" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "snnllinen lauseke",
    email: "shkpostiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-pivmr",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Virheellinen tyyppi: odotettiin instanceof ${issue2.expected}, oli ${received}`;
        }
        return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen syte: tytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: tytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} tytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon tytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} tytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon tytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen syte: tytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen syte: tytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen syte: tytyy sislt "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen syte: tytyy vastata snnllist lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: tytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen syte`;
    }
  };
};
function fi() {
  return {
    localeError: error$y()
  };
}
const error$x = () => {
  const Sizable = {
    string: { unit: "caractres", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "lments", verb: "avoir" },
    set: { unit: "lments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entre",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dure ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chane encode en base64",
    base64url: "chane encode en base64url",
    json_string: "chane JSON",
    e164: "numro E.164",
    jwt: "JWT",
    template_literal: "entre"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombre",
    array: "tableau"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entre invalide : instanceof ${issue2.expected} attendu, ${received} reu`;
        }
        return `Entre invalide : ${expected} attendu, ${received} reu`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entre invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "lment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit tre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit tre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chane invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chane invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chane invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chane invalide : doit correspondre au modle ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entre invalide`;
    }
  };
};
function fr() {
  return {
    localeError: error$x()
  };
}
const error$w = () => {
  const Sizable = {
    string: { unit: "caractres", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "lments", verb: "avoir" },
    set: { unit: "lments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entre",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dure ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chane encode en base64",
    base64url: "chane encode en base64url",
    json_string: "chane JSON",
    e164: "numro E.164",
    jwt: "JWT",
    template_literal: "entre"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entre invalide : attendu instanceof ${issue2.expected}, reu ${received}`;
        }
        return `Entre invalide : attendu ${expected}, reu ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entre invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Chane invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Chane invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chane invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chane invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entre invalide`;
    }
  };
};
function frCA() {
  return {
    localeError: error$w()
  };
}
const error$v = () => {
  const TypeNames = {
    string: { label: "", gender: "f" },
    number: { label: "", gender: "m" },
    boolean: { label: " ", gender: "m" },
    bigint: { label: "BigInt", gender: "m" },
    date: { label: "", gender: "m" },
    array: { label: "", gender: "m" },
    object: { label: "", gender: "m" },
    null: { label: "  (null)", gender: "m" },
    undefined: { label: "   (undefined)", gender: "m" },
    symbol: { label: " (Symbol)", gender: "m" },
    function: { label: "", gender: "f" },
    map: { label: " (Map)", gender: "f" },
    set: { label: " (Set)", gender: "f" },
    file: { label: "", gender: "m" },
    promise: { label: "Promise", gender: "m" },
    NaN: { label: "NaN", gender: "m" },
    unknown: { label: "  ", gender: "m" },
    value: { label: "", gender: "m" }
  };
  const Sizable = {
    string: { unit: "", shortLabel: "", longLabel: "" },
    file: { unit: "", shortLabel: "", longLabel: "" },
    array: { unit: "", shortLabel: "", longLabel: "" },
    set: { unit: "", shortLabel: "", longLabel: "" },
    number: { unit: "", shortLabel: "", longLabel: "" }
    // no unit
  };
  const typeEntry = (t) => t ? TypeNames[t] : void 0;
  const typeLabel = (t) => {
    const e = typeEntry(t);
    if (e)
      return e.label;
    return t ?? TypeNames.unknown.label;
  };
  const withDefinite = (t) => `${typeLabel(t)}`;
  const verbFor = (t) => {
    const e = typeEntry(t);
    const gender = e?.gender ?? "m";
    return gender === "f" ? " " : " ";
  };
  const getSizing = (origin) => {
    if (!origin)
      return null;
    return Sizable[origin] ?? null;
  };
  const FormatDictionary = {
    regex: { label: "", gender: "m" },
    email: { label: " ", gender: "f" },
    url: { label: " ", gender: "f" },
    emoji: { label: "'", gender: "m" },
    uuid: { label: "UUID", gender: "m" },
    nanoid: { label: "nanoid", gender: "m" },
    guid: { label: "GUID", gender: "m" },
    cuid: { label: "cuid", gender: "m" },
    cuid2: { label: "cuid2", gender: "m" },
    ulid: { label: "ULID", gender: "m" },
    xid: { label: "XID", gender: "m" },
    ksuid: { label: "KSUID", gender: "m" },
    datetime: { label: "  ISO", gender: "m" },
    date: { label: " ISO", gender: "m" },
    time: { label: " ISO", gender: "m" },
    duration: { label: "  ISO", gender: "m" },
    ipv4: { label: " IPv4", gender: "f" },
    ipv6: { label: " IPv6", gender: "f" },
    cidrv4: { label: " IPv4", gender: "m" },
    cidrv6: { label: " IPv6", gender: "m" },
    base64: { label: "  64", gender: "f" },
    base64url: { label: "  64  ", gender: "f" },
    json_string: { label: " JSON", gender: "f" },
    e164: { label: " E.164", gender: "m" },
    jwt: { label: "JWT", gender: "m" },
    ends_with: { label: "", gender: "m" },
    includes: { label: "", gender: "m" },
    lowercase: { label: "", gender: "m" },
    starts_with: { label: "", gender: "m" },
    uppercase: { label: "", gender: "m" }
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expectedKey = issue2.expected;
        const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `  :   instanceof ${issue2.expected},  ${received}`;
        }
        return `  :   ${expected},  ${received}`;
      }
      case "invalid_value": {
        if (issue2.values.length === 1) {
          return `  :    ${stringifyPrimitive(issue2.values[0])}`;
        }
        const stringified = issue2.values.map((v) => stringifyPrimitive(v));
        if (issue2.values.length === 2) {
          return `  :    ${stringified[0]}  ${stringified[1]}`;
        }
        const lastValue = stringified[stringified.length - 1];
        const restValues = stringified.slice(0, -1).join(", ");
        return `  :    ${restValues}  ${lastValue}`;
      }
      case "too_big": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.longLabel ?? ""} : ${subject}   ${issue2.maximum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? " " : " "}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `   -${issue2.maximum}` : ` -${issue2.maximum}`;
          return ` : ${subject}   ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "" : "";
          const comparison = issue2.inclusive ? `${issue2.maximum} ${sizing?.unit ?? ""}  ` : ` -${issue2.maximum} ${sizing?.unit ?? ""}`;
          return ` : ${subject} ${verb}  ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? "<=" : "<";
        const be2 = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.longLabel} : ${subject} ${be2} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.longLabel ?? ""} : ${subject} ${be2} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.shortLabel ?? ""} : ${subject}   ${issue2.minimum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? " " : ""}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `   -${issue2.minimum}` : ` -${issue2.minimum}`;
          return ` : ${subject}   ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "" : "";
          if (issue2.minimum === 1 && issue2.inclusive) {
            const singularPhrase = issue2.origin === "set" ? "  " : "  ";
            return ` : ${subject} ${verb}  ${singularPhrase}`;
          }
          const comparison = issue2.inclusive ? `${issue2.minimum} ${sizing?.unit ?? ""}  ` : ` -${issue2.minimum} ${sizing?.unit ?? ""}`;
          return ` : ${subject} ${verb}  ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? ">=" : ">";
        const be2 = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.shortLabel} : ${subject} ${be2} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.shortLabel ?? ""} : ${subject} ${be2} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `    ${_issue.pattern}`;
        const nounEntry = FormatDictionary[_issue.format];
        const noun = nounEntry?.label ?? _issue.format;
        const gender = nounEntry?.gender ?? "m";
        const adjective = gender === "f" ? "" : "";
        return `${noun}  ${adjective}`;
      }
      case "not_multiple_of":
        return `  :     ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}  ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key": {
        return `   `;
      }
      case "invalid_union":
        return "  ";
      case "invalid_element": {
        const place = withDefinite(issue2.origin ?? "array");
        return `   ${place}`;
      }
      default:
        return `  `;
    }
  };
};
function he() {
  return {
    localeError: error$v()
  };
}
const error$u = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "bemenet",
    email: "email cm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO idblyeg",
    date: "ISO dtum",
    time: "ISO id",
    duration: "ISO idintervallum",
    ipv4: "IPv4 cm",
    ipv6: "IPv6 cm",
    cidrv4: "IPv4 tartomny",
    cidrv6: "IPv6 tartomny",
    base64: "base64-kdolt string",
    base64url: "base64url-kdolt string",
    json_string: "JSON string",
    e164: "E.164 szm",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "szm",
    array: "tmb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `rvnytelen bemenet: a vrt rtk instanceof ${issue2.expected}, a kapott rtk ${received}`;
        }
        return `rvnytelen bemenet: a vrt rtk ${expected}, a kapott rtk ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `rvnytelen bemenet: a vrt rtk ${stringifyPrimitive(issue2.values[0])}`;
        return `rvnytelen opci: valamelyik rtk vrt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tl nagy: ${issue2.origin ?? "rtk"} mrete tl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `Tl nagy: a bemeneti rtk ${issue2.origin ?? "rtk"} tl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tl kicsi: a bemeneti rtk ${issue2.origin} mrete tl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tl kicsi: a bemeneti rtk ${issue2.origin} tl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `rvnytelen string: "${_issue.prefix}" rtkkel kell kezddnie`;
        if (_issue.format === "ends_with")
          return `rvnytelen string: "${_issue.suffix}" rtkkel kell vgzdnie`;
        if (_issue.format === "includes")
          return `rvnytelen string: "${_issue.includes}" rtket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `rvnytelen string: ${_issue.pattern} mintnak kell megfelelnie`;
        return `rvnytelen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `rvnytelen szm: ${issue2.divisor} tbbszrsnek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `rvnytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "rvnytelen bemenet";
      case "invalid_element":
        return `rvnytelen rtk: ${issue2.origin}`;
      default:
        return `rvnytelen bemenet`;
    }
  };
};
function hu() {
  return {
    localeError: error$u()
  };
}
function getArmenianPlural(count, one, many) {
  return Math.abs(count) === 1 ? one : many;
}
function withDefiniteArticle(word) {
  if (!word)
    return "";
  const vowels = ["", "", "", "", "", "", ""];
  const lastChar = word[word.length - 1];
  return word + (vowels.includes(lastChar) ? "" : "");
}
const error$t = () => {
  const Sizable = {
    string: {
      unit: {
        one: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        many: ""
      },
      verb: ""
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: ". ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64  ",
    base64url: "base64url  ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `    instanceof ${issue2.expected},   ${received}`;
        }
        return `    ${expected},   ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `    ${stringifyPrimitive(issue2.values[1])}`;
        return `      ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
          return `    ,  ${withDefiniteArticle(issue2.origin ?? "")}  ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `    ,  ${withDefiniteArticle(issue2.origin ?? "")}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
          return `    ,  ${withDefiniteArticle(issue2.origin)}  ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `    ,  ${withDefiniteArticle(issue2.origin)}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `     "${_issue.prefix}"-`;
        if (_issue.format === "ends_with")
          return `     "${_issue.suffix}"-`;
        if (_issue.format === "includes")
          return `     "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `     ${_issue.pattern} `;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `      ${issue2.divisor}-`;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}. ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `  ${withDefiniteArticle(issue2.origin)}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${withDefiniteArticle(issue2.origin)}-`;
      default:
        return ` `;
    }
  };
};
function hy() {
  return {
    localeError: error$t()
  };
}
const error$s = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak valid: diharapkan instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id() {
  return {
    localeError: error$s()
  };
}
const error$r = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "a hafa" },
    file: { unit: "bti", verb: "a hafa" },
    array: { unit: "hluti", verb: "a hafa" },
    set: { unit: "hluti", verb: "a hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og tmi",
    date: "ISO dagsetning",
    time: "ISO tmi",
    duration: "ISO tmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 tlugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nmer",
    array: "fylki"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Rangt gildi:  slst inn ${received} ar sem  a vera instanceof ${issue2.expected}`;
        }
        return `Rangt gildi:  slst inn ${received} ar sem  a vera ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Rangt gildi: gert r fyrir ${stringifyPrimitive(issue2.values[0])}`;
        return `gilt val: m vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Of strt: gert er r fyrir a ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of strt: gert er r fyrir a ${issue2.origin ?? "gildi"} s ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Of lti: gert er r fyrir a ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Of lti: gert er r fyrir a ${issue2.origin} s ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `gildur strengur: verur a byrja  "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `gildur strengur: verur a enda  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `gildur strengur: verur a innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `gildur strengur: verur a fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Rng tala: verur a vera margfeldi af ${issue2.divisor}`;
      case "unrecognized_keys":
        return `ekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill  ${issue2.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi  ${issue2.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
function is() {
  return {
    localeError: error$r()
  };
}
const error$q = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numero",
    array: "vettore"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input non valido: atteso instanceof ${issue2.expected}, ricevuto ${received}`;
        }
        return `Input non valido: atteso ${expected}, ricevuto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it() {
  return {
    localeError: error$q()
  };
}
const error$p = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO",
    date: "ISO",
    time: "ISO",
    duration: "ISO",
    ipv4: "IPv4",
    ipv6: "IPv6",
    cidrv4: "IPv4",
    cidrv6: "IPv6",
    base64: "base64",
    base64url: "base64url",
    json_string: "JSON",
    e164: "E.164",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `: instanceof ${issue2.expected}${received}`;
        }
        return `: ${expected}${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `: ${stringifyPrimitive(issue2.values[0])}`;
        return `: ${joinValues(issue2.values, "")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin ?? ""}${issue2.maximum.toString()}${sizing.unit ?? ""}${adj}`;
        return `: ${issue2.origin ?? ""}${issue2.maximum.toString()}${adj}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin}${issue2.minimum.toString()}${sizing.unit}${adj}`;
        return `: ${issue2.origin}${issue2.minimum.toString()}${adj}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `: "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `: "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `: "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `: ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `: ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, "")}`;
      case "invalid_key":
        return `${issue2.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin}`;
      default:
        return ``;
    }
  };
};
function ja() {
  return {
    localeError: error$p()
  };
}
const error$o = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "- ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "-",
    date: "",
    time: "",
    duration: "",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64- ",
    base64url: "base64url- ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    string: "",
    boolean: "",
    function: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` :  instanceof ${issue2.expected},  ${received}`;
        }
        return ` :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :  - ${joinValues(issue2.values, "|")}-`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :  ${issue2.origin ?? ""} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return ` :  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :  ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` :  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :   "${_issue.prefix}"-`;
        }
        if (_issue.format === "ends_with")
          return ` :   "${_issue.suffix}"-`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"-`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :   ${issue2.divisor}- `;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `  ${issue2.origin}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${issue2.origin}-`;
      default:
        return ` `;
    }
  };
};
function ka() {
  return {
    localeError: error$o()
  };
}
const error$n = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: " base64",
    base64url: " base64url",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: " (Array)",
    null: " (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `  instanceof ${issue2.expected}  ${received}`;
        }
        return `  ${expected}  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  ${stringifyPrimitive(issue2.values[0])}`;
        return `  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `  ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `  ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `  ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `  ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `  "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `  "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `  ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `  ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` ${issue2.origin}`;
      case "invalid_union":
        return ``;
      case "invalid_element":
        return ` ${issue2.origin}`;
      default:
        return ``;
    }
  };
};
function km() {
  return {
    localeError: error$n()
  };
}
function kh() {
  return km();
}
const error$m = () => {
  const Sizable = {
    string: { unit: "", verb: "to have" },
    file: { unit: "", verb: "to have" },
    array: { unit: "", verb: "to have" },
    set: { unit: "", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64  ",
    base64url: "base64url  ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` :   instanceof ${issue2.expected},   ${received}`;
        }
        return ` :   ${expected},   ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}  `;
        return ` : ${joinValues(issue2.values, " ")}   `;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "";
        const suffix = adj === "" ? " " : " ";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "";
        if (sizing)
          return `${issue2.origin ?? ""}  : ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? ""}  : ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : "";
        const suffix = adj === "" ? " " : " ";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "";
        if (sizing) {
          return `${issue2.origin ?? ""}  : ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? ""}  : ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` : "${_issue.prefix}"()  `;
        }
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"()  `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"()  `;
        if (_issue.format === "regex")
          return ` :  ${_issue.pattern}   `;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}  `;
      case "unrecognized_keys":
        return `   : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` : ${issue2.origin}`;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return ` : ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function ko() {
  return {
    localeError: error$m()
  };
}
const capitalizeFirstCharacter = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
function getUnitTypeFromNumber(number2) {
  const abs2 = Math.abs(number2);
  const last = abs2 % 10;
  const last2 = abs2 % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
const error$l = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli"
      },
      verb: {
        smaller: {
          inclusive: "turi bti ne ilgesn kaip",
          notInclusive: "turi bti trumpesn kaip"
        },
        bigger: {
          inclusive: "turi bti ne trumpesn kaip",
          notInclusive: "turi bti ilgesn kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait"
      },
      verb: {
        smaller: {
          inclusive: "turi bti ne didesnis kaip",
          notInclusive: "turi bti maesnis kaip"
        },
        bigger: {
          inclusive: "turi bti ne maesnis kaip",
          notInclusive: "turi bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element",
        few: "elementus",
        many: "element"
      },
      verb: {
        smaller: {
          inclusive: "turi turti ne daugiau kaip",
          notInclusive: "turi turti maiau kaip"
        },
        bigger: {
          inclusive: "turi turti ne maiau kaip",
          notInclusive: "turi turti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element",
        few: "elementus",
        many: "element"
      },
      verb: {
        smaller: {
          inclusive: "turi turti ne daugiau kaip",
          notInclusive: "turi turti maiau kaip"
        },
        bigger: {
          inclusive: "turi turti ne maiau kaip",
          notInclusive: "turi turti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const FormatDictionary = {
    regex: "vestis",
    email: "el. pato adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 ukoduota eilut",
    base64url: "base64url ukoduota eilut",
    json_string: "JSON eilut",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "vestis"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "skaiius",
    bigint: "sveikasis skaiius",
    string: "eilut",
    boolean: "login reikm",
    undefined: "neapibrta reikm",
    function: "funkcija",
    symbol: "simbolis",
    array: "masyvas",
    object: "objektas",
    null: "nulin reikm"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Gautas tipas ${received}, o tiktasi - instanceof ${issue2.expected}`;
        }
        return `Gautas tipas ${received}, o tiktasi - ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Privalo bti ${stringifyPrimitive(issue2.values[0])}`;
        return `Privalo bti vienas i ${joinValues(issue2.values, "|")} pasirinkim`;
      case "too_big": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        const adj = issue2.inclusive ? "ne didesnis kaip" : "maesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} turi bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element"}`;
        const adj = issue2.inclusive ? "ne maesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} turi bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Eilut privalo prasidti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut privalo traukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Skaiius privalo bti ${issue2.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpaint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga vestis";
      case "invalid_element": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} turi klaiding vest`;
      }
      default:
        return "Klaidinga vestis";
    }
  };
};
function lt() {
  return {
    localeError: error$l()
  };
}
const error$k = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "  -",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64- ",
    base64url: "base64url- ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` :   instanceof ${issue2.expected},  ${received}`;
        }
        return ` :   ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :     "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return ` :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :      ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :      ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? " " : " "}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function mk() {
  return {
    localeError: error$k()
  };
}
const error$j = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombor"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak sah: dijangka instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms() {
  return {
    localeError: error$j()
  };
}
const error$i = () => {
  const Sizable = {
    string: { unit: "tekens", verb: "heeft" },
    file: { unit: "bytes", verb: "heeft" },
    array: { unit: "elementen", verb: "heeft" },
    set: { unit: "elementen", verb: "heeft" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "getal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ongeldige invoer: verwacht instanceof ${issue2.expected}, ontving ${received}`;
        }
        return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const longName = issue2.origin === "date" ? "laat" : issue2.origin === "string" ? "lang" : "groot";
        if (sizing)
          return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
        return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const shortName = issue2.origin === "date" ? "vroeg" : issue2.origin === "string" ? "kort" : "klein";
        if (sizing) {
          return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl() {
  return {
    localeError: error$i()
  };
}
const error$h = () => {
  const Sizable = {
    string: { unit: "tegn", verb: " ha" },
    file: { unit: "bytes", verb: " ha" },
    array: { unit: "elementer", verb: " inneholde" },
    set: { unit: "elementer", verb: " inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omrde",
    ipv6: "IPv6-omrde",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "tall",
    array: "liste"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldig input: forventet instanceof ${issue2.expected}, fikk ${received}`;
        }
        return `Ugyldig input: forventet ${expected}, fikk ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til  ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til  ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til  ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til  ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m matche mnsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m vre et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente nkler" : "Ukjent nkkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nkkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no() {
  return {
    localeError: error$h()
  };
}
const error$g = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmaldr" },
    file: { unit: "bayt", verb: "olmaldr" },
    array: { unit: "unsur", verb: "olmaldr" },
    set: { unit: "unsur", verb: "olmaldr" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "giren",
    email: "epostagh",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO hengm",
    date: "ISO tarihi",
    time: "ISO zaman",
    duration: "ISO mddeti",
    ipv4: "IPv4 nin",
    ipv6: "IPv6 nin",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-ifreli metin",
    base64url: "base64url-ifreli metin",
    json_string: "JSON metin",
    e164: "E.164 says",
    jwt: "JWT",
    template_literal: "giren"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numara",
    array: "saf",
    null: "gayb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Fsit giren: umulan instanceof ${issue2.expected}, alnan ${received}`;
        }
        return `Fsit giren: umulan ${expected}, alnan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Fsit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `Fsit tercih: mteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla byk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalyd.`;
        return `Fazla byk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmalyd.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla kk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmalyd.`;
        }
        return `Fazla kk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmalyd.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Fsit metin: "${_issue.prefix}" ile balamal.`;
        if (_issue.format === "ends_with")
          return `Fsit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `Fsit metin: "${_issue.includes}" ihtiv etmeli.`;
        if (_issue.format === "regex")
          return `Fsit metin: ${_issue.pattern} nakna uymal.`;
        return `Fsit ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Fsit say: ${issue2.divisor} kat olmalyd.`;
      case "unrecognized_keys":
        return `Tannmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} iin tannmayan anahtar var.`;
      case "invalid_union":
        return "Giren tannamad.";
      case "invalid_element":
        return `${issue2.origin} iin tannmayan kymet var.`;
      default:
        return `Kymet tannamad.`;
    }
  };
};
function ota() {
  return {
    localeError: error$g()
  };
}
const error$f = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "",
    url: "  ",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ",
    date: "",
    time: "",
    duration: "",
    ipv4: " IPv4 ",
    ipv6: " IPv6 ",
    cidrv4: " IPv4 ",
    cidrv6: " IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: " E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` :  instanceof ${issue2.expected} ,  ${received}  `;
        }
        return ` :  ${expected} ,  ${received}  `;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return ` :  ${stringifyPrimitive(issue2.values[0])} `;
        }
        return ` :    ${joinValues(issue2.values, "|")}  `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""} `;
        }
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit} `;
        }
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :   "${_issue.prefix}"   `;
        }
        if (_issue.format === "ends_with") {
          return ` :   "${_issue.suffix}"    `;
        }
        if (_issue.format === "includes") {
          return ` :  "${_issue.includes}" `;
        }
        if (_issue.format === "regex") {
          return ` :   ${_issue.pattern}   `;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format}  `;
      }
      case "not_multiple_of":
        return ` :   ${issue2.divisor}  `;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin} `;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return `   ${issue2.origin} `;
      default:
        return ` `;
    }
  };
};
function ps() {
  return {
    localeError: error$f()
  };
}
const error$e = () => {
  const Sizable = {
    string: { unit: "znakw", verb: "mie" },
    file: { unit: "bajtw", verb: "mie" },
    array: { unit: "elementw", verb: "mie" },
    set: { unit: "elementw", verb: "mie" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "wyraenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "cig znakw zakodowany w formacie base64",
    base64url: "cig znakw zakodowany w formacie base64url",
    json_string: "cig znakw w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wejcie"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "liczba",
    array: "tablica"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nieprawidowe dane wejciowe: oczekiwano instanceof ${issue2.expected}, otrzymano ${received}`;
        }
        return `Nieprawidowe dane wejciowe: oczekiwano ${expected}, otrzymano ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawidowe dane wejciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawidowa opcja: oczekiwano jednej z wartoci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za dua warto: oczekiwano, e ${issue2.origin ?? "warto"} bdzie mie ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementw"}`;
        }
        return `Zbyt du(y/a/e): oczekiwano, e ${issue2.origin ?? "warto"} bdzie wynosi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za maa warto: oczekiwano, e ${issue2.origin ?? "warto"} bdzie mie ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "elementw"}`;
        }
        return `Zbyt ma(y/a/e): oczekiwano, e ${issue2.origin ?? "warto"} bdzie wynosi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawidowy cig znakw: musi zaczyna si od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawidowy cig znakw: musi koczy si na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawidowy cig znakw: musi zawiera "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${_issue.pattern}`;
        return `Nieprawidow(y/a/e) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidowa liczba: musi by wielokrotnoci ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidowy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawidowe dane wejciowe";
      case "invalid_element":
        return `Nieprawidowa warto w ${issue2.origin}`;
      default:
        return `Nieprawidowe dane wejciowe`;
    }
  };
};
function pl() {
  return {
    localeError: error$e()
  };
}
const error$d = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "padro",
    email: "endereo de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durao ISO",
    ipv4: "endereo IPv4",
    ipv6: "endereo IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nmero",
    null: "nulo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipo invlido: esperado instanceof ${issue2.expected}, recebido ${received}`;
        }
        return `Tipo invlido: esperado ${expected}, recebido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada invlida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Opo invlida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto invlido: deve comear com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto invlido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto invlido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto invlido: deve corresponder ao padro ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invlido`;
      }
      case "not_multiple_of":
        return `Nmero invlido: deve ser mltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave invlida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido em ${issue2.origin}`;
      default:
        return `Campo invlido`;
    }
  };
};
function pt() {
  return {
    localeError: error$d()
  };
}
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
const error$c = () => {
  const Sizable = {
    string: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "email ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "   base64",
    base64url: "   base64url",
    json_string: "JSON ",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` :  instanceof ${issue2.expected},  ${received}`;
        }
        return ` :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `  : ,  ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `  : ,  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `  : ,  ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `  : ,  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return `  `;
    }
  };
};
function ru() {
  return {
    localeError: error$c()
  };
}
const error$b = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "vnos",
    email: "e-potni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in as",
    date: "ISO datum",
    time: "ISO as",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "tevilo",
    array: "tabela"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neveljaven vnos: priakovano instanceof ${issue2.expected}, prejeto ${received}`;
        }
        return `Neveljaven vnos: priakovano ${expected}, prejeto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: priakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna monost: priakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: priakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: priakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: priakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: priakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se zaeti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se konati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno tevilo: mora biti vekratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i kljui" : " klju"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl() {
  return {
    localeError: error$b()
  };
}
const error$a = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att innehlla" },
    set: { unit: "objekt", verb: "att innehlla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "reguljrt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad strng",
    base64url: "base64url-kodad strng",
    json_string: "JSON-strng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "antal",
    array: "lista"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ogiltig inmatning: frvntat instanceof ${issue2.expected}, fick ${received}`;
        }
        return `Ogiltig inmatning: frvntat ${expected}, fick ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: frvntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: frvntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fr stor(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `Fr stor(t): frvntat ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fr lite(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Fr lite(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig strng: mste brja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig strng: mste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig strng: mste innehlla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig strng: mste matcha mnstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: mste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Oknda nycklar" : "Oknd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "vrdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt vrde i ${issue2.origin ?? "vrdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv() {
  return {
    localeError: error$a()
  };
}
const error$9 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO  ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO  ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: "",
    null: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` :  instanceof ${issue2.expected},  ${received}`;
        }
        return ` :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :  ${joinValues(issue2.values, "|")}  `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :  ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}   `;
        }
        return ` :  ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()}   `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :  ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}   `;
        }
        return ` :  ${issue2.origin} ${adj}${issue2.minimum.toString()}   `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` : "${_issue.prefix}"   `;
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"   `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"   `;
        if (_issue.format === "regex")
          return ` : ${_issue.pattern}   `;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}    `;
      case "unrecognized_keys":
        return `  ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin}   `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `${issue2.origin}   `;
      default:
        return ` `;
    }
  };
};
function ta() {
  return {
    localeError: error$9()
  };
}
const error$8 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: " ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IP  IPv4",
    cidrv6: " IP  IPv6",
    base64: " Base64",
    base64url: " Base64  URL",
    json_string: " JSON",
    e164: " (E.164)",
    jwt: " JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: " (Array)",
    null: " (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `:  instanceof ${issue2.expected}  ${received}`;
        }
        return `:  ${expected}  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `:  ${stringifyPrimitive(issue2.values[0])}`;
        return `:  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `: ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `: ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `: ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `:  "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `:  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `:  "${_issue.includes}" `;
        if (_issue.format === "regex")
          return `:  ${_issue.pattern}`;
        return `: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `:  ${issue2.divisor} `;
      case "unrecognized_keys":
        return `: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` ${issue2.origin}`;
      case "invalid_union":
        return ": ";
      case "invalid_element":
        return ` ${issue2.origin}`;
      default:
        return ``;
    }
  };
};
function th() {
  return {
    localeError: error$8()
  };
}
const error$7 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal" },
    file: { unit: "bayt", verb: "olmal" },
    array: { unit: "e", verb: "olmal" },
    set: { unit: "e", verb: "olmal" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO sre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral",
    cidrv6: "IPv6 aral",
    base64: "base64 ile ifrelenmi metin",
    base64url: "base64url ile ifrelenmi metin",
    json_string: "JSON dizesi",
    e164: "E.164 says",
    jwt: "JWT",
    template_literal: "ablon dizesi"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Geersiz deer: beklenen instanceof ${issue2.expected}, alnan ${received}`;
        }
        return `Geersiz deer: beklenen ${expected}, alnan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Geersiz deer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Geersiz seenek: aadakilerden biri olmal: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ok byk: beklenen ${issue2.origin ?? "deer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "e"}`;
        return `ok byk: beklenen ${issue2.origin ?? "deer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ok kk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `ok kk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Geersiz metin: "${_issue.prefix}" ile balamal`;
        if (_issue.format === "ends_with")
          return `Geersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Geersiz metin: "${_issue.includes}" iermeli`;
        if (_issue.format === "regex")
          return `Geersiz metin: ${_issue.pattern} desenine uymal`;
        return `Geersiz ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Geersiz say: ${issue2.divisor} ile tam blnebilmeli`;
      case "unrecognized_keys":
        return `Tannmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} iinde geersiz anahtar`;
      case "invalid_union":
        return "Geersiz deer";
      case "invalid_element":
        return `${issue2.origin} iinde geersiz deer`;
      default:
        return `Geersiz deer`;
    }
  };
};
function tr() {
  return {
    localeError: error$7()
  };
}
const error$6 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: " ",
    email: "  ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: "   base64",
    base64url: "   base64url",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: " "
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `  :  instanceof ${issue2.expected},  ${received}`;
        }
        return `  :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ,  ${issue2.origin ?? ""} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` : ,  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ,  ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` : ,  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return `  `;
    }
  };
};
function uk() {
  return {
    localeError: error$6()
  };
}
function ua() {
  return uk();
}
const error$5 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: " ",
    email: "  ",
    url: "  ",
    emoji: "",
    uuid: "   ",
    uuidv4: "     4",
    uuidv6: "     6",
    nanoid: "  ",
    guid: "   ",
    cuid: "   ",
    cuid2: "    2",
    ulid: "   ",
    xid: "  ",
    ksuid: "    ",
    datetime: "    ",
    date: "   ",
    time: "   ",
    duration: "   ",
    ipv4: "   4 ",
    ipv6: "   6 ",
    cidrv4: "   4 ",
    cidrv6: "   6 ",
    base64: " 64   ",
    base64url: " 64      ",
    json_string: "    ",
    e164: " 164 ",
    jwt: "  ",
    template_literal: " "
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: "",
    null: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `  : instanceof ${issue2.expected}   ${received}  `;
        }
        return `  : ${expected}   ${received}  `;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  : ${stringifyPrimitive(issue2.values[0])}  `;
        return ` : ${joinValues(issue2.values, "|")}     `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}   `;
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}   `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit}   `;
        }
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()}   `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` : "${_issue.prefix}"    `;
        }
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"    `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"   `;
        if (_issue.format === "regex")
          return ` :  ${_issue.pattern}    `;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}    `;
      case "unrecognized_keys":
        return `   ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, " ")}`;
      case "invalid_key":
        return `${issue2.origin}   `;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `${issue2.origin}   `;
      default:
        return `  `;
    }
  };
};
function ur() {
  return {
    localeError: error$5()
  };
}
const error$4 = () => {
  const Sizable = {
    string: { unit: "belgi", verb: "bolishi kerak" },
    file: { unit: "bayt", verb: "bolishi kerak" },
    array: { unit: "element", verb: "bolishi kerak" },
    set: { unit: "element", verb: "bolishi kerak" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "kirish",
    email: "elektron pochta manzili",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO sana va vaqti",
    date: "ISO sana",
    time: "ISO vaqt",
    duration: "ISO davomiylik",
    ipv4: "IPv4 manzil",
    ipv6: "IPv6 manzil",
    mac: "MAC manzil",
    cidrv4: "IPv4 diapazon",
    cidrv6: "IPv6 diapazon",
    base64: "base64 kodlangan satr",
    base64url: "base64url kodlangan satr",
    json_string: "JSON satr",
    e164: "E.164 raqam",
    jwt: "JWT",
    template_literal: "kirish"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "raqam",
    array: "massiv"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Notogri kirish: kutilgan instanceof ${issue2.expected}, qabul qilingan ${received}`;
        }
        return `Notogri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Notogri kirish: kutilgan ${stringifyPrimitive(issue2.values[0])}`;
        return `Notogri variant: quyidagilardan biri kutilgan ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
        return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Notogri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
        if (_issue.format === "ends_with")
          return `Notogri satr: "${_issue.suffix}" bilan tugashi kerak`;
        if (_issue.format === "includes")
          return `Notogri satr: "${_issue.includes}" ni oz ichiga olishi kerak`;
        if (_issue.format === "regex")
          return `Notogri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
        return `Notogri ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Notogri raqam: ${issue2.divisor} ning karralisi bolishi kerak`;
      case "unrecognized_keys":
        return `Nomalum kalit${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} dagi kalit notogri`;
      case "invalid_union":
        return "Notogri kirish";
      case "invalid_element":
        return `${issue2.origin} da notogri qiymat`;
      default:
        return `Notogri kirish`;
    }
  };
};
function uz() {
  return {
    localeError: error$4()
  };
}
const error$3 = () => {
  const Sizable = {
    string: { unit: "k t", verb: "c" },
    file: { unit: "byte", verb: "c" },
    array: { unit: "phn t", verb: "c" },
    set: { unit: "phn t", verb: "c" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "u vo",
    email: "a ch email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ngy gi ISO",
    date: "ngy ISO",
    time: "gi ISO",
    duration: "khong thi gian ISO",
    ipv4: "a ch IPv4",
    ipv6: "a ch IPv6",
    cidrv4: "di IPv4",
    cidrv6: "di IPv6",
    base64: "chui m ha base64",
    base64url: "chui m ha base64url",
    json_string: "chui JSON",
    e164: "s E.164",
    jwt: "JWT",
    template_literal: "u vo"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "s",
    array: "mng"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `u vo khng hp l: mong i instanceof ${issue2.expected}, nhn c ${received}`;
        }
        return `u vo khng hp l: mong i ${expected}, nhn c ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `u vo khng hp l: mong i ${stringifyPrimitive(issue2.values[0])}`;
        return `Ty chn khng hp l: mong i mt trong cc gi tr ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu ln: mong i ${issue2.origin ?? "gi tr"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "phn t"}`;
        return `Qu ln: mong i ${issue2.origin ?? "gi tr"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu nh: mong i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu nh: mong i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chui khng hp l: phi bt u bng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chui khng hp l: phi kt thc bng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chui khng hp l: phi bao gm "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chui khng hp l: phi khp vi mu ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} khng hp l`;
      }
      case "not_multiple_of":
        return `S khng hp l: phi l bi s ca ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kha khng c nhn dng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kha khng hp l trong ${issue2.origin}`;
      case "invalid_union":
        return "u vo khng hp l";
      case "invalid_element":
        return `Gi tr khng hp l trong ${issue2.origin}`;
      default:
        return `u vo khng hp l`;
    }
  };
};
function vi() {
  return {
    localeError: error$3()
  };
}
const error$2 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO",
    date: "ISO",
    time: "ISO",
    duration: "ISO",
    ipv4: "IPv4",
    ipv6: "IPv6",
    cidrv4: "IPv4",
    cidrv6: "IPv6",
    base64: "base64",
    base64url: "base64url",
    json_string: "JSON",
    e164: "E.164",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: "",
    null: "(null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` instanceof ${issue2.expected} ${received}`;
        }
        return ` ${expected} ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` ${stringifyPrimitive(issue2.values[0])}`;
        return ` ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` "${_issue.prefix}" `;
        if (_issue.format === "ends_with")
          return ` "${_issue.suffix}" `;
        if (_issue.format === "includes")
          return ` "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` ${issue2.divisor} `;
      case "unrecognized_keys":
        return `(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} (key)`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin} (value)`;
      default:
        return ``;
    }
  };
};
function zhCN() {
  return {
    localeError: error$2()
  };
}
const error$1 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64 ",
    base64url: "base64url ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` instanceof ${issue2.expected} ${received}`;
        }
        return ` ${expected} ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` ${stringifyPrimitive(issue2.values[0])}`;
        return ` ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` "${_issue.prefix}" `;
        }
        if (_issue.format === "ends_with")
          return ` "${_issue.suffix}" `;
        if (_issue.format === "includes")
          return ` "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` ${issue2.divisor} `;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}${joinValues(issue2.keys, "")}`;
      case "invalid_key":
        return `${issue2.origin} `;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin} `;
      default:
        return ``;
    }
  };
};
function zhTW() {
  return {
    localeError: error$1()
  };
}
const error = () => {
  const Sizable = {
    string: { unit: "mi", verb: "n" },
    file: { unit: "bytes", verb: "n" },
    array: { unit: "nkan", verb: "n" },
    set: { unit: "nkan", verb: "n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "r bwl",
    email: "drs ml",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "kk ISO",
    date: "j ISO",
    time: "kk ISO",
    duration: "kk t p ISO",
    ipv4: "drs IPv4",
    ipv6: "drs IPv6",
    cidrv4: "gbgb IPv4",
    cidrv6: "gbgb IPv6",
    base64: "r t a k n base64",
    base64url: "r base64url",
    json_string: "r JSON",
    e164: "nmb E.164",
    jwt: "JWT",
    template_literal: "r bwl"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nmb",
    array: "akop"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `bwl ae: a n lti fi instanceof ${issue2.expected}, m a r ${received}`;
        }
        return `bwl ae: a n lti fi ${expected}, m a r ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `bwl ae: a n lti fi ${stringifyPrimitive(issue2.values[0])}`;
        return `yn ae: yan kan lra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T p j: a n lti j p ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
        return `T p j: a n lti j ${adj}${issue2.maximum}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Kr ju: a n lti j p ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
        return `Kr ju: a n lti j ${adj}${issue2.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `r ae: gbd br pl "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `r ae: gbd par pl "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `r ae: gbd n "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `r ae: gbd b pr mu ${_issue.pattern}`;
        return `Ae: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nmb ae: gbd j y ppn ti ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Btn m: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Btn ae nn ${issue2.origin}`;
      case "invalid_union":
        return "bwl ae";
      case "invalid_element":
        return `Iye ae nn ${issue2.origin}`;
      default:
        return "bwl ae";
    }
  };
};
function yo() {
  return {
    localeError: error()
  };
}
const index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ar,
  az,
  be,
  bg,
  ca,
  cs,
  da,
  de,
  en,
  eo,
  es,
  fa,
  fi,
  fr,
  frCA,
  he,
  hu,
  hy,
  id,
  is,
  it,
  ja,
  ka,
  kh,
  km,
  ko,
  lt,
  mk,
  ms,
  nl,
  no,
  ota,
  pl,
  ps,
  pt,
  ru,
  sl,
  sv,
  ta,
  th,
  tr,
  ua,
  uk,
  ur,
  uz,
  vi,
  yo,
  zhCN,
  zhTW
}, Symbol.toStringTag, { value: "Module" }));
var _a;
const $output = /* @__PURE__ */ Symbol("ZodOutput");
const $input = /* @__PURE__ */ Symbol("ZodInput");
class $ZodRegistry {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta2 = _meta[0];
    this._map.set(schema, meta2);
    if (meta2 && typeof meta2 === "object" && "id" in meta2) {
      this._idmap.set(meta2.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta2 = this._map.get(schema);
    if (meta2 && typeof meta2 === "object" && "id" in meta2) {
      this._idmap.delete(meta2.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry();
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
const globalRegistry = globalThis.__zod_globalRegistry;
// @__NO_SIDE_EFFECTS__
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _emoji(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mac(Class2, params) {
  return new Class2({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
const TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
// @__NO_SIDE_EFFECTS__
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _undefined$1(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _null$1(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
// @__NO_SIDE_EFFECTS__
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _void$1(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _positive(params) {
  return /* @__PURE__ */ _gt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _negative(params) {
  return /* @__PURE__ */ _lt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonpositive(params) {
  return /* @__PURE__ */ _lte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonnegative(params) {
  return /* @__PURE__ */ _gte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
// @__NO_SIDE_EFFECTS__
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
// @__NO_SIDE_EFFECTS__
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
// @__NO_SIDE_EFFECTS__
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
// @__NO_SIDE_EFFECTS__
function _regex(pattern2, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern: pattern2
  });
}
// @__NO_SIDE_EFFECTS__
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
// @__NO_SIDE_EFFECTS__
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
// @__NO_SIDE_EFFECTS__
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
// @__NO_SIDE_EFFECTS__
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mime(types2, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types2,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
// @__NO_SIDE_EFFECTS__
function _normalize(form) {
  return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
}
// @__NO_SIDE_EFFECTS__
function _trim() {
  return /* @__PURE__ */ _overwrite((input) => input.trim());
}
// @__NO_SIDE_EFFECTS__
function _toLowerCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function _toUpperCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function _slugify() {
  return /* @__PURE__ */ _overwrite((input) => slugify(input));
}
// @__NO_SIDE_EFFECTS__
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _xor(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    inclusive: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
// @__NO_SIDE_EFFECTS__
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _enum$1(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
// @__NO_SIDE_EFFECTS__
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _default$1(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
// @__NO_SIDE_EFFECTS__
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _catch$1(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
// @__NO_SIDE_EFFECTS__
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
// @__NO_SIDE_EFFECTS__
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
// @__NO_SIDE_EFFECTS__
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
// @__NO_SIDE_EFFECTS__
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
// @__NO_SIDE_EFFECTS__
function _superRefine(fn) {
  const ch = /* @__PURE__ */ _check((payload) => {
    payload.addIssue = (issue$1) => {
      if (typeof issue$1 === "string") {
        payload.issues.push(issue(issue$1, payload.value, ch._zod.def));
      } else {
        const _issue = issue$1;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
// @__NO_SIDE_EFFECTS__
function describe$1(description) {
  const ch = new $ZodCheck({ check: "describe" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
// @__NO_SIDE_EFFECTS__
function meta$1(metadata) {
  const ch = new $ZodCheck({ check: "meta" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: ((input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec2,
          continue: false
        });
        return {};
      }
    }),
    reverseTransform: ((input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    }),
    error: params.error
  });
  return codec2;
}
// @__NO_SIDE_EFFECTS__
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  if (target === "draft-4")
    target = "draft-04";
  if (target === "draft-7")
    target = "draft-07";
  return {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {
    }),
    io: params?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? void 0
  };
}
function process$1(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a2;
  const def = schema._zod.def;
  const seen2 = ctx.seen.get(schema);
  if (seen2) {
    seen2.count++;
    const isCycle = _params.schemaPath.includes(schema);
    if (isCycle) {
      seen2.cycle = _params.path;
    }
    return seen2.schema;
  }
  const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
  ctx.seen.set(schema, result);
  const overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema) {
    result.schema = overrideSchema;
  } else {
    const params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema) {
      schema._zod.processJSONSchema(ctx, result.schema, params);
    } else {
      const _json = result.schema;
      const processor2 = ctx.processors[def.type];
      if (!processor2) {
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      }
      processor2(schema, ctx, _json, params);
    }
    const parent = schema._zod.parent;
    if (parent) {
      if (!result.ref)
        result.ref = parent;
      process$1(parent, ctx, params);
      ctx.seen.get(parent).isParent = true;
    }
  }
  const meta2 = ctx.metadataRegistry.get(schema);
  if (meta2)
    Object.assign(result.schema, meta2);
  if (ctx.io === "input" && isTransforming(schema)) {
    delete result.schema.examples;
    delete result.schema.default;
  }
  if (ctx.io === "input" && result.schema._prefault)
    (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
  delete result.schema._prefault;
  const _result = ctx.seen.get(schema);
  return _result.schema;
}
function extractDefs(ctx, schema) {
  const root2 = ctx.seen.get(schema);
  if (!root2)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const idToSchema = /* @__PURE__ */ new Map();
  for (const entry of ctx.seen.entries()) {
    const id2 = ctx.metadataRegistry.get(entry[0])?.id;
    if (id2) {
      const existing = idToSchema.get(id2);
      if (existing && existing !== entry[0]) {
        throw new Error(`Duplicate schema id "${id2}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      }
      idToSchema.set(id2, entry[0]);
    }
  }
  const makeURI = (entry) => {
    const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      const externalId = ctx.external.registry.get(entry[0])?.id;
      const uriGenerator = ctx.external.uri ?? ((id3) => id3);
      if (externalId) {
        return { ref: uriGenerator(externalId) };
      }
      const id2 = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      entry[1].defId = id2;
      return { defId: id2, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id2}` };
    }
    if (entry[1] === root2) {
      return { ref: "#" };
    }
    const uriPrefix = `#`;
    const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
    const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  };
  const extractToDef = (entry) => {
    if (entry[1].schema.$ref) {
      return;
    }
    const seen2 = entry[1];
    const { ref: ref2, defId } = makeURI(entry);
    seen2.def = { ...seen2.schema };
    if (defId)
      seen2.defId = defId;
    const schema2 = seen2.schema;
    for (const key2 in schema2) {
      delete schema2[key2];
    }
    schema2.$ref = ref2;
  };
  if (ctx.cycles === "throw") {
    for (const entry of ctx.seen.entries()) {
      const seen2 = entry[1];
      if (seen2.cycle) {
        throw new Error(`Cycle detected: #/${seen2.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    }
  }
  for (const entry of ctx.seen.entries()) {
    const seen2 = entry[1];
    if (schema === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      const ext = ctx.external.registry.get(entry[0])?.id;
      if (schema !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    const id2 = ctx.metadataRegistry.get(entry[0])?.id;
    if (id2) {
      extractToDef(entry);
      continue;
    }
    if (seen2.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen2.count > 1) {
      if (ctx.reused === "ref") {
        extractToDef(entry);
        continue;
      }
    }
  }
}
function finalize(ctx, schema) {
  const root2 = ctx.seen.get(schema);
  if (!root2)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const flattenRef = (zodSchema) => {
    const seen2 = ctx.seen.get(zodSchema);
    if (seen2.ref === null)
      return;
    const schema2 = seen2.def ?? seen2.schema;
    const _cached = { ...schema2 };
    const ref2 = seen2.ref;
    seen2.ref = null;
    if (ref2) {
      flattenRef(ref2);
      const refSeen = ctx.seen.get(ref2);
      const refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
        schema2.allOf = schema2.allOf ?? [];
        schema2.allOf.push(refSchema);
      } else {
        Object.assign(schema2, refSchema);
      }
      Object.assign(schema2, _cached);
      const isParentRef = zodSchema._zod.parent === ref2;
      if (isParentRef) {
        for (const key2 in schema2) {
          if (key2 === "$ref" || key2 === "allOf")
            continue;
          if (!(key2 in _cached)) {
            delete schema2[key2];
          }
        }
      }
      if (refSchema.$ref) {
        for (const key2 in schema2) {
          if (key2 === "$ref" || key2 === "allOf")
            continue;
          if (key2 in refSeen.def && JSON.stringify(schema2[key2]) === JSON.stringify(refSeen.def[key2])) {
            delete schema2[key2];
          }
        }
      }
    }
    const parent = zodSchema._zod.parent;
    if (parent && parent !== ref2) {
      flattenRef(parent);
      const parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref) {
        schema2.$ref = parentSeen.schema.$ref;
        if (parentSeen.def) {
          for (const key2 in schema2) {
            if (key2 === "$ref" || key2 === "allOf")
              continue;
            if (key2 in parentSeen.def && JSON.stringify(schema2[key2]) === JSON.stringify(parentSeen.def[key2])) {
              delete schema2[key2];
            }
          }
        }
      }
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen2.path ?? []
    });
  };
  for (const entry of [...ctx.seen.entries()].reverse()) {
    flattenRef(entry[0]);
  }
  const result = {};
  if (ctx.target === "draft-2020-12") {
    result.$schema = "https://json-schema.org/draft/2020-12/schema";
  } else if (ctx.target === "draft-07") {
    result.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (ctx.target === "draft-04") {
    result.$schema = "http://json-schema.org/draft-04/schema#";
  } else if (ctx.target === "openapi-3.0") ;
  else ;
  if (ctx.external?.uri) {
    const id2 = ctx.external.registry.get(schema)?.id;
    if (!id2)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id2);
  }
  Object.assign(result, root2.def ?? root2.schema);
  const defs = ctx.external?.defs ?? {};
  for (const entry of ctx.seen.entries()) {
    const seen2 = entry[1];
    if (seen2.def && seen2.defId) {
      defs[seen2.defId] = seen2.def;
    }
  }
  if (ctx.external) ;
  else {
    if (Object.keys(defs).length > 0) {
      if (ctx.target === "draft-2020-12") {
        result.$defs = defs;
      } else {
        result.definitions = defs;
      }
    }
  }
  try {
    const finalized = JSON.parse(JSON.stringify(result));
    Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: false,
      writable: false
    });
    return finalized;
  } catch (_err) {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key2 in def.shape) {
      if (isTransforming(def.shape[key2], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
const createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
  const ctx = initializeContext({ ...params, processors });
  process$1(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};
const createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
  const { libraryOptions, target } = params ?? {};
  const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
  process$1(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};
const formatMap = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
};
const stringProcessor = (schema, ctx, _json, _params) => {
  const json2 = _json;
  json2.type = "string";
  const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
  if (typeof minimum === "number")
    json2.minLength = minimum;
  if (typeof maximum === "number")
    json2.maxLength = maximum;
  if (format) {
    json2.format = formatMap[format] ?? format;
    if (json2.format === "")
      delete json2.format;
    if (format === "time") {
      delete json2.format;
    }
  }
  if (contentEncoding)
    json2.contentEncoding = contentEncoding;
  if (patterns && patterns.size > 0) {
    const regexes2 = [...patterns];
    if (regexes2.length === 1)
      json2.pattern = regexes2[0].source;
    else if (regexes2.length > 1) {
      json2.allOf = [
        ...regexes2.map((regex) => ({
          ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
          pattern: regex.source
        }))
      ];
    }
  }
};
const numberProcessor = (schema, ctx, _json, _params) => {
  const json2 = _json;
  const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
  if (typeof format === "string" && format.includes("int"))
    json2.type = "integer";
  else
    json2.type = "number";
  if (typeof exclusiveMinimum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json2.minimum = exclusiveMinimum;
      json2.exclusiveMinimum = true;
    } else {
      json2.exclusiveMinimum = exclusiveMinimum;
    }
  }
  if (typeof minimum === "number") {
    json2.minimum = minimum;
    if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMinimum >= minimum)
        delete json2.minimum;
      else
        delete json2.exclusiveMinimum;
    }
  }
  if (typeof exclusiveMaximum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json2.maximum = exclusiveMaximum;
      json2.exclusiveMaximum = true;
    } else {
      json2.exclusiveMaximum = exclusiveMaximum;
    }
  }
  if (typeof maximum === "number") {
    json2.maximum = maximum;
    if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMaximum <= maximum)
        delete json2.maximum;
      else
        delete json2.exclusiveMaximum;
    }
  }
  if (typeof multipleOf === "number")
    json2.multipleOf = multipleOf;
};
const booleanProcessor = (_schema, _ctx, json2, _params) => {
  json2.type = "boolean";
};
const bigintProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("BigInt cannot be represented in JSON Schema");
  }
};
const symbolProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Symbols cannot be represented in JSON Schema");
  }
};
const nullProcessor = (_schema, ctx, json2, _params) => {
  if (ctx.target === "openapi-3.0") {
    json2.type = "string";
    json2.nullable = true;
    json2.enum = [null];
  } else {
    json2.type = "null";
  }
};
const undefinedProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Undefined cannot be represented in JSON Schema");
  }
};
const voidProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Void cannot be represented in JSON Schema");
  }
};
const neverProcessor = (_schema, _ctx, json2, _params) => {
  json2.not = {};
};
const anyProcessor = (_schema, _ctx, _json, _params) => {
};
const unknownProcessor = (_schema, _ctx, _json, _params) => {
};
const dateProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Date cannot be represented in JSON Schema");
  }
};
const enumProcessor = (schema, _ctx, json2, _params) => {
  const def = schema._zod.def;
  const values = getEnumValues(def.entries);
  if (values.every((v) => typeof v === "number"))
    json2.type = "number";
  if (values.every((v) => typeof v === "string"))
    json2.type = "string";
  json2.enum = values;
};
const literalProcessor = (schema, ctx, json2, _params) => {
  const def = schema._zod.def;
  const vals = [];
  for (const val of def.values) {
    if (val === void 0) {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
      }
    } else if (typeof val === "bigint") {
      if (ctx.unrepresentable === "throw") {
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      } else {
        vals.push(Number(val));
      }
    } else {
      vals.push(val);
    }
  }
  if (vals.length === 0) ;
  else if (vals.length === 1) {
    const val = vals[0];
    json2.type = val === null ? "null" : typeof val;
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json2.enum = [val];
    } else {
      json2.const = val;
    }
  } else {
    if (vals.every((v) => typeof v === "number"))
      json2.type = "number";
    if (vals.every((v) => typeof v === "string"))
      json2.type = "string";
    if (vals.every((v) => typeof v === "boolean"))
      json2.type = "boolean";
    if (vals.every((v) => v === null))
      json2.type = "null";
    json2.enum = vals;
  }
};
const nanProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("NaN cannot be represented in JSON Schema");
  }
};
const templateLiteralProcessor = (schema, _ctx, json2, _params) => {
  const _json = json2;
  const pattern2 = schema._zod.pattern;
  if (!pattern2)
    throw new Error("Pattern not found in template literal");
  _json.type = "string";
  _json.pattern = pattern2.source;
};
const fileProcessor = (schema, _ctx, json2, _params) => {
  const _json = json2;
  const file2 = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  };
  const { minimum, maximum, mime } = schema._zod.bag;
  if (minimum !== void 0)
    file2.minLength = minimum;
  if (maximum !== void 0)
    file2.maxLength = maximum;
  if (mime) {
    if (mime.length === 1) {
      file2.contentMediaType = mime[0];
      Object.assign(_json, file2);
    } else {
      Object.assign(_json, file2);
      _json.anyOf = mime.map((m) => ({ contentMediaType: m }));
    }
  } else {
    Object.assign(_json, file2);
  }
};
const successProcessor = (_schema, _ctx, json2, _params) => {
  json2.type = "boolean";
};
const customProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Custom types cannot be represented in JSON Schema");
  }
};
const functionProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Function types cannot be represented in JSON Schema");
  }
};
const transformProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Transforms cannot be represented in JSON Schema");
  }
};
const mapProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Map cannot be represented in JSON Schema");
  }
};
const setProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Set cannot be represented in JSON Schema");
  }
};
const arrayProcessor = (schema, ctx, _json, params) => {
  const json2 = _json;
  const def = schema._zod.def;
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json2.minItems = minimum;
  if (typeof maximum === "number")
    json2.maxItems = maximum;
  json2.type = "array";
  json2.items = process$1(def.element, ctx, { ...params, path: [...params.path, "items"] });
};
const objectProcessor = (schema, ctx, _json, params) => {
  const json2 = _json;
  const def = schema._zod.def;
  json2.type = "object";
  json2.properties = {};
  const shape = def.shape;
  for (const key2 in shape) {
    json2.properties[key2] = process$1(shape[key2], ctx, {
      ...params,
      path: [...params.path, "properties", key2]
    });
  }
  const allKeys = new Set(Object.keys(shape));
  const requiredKeys = new Set([...allKeys].filter((key2) => {
    const v = def.shape[key2]._zod;
    if (ctx.io === "input") {
      return v.optin === void 0;
    } else {
      return v.optout === void 0;
    }
  }));
  if (requiredKeys.size > 0) {
    json2.required = Array.from(requiredKeys);
  }
  if (def.catchall?._zod.def.type === "never") {
    json2.additionalProperties = false;
  } else if (!def.catchall) {
    if (ctx.io === "output")
      json2.additionalProperties = false;
  } else if (def.catchall) {
    json2.additionalProperties = process$1(def.catchall, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
};
const unionProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  const isExclusive = def.inclusive === false;
  const options = def.options.map((x, i) => process$1(x, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
  }));
  if (isExclusive) {
    json2.oneOf = options;
  } else {
    json2.anyOf = options;
  }
};
const intersectionProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  const a = process$1(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  });
  const b = process$1(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  });
  const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
  const allOf = [
    ...isSimpleIntersection(a) ? a.allOf : [a],
    ...isSimpleIntersection(b) ? b.allOf : [b]
  ];
  json2.allOf = allOf;
};
const tupleProcessor = (schema, ctx, _json, params) => {
  const json2 = _json;
  const def = schema._zod.def;
  json2.type = "array";
  const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
  const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
  const prefixItems = def.items.map((x, i) => process$1(x, ctx, {
    ...params,
    path: [...params.path, prefixPath, i]
  }));
  const rest = def.rest ? process$1(def.rest, ctx, {
    ...params,
    path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
  }) : null;
  if (ctx.target === "draft-2020-12") {
    json2.prefixItems = prefixItems;
    if (rest) {
      json2.items = rest;
    }
  } else if (ctx.target === "openapi-3.0") {
    json2.items = {
      anyOf: prefixItems
    };
    if (rest) {
      json2.items.anyOf.push(rest);
    }
    json2.minItems = prefixItems.length;
    if (!rest) {
      json2.maxItems = prefixItems.length;
    }
  } else {
    json2.items = prefixItems;
    if (rest) {
      json2.additionalItems = rest;
    }
  }
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json2.minItems = minimum;
  if (typeof maximum === "number")
    json2.maxItems = maximum;
};
const recordProcessor = (schema, ctx, _json, params) => {
  const json2 = _json;
  const def = schema._zod.def;
  json2.type = "object";
  const keyType = def.keyType;
  const keyBag = keyType._zod.bag;
  const patterns = keyBag?.patterns;
  if (def.mode === "loose" && patterns && patterns.size > 0) {
    const valueSchema = process$1(def.valueType, ctx, {
      ...params,
      path: [...params.path, "patternProperties", "*"]
    });
    json2.patternProperties = {};
    for (const pattern2 of patterns) {
      json2.patternProperties[pattern2.source] = valueSchema;
    }
  } else {
    if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
      json2.propertyNames = process$1(def.keyType, ctx, {
        ...params,
        path: [...params.path, "propertyNames"]
      });
    }
    json2.additionalProperties = process$1(def.valueType, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
  const keyValues = keyType._zod.values;
  if (keyValues) {
    const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
    if (validKeyValues.length > 0) {
      json2.required = validKeyValues;
    }
  }
};
const nullableProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  const inner = process$1(def.innerType, ctx, params);
  const seen2 = ctx.seen.get(schema);
  if (ctx.target === "openapi-3.0") {
    seen2.ref = def.innerType;
    json2.nullable = true;
  } else {
    json2.anyOf = [inner, { type: "null" }];
  }
};
const nonoptionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process$1(def.innerType, ctx, params);
  const seen2 = ctx.seen.get(schema);
  seen2.ref = def.innerType;
};
const defaultProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  process$1(def.innerType, ctx, params);
  const seen2 = ctx.seen.get(schema);
  seen2.ref = def.innerType;
  json2.default = JSON.parse(JSON.stringify(def.defaultValue));
};
const prefaultProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  process$1(def.innerType, ctx, params);
  const seen2 = ctx.seen.get(schema);
  seen2.ref = def.innerType;
  if (ctx.io === "input")
    json2._prefault = JSON.parse(JSON.stringify(def.defaultValue));
};
const catchProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  process$1(def.innerType, ctx, params);
  const seen2 = ctx.seen.get(schema);
  seen2.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  json2.default = catchValue;
};
const pipeProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process$1(innerType, ctx, params);
  const seen2 = ctx.seen.get(schema);
  seen2.ref = innerType;
};
const readonlyProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  process$1(def.innerType, ctx, params);
  const seen2 = ctx.seen.get(schema);
  seen2.ref = def.innerType;
  json2.readOnly = true;
};
const promiseProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process$1(def.innerType, ctx, params);
  const seen2 = ctx.seen.get(schema);
  seen2.ref = def.innerType;
};
const optionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process$1(def.innerType, ctx, params);
  const seen2 = ctx.seen.get(schema);
  seen2.ref = def.innerType;
};
const lazyProcessor = (schema, ctx, _json, params) => {
  const innerType = schema._zod.innerType;
  process$1(innerType, ctx, params);
  const seen2 = ctx.seen.get(schema);
  seen2.ref = innerType;
};
const allProcessors = {
  string: stringProcessor,
  number: numberProcessor,
  boolean: booleanProcessor,
  bigint: bigintProcessor,
  symbol: symbolProcessor,
  null: nullProcessor,
  undefined: undefinedProcessor,
  void: voidProcessor,
  never: neverProcessor,
  any: anyProcessor,
  unknown: unknownProcessor,
  date: dateProcessor,
  enum: enumProcessor,
  literal: literalProcessor,
  nan: nanProcessor,
  template_literal: templateLiteralProcessor,
  file: fileProcessor,
  success: successProcessor,
  custom: customProcessor,
  function: functionProcessor,
  transform: transformProcessor,
  map: mapProcessor,
  set: setProcessor,
  array: arrayProcessor,
  object: objectProcessor,
  union: unionProcessor,
  intersection: intersectionProcessor,
  tuple: tupleProcessor,
  record: recordProcessor,
  nullable: nullableProcessor,
  nonoptional: nonoptionalProcessor,
  default: defaultProcessor,
  prefault: prefaultProcessor,
  catch: catchProcessor,
  pipe: pipeProcessor,
  readonly: readonlyProcessor,
  promise: promiseProcessor,
  optional: optionalProcessor,
  lazy: lazyProcessor
};
function toJSONSchema(input, params) {
  if ("_idmap" in input) {
    const registry2 = input;
    const ctx2 = initializeContext({ ...params, processors: allProcessors });
    const defs = {};
    for (const entry of registry2._idmap.entries()) {
      const [_, schema] = entry;
      process$1(schema, ctx2);
    }
    const schemas = {};
    const external = {
      registry: registry2,
      uri: params?.uri,
      defs
    };
    ctx2.external = external;
    for (const entry of registry2._idmap.entries()) {
      const [key2, schema] = entry;
      extractDefs(ctx2, schema);
      schemas[key2] = finalize(ctx2, schema);
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const ctx = initializeContext({ ...params, processors: allProcessors });
  process$1(input, ctx);
  extractDefs(ctx, input);
  return finalize(ctx, input);
}
class JSONSchemaGenerator {
  /** @deprecated Access via ctx instead */
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  /** @deprecated Access via ctx instead */
  get target() {
    return this.ctx.target;
  }
  /** @deprecated Access via ctx instead */
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  /** @deprecated Access via ctx instead */
  get override() {
    return this.ctx.override;
  }
  /** @deprecated Access via ctx instead */
  get io() {
    return this.ctx.io;
  }
  /** @deprecated Access via ctx instead */
  get counter() {
    return this.ctx.counter;
  }
  set counter(value) {
    this.ctx.counter = value;
  }
  /** @deprecated Access via ctx instead */
  get seen() {
    return this.ctx.seen;
  }
  constructor(params) {
    let normalizedTarget = params?.target ?? "draft-2020-12";
    if (normalizedTarget === "draft-4")
      normalizedTarget = "draft-04";
    if (normalizedTarget === "draft-7")
      normalizedTarget = "draft-07";
    this.ctx = initializeContext({
      processors: allProcessors,
      target: normalizedTarget,
      ...params?.metadata && { metadata: params.metadata },
      ...params?.unrepresentable && { unrepresentable: params.unrepresentable },
      ...params?.override && { override: params.override },
      ...params?.io && { io: params.io }
    });
  }
  /**
   * Process a schema to prepare it for JSON Schema generation.
   * This must be called before emit().
   */
  process(schema, _params = { path: [], schemaPath: [] }) {
    return process$1(schema, this.ctx, _params);
  }
  /**
   * Emit the final JSON Schema after processing.
   * Must call process() first.
   */
  emit(schema, _params) {
    if (_params) {
      if (_params.cycles)
        this.ctx.cycles = _params.cycles;
      if (_params.reused)
        this.ctx.reused = _params.reused;
      if (_params.external)
        this.ctx.external = _params.external;
    }
    extractDefs(this.ctx, schema);
    const result = finalize(this.ctx, schema);
    const { "~standard": _, ...plainResult } = result;
    return plainResult;
  }
}
const jsonSchema = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $ZodAny,
  $ZodArray,
  $ZodAsyncError,
  $ZodBase64,
  $ZodBase64URL,
  $ZodBigInt,
  $ZodBigIntFormat,
  $ZodBoolean,
  $ZodCIDRv4,
  $ZodCIDRv6,
  $ZodCUID,
  $ZodCUID2,
  $ZodCatch,
  $ZodCheck,
  $ZodCheckBigIntFormat,
  $ZodCheckEndsWith,
  $ZodCheckGreaterThan,
  $ZodCheckIncludes,
  $ZodCheckLengthEquals,
  $ZodCheckLessThan,
  $ZodCheckLowerCase,
  $ZodCheckMaxLength,
  $ZodCheckMaxSize,
  $ZodCheckMimeType,
  $ZodCheckMinLength,
  $ZodCheckMinSize,
  $ZodCheckMultipleOf,
  $ZodCheckNumberFormat,
  $ZodCheckOverwrite,
  $ZodCheckProperty,
  $ZodCheckRegex,
  $ZodCheckSizeEquals,
  $ZodCheckStartsWith,
  $ZodCheckStringFormat,
  $ZodCheckUpperCase,
  $ZodCodec,
  $ZodCustom,
  $ZodCustomStringFormat,
  $ZodDate,
  $ZodDefault,
  $ZodDiscriminatedUnion,
  $ZodE164,
  $ZodEmail,
  $ZodEmoji,
  $ZodEncodeError,
  $ZodEnum,
  $ZodError,
  $ZodExactOptional,
  $ZodFile,
  $ZodFunction,
  $ZodGUID,
  $ZodIPv4,
  $ZodIPv6,
  $ZodISODate,
  $ZodISODateTime,
  $ZodISODuration,
  $ZodISOTime,
  $ZodIntersection,
  $ZodJWT,
  $ZodKSUID,
  $ZodLazy,
  $ZodLiteral,
  $ZodMAC,
  $ZodMap,
  $ZodNaN,
  $ZodNanoID,
  $ZodNever,
  $ZodNonOptional,
  $ZodNull,
  $ZodNullable,
  $ZodNumber,
  $ZodNumberFormat,
  $ZodObject,
  $ZodObjectJIT,
  $ZodOptional,
  $ZodPipe,
  $ZodPrefault,
  $ZodPromise,
  $ZodReadonly,
  $ZodRealError,
  $ZodRecord,
  $ZodRegistry,
  $ZodSet,
  $ZodString,
  $ZodStringFormat,
  $ZodSuccess,
  $ZodSymbol,
  $ZodTemplateLiteral,
  $ZodTransform,
  $ZodTuple,
  $ZodType,
  $ZodULID,
  $ZodURL,
  $ZodUUID,
  $ZodUndefined,
  $ZodUnion,
  $ZodUnknown,
  $ZodVoid,
  $ZodXID,
  $ZodXor,
  $brand,
  $constructor,
  $input,
  $output,
  Doc,
  JSONSchema: jsonSchema,
  JSONSchemaGenerator,
  NEVER,
  TimePrecision,
  _any,
  _array,
  _base64,
  _base64url,
  _bigint,
  _boolean,
  _catch: _catch$1,
  _check,
  _cidrv4,
  _cidrv6,
  _coercedBigint,
  _coercedBoolean,
  _coercedDate,
  _coercedNumber,
  _coercedString,
  _cuid,
  _cuid2,
  _custom,
  _date,
  _decode,
  _decodeAsync,
  _default: _default$1,
  _discriminatedUnion,
  _e164,
  _email,
  _emoji,
  _encode,
  _encodeAsync,
  _endsWith,
  _enum: _enum$1,
  _file,
  _float32,
  _float64,
  _gt,
  _gte,
  _guid,
  _includes,
  _int,
  _int32,
  _int64,
  _intersection,
  _ipv4,
  _ipv6,
  _isoDate,
  _isoDateTime,
  _isoDuration,
  _isoTime,
  _jwt,
  _ksuid,
  _lazy,
  _length,
  _literal,
  _lowercase,
  _lt,
  _lte,
  _mac,
  _map,
  _max: _lte,
  _maxLength,
  _maxSize,
  _mime,
  _min: _gte,
  _minLength,
  _minSize,
  _multipleOf,
  _nan,
  _nanoid,
  _nativeEnum,
  _negative,
  _never,
  _nonnegative,
  _nonoptional,
  _nonpositive,
  _normalize,
  _null: _null$1,
  _nullable,
  _number,
  _optional,
  _overwrite,
  _parse,
  _parseAsync,
  _pipe,
  _positive,
  _promise,
  _property,
  _readonly,
  _record,
  _refine,
  _regex,
  _safeDecode,
  _safeDecodeAsync,
  _safeEncode,
  _safeEncodeAsync,
  _safeParse,
  _safeParseAsync,
  _set,
  _size,
  _slugify,
  _startsWith,
  _string,
  _stringFormat,
  _stringbool,
  _success,
  _superRefine,
  _symbol,
  _templateLiteral,
  _toLowerCase,
  _toUpperCase,
  _transform,
  _trim,
  _tuple,
  _uint32,
  _uint64,
  _ulid,
  _undefined: _undefined$1,
  _union,
  _unknown,
  _uppercase,
  _url,
  _uuid,
  _uuidv4,
  _uuidv6,
  _uuidv7,
  _void: _void$1,
  _xid,
  _xor,
  clone,
  config,
  createStandardJSONSchemaMethod,
  createToJSONSchemaMethod,
  decode: decode$1,
  decodeAsync: decodeAsync$1,
  describe: describe$1,
  encode: encode$1,
  encodeAsync: encodeAsync$1,
  extractDefs,
  finalize,
  flattenError,
  formatError,
  globalConfig,
  globalRegistry,
  initializeContext,
  isValidBase64,
  isValidBase64URL,
  isValidJWT,
  locales: index$1,
  meta: meta$1,
  parse: parse$1,
  parseAsync: parseAsync$1,
  prettifyError,
  process: process$1,
  regexes,
  registry,
  safeDecode: safeDecode$1,
  safeDecodeAsync: safeDecodeAsync$1,
  safeEncode: safeEncode$1,
  safeEncodeAsync: safeEncodeAsync$1,
  safeParse: safeParse$1,
  safeParseAsync: safeParseAsync$1,
  toDotPath,
  toJSONSchema,
  treeifyError,
  util,
  version: version$1
}, Symbol.toStringTag, { value: "Module" }));
const _checks = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  endsWith: _endsWith,
  gt: _gt,
  gte: _gte,
  includes: _includes,
  length: _length,
  lowercase: _lowercase,
  lt: _lt,
  lte: _lte,
  maxLength: _maxLength,
  maxSize: _maxSize,
  mime: _mime,
  minLength: _minLength,
  minSize: _minSize,
  multipleOf: _multipleOf,
  negative: _negative,
  nonnegative: _nonnegative,
  nonpositive: _nonpositive,
  normalize: _normalize,
  overwrite: _overwrite,
  positive: _positive,
  property: _property,
  regex: _regex,
  size: _size,
  slugify: _slugify,
  startsWith: _startsWith,
  toLowerCase: _toLowerCase,
  toUpperCase: _toUpperCase,
  trim: _trim,
  uppercase: _uppercase
}, Symbol.toStringTag, { value: "Module" }));
const ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime(params) {
  return /* @__PURE__ */ _isoDateTime(ZodISODateTime, params);
}
const ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date$2(params) {
  return /* @__PURE__ */ _isoDate(ZodISODate, params);
}
const ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time(params) {
  return /* @__PURE__ */ _isoTime(ZodISOTime, params);
}
const ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration(params) {
  return /* @__PURE__ */ _isoDuration(ZodISODuration, params);
}
const _iso = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ZodISODate,
  ZodISODateTime,
  ZodISODuration,
  ZodISOTime,
  date: date$2,
  datetime,
  duration,
  time
}, Symbol.toStringTag, { value: "Module" }));
const initializer = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
const ZodError = $constructor("ZodError", initializer);
const ZodRealError = $constructor("ZodError", initializer, {
  Parent: Error
});
const parse2 = /* @__PURE__ */ _parse(ZodRealError);
const parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
const safeParse = /* @__PURE__ */ _safeParse(ZodRealError);
const safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);
const encode = /* @__PURE__ */ _encode(ZodRealError);
const decode = /* @__PURE__ */ _decode(ZodRealError);
const encodeAsync = /* @__PURE__ */ _encodeAsync(ZodRealError);
const decodeAsync = /* @__PURE__ */ _decodeAsync(ZodRealError);
const safeEncode = /* @__PURE__ */ _safeEncode(ZodRealError);
const safeDecode = /* @__PURE__ */ _safeDecode(ZodRealError);
const safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
const safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);
const ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  Object.assign(inst["~standard"], {
    jsonSchema: {
      input: createStandardJSONSchemaMethod(inst, "input"),
      output: createStandardJSONSchemaMethod(inst, "output")
    }
  });
  inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }), {
      parent: true
    });
  };
  inst.with = inst.check;
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta2) => {
    reg.add(inst, meta2);
    return inst;
  });
  inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode(inst, data, params);
  inst.decode = (data, params) => decode(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync(inst, data, params);
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(/* @__PURE__ */ _overwrite(fn));
  inst.optional = () => optional(inst);
  inst.exactOptional = () => exactOptional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  inst.apply = (fn) => fn(inst);
  return inst;
});
const _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => stringProcessor(inst, ctx, json2);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(/* @__PURE__ */ _regex(...args));
  inst.includes = (...args) => inst.check(/* @__PURE__ */ _includes(...args));
  inst.startsWith = (...args) => inst.check(/* @__PURE__ */ _startsWith(...args));
  inst.endsWith = (...args) => inst.check(/* @__PURE__ */ _endsWith(...args));
  inst.min = (...args) => inst.check(/* @__PURE__ */ _minLength(...args));
  inst.max = (...args) => inst.check(/* @__PURE__ */ _maxLength(...args));
  inst.length = (...args) => inst.check(/* @__PURE__ */ _length(...args));
  inst.nonempty = (...args) => inst.check(/* @__PURE__ */ _minLength(1, ...args));
  inst.lowercase = (params) => inst.check(/* @__PURE__ */ _lowercase(params));
  inst.uppercase = (params) => inst.check(/* @__PURE__ */ _uppercase(params));
  inst.trim = () => inst.check(/* @__PURE__ */ _trim());
  inst.normalize = (...args) => inst.check(/* @__PURE__ */ _normalize(...args));
  inst.toLowerCase = () => inst.check(/* @__PURE__ */ _toLowerCase());
  inst.toUpperCase = () => inst.check(/* @__PURE__ */ _toUpperCase());
  inst.slugify = () => inst.check(/* @__PURE__ */ _slugify());
});
const ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(/* @__PURE__ */ _email(ZodEmail, params));
  inst.url = (params) => inst.check(/* @__PURE__ */ _url(ZodURL, params));
  inst.jwt = (params) => inst.check(/* @__PURE__ */ _jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(/* @__PURE__ */ _emoji(ZodEmoji, params));
  inst.guid = (params) => inst.check(/* @__PURE__ */ _guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(/* @__PURE__ */ _uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(/* @__PURE__ */ _uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(/* @__PURE__ */ _uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(/* @__PURE__ */ _uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(/* @__PURE__ */ _nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(/* @__PURE__ */ _guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(/* @__PURE__ */ _cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(/* @__PURE__ */ _cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(/* @__PURE__ */ _ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(/* @__PURE__ */ _base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(/* @__PURE__ */ _base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(/* @__PURE__ */ _xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(/* @__PURE__ */ _ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(/* @__PURE__ */ _ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(/* @__PURE__ */ _ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(/* @__PURE__ */ _cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(/* @__PURE__ */ _cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(/* @__PURE__ */ _e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime(params));
  inst.date = (params) => inst.check(date$2(params));
  inst.time = (params) => inst.check(time(params));
  inst.duration = (params) => inst.check(duration(params));
});
function string$1(params) {
  return /* @__PURE__ */ _string(ZodString, params);
}
const ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
const ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email(params) {
  return /* @__PURE__ */ _email(ZodEmail, params);
}
const ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid(params) {
  return /* @__PURE__ */ _guid(ZodGUID, params);
}
const ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid(params) {
  return /* @__PURE__ */ _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return /* @__PURE__ */ _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return /* @__PURE__ */ _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return /* @__PURE__ */ _uuidv7(ZodUUID, params);
}
const ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return /* @__PURE__ */ _url(ZodURL, params);
}
function httpUrl(params) {
  return /* @__PURE__ */ _url(ZodURL, {
    protocol: /^https?$/,
    hostname: domain,
    ...normalizeParams(params)
  });
}
const ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji(params) {
  return /* @__PURE__ */ _emoji(ZodEmoji, params);
}
const ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid(params) {
  return /* @__PURE__ */ _nanoid(ZodNanoID, params);
}
const ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid(params) {
  return /* @__PURE__ */ _cuid(ZodCUID, params);
}
const ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid2(params) {
  return /* @__PURE__ */ _cuid2(ZodCUID2, params);
}
const ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid(params) {
  return /* @__PURE__ */ _ulid(ZodULID, params);
}
const ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid(params) {
  return /* @__PURE__ */ _xid(ZodXID, params);
}
const ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid(params) {
  return /* @__PURE__ */ _ksuid(ZodKSUID, params);
}
const ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv4(params) {
  return /* @__PURE__ */ _ipv4(ZodIPv4, params);
}
const ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
  $ZodMAC.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function mac(params) {
  return /* @__PURE__ */ _mac(ZodMAC, params);
}
const ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv6(params) {
  return /* @__PURE__ */ _ipv6(ZodIPv6, params);
}
const ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv4(params) {
  return /* @__PURE__ */ _cidrv4(ZodCIDRv4, params);
}
const ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv6(params) {
  return /* @__PURE__ */ _cidrv6(ZodCIDRv6, params);
}
const ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64(params) {
  return /* @__PURE__ */ _base64(ZodBase64, params);
}
const ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url(params) {
  return /* @__PURE__ */ _base64url(ZodBase64URL, params);
}
const ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e164(params) {
  return /* @__PURE__ */ _e164(ZodE164, params);
}
const ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return /* @__PURE__ */ _jwt(ZodJWT, params);
}
const ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return /* @__PURE__ */ _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname(_params) {
  return /* @__PURE__ */ _stringFormat(ZodCustomStringFormat, "hostname", hostname$1, _params);
}
function hex(_params) {
  return /* @__PURE__ */ _stringFormat(ZodCustomStringFormat, "hex", hex$1, _params);
}
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = regexes[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return /* @__PURE__ */ _stringFormat(ZodCustomStringFormat, format, regex, params);
}
const ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => numberProcessor(inst, ctx, json2);
  inst.gt = (value, params) => inst.check(/* @__PURE__ */ _gt(value, params));
  inst.gte = (value, params) => inst.check(/* @__PURE__ */ _gte(value, params));
  inst.min = (value, params) => inst.check(/* @__PURE__ */ _gte(value, params));
  inst.lt = (value, params) => inst.check(/* @__PURE__ */ _lt(value, params));
  inst.lte = (value, params) => inst.check(/* @__PURE__ */ _lte(value, params));
  inst.max = (value, params) => inst.check(/* @__PURE__ */ _lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(/* @__PURE__ */ _gt(0, params));
  inst.nonnegative = (params) => inst.check(/* @__PURE__ */ _gte(0, params));
  inst.negative = (params) => inst.check(/* @__PURE__ */ _lt(0, params));
  inst.nonpositive = (params) => inst.check(/* @__PURE__ */ _lte(0, params));
  inst.multipleOf = (value, params) => inst.check(/* @__PURE__ */ _multipleOf(value, params));
  inst.step = (value, params) => inst.check(/* @__PURE__ */ _multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number$1(params) {
  return /* @__PURE__ */ _number(ZodNumber, params);
}
const ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return /* @__PURE__ */ _int(ZodNumberFormat, params);
}
function float32(params) {
  return /* @__PURE__ */ _float32(ZodNumberFormat, params);
}
function float64(params) {
  return /* @__PURE__ */ _float64(ZodNumberFormat, params);
}
function int32(params) {
  return /* @__PURE__ */ _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return /* @__PURE__ */ _uint32(ZodNumberFormat, params);
}
const ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => booleanProcessor(inst, ctx, json2);
});
function boolean$1(params) {
  return /* @__PURE__ */ _boolean(ZodBoolean, params);
}
const ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => bigintProcessor(inst, ctx);
  inst.gte = (value, params) => inst.check(/* @__PURE__ */ _gte(value, params));
  inst.min = (value, params) => inst.check(/* @__PURE__ */ _gte(value, params));
  inst.gt = (value, params) => inst.check(/* @__PURE__ */ _gt(value, params));
  inst.gte = (value, params) => inst.check(/* @__PURE__ */ _gte(value, params));
  inst.min = (value, params) => inst.check(/* @__PURE__ */ _gte(value, params));
  inst.lt = (value, params) => inst.check(/* @__PURE__ */ _lt(value, params));
  inst.lte = (value, params) => inst.check(/* @__PURE__ */ _lte(value, params));
  inst.max = (value, params) => inst.check(/* @__PURE__ */ _lte(value, params));
  inst.positive = (params) => inst.check(/* @__PURE__ */ _gt(BigInt(0), params));
  inst.negative = (params) => inst.check(/* @__PURE__ */ _lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(/* @__PURE__ */ _lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(/* @__PURE__ */ _gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(/* @__PURE__ */ _multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint$1(params) {
  return /* @__PURE__ */ _bigint(ZodBigInt, params);
}
const ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return /* @__PURE__ */ _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return /* @__PURE__ */ _uint64(ZodBigIntFormat, params);
}
const ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => symbolProcessor(inst, ctx);
});
function symbol(params) {
  return /* @__PURE__ */ _symbol(ZodSymbol, params);
}
const ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => undefinedProcessor(inst, ctx);
});
function _undefined(params) {
  return /* @__PURE__ */ _undefined$1(ZodUndefined, params);
}
const ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => nullProcessor(inst, ctx, json2);
});
function _null(params) {
  return /* @__PURE__ */ _null$1(ZodNull, params);
}
const ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => anyProcessor();
});
function any() {
  return /* @__PURE__ */ _any(ZodAny);
}
const ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => unknownProcessor();
});
function unknown() {
  return /* @__PURE__ */ _unknown(ZodUnknown);
}
const ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => neverProcessor(inst, ctx, json2);
});
function never(params) {
  return /* @__PURE__ */ _never(ZodNever, params);
}
const ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => voidProcessor(inst, ctx);
});
function _void(params) {
  return /* @__PURE__ */ _void$1(ZodVoid, params);
}
const ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => dateProcessor(inst, ctx);
  inst.min = (value, params) => inst.check(/* @__PURE__ */ _gte(value, params));
  inst.max = (value, params) => inst.check(/* @__PURE__ */ _lte(value, params));
  const c2 = inst._zod.bag;
  inst.minDate = c2.minimum ? new Date(c2.minimum) : null;
  inst.maxDate = c2.maximum ? new Date(c2.maximum) : null;
});
function date$1(params) {
  return /* @__PURE__ */ _date(ZodDate, params);
}
const ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => arrayProcessor(inst, ctx, json2, params);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(/* @__PURE__ */ _minLength(minLength, params));
  inst.nonempty = (params) => inst.check(/* @__PURE__ */ _minLength(1, params));
  inst.max = (maxLength, params) => inst.check(/* @__PURE__ */ _maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(/* @__PURE__ */ _length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return /* @__PURE__ */ _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum(Object.keys(shape));
}
const ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => objectProcessor(inst, ctx, json2, params);
  defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return safeExtend(inst, incoming);
  };
  inst.merge = (other) => merge(inst, other);
  inst.pick = (mask) => pick(inst, mask);
  inst.omit = (mask) => omit(inst, mask);
  inst.partial = (...args) => partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...normalizeParams(params)
  });
}
const ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
const ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodXor.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params);
  inst.options = def.options;
});
function xor(options, params) {
  return new ZodXor({
    type: "union",
    options,
    inclusive: false,
    ...normalizeParams(params)
  });
}
const ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
const ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => intersectionProcessor(inst, ctx, json2, params);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
const ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => tupleProcessor(inst, ctx, json2, params);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
const ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => recordProcessor(inst, ctx, json2, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone(keyType);
  k._zod.values = void 0;
  return new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...normalizeParams(params)
  });
}
function looseRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...normalizeParams(params)
  });
}
const ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => mapProcessor(inst, ctx);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
  inst.min = (...args) => inst.check(/* @__PURE__ */ _minSize(...args));
  inst.nonempty = (params) => inst.check(/* @__PURE__ */ _minSize(1, params));
  inst.max = (...args) => inst.check(/* @__PURE__ */ _maxSize(...args));
  inst.size = (...args) => inst.check(/* @__PURE__ */ _size(...args));
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
const ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => setProcessor(inst, ctx);
  inst.min = (...args) => inst.check(/* @__PURE__ */ _minSize(...args));
  inst.nonempty = (params) => inst.check(/* @__PURE__ */ _minSize(1, params));
  inst.max = (...args) => inst.check(/* @__PURE__ */ _maxSize(...args));
  inst.size = (...args) => inst.check(/* @__PURE__ */ _size(...args));
});
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
const ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => enumProcessor(inst, ctx, json2);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
const ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => literalProcessor(inst, ctx, json2);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
const ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => fileProcessor(inst, ctx, json2);
  inst.min = (size, params) => inst.check(/* @__PURE__ */ _minSize(size, params));
  inst.max = (size, params) => inst.check(/* @__PURE__ */ _maxSize(size, params));
  inst.mime = (types2, params) => inst.check(/* @__PURE__ */ _mime(Array.isArray(types2) ? types2 : [types2], params));
});
function file(params) {
  return /* @__PURE__ */ _file(ZodFile, params);
}
const ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => transformProcessor(inst, ctx);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue$1) => {
      if (typeof issue$1 === "string") {
        payload.issues.push(issue(issue$1, payload.value, def));
      } else {
        const _issue = issue$1;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(issue(_issue));
      }
    };
    const output2 = def.transform(payload.value, payload);
    if (output2 instanceof Promise) {
      return output2.then((output3) => {
        payload.value = output3;
        return payload;
      });
    }
    payload.value = output2;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
const ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
const ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
  $ZodExactOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
const ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => nullableProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish(innerType) {
  return optional(nullable(innerType));
}
const ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => defaultProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
const ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => prefaultProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
const ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => nonoptionalProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
const ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => successProcessor(inst, ctx, json2);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
const ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => catchProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
const ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => nanProcessor(inst, ctx);
});
function nan(params) {
  return /* @__PURE__ */ _nan(ZodNaN, params);
}
const ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => pipeProcessor(inst, ctx, json2, params);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
const ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def);
  $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
const ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => readonlyProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
const ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => templateLiteralProcessor(inst, ctx, json2);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
const ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => lazyProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
const ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => promiseProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
const ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => functionProcessor(inst, ctx);
});
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
const ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => customProcessor(inst, ctx);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return /* @__PURE__ */ _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return /* @__PURE__ */ _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return /* @__PURE__ */ _superRefine(fn);
}
const describe = describe$1;
const meta = meta$1;
function _instanceof(cls, params = {}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  inst._zod.check = (payload) => {
    if (!(payload.value instanceof cls)) {
      payload.issues.push({
        code: "invalid_type",
        expected: cls.name,
        input: payload.value,
        inst,
        path: [...inst._zod.def.path ?? []]
      });
    }
  };
  return inst;
}
const stringbool = (...args) => /* @__PURE__ */ _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean,
  String: ZodString
}, ...args);
function json(params) {
  const jsonSchema2 = lazy(() => {
    return union([string$1(params), number$1(), boolean$1(), _null(), array(jsonSchema2), record(string$1(), jsonSchema2)]);
  });
  return jsonSchema2;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}
const _schemas = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ZodAny,
  ZodArray,
  ZodBase64,
  ZodBase64URL,
  ZodBigInt,
  ZodBigIntFormat,
  ZodBoolean,
  ZodCIDRv4,
  ZodCIDRv6,
  ZodCUID,
  ZodCUID2,
  ZodCatch,
  ZodCodec,
  ZodCustom,
  ZodCustomStringFormat,
  ZodDate,
  ZodDefault,
  ZodDiscriminatedUnion,
  ZodE164,
  ZodEmail,
  ZodEmoji,
  ZodEnum,
  ZodExactOptional,
  ZodFile,
  ZodFunction,
  ZodGUID,
  ZodIPv4,
  ZodIPv6,
  ZodIntersection,
  ZodJWT,
  ZodKSUID,
  ZodLazy,
  ZodLiteral,
  ZodMAC,
  ZodMap,
  ZodNaN,
  ZodNanoID,
  ZodNever,
  ZodNonOptional,
  ZodNull,
  ZodNullable,
  ZodNumber,
  ZodNumberFormat,
  ZodObject,
  ZodOptional,
  ZodPipe,
  ZodPrefault,
  ZodPromise,
  ZodReadonly,
  ZodRecord,
  ZodSet,
  ZodString,
  ZodStringFormat,
  ZodSuccess,
  ZodSymbol,
  ZodTemplateLiteral,
  ZodTransform,
  ZodTuple,
  ZodType,
  ZodULID,
  ZodURL,
  ZodUUID,
  ZodUndefined,
  ZodUnion,
  ZodUnknown,
  ZodVoid,
  ZodXID,
  ZodXor,
  _ZodString,
  _default,
  _function,
  any,
  array,
  base64,
  base64url,
  bigint: bigint$1,
  boolean: boolean$1,
  catch: _catch,
  check,
  cidrv4,
  cidrv6,
  codec,
  cuid,
  cuid2,
  custom,
  date: date$1,
  describe,
  discriminatedUnion,
  e164,
  email,
  emoji,
  enum: _enum,
  exactOptional,
  file,
  float32,
  float64,
  function: _function,
  guid,
  hash,
  hex,
  hostname,
  httpUrl,
  instanceof: _instanceof,
  int,
  int32,
  int64,
  intersection,
  ipv4,
  ipv6,
  json,
  jwt,
  keyof,
  ksuid,
  lazy,
  literal,
  looseObject,
  looseRecord,
  mac,
  map,
  meta,
  nan,
  nanoid,
  nativeEnum,
  never,
  nonoptional,
  null: _null,
  nullable,
  nullish,
  number: number$1,
  object,
  optional,
  partialRecord,
  pipe,
  prefault,
  preprocess,
  promise,
  readonly,
  record,
  refine,
  set,
  strictObject,
  string: string$1,
  stringFormat,
  stringbool,
  success,
  superRefine,
  symbol,
  templateLiteral,
  transform,
  tuple,
  uint32,
  uint64,
  ulid,
  undefined: _undefined,
  union,
  unknown,
  url,
  uuid,
  uuidv4,
  uuidv6,
  uuidv7,
  void: _void,
  xid,
  xor
}, Symbol.toStringTag, { value: "Module" }));
const ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map2) {
  config({
    customError: map2
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodFirstPartyTypeKind;
/* @__PURE__ */ (function(ZodFirstPartyTypeKind2) {
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const z$1 = {
  ..._schemas,
  ..._checks,
  iso: _iso
};
const RECOGNIZED_KEYS = /* @__PURE__ */ new Set([
  // Schema identification
  "$schema",
  "$ref",
  "$defs",
  "definitions",
  // Core schema keywords
  "$id",
  "id",
  "$comment",
  "$anchor",
  "$vocabulary",
  "$dynamicRef",
  "$dynamicAnchor",
  // Type
  "type",
  "enum",
  "const",
  // Composition
  "anyOf",
  "oneOf",
  "allOf",
  "not",
  // Object
  "properties",
  "required",
  "additionalProperties",
  "patternProperties",
  "propertyNames",
  "minProperties",
  "maxProperties",
  // Array
  "items",
  "prefixItems",
  "additionalItems",
  "minItems",
  "maxItems",
  "uniqueItems",
  "contains",
  "minContains",
  "maxContains",
  // String
  "minLength",
  "maxLength",
  "pattern",
  "format",
  // Number
  "minimum",
  "maximum",
  "exclusiveMinimum",
  "exclusiveMaximum",
  "multipleOf",
  // Already handled metadata
  "description",
  "default",
  // Content
  "contentEncoding",
  "contentMediaType",
  "contentSchema",
  // Unsupported (error-throwing)
  "unevaluatedItems",
  "unevaluatedProperties",
  "if",
  "then",
  "else",
  "dependentSchemas",
  "dependentRequired",
  // OpenAPI
  "nullable",
  "readOnly"
]);
function detectVersion(schema, defaultTarget) {
  const $schema = schema.$schema;
  if ($schema === "https://json-schema.org/draft/2020-12/schema") {
    return "draft-2020-12";
  }
  if ($schema === "http://json-schema.org/draft-07/schema#") {
    return "draft-7";
  }
  if ($schema === "http://json-schema.org/draft-04/schema#") {
    return "draft-4";
  }
  return defaultTarget ?? "draft-2020-12";
}
function resolveRef(ref2, ctx) {
  if (!ref2.startsWith("#")) {
    throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
  }
  const path2 = ref2.slice(1).split("/").filter(Boolean);
  if (path2.length === 0) {
    return ctx.rootSchema;
  }
  const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
  if (path2[0] === defsKey) {
    const key2 = path2[1];
    if (!key2 || !ctx.defs[key2]) {
      throw new Error(`Reference not found: ${ref2}`);
    }
    return ctx.defs[key2];
  }
  throw new Error(`Reference not found: ${ref2}`);
}
function convertBaseSchema(schema, ctx) {
  if (schema.not !== void 0) {
    if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) {
      return z$1.never();
    }
    throw new Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (schema.unevaluatedItems !== void 0) {
    throw new Error("unevaluatedItems is not supported");
  }
  if (schema.unevaluatedProperties !== void 0) {
    throw new Error("unevaluatedProperties is not supported");
  }
  if (schema.if !== void 0 || schema.then !== void 0 || schema.else !== void 0) {
    throw new Error("Conditional schemas (if/then/else) are not supported");
  }
  if (schema.dependentSchemas !== void 0 || schema.dependentRequired !== void 0) {
    throw new Error("dependentSchemas and dependentRequired are not supported");
  }
  if (schema.$ref) {
    const refPath = schema.$ref;
    if (ctx.refs.has(refPath)) {
      return ctx.refs.get(refPath);
    }
    if (ctx.processing.has(refPath)) {
      return z$1.lazy(() => {
        if (!ctx.refs.has(refPath)) {
          throw new Error(`Circular reference not resolved: ${refPath}`);
        }
        return ctx.refs.get(refPath);
      });
    }
    ctx.processing.add(refPath);
    const resolved = resolveRef(refPath, ctx);
    const zodSchema2 = convertSchema(resolved, ctx);
    ctx.refs.set(refPath, zodSchema2);
    ctx.processing.delete(refPath);
    return zodSchema2;
  }
  if (schema.enum !== void 0) {
    const enumValues = schema.enum;
    if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
      return z$1.null();
    }
    if (enumValues.length === 0) {
      return z$1.never();
    }
    if (enumValues.length === 1) {
      return z$1.literal(enumValues[0]);
    }
    if (enumValues.every((v) => typeof v === "string")) {
      return z$1.enum(enumValues);
    }
    const literalSchemas = enumValues.map((v) => z$1.literal(v));
    if (literalSchemas.length < 2) {
      return literalSchemas[0];
    }
    return z$1.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
  }
  if (schema.const !== void 0) {
    return z$1.literal(schema.const);
  }
  const type2 = schema.type;
  if (Array.isArray(type2)) {
    const typeSchemas = type2.map((t) => {
      const typeSchema = { ...schema, type: t };
      return convertBaseSchema(typeSchema, ctx);
    });
    if (typeSchemas.length === 0) {
      return z$1.never();
    }
    if (typeSchemas.length === 1) {
      return typeSchemas[0];
    }
    return z$1.union(typeSchemas);
  }
  if (!type2) {
    return z$1.any();
  }
  let zodSchema;
  switch (type2) {
    case "string": {
      let stringSchema = z$1.string();
      if (schema.format) {
        const format = schema.format;
        if (format === "email") {
          stringSchema = stringSchema.check(z$1.email());
        } else if (format === "uri" || format === "uri-reference") {
          stringSchema = stringSchema.check(z$1.url());
        } else if (format === "uuid" || format === "guid") {
          stringSchema = stringSchema.check(z$1.uuid());
        } else if (format === "date-time") {
          stringSchema = stringSchema.check(z$1.iso.datetime());
        } else if (format === "date") {
          stringSchema = stringSchema.check(z$1.iso.date());
        } else if (format === "time") {
          stringSchema = stringSchema.check(z$1.iso.time());
        } else if (format === "duration") {
          stringSchema = stringSchema.check(z$1.iso.duration());
        } else if (format === "ipv4") {
          stringSchema = stringSchema.check(z$1.ipv4());
        } else if (format === "ipv6") {
          stringSchema = stringSchema.check(z$1.ipv6());
        } else if (format === "mac") {
          stringSchema = stringSchema.check(z$1.mac());
        } else if (format === "cidr") {
          stringSchema = stringSchema.check(z$1.cidrv4());
        } else if (format === "cidr-v6") {
          stringSchema = stringSchema.check(z$1.cidrv6());
        } else if (format === "base64") {
          stringSchema = stringSchema.check(z$1.base64());
        } else if (format === "base64url") {
          stringSchema = stringSchema.check(z$1.base64url());
        } else if (format === "e164") {
          stringSchema = stringSchema.check(z$1.e164());
        } else if (format === "jwt") {
          stringSchema = stringSchema.check(z$1.jwt());
        } else if (format === "emoji") {
          stringSchema = stringSchema.check(z$1.emoji());
        } else if (format === "nanoid") {
          stringSchema = stringSchema.check(z$1.nanoid());
        } else if (format === "cuid") {
          stringSchema = stringSchema.check(z$1.cuid());
        } else if (format === "cuid2") {
          stringSchema = stringSchema.check(z$1.cuid2());
        } else if (format === "ulid") {
          stringSchema = stringSchema.check(z$1.ulid());
        } else if (format === "xid") {
          stringSchema = stringSchema.check(z$1.xid());
        } else if (format === "ksuid") {
          stringSchema = stringSchema.check(z$1.ksuid());
        }
      }
      if (typeof schema.minLength === "number") {
        stringSchema = stringSchema.min(schema.minLength);
      }
      if (typeof schema.maxLength === "number") {
        stringSchema = stringSchema.max(schema.maxLength);
      }
      if (schema.pattern) {
        stringSchema = stringSchema.regex(new RegExp(schema.pattern));
      }
      zodSchema = stringSchema;
      break;
    }
    case "number":
    case "integer": {
      let numberSchema = type2 === "integer" ? z$1.number().int() : z$1.number();
      if (typeof schema.minimum === "number") {
        numberSchema = numberSchema.min(schema.minimum);
      }
      if (typeof schema.maximum === "number") {
        numberSchema = numberSchema.max(schema.maximum);
      }
      if (typeof schema.exclusiveMinimum === "number") {
        numberSchema = numberSchema.gt(schema.exclusiveMinimum);
      } else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") {
        numberSchema = numberSchema.gt(schema.minimum);
      }
      if (typeof schema.exclusiveMaximum === "number") {
        numberSchema = numberSchema.lt(schema.exclusiveMaximum);
      } else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") {
        numberSchema = numberSchema.lt(schema.maximum);
      }
      if (typeof schema.multipleOf === "number") {
        numberSchema = numberSchema.multipleOf(schema.multipleOf);
      }
      zodSchema = numberSchema;
      break;
    }
    case "boolean": {
      zodSchema = z$1.boolean();
      break;
    }
    case "null": {
      zodSchema = z$1.null();
      break;
    }
    case "object": {
      const shape = {};
      const properties = schema.properties || {};
      const requiredSet = new Set(schema.required || []);
      for (const [key2, propSchema] of Object.entries(properties)) {
        const propZodSchema = convertSchema(propSchema, ctx);
        shape[key2] = requiredSet.has(key2) ? propZodSchema : propZodSchema.optional();
      }
      if (schema.propertyNames) {
        const keySchema = convertSchema(schema.propertyNames, ctx);
        const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z$1.any();
        if (Object.keys(shape).length === 0) {
          zodSchema = z$1.record(keySchema, valueSchema);
          break;
        }
        const objectSchema2 = z$1.object(shape).passthrough();
        const recordSchema = z$1.looseRecord(keySchema, valueSchema);
        zodSchema = z$1.intersection(objectSchema2, recordSchema);
        break;
      }
      if (schema.patternProperties) {
        const patternProps = schema.patternProperties;
        const patternKeys = Object.keys(patternProps);
        const looseRecords = [];
        for (const pattern2 of patternKeys) {
          const patternValue = convertSchema(patternProps[pattern2], ctx);
          const keySchema = z$1.string().regex(new RegExp(pattern2));
          looseRecords.push(z$1.looseRecord(keySchema, patternValue));
        }
        const schemasToIntersect = [];
        if (Object.keys(shape).length > 0) {
          schemasToIntersect.push(z$1.object(shape).passthrough());
        }
        schemasToIntersect.push(...looseRecords);
        if (schemasToIntersect.length === 0) {
          zodSchema = z$1.object({}).passthrough();
        } else if (schemasToIntersect.length === 1) {
          zodSchema = schemasToIntersect[0];
        } else {
          let result = z$1.intersection(schemasToIntersect[0], schemasToIntersect[1]);
          for (let i = 2; i < schemasToIntersect.length; i++) {
            result = z$1.intersection(result, schemasToIntersect[i]);
          }
          zodSchema = result;
        }
        break;
      }
      const objectSchema = z$1.object(shape);
      if (schema.additionalProperties === false) {
        zodSchema = objectSchema.strict();
      } else if (typeof schema.additionalProperties === "object") {
        zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
      } else {
        zodSchema = objectSchema.passthrough();
      }
      break;
    }
    case "array": {
      const prefixItems = schema.prefixItems;
      const items = schema.items;
      if (prefixItems && Array.isArray(prefixItems)) {
        const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
        const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : void 0;
        if (rest) {
          zodSchema = z$1.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z$1.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z$1.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z$1.maxLength(schema.maxItems));
        }
      } else if (Array.isArray(items)) {
        const tupleItems = items.map((item) => convertSchema(item, ctx));
        const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : void 0;
        if (rest) {
          zodSchema = z$1.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z$1.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z$1.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z$1.maxLength(schema.maxItems));
        }
      } else if (items !== void 0) {
        const element = convertSchema(items, ctx);
        let arraySchema = z$1.array(element);
        if (typeof schema.minItems === "number") {
          arraySchema = arraySchema.min(schema.minItems);
        }
        if (typeof schema.maxItems === "number") {
          arraySchema = arraySchema.max(schema.maxItems);
        }
        zodSchema = arraySchema;
      } else {
        zodSchema = z$1.array(z$1.any());
      }
      break;
    }
    default:
      throw new Error(`Unsupported type: ${type2}`);
  }
  if (schema.description) {
    zodSchema = zodSchema.describe(schema.description);
  }
  if (schema.default !== void 0) {
    zodSchema = zodSchema.default(schema.default);
  }
  return zodSchema;
}
function convertSchema(schema, ctx) {
  if (typeof schema === "boolean") {
    return schema ? z$1.any() : z$1.never();
  }
  let baseSchema = convertBaseSchema(schema, ctx);
  const hasExplicitType = schema.type || schema.enum !== void 0 || schema.const !== void 0;
  if (schema.anyOf && Array.isArray(schema.anyOf)) {
    const options = schema.anyOf.map((s) => convertSchema(s, ctx));
    const anyOfUnion = z$1.union(options);
    baseSchema = hasExplicitType ? z$1.intersection(baseSchema, anyOfUnion) : anyOfUnion;
  }
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    const options = schema.oneOf.map((s) => convertSchema(s, ctx));
    const oneOfUnion = z$1.xor(options);
    baseSchema = hasExplicitType ? z$1.intersection(baseSchema, oneOfUnion) : oneOfUnion;
  }
  if (schema.allOf && Array.isArray(schema.allOf)) {
    if (schema.allOf.length === 0) {
      baseSchema = hasExplicitType ? baseSchema : z$1.any();
    } else {
      let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);
      const startIdx = hasExplicitType ? 0 : 1;
      for (let i = startIdx; i < schema.allOf.length; i++) {
        result = z$1.intersection(result, convertSchema(schema.allOf[i], ctx));
      }
      baseSchema = result;
    }
  }
  if (schema.nullable === true && ctx.version === "openapi-3.0") {
    baseSchema = z$1.nullable(baseSchema);
  }
  if (schema.readOnly === true) {
    baseSchema = z$1.readonly(baseSchema);
  }
  const extraMeta = {};
  const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (const key2 of coreMetadataKeys) {
    if (key2 in schema) {
      extraMeta[key2] = schema[key2];
    }
  }
  const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (const key2 of contentMetadataKeys) {
    if (key2 in schema) {
      extraMeta[key2] = schema[key2];
    }
  }
  for (const key2 of Object.keys(schema)) {
    if (!RECOGNIZED_KEYS.has(key2)) {
      extraMeta[key2] = schema[key2];
    }
  }
  if (Object.keys(extraMeta).length > 0) {
    ctx.registry.add(baseSchema, extraMeta);
  }
  return baseSchema;
}
function fromJSONSchema(schema, params) {
  if (typeof schema === "boolean") {
    return schema ? z$1.any() : z$1.never();
  }
  const version2 = detectVersion(schema, params?.defaultTarget);
  const defs = schema.$defs || schema.definitions || {};
  const ctx = {
    version: version2,
    defs,
    refs: /* @__PURE__ */ new Map(),
    processing: /* @__PURE__ */ new Set(),
    rootSchema: schema,
    registry: params?.registry ?? globalRegistry
  };
  return convertSchema(schema, ctx);
}
function string(params) {
  return /* @__PURE__ */ _coercedString(ZodString, params);
}
function number(params) {
  return /* @__PURE__ */ _coercedNumber(ZodNumber, params);
}
function boolean(params) {
  return /* @__PURE__ */ _coercedBoolean(ZodBoolean, params);
}
function bigint(params) {
  return /* @__PURE__ */ _coercedBigint(ZodBigInt, params);
}
function date(params) {
  return /* @__PURE__ */ _coercedDate(ZodDate, params);
}
const coerce = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bigint,
  boolean,
  date,
  number,
  string
}, Symbol.toStringTag, { value: "Module" }));
config(en());
const z = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $brand,
  $input,
  $output,
  NEVER,
  TimePrecision,
  ZodAny,
  ZodArray,
  ZodBase64,
  ZodBase64URL,
  ZodBigInt,
  ZodBigIntFormat,
  ZodBoolean,
  ZodCIDRv4,
  ZodCIDRv6,
  ZodCUID,
  ZodCUID2,
  ZodCatch,
  ZodCodec,
  ZodCustom,
  ZodCustomStringFormat,
  ZodDate,
  ZodDefault,
  ZodDiscriminatedUnion,
  ZodE164,
  ZodEmail,
  ZodEmoji,
  ZodEnum,
  ZodError,
  ZodExactOptional,
  ZodFile,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  ZodFunction,
  ZodGUID,
  ZodIPv4,
  ZodIPv6,
  ZodISODate,
  ZodISODateTime,
  ZodISODuration,
  ZodISOTime,
  ZodIntersection,
  ZodIssueCode,
  ZodJWT,
  ZodKSUID,
  ZodLazy,
  ZodLiteral,
  ZodMAC,
  ZodMap,
  ZodNaN,
  ZodNanoID,
  ZodNever,
  ZodNonOptional,
  ZodNull,
  ZodNullable,
  ZodNumber,
  ZodNumberFormat,
  ZodObject,
  ZodOptional,
  ZodPipe,
  ZodPrefault,
  ZodPromise,
  ZodReadonly,
  ZodRealError,
  ZodRecord,
  ZodSet,
  ZodString,
  ZodStringFormat,
  ZodSuccess,
  ZodSymbol,
  ZodTemplateLiteral,
  ZodTransform,
  ZodTuple,
  ZodType,
  ZodULID,
  ZodURL,
  ZodUUID,
  ZodUndefined,
  ZodUnion,
  ZodUnknown,
  ZodVoid,
  ZodXID,
  ZodXor,
  _ZodString,
  _default,
  _function,
  any,
  array,
  base64,
  base64url,
  bigint: bigint$1,
  boolean: boolean$1,
  catch: _catch,
  check,
  cidrv4,
  cidrv6,
  clone,
  codec,
  coerce,
  config,
  core: index,
  cuid,
  cuid2,
  custom,
  date: date$1,
  decode,
  decodeAsync,
  describe,
  discriminatedUnion,
  e164,
  email,
  emoji,
  encode,
  encodeAsync,
  endsWith: _endsWith,
  enum: _enum,
  exactOptional,
  file,
  flattenError,
  float32,
  float64,
  formatError,
  fromJSONSchema,
  function: _function,
  getErrorMap,
  globalRegistry,
  gt: _gt,
  gte: _gte,
  guid,
  hash,
  hex,
  hostname,
  httpUrl,
  includes: _includes,
  instanceof: _instanceof,
  int,
  int32,
  int64,
  intersection,
  ipv4,
  ipv6,
  iso: _iso,
  json,
  jwt,
  keyof,
  ksuid,
  lazy,
  length: _length,
  literal,
  locales: index$1,
  looseObject,
  looseRecord,
  lowercase: _lowercase,
  lt: _lt,
  lte: _lte,
  mac,
  map,
  maxLength: _maxLength,
  maxSize: _maxSize,
  meta,
  mime: _mime,
  minLength: _minLength,
  minSize: _minSize,
  multipleOf: _multipleOf,
  nan,
  nanoid,
  nativeEnum,
  negative: _negative,
  never,
  nonnegative: _nonnegative,
  nonoptional,
  nonpositive: _nonpositive,
  normalize: _normalize,
  null: _null,
  nullable,
  nullish,
  number: number$1,
  object,
  optional,
  overwrite: _overwrite,
  parse: parse2,
  parseAsync,
  partialRecord,
  pipe,
  positive: _positive,
  prefault,
  preprocess,
  prettifyError,
  promise,
  property: _property,
  readonly,
  record,
  refine,
  regex: _regex,
  regexes,
  registry,
  safeDecode,
  safeDecodeAsync,
  safeEncode,
  safeEncodeAsync,
  safeParse,
  safeParseAsync,
  set,
  setErrorMap,
  size: _size,
  slugify: _slugify,
  startsWith: _startsWith,
  strictObject,
  string: string$1,
  stringFormat,
  stringbool,
  success,
  superRefine,
  symbol,
  templateLiteral,
  toJSONSchema,
  toLowerCase: _toLowerCase,
  toUpperCase: _toUpperCase,
  transform,
  treeifyError,
  trim: _trim,
  tuple,
  uint32,
  uint64,
  ulid,
  undefined: _undefined,
  union,
  unknown,
  uppercase: _uppercase,
  url,
  util,
  uuid,
  uuidv4,
  uuidv6,
  uuidv7,
  void: _void,
  xid,
  xor
}, Symbol.toStringTag, { value: "Module" }));
function defineApi(endpoint, validator, outputTypeInfo, handler) {
  return { endpoint, validator, handler };
}
function Ok(data) {
  return { status: "ok", retcode: 0, data };
}
function Failed(retcode, message) {
  return { status: "failed", retcode, message };
}
function encodeZodIssues(issues) {
  return issues.map((issue2) => `[${issue2.code}] ${issue2.path.join("/")}: ${issue2.message}`).join(" ");
}
class MilkyApiCollection {
  constructor(ctx, apiList) {
    this.ctx = ctx;
    apiList.forEach((api) => {
      if (this.apiMap.has(api.endpoint)) {
        throw new Error(`API endpoint "${api.endpoint}" is already defined.`);
      }
      this.apiMap.set(api.endpoint, api);
    });
  }
  apiMap = /* @__PURE__ */ new Map();
  /**
   * Checks if the API endpoint is defined.
   */
  hasApi(endpoint) {
    return this.apiMap.has(endpoint);
  }
  async handle(endpoint, payload) {
    const api = this.apiMap.get(endpoint);
    try {
      const parsedPayload = api.validator.safeParse(payload);
      if (!parsedPayload.success) {
        return Failed(-400, "Invalid payload: " + encodeZodIssues(parsedPayload.error.issues));
      }
      const response2 = await api.handler(this.ctx, parsedPayload.data);
      if (response2.status === "failed") {
        this.ctx.logger.warn(
          "Milky",
          `Error while handling API /${endpoint}: ${response2.message}`
        );
      }
      return response2;
    } catch (e) {
      this.ctx.logger.warn(
        "Milky",
        `Error while handling API /${endpoint}: ${e instanceof Error ? e.message + "\n" + e.stack : String(e)}`
      );
      if (e instanceof ZodError) {
        return Failed(-400, "Zod error: " + encodeZodIssues(e.issues));
      }
      return Failed(500, "Internal error: " + (e instanceof Error ? e.message : String(e)));
    }
  }
}
class MilkyHttpHandler {
  constructor(milkyAdapter, ctx, config2) {
    this.milkyAdapter = milkyAdapter;
    this.ctx = ctx;
    this.config = config2;
  }
  eventPushClients = /* @__PURE__ */ new Set();
  sseClients = /* @__PURE__ */ new Set();
  app;
  httpServer;
  wsServer;
  /**
   * Extract token from Authorization header or query parameter
   */
  extractToken(headers, query) {
    const authHeader = headers["authorization"];
    if (authHeader?.toLowerCase().startsWith("bearer ")) {
      return authHeader.slice(7).trim();
    }
    return query?.["access_token"] ?? "";
  }
  /**
   * Validate access token
   */
  validateToken(inputToken) {
    if (!this.config.accessToken) return true;
    return inputToken === this.config.accessToken;
  }
  start() {
    this.app = express();
    this.app.use(cors());
    this.app.use(express.json({ limit: "1024mb" }));
    if (this.config.accessToken) {
      this.app.use(`${this.config.prefix}/api`, (req, res, next) => {
        if (req.headers["content-type"] !== "application/json") {
          this.ctx.logger.warn(
            "MilkyHttp",
            `${req.ip} -> ${req.path} (Content-Type not application/json)`
          );
          return res.status(415).json(Failed(-415, "Unsupported Media Type"));
        }
        const authorization = req.headers["authorization"];
        if (!authorization || !authorization.startsWith("Bearer ")) {
          this.ctx.logger.warn("MilkyHttp", `${req.ip} -> ${req.path} (Credentials missing)`);
          return res.status(401).json(Failed(-401, "Unauthorized"));
        }
        const inputToken = authorization.slice(7);
        if (inputToken !== this.config.accessToken) {
          this.ctx.logger.warn("MilkyHttp", `${req.ip} -> ${req.path} (Credentials wrong)`);
          return res.status(401).json(Failed(-401, "Unauthorized"));
        }
        next();
      });
    }
    this.app.post(`${this.config.prefix}/api/:endpoint`, async (req, res) => {
      const endpoint = req.params.endpoint;
      const payload = req.body;
      if (!this.milkyAdapter.apiCollection.hasApi(endpoint)) {
        this.ctx.logger.warn("MilkyHttp", `${req.ip} -> ${req.path} (API not found)`);
        return res.status(404).json(Failed(404, "API not found"));
      }
      const start = Date.now();
      const response2 = await this.milkyAdapter.apiCollection.handle(endpoint, payload);
      const end = Date.now();
      this.ctx.logger.info(
        "MilkyHttp",
        `${req.ip} -> ${req.path} (${response2.retcode === 0 ? "OK" : response2.retcode} ${end - start}ms)`,
        payload
      );
      return res.json(response2);
    });
    this.app.get("/event", (req, res) => {
      if (this.config.accessToken) {
        const inputToken = this.extractToken(req.headers, req.query);
        if (!this.validateToken(inputToken)) {
          this.ctx.logger.warn("MilkyHttp", `${req.ip} -> /event SSE (Credentials invalid)`);
          return res.status(401).json(Failed(-401, "Unauthorized"));
        }
      }
      res.setHeader("Content-Type", "text/event-stream; charset=utf-8");
      res.setHeader("Cache-Control", "no-cache");
      res.setHeader("Connection", "keep-alive");
      res.setHeader("X-Accel-Buffering", "no");
      res.flushHeaders();
      this.sseClients.add(res);
      this.ctx.logger.info("MilkyHttp", `${req.ip} -> /event SSE (Connected)`);
      req.on("close", () => {
        this.sseClients.delete(res);
        this.ctx.logger.info("MilkyHttp", `${req.ip} -> /event SSE (Disconnected)`);
      });
    });
    const host = this.config.onlyLocalhost ? "127.0.0.1" : "";
    this.httpServer = this.app.listen(this.config.port, host, () => {
      this.ctx.logger.info(
        "MilkyHttp",
        `HTTP server started at http://127.0.0.1:${this.config.port}${this.config.prefix}`
      );
    });
    this.wsServer = new WebSocketServer({
      server: this.httpServer,
      path: `${this.config.prefix}/event`,
      maxPayload: 1024 * 1024 * 1024
    });
    this.wsServer.on("connection", (ws, req) => {
      if (this.config.accessToken) {
        const url2 = new URL(req.url, `http://${req.headers.host}`);
        const query = Object.fromEntries(url2.searchParams.entries());
        const inputToken = this.extractToken(req.headers, query);
        if (!this.validateToken(inputToken)) {
          this.ctx.logger.warn("MilkyHttp", `${req.socket.remoteAddress} -> /event WS (Credentials invalid)`);
          ws.close(1008, "Unauthorized");
          return;
        }
      }
      this.eventPushClients.add(ws);
      this.ctx.logger.info("MilkyHttp", `${req.socket.remoteAddress} -> /event (Connected)`);
      ws.on("close", () => {
        this.eventPushClients.delete(ws);
        this.ctx.logger.info("MilkyHttp", `${req.socket.remoteAddress} -> /event (Disconnected)`);
      });
      ws.on("error", (error2) => {
        this.ctx.logger.warn("MilkyHttp", `WebSocket error: ${error2.message}`);
        this.eventPushClients.delete(ws);
      });
    });
  }
  stop() {
    for (const res of this.sseClients) {
      res.end();
    }
    this.sseClients.clear();
    this.wsServer?.close();
    this.httpServer?.close();
    this.app = void 0;
  }
  broadcast(msg) {
    for (const ws of this.eventPushClients) {
      try {
        if (ws.readyState === WebSocket$2.OPEN) {
          ws.send(msg);
        }
      } catch (e) {
        this.ctx.logger.warn("MilkyHttp", `Failed to send WebSocket message: ${e}`);
      }
    }
    for (const res of this.sseClients) {
      try {
        res.write(`data: ${msg}

`);
      } catch (e) {
        this.ctx.logger.warn("MilkyHttp", `Failed to send SSE message: ${e}`);
        this.sseClients.delete(res);
      }
    }
  }
  updateConfig(config2) {
    Object.assign(this.config, config2);
  }
}
class MilkyWebhookHandler {
  constructor(milkyAdapter, ctx, config2) {
    this.milkyAdapter = milkyAdapter;
    this.ctx = ctx;
    this.config = config2;
  }
  activated = false;
  start() {
    this.activated = true;
  }
  stop() {
    this.activated = false;
  }
  async broadcast(msg) {
    if (!this.activated || this.config.urls.length === 0) {
      return;
    }
    const sendResult = await Promise.allSettled(this.config.urls.map(async (url2) => {
      try {
        const headers = new Headers({
          "Content-Type": "application/json"
        });
        if (this.config.accessToken) {
          headers.append("Authorization", `Bearer ${this.config.accessToken}`);
        }
        await fetch(url2, {
          method: "POST",
          headers,
          body: msg
        });
      } catch (e) {
        this.ctx.logger.warn(
          "MilkyWebhook",
          `Failed to send message to ${url2}: ${e instanceof Error ? e.stack : e}`
        );
        throw e;
      }
    }));
    this.ctx.logger.debug(
      "MilkyWebhook",
      `Broadcasted message to ${sendResult.filter((result) => result.status === "fulfilled").length} URLs`
    );
  }
  updateConfig(config2) {
    Object.assign(this.config, config2);
  }
}
function transformGender(gender) {
  if (gender === Sex.Male) return "male";
  if (gender === Sex.Female) return "female";
  return "unknown";
}
function transformFriend(friend, category) {
  return {
    user_id: +friend.uin,
    nickname: friend.coreInfo.nick,
    sex: transformGender(friend.baseInfo.sex),
    qid: friend.baseInfo.qid,
    remark: friend.coreInfo.remark,
    category: {
      category_id: category.categoryId,
      category_name: category.categroyName
    }
  };
}
function transformGroup(group) {
  return {
    group_id: +group.groupCode,
    group_name: group.groupName,
    member_count: group.memberNum,
    max_member_count: group.maxMemberNum
  };
}
function transformGroupMemberRole(role) {
  if (role === 4) return "owner";
  if (role === 3) return "admin";
  return "member";
}
function transformGroupMember(member, groupId) {
  return {
    user_id: +member.uin,
    nickname: member.nick,
    sex: "unknown",
    group_id: groupId,
    card: member.cardName,
    title: member.memberSpecialTitle,
    level: member.memberRealLevel,
    role: transformGroupMemberRole(member.role),
    join_time: member.joinTime,
    last_sent_time: member.lastSpeakTime,
    shut_up_end_time: member.shutUpTime || void 0
  };
}
function transformGroupFileList(data) {
  const files = [];
  const folders = [];
  if (data.item.length === 0) {
    return { files, folders };
  }
  for (const item of data.item) {
    if (item.folderInfo) {
      folders.push({
        group_id: +item.peerId,
        folder_id: item.folderInfo.folderId,
        parent_folder_id: item.folderInfo.parentFolderId,
        folder_name: item.folderInfo.folderName,
        created_time: item.folderInfo.createTime,
        last_modified_time: item.folderInfo.modifyTime,
        creator_id: +item.folderInfo.createUin,
        file_count: item.folderInfo.totalFileCount
      });
    } else if (item.fileInfo) {
      files.push({
        group_id: +item.peerId,
        file_id: item.fileInfo.fileId,
        file_name: item.fileInfo.fileName,
        parent_folder_id: item.fileInfo.parentFolderId,
        file_size: +item.fileInfo.fileSize,
        uploaded_time: item.fileInfo.uploadTime,
        expire_time: item.fileInfo.deadTime || void 0,
        uploader_id: +item.fileInfo.uploaderUin,
        downloaded_times: item.fileInfo.downloadTimes
      });
    }
  }
  return { files, folders };
}
function transformProtocolOsType(type2) {
  if (type2 === "Linux") {
    return "linux";
  } else if (type2 === "Darwin") {
    return "macos";
  } else {
    return "windows";
  }
}
const ZInt32 = number$1().int().nonnegative().meta({ scalarType: "int32" });
const ZInt64 = number$1().int().nonnegative().meta({ scalarType: "int64" });
const ZBoolean = boolean$1().meta({ scalarType: "boolean" });
const ZString = string$1().meta({ scalarType: "string" });
const ZUin = number$1().int().min(10001).max(4294967295).meta({ scalarType: "int64" });
const ZInt32WithDefault = (defaultValue) => number$1().int().nonnegative().nullish().default(defaultValue).transform((v) => v ?? defaultValue).meta({ scalarType: "int32" });
const ZInt64WithDefault = (defaultValue) => number$1().int().nonnegative().nullish().default(defaultValue).transform((v) => v ?? defaultValue).meta({ scalarType: "int64" });
const ZBooleanWithDefault = (defaultValue) => boolean$1().nullish().default(defaultValue).transform((v) => v ?? defaultValue).meta({ scalarType: "boolean" });
const ZStringWithDefault = (defaultValue) => string$1().nullish().default(defaultValue).transform((v) => v ?? defaultValue).meta({ scalarType: "string" });
const UserEntityBase = object({
  user_id: ZUin.describe(" QQ "),
  nickname: ZString.describe(""),
  sex: _enum([
    "male",
    "female",
    "unknown"
  ]).describe("")
}).describe("");
const FriendCategoryEntity = object({
  category_id: ZInt32.describe(" ID"),
  category_name: ZString.describe("")
}).describe("");
const FriendEntity = UserEntityBase.extend({
  qid: ZString.describe(" QID"),
  remark: ZString.describe(""),
  category: lazy(() => FriendCategoryEntity).describe("")
}).describe("");
const GroupEntity = object({
  group_id: ZUin.describe(""),
  group_name: ZString.describe(""),
  member_count: ZInt32.describe(""),
  max_member_count: ZInt32.describe("")
}).describe("");
const GroupMemberEntity = UserEntityBase.extend({
  group_id: ZUin.describe(""),
  card: ZString.describe(""),
  title: ZString.describe(""),
  level: ZInt32.describe(" QQ "),
  role: _enum([
    "owner",
    "admin",
    "member"
  ]).describe(""),
  join_time: ZInt64.describe("Unix "),
  last_sent_time: ZInt64.describe("Unix "),
  shut_up_end_time: ZInt64.nullish().describe("Unix ")
}).describe("");
const GroupAnnouncementEntity = object({
  group_id: ZUin.describe(""),
  announcement_id: ZString.describe(" ID"),
  user_id: ZUin.describe(" QQ "),
  time: ZInt64.describe("Unix "),
  content: ZString.describe(""),
  image_url: ZString.nullish().describe(" URL")
}).describe("");
const GroupFileEntity = object({
  group_id: ZUin.describe(""),
  file_id: ZString.describe(" ID"),
  file_name: ZString.describe(""),
  parent_folder_id: ZString.describe(" ID"),
  file_size: ZInt64.describe(""),
  uploaded_time: ZInt64.describe(" Unix "),
  expire_time: ZInt64.nullish().describe(" Unix "),
  uploader_id: ZUin.describe(" QQ "),
  downloaded_times: ZInt32.describe("")
}).describe("");
const GroupFolderEntity = object({
  group_id: ZUin.describe(""),
  folder_id: ZString.describe(" ID"),
  parent_folder_id: ZString.describe(" ID"),
  folder_name: ZString.describe(""),
  created_time: ZInt64.describe(" Unix "),
  last_modified_time: ZInt64.describe(" Unix "),
  creator_id: ZUin.describe(" QQ "),
  file_count: ZInt32.describe("")
}).describe("");
const FriendRequest = object({
  time: ZInt64.describe(" Unix "),
  initiator_id: ZUin.describe(" QQ "),
  initiator_uid: ZString.describe(" UID"),
  target_user_id: ZUin.describe(" QQ "),
  target_user_uid: ZString.describe(" UID"),
  state: _enum([
    "pending",
    "accepted",
    "rejected",
    "ignored"
  ]).describe(""),
  comment: ZString.describe(""),
  via: ZString.describe(""),
  is_filtered: ZBoolean.describe("")
}).describe("");
const GroupNotification = discriminatedUnion("type", [
  object({
    type: literal("join_request"),
    group_id: ZUin.describe(""),
    notification_seq: ZInt64.describe(""),
    is_filtered: ZBoolean.describe(""),
    initiator_id: ZUin.describe(" QQ "),
    state: _enum([
      "pending",
      "accepted",
      "rejected",
      "ignored"
    ]).describe(""),
    operator_id: ZUin.nullish().describe(" QQ "),
    comment: ZString.describe("")
  }).describe(""),
  object({
    type: literal("admin_change"),
    group_id: ZUin.describe(""),
    notification_seq: ZInt64.describe(""),
    target_user_id: ZUin.describe("/ QQ "),
    is_set: ZBoolean.describe("`false` "),
    operator_id: ZUin.describe("QQ ")
  }).describe(""),
  object({
    type: literal("kick"),
    group_id: ZUin.describe(""),
    notification_seq: ZInt64.describe(""),
    target_user_id: ZUin.describe(" QQ "),
    operator_id: ZUin.describe(" QQ ")
  }).describe(""),
  object({
    type: literal("quit"),
    group_id: ZUin.describe(""),
    notification_seq: ZInt64.describe(""),
    target_user_id: ZUin.describe(" QQ ")
  }).describe(""),
  object({
    type: literal("invited_join_request"),
    group_id: ZUin.describe(""),
    notification_seq: ZInt64.describe(""),
    initiator_id: ZUin.describe(" QQ "),
    target_user_id: ZUin.describe(" QQ "),
    state: _enum([
      "pending",
      "accepted",
      "rejected",
      "ignored"
    ]).describe(""),
    operator_id: ZUin.nullish().describe(" QQ ")
  }).describe("")
]).describe("");
const IncomingResourceSegmentBase = object({
  resource_id: ZString.describe(" ID"),
  temp_url: ZString.describe(" URL")
});
const OutgoingResourceSegmentBase = object({ uri: ZString.describe(" URI `file://` `http(s)://` `base64://` ") });
const IncomingSegment = discriminatedUnion("type", [
  object({
    type: literal("text"),
    data: object({ text: ZString.describe("") })
  }).describe(""),
  object({
    type: literal("mention"),
    data: object({ user_id: ZUin.describe(" QQ ") })
  }).describe(""),
  object({
    type: literal("mention_all"),
    data: object({})
  }).describe(""),
  object({
    type: literal("face"),
    data: object({
      face_id: ZString.describe(" ID"),
      is_large: ZBoolean.describe("")
    })
  }).describe(""),
  object({
    type: literal("reply"),
    data: object({ message_seq: ZInt64.describe("") })
  }).describe(""),
  object({
    type: literal("image"),
    data: IncomingResourceSegmentBase.extend({
      width: ZInt32.describe(""),
      height: ZInt32.describe(""),
      summary: ZString.describe(""),
      sub_type: _enum(["normal", "sticker"]).describe("")
    })
  }).describe(""),
  object({
    type: literal("record"),
    data: IncomingResourceSegmentBase.extend({ duration: ZInt32.describe("") })
  }).describe(""),
  object({
    type: literal("video"),
    data: IncomingResourceSegmentBase.extend({
      width: ZInt32.describe(""),
      height: ZInt32.describe(""),
      duration: ZInt32.describe("")
    })
  }).describe(""),
  object({
    type: literal("file"),
    data: object({
      file_id: ZString.describe(" ID"),
      file_name: ZString.describe(""),
      file_size: ZInt64.describe(""),
      file_hash: ZString.nullish().describe(" TriSHA1 ")
    })
  }).describe(""),
  object({
    type: literal("forward"),
    data: object({
      forward_id: ZString.describe(" ID"),
      title: ZString.describe(""),
      preview: array(ZString).describe(""),
      summary: ZString.describe("")
    })
  }).describe(""),
  object({
    type: literal("market_face"),
    data: object({
      emoji_package_id: ZInt32.describe(" ID"),
      emoji_id: ZString.describe(" ID"),
      key: ZString.describe(" Key"),
      summary: ZString.describe(""),
      url: ZString.describe(" URL")
    })
  }).describe(""),
  object({
    type: literal("light_app"),
    data: object({
      app_name: ZString.describe(""),
      json_payload: ZString.describe(" JSON ")
    })
  }).describe(""),
  object({
    type: literal("xml"),
    data: object({
      service_id: ZInt32.describe(" ID"),
      xml_payload: ZString.describe("XML ")
    })
  }).describe("XML ")
]).describe("");
const IncomingForwardedMessage = object({
  sender_name: ZString.describe(""),
  avatar_url: ZString.describe(" URL"),
  time: ZInt64.describe(" Unix "),
  segments: array(lazy(() => IncomingSegment)).describe("")
}).describe("");
const OutgoingSegment = discriminatedUnion("type", [
  object({
    type: literal("text"),
    data: object({ text: ZString.describe("") })
  }).describe(""),
  object({
    type: literal("mention"),
    data: object({ user_id: ZUin.describe(" QQ ") })
  }).describe(""),
  object({
    type: literal("mention_all"),
    data: object({})
  }).describe(""),
  object({
    type: literal("face"),
    data: object({
      face_id: ZString.describe(" ID"),
      is_large: ZBoolean.default(false).describe("")
    })
  }).describe(""),
  object({
    type: literal("reply"),
    data: object({ message_seq: ZInt64.describe("") })
  }).describe(""),
  object({
    type: literal("image"),
    data: OutgoingResourceSegmentBase.extend({
      sub_type: _enum(["normal", "sticker"]).default("normal").describe(""),
      summary: ZString.nullish().describe("")
    })
  }).describe(""),
  object({
    type: literal("record"),
    data: OutgoingResourceSegmentBase
  }).describe(""),
  object({
    type: literal("video"),
    data: OutgoingResourceSegmentBase.extend({ thumb_uri: ZString.nullish().describe(" URI") })
  }).describe(""),
  object({
    type: literal("forward"),
    data: object({ get messages() {
      return array(lazy(() => OutgoingForwardedMessage)).describe("");
    } })
  }).describe("")
]).describe("");
const OutgoingForwardedMessage = object({
  user_id: ZUin.describe(" QQ "),
  sender_name: ZString.describe(""),
  segments: array(lazy(() => OutgoingSegment)).describe("")
}).describe("");
const IncomingMessage = discriminatedUnion("message_scene", [
  object({
    message_scene: literal("friend"),
    peer_id: ZUin.describe(" QQ "),
    message_seq: ZInt64.describe(""),
    sender_id: ZUin.describe(" QQ "),
    time: ZInt64.describe(" Unix "),
    segments: array(lazy(() => IncomingSegment)).describe(""),
    friend: lazy(() => FriendEntity).describe("")
  }).describe(""),
  object({
    message_scene: literal("group"),
    peer_id: ZUin.describe(" QQ "),
    message_seq: ZInt64.describe(""),
    sender_id: ZUin.describe(" QQ "),
    time: ZInt64.describe(" Unix "),
    segments: array(lazy(() => IncomingSegment)).describe(""),
    group: lazy(() => GroupEntity).describe(""),
    group_member: lazy(() => GroupMemberEntity).describe("")
  }).describe(""),
  object({
    message_scene: literal("temp"),
    peer_id: ZUin.describe(" QQ "),
    message_seq: ZInt64.describe(""),
    sender_id: ZUin.describe(" QQ "),
    time: ZInt64.describe(" Unix "),
    segments: array(lazy(() => IncomingSegment)).describe(""),
    group: lazy(() => GroupEntity).nullish().describe("")
  }).describe("")
]).describe("");
const GroupEssenceMessage = object({
  group_id: ZUin.describe(""),
  message_seq: ZInt64.describe(""),
  message_time: ZInt64.describe(" Unix "),
  sender_id: ZUin.describe(" QQ "),
  sender_name: ZString.describe(""),
  operator_id: ZUin.describe(" QQ "),
  operator_name: ZString.describe(""),
  operation_time: ZInt64.describe(" Unix "),
  segments: array(lazy(() => IncomingSegment)).describe("")
}).describe("");
const BotOfflineEvent = object({ reason: ZString.describe("") });
const MessageRecallEvent = object({
  message_scene: _enum([
    "friend",
    "group",
    "temp"
  ]).describe(""),
  peer_id: ZUin.describe(" QQ "),
  message_seq: ZInt64.describe(""),
  sender_id: ZUin.describe(" QQ "),
  operator_id: ZUin.describe(" QQ "),
  display_suffix: ZString.describe("")
});
const FriendRequestEvent = object({
  initiator_id: ZUin.describe(" QQ "),
  initiator_uid: ZString.describe(" UID"),
  comment: ZString.describe(""),
  via: ZString.describe("")
});
const GroupJoinRequestEvent = object({
  group_id: ZUin.describe(""),
  notification_seq: ZInt64.describe(""),
  is_filtered: ZBoolean.describe(""),
  initiator_id: ZUin.describe(" QQ "),
  comment: ZString.describe("")
});
const GroupInvitedJoinRequestEvent = object({
  group_id: ZUin.describe(""),
  notification_seq: ZInt64.describe(""),
  initiator_id: ZUin.describe(" QQ "),
  target_user_id: ZUin.describe(" QQ ")
});
const GroupInvitationEvent = object({
  group_id: ZUin.describe(""),
  invitation_seq: ZInt64.describe(""),
  initiator_id: ZUin.describe(" QQ ")
});
const FriendNudgeEvent = object({
  user_id: ZUin.describe(" QQ "),
  is_self_send: ZBoolean.describe(""),
  is_self_receive: ZBoolean.describe(""),
  display_action: ZString.describe(""),
  display_suffix: ZString.describe(""),
  display_action_img_url: ZString.describe(" URL")
});
const FriendFileUploadEvent = object({
  user_id: ZUin.describe(" QQ "),
  file_id: ZString.describe(" ID"),
  file_name: ZString.describe(""),
  file_size: ZInt64.describe(""),
  file_hash: ZString.describe(" TriSHA1 "),
  is_self: ZBoolean.describe("")
});
const GroupAdminChangeEvent = object({
  group_id: ZUin.describe(""),
  user_id: ZUin.describe(" QQ "),
  operator_id: ZUin.describe(" QQ "),
  is_set: ZBoolean.describe("`false` ")
});
const GroupEssenceMessageChangeEvent = object({
  group_id: ZUin.describe(""),
  message_seq: ZInt64.describe(""),
  operator_id: ZUin.describe(" QQ "),
  is_set: ZBoolean.describe("`false` ")
});
const GroupMemberIncreaseEvent = object({
  group_id: ZUin.describe(""),
  user_id: ZUin.describe(" QQ "),
  operator_id: ZUin.nullish().describe(" QQ "),
  invitor_id: ZUin.nullish().describe(" QQ ")
});
const GroupMemberDecreaseEvent = object({
  group_id: ZUin.describe(""),
  user_id: ZUin.describe(" QQ "),
  operator_id: ZUin.nullish().describe(" QQ ")
});
const GroupNameChangeEvent = object({
  group_id: ZUin.describe(""),
  new_group_name: ZString.describe(""),
  operator_id: ZUin.describe(" QQ ")
});
const GroupMessageReactionEvent = object({
  group_id: ZUin.describe(""),
  user_id: ZUin.describe(" QQ "),
  message_seq: ZInt64.describe(""),
  face_id: ZString.describe(" ID"),
  is_add: ZBoolean.describe("`false` ")
});
const GroupMuteEvent = object({
  group_id: ZUin.describe(""),
  user_id: ZUin.describe(" QQ "),
  operator_id: ZUin.describe(" QQ "),
  duration: ZInt32.describe(" 0 ")
});
const GroupWholeMuteEvent = object({
  group_id: ZUin.describe(""),
  operator_id: ZUin.describe(" QQ "),
  is_mute: ZBoolean.describe("`false` ")
});
const GroupNudgeEvent = object({
  group_id: ZUin.describe(""),
  sender_id: ZUin.describe(" QQ "),
  receiver_id: ZUin.describe(" QQ "),
  display_action: ZString.describe(""),
  display_suffix: ZString.describe(""),
  display_action_img_url: ZString.describe(" URL")
});
const GroupFileUploadEvent = object({
  group_id: ZUin.describe(""),
  user_id: ZUin.describe(" QQ "),
  file_id: ZString.describe(" ID"),
  file_name: ZString.describe(""),
  file_size: ZInt64.describe("")
});
discriminatedUnion("event_type", [
  object({
    event_type: literal("bot_offline"),
    time: ZInt64.describe(" Unix "),
    self_id: ZUin.describe(" QQ "),
    data: BotOfflineEvent
  }).describe(""),
  object({
    event_type: literal("message_receive"),
    time: ZInt64.describe(" Unix "),
    self_id: ZUin.describe(" QQ "),
    data: IncomingMessage
  }).describe(""),
  object({
    event_type: literal("message_recall"),
    time: ZInt64.describe(" Unix "),
    self_id: ZUin.describe(" QQ "),
    data: MessageRecallEvent
  }).describe(""),
  object({
    event_type: literal("friend_request"),
    time: ZInt64.describe(" Unix "),
    self_id: ZUin.describe(" QQ "),
    data: FriendRequestEvent
  }).describe(""),
  object({
    event_type: literal("group_join_request"),
    time: ZInt64.describe(" Unix "),
    self_id: ZUin.describe(" QQ "),
    data: GroupJoinRequestEvent
  }).describe(""),
  object({
    event_type: literal("group_invited_join_request"),
    time: ZInt64.describe(" Unix "),
    self_id: ZUin.describe(" QQ "),
    data: GroupInvitedJoinRequestEvent
  }).describe(""),
  object({
    event_type: literal("group_invitation"),
    time: ZInt64.describe(" Unix "),
    self_id: ZUin.describe(" QQ "),
    data: GroupInvitationEvent
  }).describe(""),
  object({
    event_type: literal("friend_nudge"),
    time: ZInt64.describe(" Unix "),
    self_id: ZUin.describe(" QQ "),
    data: FriendNudgeEvent
  }).describe(""),
  object({
    event_type: literal("friend_file_upload"),
    time: ZInt64.describe(" Unix "),
    self_id: ZUin.describe(" QQ "),
    data: FriendFileUploadEvent
  }).describe(""),
  object({
    event_type: literal("group_admin_change"),
    time: ZInt64.describe(" Unix "),
    self_id: ZUin.describe(" QQ "),
    data: GroupAdminChangeEvent
  }).describe(""),
  object({
    event_type: literal("group_essence_message_change"),
    time: ZInt64.describe(" Unix "),
    self_id: ZUin.describe(" QQ "),
    data: GroupEssenceMessageChangeEvent
  }).describe(""),
  object({
    event_type: literal("group_member_increase"),
    time: ZInt64.describe(" Unix "),
    self_id: ZUin.describe(" QQ "),
    data: GroupMemberIncreaseEvent
  }).describe(""),
  object({
    event_type: literal("group_member_decrease"),
    time: ZInt64.describe(" Unix "),
    self_id: ZUin.describe(" QQ "),
    data: GroupMemberDecreaseEvent
  }).describe(""),
  object({
    event_type: literal("group_name_change"),
    time: ZInt64.describe(" Unix "),
    self_id: ZUin.describe(" QQ "),
    data: GroupNameChangeEvent
  }).describe(""),
  object({
    event_type: literal("group_message_reaction"),
    time: ZInt64.describe(" Unix "),
    self_id: ZUin.describe(" QQ "),
    data: GroupMessageReactionEvent
  }).describe(""),
  object({
    event_type: literal("group_mute"),
    time: ZInt64.describe(" Unix "),
    self_id: ZUin.describe(" QQ "),
    data: GroupMuteEvent
  }).describe(""),
  object({
    event_type: literal("group_whole_mute"),
    time: ZInt64.describe(" Unix "),
    self_id: ZUin.describe(" QQ "),
    data: GroupWholeMuteEvent
  }).describe(""),
  object({
    event_type: literal("group_nudge"),
    time: ZInt64.describe(" Unix "),
    self_id: ZUin.describe(" QQ "),
    data: GroupNudgeEvent
  }).describe(""),
  object({
    event_type: literal("group_file_upload"),
    time: ZInt64.describe(" Unix "),
    self_id: ZUin.describe(" QQ "),
    data: GroupFileUploadEvent
  }).describe("")
]).describe("");
var version = "1.1.0-rc.6";
const milkyPackageVersion = version;
const milkyVersion = milkyPackageVersion.split(".").slice(0, 2).join(".");
const CachedApiBase = object({ no_cache: ZBooleanWithDefault(false).describe("") });
const GetLoginInfoOutput = object({
  uin: ZUin.describe(" QQ "),
  nickname: ZString.describe("")
});
const GetImplInfoOutput = object({
  impl_name: ZString.describe(""),
  impl_version: ZString.describe(""),
  qq_protocol_version: ZString.describe(" QQ "),
  qq_protocol_type: _enum([
    "windows",
    "linux",
    "macos",
    "android_pad",
    "android_phone",
    "ipad",
    "iphone",
    "harmony",
    "watch"
  ]).describe(" QQ "),
  milky_version: ZString.describe(` Milky  "${milkyVersion}"`)
});
const GetUserProfileInput = object({ user_id: ZUin.describe(" QQ ") });
const GetUserProfileOutput = object({
  nickname: ZString.describe(""),
  qid: ZString.describe("QID"),
  age: ZInt32.describe(""),
  sex: _enum([
    "male",
    "female",
    "unknown"
  ]).describe(""),
  remark: ZString.describe(""),
  bio: ZString.describe(""),
  level: ZInt32.describe("QQ "),
  country: ZString.describe(""),
  city: ZString.describe(""),
  school: ZString.describe("")
});
const GetFriendListInput = CachedApiBase;
const GetFriendListOutput = object({ friends: array(lazy(() => FriendEntity)).describe("") });
const GetFriendInfoInput = object({ user_id: ZUin.describe(" QQ ") }).extend(CachedApiBase.shape);
const GetFriendInfoOutput = object({ friend: lazy(() => FriendEntity).describe("") });
const GetGroupListInput = CachedApiBase;
const GetGroupListOutput = object({ groups: array(lazy(() => GroupEntity)).describe("") });
const GetGroupInfoInput = object({ group_id: ZUin.describe("") }).extend(CachedApiBase.shape);
const GetGroupInfoOutput = object({ group: lazy(() => GroupEntity).describe("") });
const GetGroupMemberListInput = object({ group_id: ZUin.describe("") }).extend(CachedApiBase.shape);
const GetGroupMemberListOutput = object({ members: array(lazy(() => GroupMemberEntity)).describe("") });
const GetGroupMemberInfoInput = object({
  group_id: ZUin.describe(""),
  user_id: ZUin.describe(" QQ ")
}).extend(CachedApiBase.shape);
const GetGroupMemberInfoOutput = object({ member: lazy(() => GroupMemberEntity).describe("") });
const SetAvatarInput = object({ uri: ZString.describe(" URI `file://` `http(s)://` `base64://` ") });
const SetNicknameInput = object({ new_nickname: ZString.describe("") });
const SetBioInput = object({ new_bio: ZString.describe("") });
const GetCustomFaceUrlListOutput = object({ urls: array(ZString).describe(" URL ") });
const GetCookiesInput = object({ domain: ZString.describe(" Cookies ") });
const GetCookiesOutput = object({ cookies: ZString.describe(" Cookies ") });
const GetCSRFTokenOutput = object({ csrf_token: ZString.describe("CSRF Token") });
const SendMessageApiBase = object({ message: array(lazy(() => OutgoingSegment)).describe("") });
const SendMessageApiCommonOutput = object({
  message_seq: ZInt64.describe(""),
  time: ZInt64.describe("")
});
const SendPrivateMessageInput = object({ user_id: ZUin.describe(" QQ ") }).extend(SendMessageApiBase.shape);
const SendPrivateMessageOutput = SendMessageApiCommonOutput;
const SendGroupMessageInput = object({ group_id: ZUin.describe("") }).extend(SendMessageApiBase.shape);
const SendGroupMessageOutput = SendMessageApiCommonOutput;
const RecallPrivateMessageInput = object({
  user_id: ZUin.describe(" QQ "),
  message_seq: ZInt64.describe("")
});
const RecallGroupMessageInput = object({
  group_id: ZUin.describe(""),
  message_seq: ZInt64.describe("")
});
const GetMessageInput = object({
  message_scene: _enum([
    "friend",
    "group",
    "temp"
  ]).describe(""),
  peer_id: ZUin.describe(" QQ "),
  message_seq: ZInt64.describe("")
});
const GetMessageOutput = object({ message: lazy(() => IncomingMessage).describe("") });
const GetHistoryMessagesInput = object({
  message_scene: _enum([
    "friend",
    "group",
    "temp"
  ]).describe(""),
  peer_id: ZUin.describe(" QQ "),
  start_message_seq: ZInt64.nullish().describe(""),
  limit: number$1().int().min(1).max(30).nullish().default(20).transform((v) => v ?? 20).meta({ scalarType: "int32" }).describe(" 30 ")
});
const GetHistoryMessagesOutput = object({
  messages: array(lazy(() => IncomingMessage)).describe("message_seq "),
  next_message_seq: ZInt64.nullish().describe("")
});
const GetResourceTempUrlInput = object({ resource_id: ZString.describe(" ID") });
const GetResourceTempUrlOutput = object({ url: ZString.describe("") });
const GetForwardedMessagesInput = object({ forward_id: ZString.describe(" ID") });
const GetForwardedMessagesOutput = object({ messages: array(lazy(() => IncomingForwardedMessage)).describe("") });
const MarkMessageAsReadInput = object({
  message_scene: _enum([
    "friend",
    "group",
    "temp"
  ]).describe(""),
  peer_id: ZUin.describe(" QQ "),
  message_seq: ZInt64.describe("")
});
const SendFriendNudgeInput = object({
  user_id: ZUin.describe(" QQ "),
  is_self: ZBooleanWithDefault(false).describe("")
});
const SendProfileLikeInput = object({
  user_id: ZUin.describe(" QQ "),
  count: ZInt32WithDefault(1).describe("")
});
const DeleteFriendInput = object({ user_id: ZUin.describe(" QQ ") });
const GetFriendRequestsInput = object({
  limit: ZInt32WithDefault(20).describe(""),
  is_filtered: ZBooleanWithDefault(false).describe("`true` `false` ")
});
const GetFriendRequestsOutput = object({ requests: array(lazy(() => FriendRequest)).describe("") });
const AcceptFriendRequestInput = object({
  initiator_uid: ZString.describe(" UID"),
  is_filtered: ZBooleanWithDefault(false).describe("")
});
const RejectFriendRequestInput = object({
  initiator_uid: ZString.describe(" UID"),
  is_filtered: ZBooleanWithDefault(false).describe(""),
  reason: ZString.nullish().describe("")
});
const SetGroupNameInput = object({
  group_id: ZUin.describe(""),
  new_group_name: ZString.describe("")
});
const SetGroupAvatarInput = object({
  group_id: ZUin.describe(""),
  image_uri: ZString.describe(" URI `file://` `http(s)://` `base64://` ")
});
const SetGroupMemberCardInput = object({
  group_id: ZUin.describe(""),
  user_id: ZUin.describe(" QQ "),
  card: ZString.describe("")
});
const SetGroupMemberSpecialTitleInput = object({
  group_id: ZUin.describe(""),
  user_id: ZUin.describe(" QQ "),
  special_title: ZString.describe("")
});
const SetGroupMemberAdminInput = object({
  group_id: ZUin.describe(""),
  user_id: ZUin.describe(" QQ "),
  is_set: ZBooleanWithDefault(true).describe("`false` ")
});
const SetGroupMemberMuteInput = object({
  group_id: ZUin.describe(""),
  user_id: ZUin.describe(" QQ "),
  duration: ZInt64WithDefault(0).describe(" `0` ")
});
const SetGroupWholeMuteInput = object({
  group_id: ZUin.describe(""),
  is_mute: ZBooleanWithDefault(true).describe("`false` ")
});
const KickGroupMemberInput = object({
  group_id: ZUin.describe(""),
  user_id: ZUin.describe(" QQ "),
  reject_add_request: ZBooleanWithDefault(false).describe("`false` ")
});
const GetGroupAnnouncementsInput = object({ group_id: ZUin.describe("") });
const GetGroupAnnouncementsOutput = object({ announcements: array(lazy(() => GroupAnnouncementEntity)).describe("") });
const SendGroupAnnouncementInput = object({
  group_id: ZUin.describe(""),
  content: ZString.describe(""),
  image_uri: ZString.nullish().describe(" URI `file://` `http(s)://` `base64://` ")
});
const DeleteGroupAnnouncementInput = object({
  group_id: ZUin.describe(""),
  announcement_id: ZString.describe(" ID")
});
const GetGroupEssenceMessagesInput = object({
  group_id: ZUin.describe(""),
  page_index: ZInt32.describe(" 0 "),
  page_size: ZInt32.describe("")
});
const GetGroupEssenceMessagesOutput = object({
  messages: array(lazy(() => GroupEssenceMessage)).describe(""),
  is_end: ZBoolean.describe("")
});
const SetGroupEssenceMessageInput = object({
  group_id: ZUin.describe(""),
  message_seq: ZInt64.describe(""),
  is_set: ZBooleanWithDefault(true).describe("`false` ")
});
const QuitGroupInput = object({ group_id: ZUin.describe("") });
const SendGroupMessageReactionInput = object({
  group_id: ZUin.describe(""),
  message_seq: ZInt64.describe(""),
  reaction: ZString.describe(" ID"),
  is_add: ZBooleanWithDefault(true).describe("`false` ")
});
const SendGroupNudgeInput = object({
  group_id: ZUin.describe(""),
  user_id: ZUin.describe(" QQ ")
});
const GetGroupNotificationsInput = object({
  start_notification_seq: ZInt64.nullish().describe(""),
  is_filtered: ZBooleanWithDefault(false).describe("`true` `false` "),
  limit: ZInt32WithDefault(20).describe("")
});
const GetGroupNotificationsOutput = object({
  notifications: array(lazy(() => GroupNotification)).describe("notification_seq "),
  next_notification_seq: ZInt64.nullish().describe("")
});
const AcceptGroupRequestInput = object({
  notification_seq: ZInt64.describe(""),
  notification_type: _enum(["join_request", "invited_join_request"]).describe(""),
  group_id: ZUin.describe(""),
  is_filtered: ZBooleanWithDefault(false).describe("")
});
const RejectGroupRequestInput = object({
  notification_seq: ZInt64.describe(""),
  notification_type: _enum(["join_request", "invited_join_request"]).describe(""),
  group_id: ZUin.describe(""),
  is_filtered: ZBooleanWithDefault(false).describe(""),
  reason: ZString.nullish().describe("")
});
const AcceptGroupInvitationInput = object({
  group_id: ZUin.describe(""),
  invitation_seq: ZInt64.describe("")
});
const RejectGroupInvitationInput = object({
  group_id: ZUin.describe(""),
  invitation_seq: ZInt64.describe("")
});
const UploadPrivateFileInput = object({
  user_id: ZUin.describe(" QQ "),
  file_uri: ZString.describe(" URI `file://` `http(s)://` `base64://` "),
  file_name: ZString.describe("")
});
const UploadPrivateFileOutput = object({ file_id: ZString.describe(" ID") });
const UploadGroupFileInput = object({
  group_id: ZUin.describe(""),
  parent_folder_id: ZStringWithDefault("/").describe(" ID"),
  file_uri: ZString.describe(" URI `file://` `http(s)://` `base64://` "),
  file_name: ZString.describe("")
});
const UploadGroupFileOutput = object({ file_id: ZString.describe(" ID") });
const GetPrivateFileDownloadUrlInput = object({
  user_id: ZUin.describe(" QQ "),
  file_id: ZString.describe(" ID"),
  file_hash: ZString.describe(" TriSHA1 ")
});
const GetPrivateFileDownloadUrlOutput = object({ download_url: ZString.describe("") });
const GetGroupFileDownloadUrlInput = object({
  group_id: ZUin.describe(""),
  file_id: ZString.describe(" ID")
});
const GetGroupFileDownloadUrlOutput = object({ download_url: ZString.describe("") });
const GetGroupFilesInput = object({
  group_id: ZUin.describe(""),
  parent_folder_id: ZStringWithDefault("/").describe(" ID")
});
const GetGroupFilesOutput = object({
  files: array(lazy(() => GroupFileEntity)).describe(""),
  folders: array(lazy(() => GroupFolderEntity)).describe("")
});
const MoveGroupFileInput = object({
  group_id: ZUin.describe(""),
  file_id: ZString.describe(" ID"),
  parent_folder_id: ZStringWithDefault("/").describe(" ID"),
  target_folder_id: ZStringWithDefault("/").describe(" ID")
});
const RenameGroupFileInput = object({
  group_id: ZUin.describe(""),
  file_id: ZString.describe(" ID"),
  parent_folder_id: ZStringWithDefault("/").describe(" ID"),
  new_file_name: ZString.describe("")
});
const DeleteGroupFileInput = object({
  group_id: ZUin.describe(""),
  file_id: ZString.describe(" ID")
});
const CreateGroupFolderInput = object({
  group_id: ZUin.describe(""),
  folder_name: ZString.describe("")
});
const CreateGroupFolderOutput = object({ folder_id: ZString.describe(" ID") });
const RenameGroupFolderInput = object({
  group_id: ZUin.describe(""),
  folder_id: ZString.describe(" ID"),
  new_folder_name: ZString.describe("")
});
const DeleteGroupFolderInput = object({
  group_id: ZUin.describe(""),
  folder_id: ZString.describe(" ID")
});
async function getResponse(url2, headers = {
  "User-Agent": "Mozilla/5.0 (Windows NT 10.0 Win64 x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.71 Safari/537.36"
}, useReferer = false) {
  if (useReferer && !headers["Referer"]) {
    headers["Referer"] = url2;
  }
  return await fetch(url2, { headers });
}
async function download(url2, headers) {
  let resp = await getResponse(url2, headers, false);
  if (resp.status === 403 && !headers) {
    resp = await getResponse(url2, headers, true);
  }
  if (!resp.ok) {
    throw new Error(`Failed to download file from ${url2}: ${resp.status} ${resp.statusText}`);
  }
  const bytes2 = await resp.blob().then((b) => b.arrayBuffer());
  return Buffer.from(bytes2);
}
async function resolveMilkyUri(uri2) {
  if (uri2.startsWith("file://")) {
    return await fsPromise.readFile(uri2.slice(7));
  }
  if (uri2.startsWith("http://") || uri2.startsWith("https://")) {
    return await download(uri2);
  }
  if (uri2.startsWith("base64://")) {
    return Buffer.from(uri2.slice(9), "base64");
  }
  throw new Error(`Unsupported URI scheme: ${uri2}`);
}
const GetLoginInfo2 = defineApi(
  "get_login_info",
  z.object({}),
  GetLoginInfoOutput,
  async (ctx) => {
    for (let i = 0; i < 5; i++) {
      try {
        await ctx.ntUserApi.getSelfNick(true);
        break;
      } catch {
        await sleep(500);
      }
    }
    return Ok({
      uin: +selfInfo.uin,
      nickname: selfInfo.nick
    });
  }
);
const GetImplInfo = defineApi(
  "get_impl_info",
  z.object({}),
  GetImplInfoOutput,
  async (ctx) => {
    const deviceInfo = await ctx.ntSystemApi.getDeviceInfo();
    return Ok({
      impl_name: "LLBot",
      impl_version: version$2,
      qq_protocol_version: deviceInfo.buildVer,
      qq_protocol_type: transformProtocolOsType(deviceInfo.devType),
      milky_version: "1.1"
    });
  }
);
const GetUserProfile = defineApi(
  "get_user_profile",
  GetUserProfileInput,
  GetUserProfileOutput,
  async (ctx, payload) => {
    const userInfo = await ctx.ntUserApi.getUserDetailInfoByUin(payload.user_id.toString());
    if (userInfo.result !== 0) {
      return Failed(-500, userInfo.errMsg);
    }
    const profile = {
      nickname: userInfo.detail.simpleInfo.coreInfo.nick,
      qid: userInfo.detail.simpleInfo.baseInfo.qid,
      age: userInfo.detail.simpleInfo.baseInfo.age,
      sex: transformGender(userInfo.detail.simpleInfo.baseInfo.sex),
      remark: userInfo.detail.simpleInfo.coreInfo.remark,
      bio: userInfo.detail.simpleInfo.baseInfo.longNick,
      level: userInfo.detail.commonExt?.qqLevel ? userInfo.detail.commonExt.qqLevel.penguinNum * 256 + userInfo.detail.commonExt.qqLevel.crownNum * 64 + userInfo.detail.commonExt.qqLevel.sunNum * 16 + userInfo.detail.commonExt.qqLevel.moonNum * 4 + userInfo.detail.commonExt.qqLevel.starNum : 0,
      country: userInfo.detail.commonExt?.country || "",
      city: userInfo.detail.commonExt?.city || "",
      school: userInfo.detail.commonExt?.college || ""
    };
    if (profile.level === 0) {
      profile.level = await ctx.app.pmhq.fetchUserLevel(payload.user_id);
    }
    return Ok(profile);
  }
);
const GetFriendList2 = defineApi(
  "get_friend_list",
  GetFriendListInput,
  GetFriendListOutput,
  async (ctx, payload) => {
    const friends = await ctx.ntFriendApi.getBuddyList();
    const friendList = [];
    for (const friend of friends) {
      const category = await ctx.ntFriendApi.getCategoryById(friend.baseInfo.categoryId);
      friendList.push(transformFriend(friend, category));
    }
    return Ok({
      friends: friendList
    });
  }
);
const GetFriendInfo = defineApi(
  "get_friend_info",
  GetFriendInfoInput,
  GetFriendInfoOutput,
  async (ctx, payload) => {
    const uid = await ctx.ntUserApi.getUidByUin(payload.user_id.toString());
    if (!uid) {
      return Failed(-404, "User not found");
    }
    const friend = await ctx.ntUserApi.getUserSimpleInfo(uid);
    const category = await ctx.ntFriendApi.getCategoryById(friend.baseInfo.categoryId);
    return Ok({
      friend: transformFriend(friend, category)
    });
  }
);
const GetGroupList2 = defineApi(
  "get_group_list",
  GetGroupListInput,
  GetGroupListOutput,
  async (ctx, payload) => {
    const groups = await ctx.ntGroupApi.getGroups(payload.no_cache);
    return Ok({
      groups: groups.map((e) => {
        return {
          group_id: +e.groupCode,
          group_name: e.groupName,
          member_count: e.memberCount,
          max_member_count: e.maxMember
        };
      })
    });
  }
);
const GetGroupInfo2 = defineApi(
  "get_group_info",
  GetGroupInfoInput,
  GetGroupInfoOutput,
  async (ctx, payload) => {
    const group = await ctx.ntGroupApi.getGroupAllInfo(payload.group_id.toString());
    return Ok({
      group: transformGroup(group)
    });
  }
);
const GetGroupMemberList2 = defineApi(
  "get_group_member_list",
  GetGroupMemberListInput,
  GetGroupMemberListOutput,
  async (ctx, payload) => {
    const result = await ctx.ntGroupApi.getGroupMembers(payload.group_id.toString());
    if (result.errCode !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({
      members: result.result.infos.values().map((e) => transformGroupMember(e, payload.group_id)).toArray()
    });
  }
);
const GetGroupMemberInfo2 = defineApi(
  "get_group_member_info",
  GetGroupMemberInfoInput,
  GetGroupMemberInfoOutput,
  async (ctx, payload) => {
    const groupCode = payload.group_id.toString();
    const memberUid = await ctx.ntUserApi.getUidByUin(payload.user_id.toString(), groupCode);
    if (!memberUid) {
      return Failed(-404, "Member not found");
    }
    const member = await ctx.ntGroupApi.getGroupMember(
      groupCode,
      memberUid
    );
    return Ok({
      member: transformGroupMember(member, payload.group_id)
    });
  }
);
const SetAvatar = defineApi(
  "set_avatar",
  SetAvatarInput,
  z.object({}),
  async (ctx, payload) => {
    const data = await resolveMilkyUri(payload.uri);
    const tempPath = path__default.join(TEMP_DIR, `avatar-${randomUUID()}`);
    await writeFile(tempPath, data);
    const result = await ctx.ntUserApi.setSelfAvatar(tempPath);
    unlink(tempPath).catch((e) => {
    });
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const SetNickname = defineApi(
  "set_nickname",
  SetNicknameInput,
  z.object({}),
  async (ctx, payload) => {
    const old = (await ctx.ntUserApi.getUserDetailInfoWithBizInfo(selfInfo.uid)).simpleInfo;
    const result = await ctx.ntUserApi.modifySelfProfile({
      nick: payload.new_nickname,
      longNick: old.baseInfo.longNick,
      sex: old.baseInfo.sex,
      birthday: {
        birthday_year: old.baseInfo.birthday_year,
        birthday_month: old.baseInfo.birthday_month,
        birthday_day: old.baseInfo.birthday_day
      },
      location: {
        country: "",
        province: "",
        city: "",
        zone: ""
      }
    });
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const SetBio = defineApi(
  "set_bio",
  SetBioInput,
  z.object({}),
  async (ctx, payload) => {
    const old = (await ctx.ntUserApi.getUserDetailInfoWithBizInfo(selfInfo.uid)).simpleInfo;
    const result = await ctx.ntUserApi.modifySelfProfile({
      nick: old.coreInfo.nick,
      longNick: payload.new_bio,
      sex: old.baseInfo.sex,
      birthday: {
        birthday_year: old.baseInfo.birthday_year,
        birthday_month: old.baseInfo.birthday_month,
        birthday_day: old.baseInfo.birthday_day
      },
      location: {
        country: "",
        province: "",
        city: "",
        zone: ""
      }
    });
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const GetCustomFaceUrlList = defineApi(
  "get_custom_face_url_list",
  z.object({}),
  GetCustomFaceUrlListOutput,
  async (ctx, payload) => {
    const result = await ctx.ntMsgApi.fetchFavEmojiList(200);
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({
      urls: result.emojiInfoList.map((e) => e.url)
    });
  }
);
const GetCookies2 = defineApi(
  "get_cookies",
  GetCookiesInput,
  GetCookiesOutput,
  async (ctx, payload) => {
    const blackList = ["pay.qq.com"];
    if (blackList.includes(payload.domain)) {
      throw new Error("cookie");
    }
    const cookiesObject = await ctx.ntUserApi.getCookies(payload.domain);
    if (!cookiesObject.p_skey) {
      const pSkey = (await ctx.ntUserApi.getPSkey([payload.domain])).domainPskeyMap.get(payload.domain);
      if (pSkey) {
        cookiesObject.p_skey = pSkey;
      }
    }
    const cookies = Object.entries(cookiesObject).map(([key2, value]) => `${key2}=${value}`).join("; ");
    return Ok({ cookies });
  }
);
const GetCSRFToken = defineApi(
  "get_csrf_token",
  z.object({}),
  GetCSRFTokenOutput,
  async (ctx, payload) => {
    const cookiesObject = await ctx.ntUserApi.getCookies("h5.qzone.qq.com");
    const csrfToken = ctx.ntWebApi.genBkn(cookiesObject.skey);
    return Ok({ csrf_token: csrfToken });
  }
);
const SystemApi = [
  GetLoginInfo2,
  GetImplInfo,
  GetUserProfile,
  GetFriendList2,
  GetFriendInfo,
  GetGroupList2,
  GetGroupInfo2,
  GetGroupMemberList2,
  GetGroupMemberInfo2,
  SetAvatar,
  SetNickname,
  SetBio,
  GetCustomFaceUrlList,
  GetCookies2,
  GetCSRFToken
];
async function transformOutgoingMessage(ctx, segments, peerUid, isGroup = false) {
  const elements = [];
  const deleteAfterSentFiles = [];
  for (const segment of segments) {
    try {
      if (segment.type === "text") {
        elements.push(SendElement.text(segment.data.text));
      } else if (segment.type === "mention" && isGroup) {
        const memberUin = segment.data.user_id.toString();
        const memberUid = await ctx.ntUserApi.getUidByUin(memberUin, peerUid);
        elements.push(SendElement.at(memberUin, memberUid, AtType.One, ""));
      } else if (segment.type === "mention_all" && isGroup) {
        elements.push(SendElement.at("", "", AtType.All, "@"));
      } else if (segment.type === "face") {
        elements.push(SendElement.face(+segment.data.face_id, segment.data.is_large ? 3 : void 0));
      } else if (segment.type === "reply") {
        const replyMsgSeq = segment.data.message_seq.toString();
        const peer = {
          chatType: isGroup ? 2 : 1,
          peerUid,
          guildId: ""
        };
        const source2 = await ctx.ntMsgApi.getMsgsBySeqAndCount(peer, replyMsgSeq, 1, true, true);
        if (source2.msgList.length === 0) {
          throw new Error("");
        }
        elements.push(SendElement.reply(replyMsgSeq, source2.msgList[0].msgId, source2.msgList[0].senderUid));
      } else if (segment.type === "image") {
        const imageBuffer = await resolveMilkyUri(segment.data.uri);
        const tempPath = path__default.join(TEMP_DIR, `image-${randomUUID()}`);
        await writeFile(tempPath, imageBuffer);
        const subType = segment.data.sub_type === "sticker" ? 1 : 0;
        const picElement = await SendElement.pic(ctx, tempPath, segment.data.summary ?? "", subType);
        elements.push(picElement);
        deleteAfterSentFiles.push(tempPath);
      } else if (segment.type === "record") {
        const recordBuffer = await resolveMilkyUri(segment.data.uri);
        const tempPath = path__default.join(TEMP_DIR, `audio-${randomUUID()}`);
        await writeFile(tempPath, recordBuffer);
        const pttElement = await SendElement.ptt(ctx, tempPath);
        elements.push(pttElement);
        deleteAfterSentFiles.push(tempPath);
      } else if (segment.type === "video") {
        const videoBuffer = await resolveMilkyUri(segment.data.uri);
        const tempPath = path__default.join(TEMP_DIR, `video-${randomUUID()}`);
        await writeFile(tempPath, videoBuffer);
        let thumbTempPath = void 0;
        if (segment.data.thumb_uri) {
          const thumbBuffer = await resolveMilkyUri(segment.data.thumb_uri);
          const thumbTempPath2 = path__default.join(TEMP_DIR, `thumb-${randomUUID()}`);
          await writeFile(thumbTempPath2, thumbBuffer);
          deleteAfterSentFiles.push(thumbTempPath2);
        }
        const videoElement = await SendElement.video(ctx, tempPath, thumbTempPath);
        elements.push(videoElement);
        deleteAfterSentFiles.push(tempPath);
      }
    } catch (error2) {
      ctx.logger.error("MilkyTransform", `Failed to transform segment ${segment.type}: ${error2}`);
    }
  }
  return {
    elements,
    deleteAfterSentFiles
  };
}
async function transformOutgoingForwardMessages(ctx, messages, peer) {
  const encoder = new ForwardMessageEncoder(ctx, peer);
  return await encoder.generate(messages);
}
class ForwardMessageEncoder {
  constructor(ctx, peer) {
    this.ctx = ctx;
    this.peer = peer;
    this.results = [];
    this.children = [];
    this.deleteAfterSentFiles = [];
    this.isGroup = peer.chatType === 2;
    this.seq = Math.trunc(Math.random() * 65430);
    this.tsum = 0;
    this.preview = "";
    this.news = [];
  }
  static support = ["text", "face", "image", "markdown", "forward"];
  results;
  children;
  deleteAfterSentFiles;
  isGroup;
  seq;
  tsum;
  preview;
  news;
  name;
  uin;
  async flush() {
    if (this.children.length === 0) return;
    const nick = this.name || selfInfo.nick || "QQ";
    if (this.news.length < 4) {
      this.news.push({
        text: `${nick}: ${this.preview}`
      });
    }
    this.results.push({
      routingHead: {
        fromUin: this.uin ?? +selfInfo.uin,
        //  1094950020
        c2c: this.isGroup ? void 0 : {
          friendName: nick
        },
        group: this.isGroup ? {
          groupCode: 284840486,
          groupCard: nick
        } : void 0
      },
      contentHead: {
        msgType: this.isGroup ? 82 : 9,
        random: Math.floor(Math.random() * 4294967290),
        msgSeq: this.seq,
        msgTime: Math.trunc(Date.now() / 1e3),
        pkgNum: 1,
        pkgIndex: 0,
        divSeq: 0,
        forward: {
          field1: 0,
          field2: 0,
          field3: 0,
          field4: "",
          avatar: ""
        }
      },
      body: {
        richText: {
          elems: this.children
        }
      }
    });
    this.seq++;
    this.tsum++;
    this.children = [];
    this.preview = "";
  }
  async packImage(data, busiType) {
    const imageSize2 = await this.ctx.ntFileApi.getImageSize(data.filePath);
    return {
      commonElem: {
        serviceType: 48,
        pbElem: Media.MsgInfo.encode({
          msgInfoBody: [{
            index: {
              info: {
                fileSize: +data.commonFileInfo.fileSize,
                md5HexStr: data.commonFileInfo.md5,
                sha1HexStr: data.commonFileInfo.sha,
                fileName: data.commonFileInfo.fileName,
                fileType: {
                  type: 1,
                  picFormat: imageSize2.type === "gif" ? 2e3 : 1e3
                },
                width: imageSize2.width,
                height: imageSize2.height,
                time: 0,
                original: 1
              },
              fileUuid: data.fileId,
              storeID: 1,
              expire: this.isGroup ? 2678400 : 15768e4
            },
            pic: {
              urlPath: `/download?appid=${this.isGroup ? 1407 : 1406}&fileid=${data.fileId}`,
              ext: {
                originalParam: "&spec=0",
                bigParam: "&spec=720",
                thumbParam: "&spec=198"
              },
              domain: "multimedia.nt.qq.com.cn"
            },
            fileExist: true
          }],
          extBizInfo: {
            pic: {
              bizType: 0,
              summary: "",
              fromScene: this.isGroup ? 2 : 1,
              //  PCQQ 
              toScene: this.isGroup ? 2 : 1,
              //  PCQQ 
              oldFileId: this.isGroup ? 574859779 : void 0
              //  PCQQ 
            },
            busiType
          }
        }),
        businessType: this.isGroup ? 20 : 10
      }
    };
  }
  packForwardMessage(resid) {
    const uuid2 = crypto.randomUUID();
    const content = JSON.stringify({
      app: "com.tencent.multimsg",
      config: {
        autosize: 1,
        forward: 1,
        round: 1,
        type: "normal",
        width: 300
      },
      desc: "[]",
      extra: JSON.stringify({
        filename: uuid2,
        tsum: 0
      }),
      meta: {
        detail: {
          news: [{
            text: ""
          }],
          resid,
          source: "",
          summary: "",
          uniseq: uuid2
        }
      },
      prompt: "[]",
      ver: "0.0.0.5",
      view: "contact"
    });
    return {
      lightApp: {
        data: Buffer.concat([Buffer.from([1]), deflateSync(Buffer.from(content, "utf-8"))])
      }
    };
  }
  async visit(content) {
    this.uin = content.user_id;
    this.name = content.sender_name;
    for (const segment of content.segments) {
      const { type: type2, data } = segment;
      if (type2 === "text") {
        this.children.push({
          text: {
            str: data.text
          }
        });
        this.preview += data.text;
      } else if (type2 === "face") {
        this.children.push({
          face: {
            index: +data.face_id
          }
        });
        const face = faceConfig.sysface.find((e) => e.QSid === data.face_id);
        if (face) {
          this.preview += face.QDes;
        }
      } else if (type2 === "image") {
        const imageBuffer = await resolveMilkyUri(segment.data.uri);
        const tempPath = path__default.join(TEMP_DIR, `image-${randomUUID()}`);
        await writeFile(tempPath, imageBuffer);
        const data2 = await this.ctx.ntFileApi.uploadRMFileWithoutMsg(tempPath, this.isGroup ? 4 : 3, this.isGroup ? this.peer.peerUid : selfInfo.uid);
        unlink(tempPath).catch((e) => {
        });
        const busiType = segment.data.sub_type === "sticker" ? 1 : 0;
        this.children.push(await this.packImage(data2, busiType));
        this.preview += busiType === 1 ? "[]" : "[]";
      }
    }
    await this.flush();
  }
  async render(content) {
    for (const item of content) {
      await this.visit(item);
    }
  }
  async generate(content) {
    await this.render(content);
    return {
      multiMsgItems: [{
        fileName: "MultiMsg",
        buffer: {
          msg: this.results
        }
      }],
      tsum: this.tsum,
      source: this.isGroup ? "" : "",
      summary: `${this.tsum}`,
      news: this.news
    };
  }
}
const nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
const nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
const nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
const regexName = new RegExp("^" + nameRegexp + "$");
function getAllMatches(string2, regex) {
  const matches = [];
  let match = regex.exec(string2);
  while (match) {
    const allmatches = [];
    allmatches.startIndex = regex.lastIndex - match[0].length;
    const len = match.length;
    for (let index2 = 0; index2 < len; index2++) {
      allmatches.push(match[index2]);
    }
    matches.push(allmatches);
    match = regex.exec(string2);
  }
  return matches;
}
const isName = function(string2) {
  const match = regexName.exec(string2);
  return !(match === null || typeof match === "undefined");
};
function isExist(v) {
  return typeof v !== "undefined";
}
const defaultOptions$1 = {
  allowBooleanAttributes: false,
  //A tag can have attributes without any value
  unpairedTags: []
};
function validate(xmlData, options) {
  options = Object.assign({}, defaultOptions$1, options);
  const tags = [];
  let tagFound = false;
  let reachedRoot = false;
  if (xmlData[0] === "\uFEFF") {
    xmlData = xmlData.substr(1);
  }
  for (let i = 0; i < xmlData.length; i++) {
    if (xmlData[i] === "<" && xmlData[i + 1] === "?") {
      i += 2;
      i = readPI(xmlData, i);
      if (i.err) return i;
    } else if (xmlData[i] === "<") {
      let tagStartPos = i;
      i++;
      if (xmlData[i] === "!") {
        i = readCommentAndCDATA(xmlData, i);
        continue;
      } else {
        let closingTag = false;
        if (xmlData[i] === "/") {
          closingTag = true;
          i++;
        }
        let tagName = "";
        for (; i < xmlData.length && xmlData[i] !== ">" && xmlData[i] !== " " && xmlData[i] !== "	" && xmlData[i] !== "\n" && xmlData[i] !== "\r"; i++) {
          tagName += xmlData[i];
        }
        tagName = tagName.trim();
        if (tagName[tagName.length - 1] === "/") {
          tagName = tagName.substring(0, tagName.length - 1);
          i--;
        }
        if (!validateTagName(tagName)) {
          let msg;
          if (tagName.trim().length === 0) {
            msg = "Invalid space after '<'.";
          } else {
            msg = "Tag '" + tagName + "' is an invalid name.";
          }
          return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i));
        }
        const result = readAttributeStr(xmlData, i);
        if (result === false) {
          return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
        }
        let attrStr = result.value;
        i = result.index;
        if (attrStr[attrStr.length - 1] === "/") {
          const attrStrStart = i - attrStr.length;
          attrStr = attrStr.substring(0, attrStr.length - 1);
          const isValid = validateAttributeString(attrStr, options);
          if (isValid === true) {
            tagFound = true;
          } else {
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
          }
        } else if (closingTag) {
          if (!result.tagClosed) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
          } else if (attrStr.trim().length > 0) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
          } else if (tags.length === 0) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
          } else {
            const otg = tags.pop();
            if (tagName !== otg.tagName) {
              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
              return getErrorObject(
                "InvalidTag",
                "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                getLineNumberForPosition(xmlData, tagStartPos)
              );
            }
            if (tags.length == 0) {
              reachedRoot = true;
            }
          }
        } else {
          const isValid = validateAttributeString(attrStr, options);
          if (isValid !== true) {
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
          }
          if (reachedRoot === true) {
            return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i));
          } else if (options.unpairedTags.indexOf(tagName) !== -1) ;
          else {
            tags.push({ tagName, tagStartPos });
          }
          tagFound = true;
        }
        for (i++; i < xmlData.length; i++) {
          if (xmlData[i] === "<") {
            if (xmlData[i + 1] === "!") {
              i++;
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else if (xmlData[i + 1] === "?") {
              i = readPI(xmlData, ++i);
              if (i.err) return i;
            } else {
              break;
            }
          } else if (xmlData[i] === "&") {
            const afterAmp = validateAmpersand(xmlData, i);
            if (afterAmp == -1)
              return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
            i = afterAmp;
          } else {
            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
              return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i));
            }
          }
        }
        if (xmlData[i] === "<") {
          i--;
        }
      }
    } else {
      if (isWhiteSpace(xmlData[i])) {
        continue;
      }
      return getErrorObject("InvalidChar", "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
    }
  }
  if (!tagFound) {
    return getErrorObject("InvalidXml", "Start tag expected.", 1);
  } else if (tags.length == 1) {
    return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
  } else if (tags.length > 0) {
    return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  }
  return true;
}
function isWhiteSpace(char) {
  return char === " " || char === "	" || char === "\n" || char === "\r";
}
function readPI(xmlData, i) {
  const start = i;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] == "?" || xmlData[i] == " ") {
      const tagname = xmlData.substr(start, i - start);
      if (i > 5 && tagname === "xml") {
        return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i));
      } else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {
        i++;
        break;
      } else {
        continue;
      }
    }
  }
  return i;
}
function readCommentAndCDATA(xmlData, i) {
  if (xmlData.length > i + 5 && xmlData[i + 1] === "-" && xmlData[i + 2] === "-") {
    for (i += 3; i < xmlData.length; i++) {
      if (xmlData[i] === "-" && xmlData[i + 1] === "-" && xmlData[i + 2] === ">") {
        i += 2;
        break;
      }
    }
  } else if (xmlData.length > i + 8 && xmlData[i + 1] === "D" && xmlData[i + 2] === "O" && xmlData[i + 3] === "C" && xmlData[i + 4] === "T" && xmlData[i + 5] === "Y" && xmlData[i + 6] === "P" && xmlData[i + 7] === "E") {
    let angleBracketsCount = 1;
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === "<") {
        angleBracketsCount++;
      } else if (xmlData[i] === ">") {
        angleBracketsCount--;
        if (angleBracketsCount === 0) {
          break;
        }
      }
    }
  } else if (xmlData.length > i + 9 && xmlData[i + 1] === "[" && xmlData[i + 2] === "C" && xmlData[i + 3] === "D" && xmlData[i + 4] === "A" && xmlData[i + 5] === "T" && xmlData[i + 6] === "A" && xmlData[i + 7] === "[") {
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === "]" && xmlData[i + 1] === "]" && xmlData[i + 2] === ">") {
        i += 2;
        break;
      }
    }
  }
  return i;
}
const doubleQuote = '"';
const singleQuote = "'";
function readAttributeStr(xmlData, i) {
  let attrStr = "";
  let startChar = "";
  let tagClosed = false;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
      if (startChar === "") {
        startChar = xmlData[i];
      } else if (startChar !== xmlData[i]) ;
      else {
        startChar = "";
      }
    } else if (xmlData[i] === ">") {
      if (startChar === "") {
        tagClosed = true;
        break;
      }
    }
    attrStr += xmlData[i];
  }
  if (startChar !== "") {
    return false;
  }
  return {
    value: attrStr,
    index: i,
    tagClosed
  };
}
const validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function validateAttributeString(attrStr, options) {
  const matches = getAllMatches(attrStr, validAttrStrRegxp);
  const attrNames = {};
  for (let i = 0; i < matches.length; i++) {
    if (matches[i][1].length === 0) {
      return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' has no space in starting.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] !== void 0 && matches[i][4] === void 0) {
      return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' is without value.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] === void 0 && !options.allowBooleanAttributes) {
      return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i][2] + "' is not allowed.", getPositionFromMatch(matches[i]));
    }
    const attrName = matches[i][2];
    if (!validateAttrName(attrName)) {
      return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i]));
    }
    if (!attrNames.hasOwnProperty(attrName)) {
      attrNames[attrName] = 1;
    } else {
      return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i]));
    }
  }
  return true;
}
function validateNumberAmpersand(xmlData, i) {
  let re = /\d/;
  if (xmlData[i] === "x") {
    i++;
    re = /[\da-fA-F]/;
  }
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === ";")
      return i;
    if (!xmlData[i].match(re))
      break;
  }
  return -1;
}
function validateAmpersand(xmlData, i) {
  i++;
  if (xmlData[i] === ";")
    return -1;
  if (xmlData[i] === "#") {
    i++;
    return validateNumberAmpersand(xmlData, i);
  }
  let count = 0;
  for (; i < xmlData.length; i++, count++) {
    if (xmlData[i].match(/\w/) && count < 20)
      continue;
    if (xmlData[i] === ";")
      break;
    return -1;
  }
  return i;
}
function getErrorObject(code, message, lineNumber) {
  return {
    err: {
      code,
      msg: message,
      line: lineNumber.line || lineNumber,
      col: lineNumber.col
    }
  };
}
function validateAttrName(attrName) {
  return isName(attrName);
}
function validateTagName(tagname) {
  return isName(tagname);
}
function getLineNumberForPosition(xmlData, index2) {
  const lines = xmlData.substring(0, index2).split(/\r?\n/);
  return {
    line: lines.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: lines[lines.length - 1].length + 1
  };
}
function getPositionFromMatch(match) {
  return match.startIndex + match[1].length;
}
const defaultOptions = {
  preserveOrder: false,
  attributeNamePrefix: "@_",
  attributesGroupName: false,
  textNodeName: "#text",
  ignoreAttributes: true,
  removeNSPrefix: false,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: false,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: true,
  parseAttributeValue: false,
  trimValues: true,
  //Trim string values of tag and attributes
  cdataPropName: false,
  numberParseOptions: {
    hex: true,
    leadingZeros: true,
    eNotation: true
  },
  tagValueProcessor: function(tagName, val) {
    return val;
  },
  attributeValueProcessor: function(attrName, val) {
    return val;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: false,
  isArray: () => false,
  commentPropName: false,
  unpairedTags: [],
  processEntities: true,
  htmlEntities: false,
  ignoreDeclaration: false,
  ignorePiTags: false,
  transformTagName: false,
  transformAttributeName: false,
  updateTag: function(tagName, jPath, attrs) {
    return tagName;
  },
  // skipEmptyListItem: false
  captureMetaData: false
};
const buildOptions = function(options) {
  return Object.assign({}, defaultOptions, options);
};
let METADATA_SYMBOL$1;
if (typeof Symbol !== "function") {
  METADATA_SYMBOL$1 = "@@xmlMetadata";
} else {
  METADATA_SYMBOL$1 = /* @__PURE__ */ Symbol("XML Node Metadata");
}
class XmlNode {
  constructor(tagname) {
    this.tagname = tagname;
    this.child = [];
    this[":@"] = {};
  }
  add(key2, val) {
    if (key2 === "__proto__") key2 = "#__proto__";
    this.child.push({ [key2]: val });
  }
  addChild(node, startIndex) {
    if (node.tagname === "__proto__") node.tagname = "#__proto__";
    if (node[":@"] && Object.keys(node[":@"]).length > 0) {
      this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
    } else {
      this.child.push({ [node.tagname]: node.child });
    }
    if (startIndex !== void 0) {
      this.child[this.child.length - 1][METADATA_SYMBOL$1] = { startIndex };
    }
  }
  /** symbol used for metadata */
  static getMetaDataSymbol() {
    return METADATA_SYMBOL$1;
  }
}
class DocTypeReader {
  constructor(processEntities) {
    this.suppressValidationErr = !processEntities;
  }
  readDocType(xmlData, i) {
    const entities = {};
    if (xmlData[i + 3] === "O" && xmlData[i + 4] === "C" && xmlData[i + 5] === "T" && xmlData[i + 6] === "Y" && xmlData[i + 7] === "P" && xmlData[i + 8] === "E") {
      i = i + 9;
      let angleBracketsCount = 1;
      let hasBody = false, comment = false;
      let exp = "";
      for (; i < xmlData.length; i++) {
        if (xmlData[i] === "<" && !comment) {
          if (hasBody && hasSeq(xmlData, "!ENTITY", i)) {
            i += 7;
            let entityName, val;
            [entityName, val, i] = this.readEntityExp(xmlData, i + 1, this.suppressValidationErr);
            if (val.indexOf("&") === -1)
              entities[entityName] = {
                regx: RegExp(`&${entityName};`, "g"),
                val
              };
          } else if (hasBody && hasSeq(xmlData, "!ELEMENT", i)) {
            i += 8;
            const { index: index2 } = this.readElementExp(xmlData, i + 1);
            i = index2;
          } else if (hasBody && hasSeq(xmlData, "!ATTLIST", i)) {
            i += 8;
          } else if (hasBody && hasSeq(xmlData, "!NOTATION", i)) {
            i += 9;
            const { index: index2 } = this.readNotationExp(xmlData, i + 1, this.suppressValidationErr);
            i = index2;
          } else if (hasSeq(xmlData, "!--", i)) comment = true;
          else throw new Error(`Invalid DOCTYPE`);
          angleBracketsCount++;
          exp = "";
        } else if (xmlData[i] === ">") {
          if (comment) {
            if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {
              comment = false;
              angleBracketsCount--;
            }
          } else {
            angleBracketsCount--;
          }
          if (angleBracketsCount === 0) {
            break;
          }
        } else if (xmlData[i] === "[") {
          hasBody = true;
        } else {
          exp += xmlData[i];
        }
      }
      if (angleBracketsCount !== 0) {
        throw new Error(`Unclosed DOCTYPE`);
      }
    } else {
      throw new Error(`Invalid Tag instead of DOCTYPE`);
    }
    return { entities, i };
  }
  readEntityExp(xmlData, i) {
    i = skipWhitespace(xmlData, i);
    let entityName = "";
    while (i < xmlData.length && !/\s/.test(xmlData[i]) && xmlData[i] !== '"' && xmlData[i] !== "'") {
      entityName += xmlData[i];
      i++;
    }
    validateEntityName(entityName);
    i = skipWhitespace(xmlData, i);
    if (!this.suppressValidationErr) {
      if (xmlData.substring(i, i + 6).toUpperCase() === "SYSTEM") {
        throw new Error("External entities are not supported");
      } else if (xmlData[i] === "%") {
        throw new Error("Parameter entities are not supported");
      }
    }
    let entityValue = "";
    [i, entityValue] = this.readIdentifierVal(xmlData, i, "entity");
    i--;
    return [entityName, entityValue, i];
  }
  readNotationExp(xmlData, i) {
    i = skipWhitespace(xmlData, i);
    let notationName = "";
    while (i < xmlData.length && !/\s/.test(xmlData[i])) {
      notationName += xmlData[i];
      i++;
    }
    !this.suppressValidationErr && validateEntityName(notationName);
    i = skipWhitespace(xmlData, i);
    const identifierType = xmlData.substring(i, i + 6).toUpperCase();
    if (!this.suppressValidationErr && identifierType !== "SYSTEM" && identifierType !== "PUBLIC") {
      throw new Error(`Expected SYSTEM or PUBLIC, found "${identifierType}"`);
    }
    i += identifierType.length;
    i = skipWhitespace(xmlData, i);
    let publicIdentifier = null;
    let systemIdentifier = null;
    if (identifierType === "PUBLIC") {
      [i, publicIdentifier] = this.readIdentifierVal(xmlData, i, "publicIdentifier");
      i = skipWhitespace(xmlData, i);
      if (xmlData[i] === '"' || xmlData[i] === "'") {
        [i, systemIdentifier] = this.readIdentifierVal(xmlData, i, "systemIdentifier");
      }
    } else if (identifierType === "SYSTEM") {
      [i, systemIdentifier] = this.readIdentifierVal(xmlData, i, "systemIdentifier");
      if (!this.suppressValidationErr && !systemIdentifier) {
        throw new Error("Missing mandatory system identifier for SYSTEM notation");
      }
    }
    return { notationName, publicIdentifier, systemIdentifier, index: --i };
  }
  readIdentifierVal(xmlData, i, type2) {
    let identifierVal = "";
    const startChar = xmlData[i];
    if (startChar !== '"' && startChar !== "'") {
      throw new Error(`Expected quoted string, found "${startChar}"`);
    }
    i++;
    while (i < xmlData.length && xmlData[i] !== startChar) {
      identifierVal += xmlData[i];
      i++;
    }
    if (xmlData[i] !== startChar) {
      throw new Error(`Unterminated ${type2} value`);
    }
    i++;
    return [i, identifierVal];
  }
  readElementExp(xmlData, i) {
    i = skipWhitespace(xmlData, i);
    let elementName = "";
    while (i < xmlData.length && !/\s/.test(xmlData[i])) {
      elementName += xmlData[i];
      i++;
    }
    if (!this.suppressValidationErr && !isName(elementName)) {
      throw new Error(`Invalid element name: "${elementName}"`);
    }
    i = skipWhitespace(xmlData, i);
    let contentModel = "";
    if (xmlData[i] === "E" && hasSeq(xmlData, "MPTY", i)) i += 4;
    else if (xmlData[i] === "A" && hasSeq(xmlData, "NY", i)) i += 2;
    else if (xmlData[i] === "(") {
      i++;
      while (i < xmlData.length && xmlData[i] !== ")") {
        contentModel += xmlData[i];
        i++;
      }
      if (xmlData[i] !== ")") {
        throw new Error("Unterminated content model");
      }
    } else if (!this.suppressValidationErr) {
      throw new Error(`Invalid Element Expression, found "${xmlData[i]}"`);
    }
    return {
      elementName,
      contentModel: contentModel.trim(),
      index: i
    };
  }
  readAttlistExp(xmlData, i) {
    i = skipWhitespace(xmlData, i);
    let elementName = "";
    while (i < xmlData.length && !/\s/.test(xmlData[i])) {
      elementName += xmlData[i];
      i++;
    }
    validateEntityName(elementName);
    i = skipWhitespace(xmlData, i);
    let attributeName = "";
    while (i < xmlData.length && !/\s/.test(xmlData[i])) {
      attributeName += xmlData[i];
      i++;
    }
    if (!validateEntityName(attributeName)) {
      throw new Error(`Invalid attribute name: "${attributeName}"`);
    }
    i = skipWhitespace(xmlData, i);
    let attributeType = "";
    if (xmlData.substring(i, i + 8).toUpperCase() === "NOTATION") {
      attributeType = "NOTATION";
      i += 8;
      i = skipWhitespace(xmlData, i);
      if (xmlData[i] !== "(") {
        throw new Error(`Expected '(', found "${xmlData[i]}"`);
      }
      i++;
      let allowedNotations = [];
      while (i < xmlData.length && xmlData[i] !== ")") {
        let notation = "";
        while (i < xmlData.length && xmlData[i] !== "|" && xmlData[i] !== ")") {
          notation += xmlData[i];
          i++;
        }
        notation = notation.trim();
        if (!validateEntityName(notation)) {
          throw new Error(`Invalid notation name: "${notation}"`);
        }
        allowedNotations.push(notation);
        if (xmlData[i] === "|") {
          i++;
          i = skipWhitespace(xmlData, i);
        }
      }
      if (xmlData[i] !== ")") {
        throw new Error("Unterminated list of notations");
      }
      i++;
      attributeType += " (" + allowedNotations.join("|") + ")";
    } else {
      while (i < xmlData.length && !/\s/.test(xmlData[i])) {
        attributeType += xmlData[i];
        i++;
      }
      const validTypes = ["CDATA", "ID", "IDREF", "IDREFS", "ENTITY", "ENTITIES", "NMTOKEN", "NMTOKENS"];
      if (!this.suppressValidationErr && !validTypes.includes(attributeType.toUpperCase())) {
        throw new Error(`Invalid attribute type: "${attributeType}"`);
      }
    }
    i = skipWhitespace(xmlData, i);
    let defaultValue = "";
    if (xmlData.substring(i, i + 8).toUpperCase() === "#REQUIRED") {
      defaultValue = "#REQUIRED";
      i += 8;
    } else if (xmlData.substring(i, i + 7).toUpperCase() === "#IMPLIED") {
      defaultValue = "#IMPLIED";
      i += 7;
    } else {
      [i, defaultValue] = this.readIdentifierVal(xmlData, i, "ATTLIST");
    }
    return {
      elementName,
      attributeName,
      attributeType,
      defaultValue,
      index: i
    };
  }
}
const skipWhitespace = (data, index2) => {
  while (index2 < data.length && /\s/.test(data[index2])) {
    index2++;
  }
  return index2;
};
function hasSeq(data, seq, i) {
  for (let j = 0; j < seq.length; j++) {
    if (seq[j] !== data[i + j + 1]) return false;
  }
  return true;
}
function validateEntityName(name) {
  if (isName(name))
    return name;
  else
    throw new Error(`Invalid entity name ${name}`);
}
const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
const numRegex = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/;
const consider = {
  hex: true,
  // oct: false,
  leadingZeros: true,
  decimalPoint: ".",
  eNotation: true
  //skipLike: /regex/
};
function toNumber(str, options = {}) {
  options = Object.assign({}, consider, options);
  if (!str || typeof str !== "string") return str;
  let trimmedStr = str.trim();
  if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr)) return str;
  else if (str === "0") return 0;
  else if (options.hex && hexRegex.test(trimmedStr)) {
    return parse_int(trimmedStr, 16);
  } else if (trimmedStr.includes("e") || trimmedStr.includes("E")) {
    return resolveEnotation(str, trimmedStr, options);
  } else {
    const match = numRegex.exec(trimmedStr);
    if (match) {
      const sign2 = match[1] || "";
      const leadingZeros = match[2];
      let numTrimmedByZeros = trimZeros(match[3]);
      const decimalAdjacentToLeadingZeros = sign2 ? (
        // 0., -00., 000.
        str[leadingZeros.length + 1] === "."
      ) : str[leadingZeros.length] === ".";
      if (!options.leadingZeros && (leadingZeros.length > 1 || leadingZeros.length === 1 && !decimalAdjacentToLeadingZeros)) {
        return str;
      } else {
        const num = Number(trimmedStr);
        const parsedStr = String(num);
        if (num === 0) return num;
        if (parsedStr.search(/[eE]/) !== -1) {
          if (options.eNotation) return num;
          else return str;
        } else if (trimmedStr.indexOf(".") !== -1) {
          if (parsedStr === "0") return num;
          else if (parsedStr === numTrimmedByZeros) return num;
          else if (parsedStr === `${sign2}${numTrimmedByZeros}`) return num;
          else return str;
        }
        let n = leadingZeros ? numTrimmedByZeros : trimmedStr;
        if (leadingZeros) {
          return n === parsedStr || sign2 + n === parsedStr ? num : str;
        } else {
          return n === parsedStr || n === sign2 + parsedStr ? num : str;
        }
      }
    } else {
      return str;
    }
  }
}
const eNotationRegx = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;
function resolveEnotation(str, trimmedStr, options) {
  if (!options.eNotation) return str;
  const notation = trimmedStr.match(eNotationRegx);
  if (notation) {
    let sign2 = notation[1] || "";
    const eChar = notation[3].indexOf("e") === -1 ? "E" : "e";
    const leadingZeros = notation[2];
    const eAdjacentToLeadingZeros = sign2 ? (
      // 0E.
      str[leadingZeros.length + 1] === eChar
    ) : str[leadingZeros.length] === eChar;
    if (leadingZeros.length > 1 && eAdjacentToLeadingZeros) return str;
    else if (leadingZeros.length === 1 && (notation[3].startsWith(`.${eChar}`) || notation[3][0] === eChar)) {
      return Number(trimmedStr);
    } else if (options.leadingZeros && !eAdjacentToLeadingZeros) {
      trimmedStr = (notation[1] || "") + notation[3];
      return Number(trimmedStr);
    } else return str;
  } else {
    return str;
  }
}
function trimZeros(numStr) {
  if (numStr && numStr.indexOf(".") !== -1) {
    numStr = numStr.replace(/0+$/, "");
    if (numStr === ".") numStr = "0";
    else if (numStr[0] === ".") numStr = "0" + numStr;
    else if (numStr[numStr.length - 1] === ".") numStr = numStr.substring(0, numStr.length - 1);
    return numStr;
  }
  return numStr;
}
function parse_int(numStr, base) {
  if (parseInt) return parseInt(numStr, base);
  else if (Number.parseInt) return Number.parseInt(numStr, base);
  else if (window && window.parseInt) return window.parseInt(numStr, base);
  else throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
}
function getIgnoreAttributesFn(ignoreAttributes) {
  if (typeof ignoreAttributes === "function") {
    return ignoreAttributes;
  }
  if (Array.isArray(ignoreAttributes)) {
    return (attrName) => {
      for (const pattern2 of ignoreAttributes) {
        if (typeof pattern2 === "string" && attrName === pattern2) {
          return true;
        }
        if (pattern2 instanceof RegExp && pattern2.test(attrName)) {
          return true;
        }
      }
    };
  }
  return () => false;
}
class OrderedObjParser {
  constructor(options) {
    this.options = options;
    this.currentNode = null;
    this.tagsNodeStack = [];
    this.docTypeEntities = {};
    this.lastEntities = {
      "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
      "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
      "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
      "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
    };
    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
    this.htmlEntities = {
      "space": { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      "cent": { regex: /&(cent|#162);/g, val: "" },
      "pound": { regex: /&(pound|#163);/g, val: "" },
      "yen": { regex: /&(yen|#165);/g, val: "" },
      "euro": { regex: /&(euro|#8364);/g, val: "" },
      "copyright": { regex: /&(copy|#169);/g, val: "" },
      "reg": { regex: /&(reg|#174);/g, val: "" },
      "inr": { regex: /&(inr|#8377);/g, val: "" },
      "num_dec": { regex: /&#([0-9]{1,7});/g, val: (_, str) => String.fromCodePoint(Number.parseInt(str, 10)) },
      "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_, str) => String.fromCodePoint(Number.parseInt(str, 16)) }
    };
    this.addExternalEntities = addExternalEntities;
    this.parseXml = parseXml;
    this.parseTextData = parseTextData;
    this.resolveNameSpace = resolveNameSpace;
    this.buildAttributesMap = buildAttributesMap;
    this.isItStopNode = isItStopNode;
    this.replaceEntitiesValue = replaceEntitiesValue;
    this.readStopNodeData = readStopNodeData;
    this.saveTextToParentTag = saveTextToParentTag;
    this.addChild = addChild;
    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
    if (this.options.stopNodes && this.options.stopNodes.length > 0) {
      this.stopNodesExact = /* @__PURE__ */ new Set();
      this.stopNodesWildcard = /* @__PURE__ */ new Set();
      for (let i = 0; i < this.options.stopNodes.length; i++) {
        const stopNodeExp = this.options.stopNodes[i];
        if (typeof stopNodeExp !== "string") continue;
        if (stopNodeExp.startsWith("*.")) {
          this.stopNodesWildcard.add(stopNodeExp.substring(2));
        } else {
          this.stopNodesExact.add(stopNodeExp);
        }
      }
    }
  }
}
function addExternalEntities(externalEntities) {
  const entKeys = Object.keys(externalEntities);
  for (let i = 0; i < entKeys.length; i++) {
    const ent = entKeys[i];
    this.lastEntities[ent] = {
      regex: new RegExp("&" + ent + ";", "g"),
      val: externalEntities[ent]
    };
  }
}
function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
  if (val !== void 0) {
    if (this.options.trimValues && !dontTrim) {
      val = val.trim();
    }
    if (val.length > 0) {
      if (!escapeEntities) val = this.replaceEntitiesValue(val);
      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
      if (newval === null || newval === void 0) {
        return val;
      } else if (typeof newval !== typeof val || newval !== val) {
        return newval;
      } else if (this.options.trimValues) {
        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
      } else {
        const trimmedVal = val.trim();
        if (trimmedVal === val) {
          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
        } else {
          return val;
        }
      }
    }
  }
}
function resolveNameSpace(tagname) {
  if (this.options.removeNSPrefix) {
    const tags = tagname.split(":");
    const prefix = tagname.charAt(0) === "/" ? "/" : "";
    if (tags[0] === "xmlns") {
      return "";
    }
    if (tags.length === 2) {
      tagname = prefix + tags[1];
    }
  }
  return tagname;
}
const attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function buildAttributesMap(attrStr, jPath) {
  if (this.options.ignoreAttributes !== true && typeof attrStr === "string") {
    const matches = getAllMatches(attrStr, attrsRegx);
    const len = matches.length;
    const attrs = {};
    for (let i = 0; i < len; i++) {
      const attrName = this.resolveNameSpace(matches[i][1]);
      if (this.ignoreAttributesFn(attrName, jPath)) {
        continue;
      }
      let oldVal = matches[i][4];
      let aName = this.options.attributeNamePrefix + attrName;
      if (attrName.length) {
        if (this.options.transformAttributeName) {
          aName = this.options.transformAttributeName(aName);
        }
        if (aName === "__proto__") aName = "#__proto__";
        if (oldVal !== void 0) {
          if (this.options.trimValues) {
            oldVal = oldVal.trim();
          }
          oldVal = this.replaceEntitiesValue(oldVal);
          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
          if (newVal === null || newVal === void 0) {
            attrs[aName] = oldVal;
          } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
            attrs[aName] = newVal;
          } else {
            attrs[aName] = parseValue(
              oldVal,
              this.options.parseAttributeValue,
              this.options.numberParseOptions
            );
          }
        } else if (this.options.allowBooleanAttributes) {
          attrs[aName] = true;
        }
      }
    }
    if (!Object.keys(attrs).length) {
      return;
    }
    if (this.options.attributesGroupName) {
      const attrCollection = {};
      attrCollection[this.options.attributesGroupName] = attrs;
      return attrCollection;
    }
    return attrs;
  }
}
const parseXml = function(xmlData) {
  xmlData = xmlData.replace(/\r\n?/g, "\n");
  const xmlObj = new XmlNode("!xml");
  let currentNode = xmlObj;
  let textData = "";
  let jPath = "";
  const docTypeReader = new DocTypeReader(this.options.processEntities);
  for (let i = 0; i < xmlData.length; i++) {
    const ch = xmlData[i];
    if (ch === "<") {
      if (xmlData[i + 1] === "/") {
        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
        let tagName = xmlData.substring(i + 2, closeIndex).trim();
        if (this.options.removeNSPrefix) {
          const colonIndex = tagName.indexOf(":");
          if (colonIndex !== -1) {
            tagName = tagName.substr(colonIndex + 1);
          }
        }
        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        if (currentNode) {
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
        }
        const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
        if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
        }
        let propIndex = 0;
        if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
          propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
          this.tagsNodeStack.pop();
        } else {
          propIndex = jPath.lastIndexOf(".");
        }
        jPath = jPath.substring(0, propIndex);
        currentNode = this.tagsNodeStack.pop();
        textData = "";
        i = closeIndex;
      } else if (xmlData[i + 1] === "?") {
        let tagData = readTagExp(xmlData, i, false, "?>");
        if (!tagData) throw new Error("Pi Tag is not closed.");
        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) ;
        else {
          const childNode = new XmlNode(tagData.tagName);
          childNode.add(this.options.textNodeName, "");
          if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
            childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath);
          }
          this.addChild(currentNode, childNode, jPath, i);
        }
        i = tagData.closeIndex + 1;
      } else if (xmlData.substr(i + 1, 3) === "!--") {
        const endIndex = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const comment = xmlData.substring(i + 4, endIndex - 2);
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
        }
        i = endIndex;
      } else if (xmlData.substr(i + 1, 2) === "!D") {
        const result = docTypeReader.readDocType(xmlData, i);
        this.docTypeEntities = result.entities;
        i = result.i;
      } else if (xmlData.substr(i + 1, 2) === "![") {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
        const tagExp = xmlData.substring(i + 9, closeIndex);
        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
        if (val == void 0) val = "";
        if (this.options.cdataPropName) {
          currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
        } else {
          currentNode.add(this.options.textNodeName, val);
        }
        i = closeIndex + 2;
      } else {
        let result = readTagExp(xmlData, i, this.options.removeNSPrefix);
        let tagName = result.tagName;
        const rawTagName = result.rawTagName;
        let tagExp = result.tagExp;
        let attrExpPresent = result.attrExpPresent;
        let closeIndex = result.closeIndex;
        if (this.options.transformTagName) {
          const newTagName = this.options.transformTagName(tagName);
          if (tagExp === tagName) {
            tagExp = newTagName;
          }
          tagName = newTagName;
        }
        if (currentNode && textData) {
          if (currentNode.tagname !== "!xml") {
            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
          }
        }
        const lastTag = currentNode;
        if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
          currentNode = this.tagsNodeStack.pop();
          jPath = jPath.substring(0, jPath.lastIndexOf("."));
        }
        if (tagName !== xmlObj.tagname) {
          jPath += jPath ? "." + tagName : tagName;
        }
        const startIndex = i;
        if (this.isItStopNode(this.stopNodesExact, this.stopNodesWildcard, jPath, tagName)) {
          let tagContent = "";
          if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            } else {
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            i = result.closeIndex;
          } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
            i = result.closeIndex;
          } else {
            const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
            if (!result2) throw new Error(`Unexpected end of ${rawTagName}`);
            i = result2.i;
            tagContent = result2.tagContent;
          }
          const childNode = new XmlNode(tagName);
          if (tagName !== tagExp && attrExpPresent) {
            childNode[":@"] = this.buildAttributesMap(
              tagExp,
              jPath
            );
          }
          if (tagContent) {
            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
          }
          jPath = jPath.substr(0, jPath.lastIndexOf("."));
          childNode.add(this.options.textNodeName, tagContent);
          this.addChild(currentNode, childNode, jPath, startIndex);
        } else {
          if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            } else {
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            if (this.options.transformTagName) {
              const newTagName = this.options.transformTagName(tagName);
              if (tagExp === tagName) {
                tagExp = newTagName;
              }
              tagName = newTagName;
            }
            const childNode = new XmlNode(tagName);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
            }
            this.addChild(currentNode, childNode, jPath, startIndex);
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
          } else {
            const childNode = new XmlNode(tagName);
            this.tagsNodeStack.push(currentNode);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
            }
            this.addChild(currentNode, childNode, jPath, startIndex);
            currentNode = childNode;
          }
          textData = "";
          i = closeIndex;
        }
      }
    } else {
      textData += xmlData[i];
    }
  }
  return xmlObj.child;
};
function addChild(currentNode, childNode, jPath, startIndex) {
  if (!this.options.captureMetaData) startIndex = void 0;
  const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
  if (result === false) ;
  else if (typeof result === "string") {
    childNode.tagname = result;
    currentNode.addChild(childNode, startIndex);
  } else {
    currentNode.addChild(childNode, startIndex);
  }
}
const replaceEntitiesValue = function(val) {
  if (this.options.processEntities) {
    for (let entityName in this.docTypeEntities) {
      const entity = this.docTypeEntities[entityName];
      val = val.replace(entity.regx, entity.val);
    }
    for (let entityName in this.lastEntities) {
      const entity = this.lastEntities[entityName];
      val = val.replace(entity.regex, entity.val);
    }
    if (this.options.htmlEntities) {
      for (let entityName in this.htmlEntities) {
        const entity = this.htmlEntities[entityName];
        val = val.replace(entity.regex, entity.val);
      }
    }
    val = val.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return val;
};
function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
  if (textData) {
    if (isLeafNode === void 0) isLeafNode = currentNode.child.length === 0;
    textData = this.parseTextData(
      textData,
      currentNode.tagname,
      jPath,
      false,
      currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
      isLeafNode
    );
    if (textData !== void 0 && textData !== "")
      currentNode.add(this.options.textNodeName, textData);
    textData = "";
  }
  return textData;
}
function isItStopNode(stopNodesExact, stopNodesWildcard, jPath, currentTagName) {
  if (stopNodesWildcard && stopNodesWildcard.has(currentTagName)) return true;
  if (stopNodesExact && stopNodesExact.has(jPath)) return true;
  return false;
}
function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
  let attrBoundary;
  let tagExp = "";
  for (let index2 = i; index2 < xmlData.length; index2++) {
    let ch = xmlData[index2];
    if (attrBoundary) {
      if (ch === attrBoundary) attrBoundary = "";
    } else if (ch === '"' || ch === "'") {
      attrBoundary = ch;
    } else if (ch === closingChar[0]) {
      if (closingChar[1]) {
        if (xmlData[index2 + 1] === closingChar[1]) {
          return {
            data: tagExp,
            index: index2
          };
        }
      } else {
        return {
          data: tagExp,
          index: index2
        };
      }
    } else if (ch === "	") {
      ch = " ";
    }
    tagExp += ch;
  }
}
function findClosingIndex(xmlData, str, i, errMsg) {
  const closingIndex = xmlData.indexOf(str, i);
  if (closingIndex === -1) {
    throw new Error(errMsg);
  } else {
    return closingIndex + str.length - 1;
  }
}
function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
  const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
  if (!result) return;
  let tagExp = result.data;
  const closeIndex = result.index;
  const separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp;
  let attrExpPresent = true;
  if (separatorIndex !== -1) {
    tagName = tagExp.substring(0, separatorIndex);
    tagExp = tagExp.substring(separatorIndex + 1).trimStart();
  }
  const rawTagName = tagName;
  if (removeNSPrefix) {
    const colonIndex = tagName.indexOf(":");
    if (colonIndex !== -1) {
      tagName = tagName.substr(colonIndex + 1);
      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
    }
  }
  return {
    tagName,
    tagExp,
    closeIndex,
    attrExpPresent,
    rawTagName
  };
}
function readStopNodeData(xmlData, tagName, i) {
  const startIndex = i;
  let openTagCount = 1;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === "<") {
      if (xmlData[i + 1] === "/") {
        const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
        let closeTagName = xmlData.substring(i + 2, closeIndex).trim();
        if (closeTagName === tagName) {
          openTagCount--;
          if (openTagCount === 0) {
            return {
              tagContent: xmlData.substring(startIndex, i),
              i: closeIndex
            };
          }
        }
        i = closeIndex;
      } else if (xmlData[i + 1] === "?") {
        const closeIndex = findClosingIndex(xmlData, "?>", i + 1, "StopNode is not closed.");
        i = closeIndex;
      } else if (xmlData.substr(i + 1, 3) === "!--") {
        const closeIndex = findClosingIndex(xmlData, "-->", i + 3, "StopNode is not closed.");
        i = closeIndex;
      } else if (xmlData.substr(i + 1, 2) === "![") {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
        i = closeIndex;
      } else {
        const tagData = readTagExp(xmlData, i, ">");
        if (tagData) {
          const openTagName = tagData && tagData.tagName;
          if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
            openTagCount++;
          }
          i = tagData.closeIndex;
        }
      }
    }
  }
}
function parseValue(val, shouldParse, options) {
  if (shouldParse && typeof val === "string") {
    const newval = val.trim();
    if (newval === "true") return true;
    else if (newval === "false") return false;
    else return toNumber(val, options);
  } else {
    if (isExist(val)) {
      return val;
    } else {
      return "";
    }
  }
}
const METADATA_SYMBOL = XmlNode.getMetaDataSymbol();
function prettify(node, options) {
  return compress(node, options);
}
function compress(arr, options, jPath) {
  let text;
  const compressedObj = {};
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i];
    const property = propName(tagObj);
    let newJpath = "";
    if (jPath === void 0) newJpath = property;
    else newJpath = jPath + "." + property;
    if (property === options.textNodeName) {
      if (text === void 0) text = tagObj[property];
      else text += "" + tagObj[property];
    } else if (property === void 0) {
      continue;
    } else if (tagObj[property]) {
      let val = compress(tagObj[property], options, newJpath);
      const isLeaf = isLeafTag(val, options);
      if (tagObj[METADATA_SYMBOL] !== void 0) {
        val[METADATA_SYMBOL] = tagObj[METADATA_SYMBOL];
      }
      if (tagObj[":@"]) {
        assignAttributes(val, tagObj[":@"], newJpath, options);
      } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
        val = val[options.textNodeName];
      } else if (Object.keys(val).length === 0) {
        if (options.alwaysCreateTextNode) val[options.textNodeName] = "";
        else val = "";
      }
      if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
        if (!Array.isArray(compressedObj[property])) {
          compressedObj[property] = [compressedObj[property]];
        }
        compressedObj[property].push(val);
      } else {
        if (options.isArray(property, newJpath, isLeaf)) {
          compressedObj[property] = [val];
        } else {
          compressedObj[property] = val;
        }
      }
    }
  }
  if (typeof text === "string") {
    if (text.length > 0) compressedObj[options.textNodeName] = text;
  } else if (text !== void 0) compressedObj[options.textNodeName] = text;
  return compressedObj;
}
function propName(obj) {
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key2 = keys[i];
    if (key2 !== ":@") return key2;
  }
}
function assignAttributes(obj, attrMap, jpath, options) {
  if (attrMap) {
    const keys = Object.keys(attrMap);
    const len = keys.length;
    for (let i = 0; i < len; i++) {
      const atrrName = keys[i];
      if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
        obj[atrrName] = [attrMap[atrrName]];
      } else {
        obj[atrrName] = attrMap[atrrName];
      }
    }
  }
}
function isLeafTag(obj, options) {
  const { textNodeName } = options;
  const propCount = Object.keys(obj).length;
  if (propCount === 0) {
    return true;
  }
  if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
    return true;
  }
  return false;
}
class XMLParser {
  constructor(options) {
    this.externalEntities = {};
    this.options = buildOptions(options);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Uint8Array} xmlData 
   * @param {boolean|Object} validationOption 
   */
  parse(xmlData, validationOption) {
    if (typeof xmlData !== "string" && xmlData.toString) {
      xmlData = xmlData.toString();
    } else if (typeof xmlData !== "string") {
      throw new Error("XML data is accepted in String or Bytes[] form.");
    }
    if (validationOption) {
      if (validationOption === true) validationOption = {};
      const result = validate(xmlData, validationOption);
      if (result !== true) {
        throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
      }
    }
    const orderedObjParser = new OrderedObjParser(this.options);
    orderedObjParser.addExternalEntities(this.externalEntities);
    const orderedResult = orderedObjParser.parseXml(xmlData);
    if (this.options.preserveOrder || orderedResult === void 0) return orderedResult;
    else return prettify(orderedResult, this.options);
  }
  /**
   * Add Entity which is not by default supported by this library
   * @param {string} key 
   * @param {string} value 
   */
  addEntity(key2, value) {
    if (value.indexOf("&") !== -1) {
      throw new Error("Entity value can't have '&'");
    } else if (key2.indexOf("&") !== -1 || key2.indexOf(";") !== -1) {
      throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    } else if (value === "&") {
      throw new Error("An entity with value '&' is not permitted");
    } else {
      this.externalEntities[key2] = value;
    }
  }
  /**
   * Returns a Symbol that can be used to access the metadata
   * property on a node.
   * 
   * If Symbol is not available in the environment, an ordinary property is used
   * and the name of the property is here returned.
   * 
   * The XMLMetaData property is only present when `captureMetaData`
   * is true in the options.
   */
  static getMetaDataSymbol() {
    return XmlNode.getMetaDataSymbol();
  }
}
async function transformIncomingPrivateMessage(ctx, friend, category, message) {
  return {
    message_scene: "friend",
    peer_id: +message.peerUin,
    message_seq: +message.msgSeq,
    sender_id: +message.senderUin,
    time: +message.msgTime,
    segments: await transformIncomingSegments(ctx, message),
    friend: transformFriend(friend, category)
  };
}
async function transformIncomingGroupMessage(ctx, group, member, message) {
  return {
    message_scene: "group",
    peer_id: +message.peerUin,
    message_seq: +message.msgSeq,
    sender_id: +message.senderUin,
    time: +message.msgTime,
    segments: await transformIncomingSegments(ctx, message),
    group: transformGroup(group),
    group_member: transformGroupMember(member, +group.groupCode)
  };
}
async function transformIncomingTempMessage(ctx, group, message) {
  return {
    message_scene: "temp",
    peer_id: +message.peerUin,
    message_seq: +message.msgSeq,
    sender_id: +message.senderUin,
    time: +message.msgTime,
    segments: await transformIncomingSegments(ctx, message),
    group: transformGroup(group)
  };
}
async function transformIncomingSegments(ctx, message) {
  const segments = [];
  for (const element of message.elements) {
    switch (element.elementType) {
      case ElementType.Text:
        if (element.textElement?.atType === AtType.All) {
          segments.push({
            type: "mention_all",
            data: {}
          });
        } else if (element.textElement?.atType === AtType.One) {
          segments.push({
            type: "mention",
            data: {
              user_id: +element.textElement.atUid
            }
          });
        } else if (element.textElement?.content) {
          segments.push({
            type: "text",
            data: {
              text: element.textElement.content
            }
          });
        }
        break;
      case ElementType.Face:
        segments.push({
          type: "face",
          data: {
            face_id: element.faceElement.faceIndex.toString(),
            is_large: element.faceElement.faceType === 3
          }
        });
        break;
      case ElementType.Reply:
        segments.push({
          type: "reply",
          data: {
            message_seq: +element.replyElement.replayMsgSeq
          }
        });
        break;
      case ElementType.Pic:
        segments.push({
          type: "image",
          data: {
            resource_id: element.picElement.fileUuid,
            temp_url: await ctx.ntFileApi.getImageUrl(element.picElement),
            width: element.picElement.picWidth,
            height: element.picElement.picHeight,
            summary: element.picElement.summary || "[]",
            sub_type: element.picElement.picSubType === 1 ? "sticker" : "normal"
          }
        });
        break;
      case ElementType.Ptt:
        segments.push({
          type: "record",
          data: {
            resource_id: element.pttElement.fileUuid,
            temp_url: await ctx.ntFileApi.getPttUrl(element.pttElement.fileUuid, message.chatType === 2),
            duration: element.pttElement.duration
          }
        });
        break;
      case ElementType.Video:
        segments.push({
          type: "video",
          data: {
            resource_id: element.videoElement.fileUuid,
            temp_url: await ctx.ntFileApi.getVideoUrl({
              chatType: message.chatType,
              peerUid: message.peerUid,
              guildId: message.guildId
            }, message.msgId, element.elementId),
            width: element.videoElement.thumbWidth,
            height: element.videoElement.thumbHeight,
            duration: element.videoElement.fileTime
          }
        });
        break;
      case ElementType.File:
        segments.push({
          type: "file",
          data: {
            file_id: element.fileElement.fileUuid,
            file_name: element.fileElement.fileName,
            file_size: +element.fileElement.fileSize
          }
        });
        break;
      case ElementType.MultiForward: {
        const parser = new XMLParser();
        const content = parser.parse(element.multiForwardMsgElement.xmlContent);
        segments.push({
          type: "forward",
          data: {
            forward_id: element.multiForwardMsgElement.resId,
            title: content.msg.item.title[0],
            preview: content.msg.item.title.slice(1),
            summary: content.msg.item.summary
          }
        });
        break;
      }
      case ElementType.MarketFace:
        segments.push({
          type: "market_face",
          data: {
            emoji_package_id: element.marketFaceElement.emojiPackageId,
            emoji_id: element.marketFaceElement.emojiId,
            key: element.marketFaceElement.key,
            summary: element.marketFaceElement.faceName,
            url: `https://gxh.vip.qq.com/club/item/parcel/item/${element.marketFaceElement.emojiId.substring(0, 2)}/${element.marketFaceElement.emojiId}/raw300.gif`
          }
        });
        break;
      case ElementType.Ark:
        segments.push({
          type: "light_app",
          data: {
            app_name: JSON.parse(element.arkElement.bytesData).app,
            json_payload: element.arkElement.bytesData
          }
        });
        break;
    }
  }
  return segments;
}
async function transformIncomingForwardedMessage(ctx, message) {
  const { body, contentHead, routingHead } = message;
  const segments = [];
  for (const elem of body.richText.elems) {
    if (elem.text) {
      segments.push({
        type: "text",
        data: {
          text: elem.text.str
        }
      });
    } else if (elem.commonElem) {
      const { businessType, serviceType } = elem.commonElem;
      if (serviceType === 33) {
        const { faceId } = Msg.QSmallFaceExtra.decode(elem.commonElem.pbElem);
        segments.push({
          type: "face",
          data: {
            face_id: faceId.toString(),
            is_large: false
          }
        });
      } else if (serviceType === 48 && (businessType === 10 || businessType === 20)) {
        const { extBizInfo, msgInfoBody } = Media.MsgInfo.decode(elem.commonElem.pbElem);
        const { index: index2, pic } = msgInfoBody[0];
        const rkeyData = await ctx.ntFileApi.rkeyManager.getRkey();
        const rkey = businessType === 10 ? rkeyData.private_rkey : rkeyData.group_rkey;
        const url2 = `https://${pic.domain}${pic.urlPath}&spec=0${rkey}`;
        segments.push({
          type: "image",
          data: {
            resource_id: index2.fileUuid,
            temp_url: url2,
            width: index2.info.width,
            height: index2.info.height,
            summary: extBizInfo.pic.summary || "[]",
            sub_type: extBizInfo.pic.bizType === 0 ? "normal" : "sticker"
          }
        });
      } else if (serviceType === 48 && (businessType === 11 || businessType === 21)) {
        const { msgInfoBody } = Media.MsgInfo.decode(elem.commonElem.pbElem);
        const { index: index2 } = msgInfoBody[0];
        const url2 = await ctx.ntFileApi.getVideoUrlByPacket(index2.fileUuid, businessType === 21);
        segments.push({
          type: "video",
          data: {
            resource_id: index2.fileUuid,
            temp_url: url2,
            width: index2.info.width,
            height: index2.info.height,
            duration: index2.info.time
          }
        });
      }
    } else if (elem.srcMsg) {
      segments.push({
        type: "reply",
        data: {
          message_seq: elem.srcMsg.origSeqs[0]
        }
      });
    } else if (elem.richMsg && elem.richMsg.serviceId === 35) {
      const xml = inflateSync(elem.richMsg.template.subarray(1)).toString();
      const resId = xml.match(/m_resid="([^"]+)"/)?.[1];
      if (resId) {
        const parser = new XMLParser();
        const content = parser.parse(xml);
        segments.push({
          type: "forward",
          data: {
            forward_id: resId,
            title: content.msg.item.title[0],
            preview: content.msg.item.title.slice(1),
            summary: content.msg.item.summary
          }
        });
      }
    }
  }
  return {
    sender_name: contentHead.msgType === 82 ? routingHead.group.groupCard : routingHead.c2c.friendName,
    avatar_url: contentHead.forward.avatar,
    time: contentHead.msgTime,
    segments
  };
}
const SendPrivateMessage = defineApi(
  "send_private_message",
  SendPrivateMessageInput,
  SendPrivateMessageOutput,
  async (ctx, payload) => {
    const uid = await ctx.ntUserApi.getUidByUin(payload.user_id.toString());
    if (!uid) {
      return Failed(-404, "User not found");
    }
    const peer = { chatType: 1, peerUid: uid, guildId: "" };
    const isBuddy = await ctx.ntFriendApi.isBuddy(uid);
    if (!isBuddy) {
      const result2 = await ctx.ntMsgApi.getTempChatInfo(100, uid);
      if (result2.tmpChatInfo.groupCode) {
        peer.chatType = 100;
      }
    }
    let result;
    if (payload.message[0].type === "forward") {
      const raw = await transformOutgoingForwardMessages(
        ctx,
        payload.message[0].data.messages,
        peer
      );
      const resid = await ctx.app.pmhq.uploadForward(peer, raw.multiMsgItems);
      const uuid2 = randomUUID();
      result = await ctx.app.sendMessage(ctx, peer, [{
        elementType: 10,
        elementId: "",
        arkElement: {
          bytesData: JSON.stringify({
            app: "com.tencent.multimsg",
            config: {
              autosize: 1,
              forward: 1,
              round: 1,
              type: "normal",
              width: 300
            },
            desc: "[]",
            extra: JSON.stringify({
              filename: uuid2,
              tsum: raw.tsum
            }),
            meta: {
              detail: {
                news: raw.news,
                resid,
                source: raw.source,
                summary: raw.summary,
                uniseq: uuid2
              }
            },
            prompt: "[]",
            ver: "0.0.0.5",
            view: "contact"
          })
        }
      }], []);
    } else {
      const { elements, deleteAfterSentFiles } = await transformOutgoingMessage(
        ctx,
        payload.message,
        uid,
        false
      );
      result = await ctx.app.sendMessage(
        ctx,
        peer,
        elements,
        deleteAfterSentFiles
      );
    }
    return Ok({
      message_seq: +result.msgSeq,
      time: +result.msgTime
    });
  }
);
const SendGroupMessage = defineApi(
  "send_group_message",
  SendGroupMessageInput,
  SendGroupMessageOutput,
  async (ctx, payload) => {
    const groupCode = payload.group_id.toString();
    const peer = { chatType: 2, peerUid: groupCode, guildId: "" };
    let result;
    if (payload.message[0].type === "forward") {
      const raw = await transformOutgoingForwardMessages(
        ctx,
        payload.message[0].data.messages,
        peer
      );
      const resid = await ctx.app.pmhq.uploadForward(peer, raw.multiMsgItems);
      const uuid2 = randomUUID();
      result = await ctx.app.sendMessage(ctx, peer, [{
        elementType: 10,
        elementId: "",
        arkElement: {
          bytesData: JSON.stringify({
            app: "com.tencent.multimsg",
            config: {
              autosize: 1,
              forward: 1,
              round: 1,
              type: "normal",
              width: 300
            },
            desc: "[]",
            extra: JSON.stringify({
              filename: uuid2,
              tsum: raw.tsum
            }),
            meta: {
              detail: {
                news: raw.news,
                resid,
                source: raw.source,
                summary: raw.summary,
                uniseq: uuid2
              }
            },
            prompt: "[]",
            ver: "0.0.0.5",
            view: "contact"
          })
        }
      }], []);
    } else {
      const { elements, deleteAfterSentFiles } = await transformOutgoingMessage(
        ctx,
        payload.message,
        groupCode,
        true
      );
      result = await ctx.app.sendMessage(
        ctx,
        peer,
        elements,
        deleteAfterSentFiles
      );
    }
    return Ok({
      message_seq: +result.msgSeq,
      time: +result.msgTime
    });
  }
);
const RecallPrivateMessage = defineApi(
  "recall_private_message",
  RecallPrivateMessageInput,
  z.object({}),
  async (ctx, payload) => {
    const uid = await ctx.ntUserApi.getUidByUin(payload.user_id.toString());
    if (!uid) {
      return Failed(-404, "User not found");
    }
    const peer = { chatType: 1, peerUid: uid, guildId: "" };
    const isBuddy = await ctx.ntFriendApi.isBuddy(uid);
    if (!isBuddy) {
      const result2 = await ctx.ntMsgApi.getTempChatInfo(100, uid);
      if (result2.tmpChatInfo.groupCode) {
        peer.chatType = 100;
      }
    }
    const msg = await ctx.ntMsgApi.getMsgsBySeqAndCount(
      peer,
      payload.message_seq.toString(),
      1,
      true,
      true
    );
    if (msg.msgList.length === 0) {
      return Failed(-404, "Message not found");
    }
    const result = await ctx.ntMsgApi.recallMsg(peer, [msg.msgList[0].msgId]);
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const RecallGroupMessage = defineApi(
  "recall_group_message",
  RecallGroupMessageInput,
  z.object({}),
  async (ctx, payload) => {
    const peer = { chatType: 2, peerUid: payload.group_id.toString(), guildId: "" };
    const msg = await ctx.ntMsgApi.getMsgsBySeqAndCount(
      peer,
      payload.message_seq.toString(),
      1,
      true,
      true
    );
    if (msg.msgList.length === 0) {
      return Failed(-404, "Message not found");
    }
    const result = await ctx.ntMsgApi.recallMsg(peer, [msg.msgList[0].msgId]);
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const GetMessage = defineApi(
  "get_message",
  GetMessageInput,
  GetMessageOutput,
  async (ctx, payload) => {
    const peer = {
      chatType: {
        friend: 1,
        group: 2,
        temp: 100
      }[payload.message_scene],
      peerUid: payload.peer_id.toString(),
      guildId: ""
    };
    if (peer.chatType === 1 || peer.chatType === 100) {
      const uid = await ctx.ntUserApi.getUidByUin(peer.peerUid);
      if (!uid) {
        return Failed(-404, "User not found");
      }
      peer.peerUid = uid;
    }
    const msgResult = await ctx.ntMsgApi.getMsgsBySeqAndCount(
      peer,
      payload.message_seq.toString(),
      1,
      true,
      true
    );
    if (msgResult.msgList.length === 0) {
      return Failed(-404, "Message not found");
    }
    const rawMsg = msgResult.msgList[0];
    if (payload.message_scene === "friend") {
      const friend = await ctx.ntUserApi.getUserSimpleInfo(rawMsg.senderUid);
      const category = await ctx.ntFriendApi.getCategoryById(friend.baseInfo.categoryId);
      return Ok({
        message: await transformIncomingPrivateMessage(ctx, friend, category, rawMsg)
      });
    } else if (payload.message_scene === "group") {
      const group = await ctx.ntGroupApi.getGroupAllInfo(rawMsg.peerUid);
      const member = await ctx.ntGroupApi.getGroupMember(rawMsg.peerUin, rawMsg.senderUid);
      return Ok({
        message: await transformIncomingGroupMessage(ctx, group, member, rawMsg)
      });
    } else {
      const { tmpChatInfo } = await ctx.ntMsgApi.getTempChatInfo(100, rawMsg.peerUid);
      const group = await ctx.ntGroupApi.getGroupAllInfo(tmpChatInfo.groupCode);
      return Ok({
        message: await transformIncomingTempMessage(ctx, group, rawMsg)
      });
    }
  }
);
const GetHistoryMessages = defineApi(
  "get_history_messages",
  GetHistoryMessagesInput,
  GetHistoryMessagesOutput,
  async (ctx, payload) => {
    const peer = {
      chatType: {
        friend: 1,
        group: 2,
        temp: 100
      }[payload.message_scene],
      peerUid: payload.peer_id.toString(),
      guildId: ""
    };
    if (peer.chatType === 1 || peer.chatType === 100) {
      const uid = await ctx.ntUserApi.getUidByUin(peer.peerUid);
      if (!uid) {
        return Failed(-404, "User not found");
      }
      peer.peerUid = uid;
    }
    let msgList;
    if (!payload.start_message_seq) {
      msgList = (await ctx.ntMsgApi.getAioFirstViewLatestMsgs(peer, payload.limit)).msgList;
    } else {
      msgList = (await ctx.ntMsgApi.getMsgsBySeqAndCount(peer, payload.start_message_seq.toString(), payload.limit, true, true)).msgList;
    }
    if (msgList.length === 0) {
      return Ok({
        messages: [],
        next_message_seq: void 0
      });
    }
    const filteredMsgList = msgList.filter((msg) => {
      if (!msg.senderUid) return false;
      if (msg.elements[0].grayTipElement?.subElementType === 1) return false;
      return true;
    });
    const transformedMessages = [];
    if (payload.message_scene === "friend") {
      for (const msg of filteredMsgList) {
        const friend = await ctx.ntUserApi.getUserSimpleInfo(msg.senderUid);
        const category = await ctx.ntFriendApi.getCategoryById(friend.baseInfo.categoryId);
        transformedMessages.push(await transformIncomingPrivateMessage(ctx, friend, category, msg));
      }
    } else if (payload.message_scene === "group") {
      const group = await ctx.ntGroupApi.getGroupAllInfo(payload.peer_id.toString());
      for (const msg of filteredMsgList) {
        const member = await ctx.ntGroupApi.getGroupMember(msg.peerUid, msg.senderUid);
        transformedMessages.push(await transformIncomingGroupMessage(ctx, group, member, msg));
      }
    } else {
      for (const msg of filteredMsgList) {
        const { tmpChatInfo } = await ctx.ntMsgApi.getTempChatInfo(100, msg.peerUid);
        const group = await ctx.ntGroupApi.getGroupAllInfo(tmpChatInfo.groupCode);
        transformedMessages.push(await transformIncomingTempMessage(ctx, group, msg));
      }
    }
    let nextMessageSeq = void 0;
    if (msgList.length > 0) {
      const seq = +msgList[0].msgSeq - 1;
      if (seq >= 0) {
        nextMessageSeq = seq;
      }
    }
    return Ok({
      messages: transformedMessages,
      next_message_seq: nextMessageSeq
    });
  }
);
const GetResourceTempUrl = defineApi(
  "get_resource_temp_url",
  GetResourceTempUrlInput,
  GetResourceTempUrlOutput,
  async (ctx, payload) => {
    const buffer2 = Buffer.from(payload.resource_id, "base64url");
    const { appid } = Media.FileIdInfo.decode(buffer2);
    if (appid === 1402 || appid === 1403) {
      const url2 = await ctx.ntFileApi.getPttUrl(payload.resource_id, appid === 1403);
      return Ok({ url: url2 });
    } else if (appid === 1406 || appid === 1407) {
      const rkeyData = await ctx.ntFileApi.rkeyManager.getRkey(true);
      const rkey = appid === 1406 ? rkeyData.private_rkey : rkeyData.group_rkey;
      const url2 = `${IMAGE_HTTP_HOST_NT}/download?appid=${appid}&fileid=${payload.resource_id}&spec=0${rkey}`;
      return Ok({ url: url2 });
    } else if (appid === 1413 || appid === 1415) {
      const url2 = await ctx.ntFileApi.getVideoUrlByPacket(payload.resource_id, appid === 1415);
      return Ok({ url: url2 });
    } else {
      ctx.logger.warn(`GetResourceTempUrl: not yet supported appid: ${appid}`);
      return Ok({
        url: ""
      });
    }
  }
);
const GetForwardedMessages = defineApi(
  "get_forwarded_messages",
  GetForwardedMessagesInput,
  GetForwardedMessagesOutput,
  async (ctx, payload) => {
    const result = await ctx.app.pmhq.getMultiMsg(payload.forward_id);
    return Ok({
      messages: await Promise.all(
        result[0].buffer.msg.map(async (e) => await transformIncomingForwardedMessage(ctx, e))
      )
    });
  }
);
const MarkMessageAsRead = defineApi(
  "mark_message_as_read",
  MarkMessageAsReadInput,
  z.object({}),
  async (ctx, payload) => {
    const peer = {
      chatType: {
        friend: 1,
        group: 2,
        temp: 100
      }[payload.message_scene],
      peerUid: payload.peer_id.toString(),
      guildId: ""
    };
    if (peer.chatType === 1 || peer.chatType === 100) {
      const uid = await ctx.ntUserApi.getUidByUin(peer.peerUid);
      if (!uid) {
        return Failed(-404, "User not found");
      }
      peer.peerUid = uid;
    }
    const result = await ctx.ntMsgApi.setMsgRead(peer);
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const MessageApi = [
  SendPrivateMessage,
  SendGroupMessage,
  GetMessage,
  GetHistoryMessages,
  GetResourceTempUrl,
  RecallPrivateMessage,
  RecallGroupMessage,
  GetForwardedMessages,
  MarkMessageAsRead
];
const SendFriendNudge = defineApi(
  "send_friend_nudge",
  SendFriendNudgeInput,
  z.object({}),
  async (ctx, payload) => {
    await ctx.app.pmhq.sendFriendPoke(payload.user_id);
    return Ok({});
  }
);
const SendProfileLike = defineApi(
  "send_profile_like",
  SendProfileLikeInput,
  z.object({}),
  async (ctx, payload) => {
    const uid = await ctx.ntUserApi.getUidByUin(payload.user_id.toString());
    if (!uid) {
      return Failed(-404, "User not found");
    }
    const result = await ctx.ntUserApi.like(uid, payload.count);
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const DeleteFriend2 = defineApi(
  "delete_friend",
  DeleteFriendInput,
  z.object({}),
  async (ctx, payload) => {
    const uid = await ctx.ntUserApi.getUidByUin(payload.user_id.toString());
    if (!uid) {
      return Failed(-404, "User not found");
    }
    const result = await ctx.ntFriendApi.delBuddy(uid);
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const GetFriendRequests = defineApi(
  "get_friend_requests",
  GetFriendRequestsInput,
  GetFriendRequestsOutput,
  async (ctx, payload) => {
    if (payload.is_filtered) {
      const result = await ctx.ntFriendApi.getDoubtBuddyReq(payload.limit);
      return Ok({
        requests: await Promise.all(result.doubtList.map(async (e) => {
          return {
            time: Number(e.reqTime),
            initiator_id: Number(await ctx.ntUserApi.getUinByUid(e.uid)),
            initiator_uid: e.uid,
            target_user_id: Number(selfInfo.uin),
            target_user_uid: selfInfo.uid,
            state: "pending",
            comment: e.msg,
            via: e.source,
            is_filtered: true
          };
        }))
      });
    } else {
      const result = await ctx.ntFriendApi.getBuddyReq();
      let buddyReqs = result.buddyReqs;
      if (buddyReqs.length > payload.limit) {
        buddyReqs = buddyReqs.slice(0, payload.limit);
      }
      return Ok({
        requests: await Promise.all(buddyReqs.map(async (e) => {
          const friendId = Number(await ctx.ntUserApi.getUinByUid(e.friendUid));
          const selfId = Number(selfInfo.uin);
          let via = "";
          if (e.sourceId === 3020) {
            via = "QQ";
          } else if (e.sourceId === 3004) {
            const groupAll = await ctx.ntGroupApi.getGroupAllInfo(e.groupCode);
            via = `QQ-${groupAll.groupName}`;
          } else if (e.sourceId === 3014) {
            via = "";
          } else if (e.sourceId === 3999) {
            via = "";
          } else if (e.sourceId === 3022) {
            via = "";
          } else if (e.sourceId > 10) {
            ctx.logger.info(`via , , friendId: ${friendId}, sourceId: ${e.sourceId}`);
          }
          return {
            time: Number(e.reqTime),
            initiator_id: e.isInitiator ? selfId : friendId,
            initiator_uid: e.isInitiator ? selfInfo.uid : e.friendUid,
            target_user_id: e.isInitiator ? friendId : selfId,
            target_user_uid: e.isInitiator ? e.friendUid : selfInfo.uid,
            state: {
              [BuddyReqType.PeerInitiator]: "pending",
              [BuddyReqType.MeInitiatorWaitPeerConfirm]: "pending",
              [BuddyReqType.PeerAgreed]: "accepted",
              [BuddyReqType.MeAgreed]: "accepted",
              [BuddyReqType.PeerRefused]: "rejected",
              [BuddyReqType.MeRefused]: "rejected"
            }[e.reqType] ?? "pending",
            comment: e.extWords,
            via,
            is_filtered: e.isDoubt
          };
        }))
      });
    }
  }
);
const AcceptFriendRequest = defineApi(
  "accept_friend_request",
  AcceptFriendRequestInput,
  z.object({}),
  async (ctx, payload) => {
    let result;
    if (payload.is_filtered) {
      result = await ctx.ntFriendApi.approvalDoubtBuddyReq(payload.initiator_uid);
    } else {
      result = await ctx.ntFriendApi.handleFriendRequest(payload.initiator_uid, "0", true);
    }
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const RejectFriendRequest = defineApi(
  "reject_friend_request",
  RejectFriendRequestInput,
  z.object({}),
  async (ctx, payload) => {
    if (!payload.is_filtered) {
      const result = await ctx.ntFriendApi.handleFriendRequest(payload.initiator_uid, "0", false);
      if (result.result !== 0) {
        return Failed(-500, result.errMsg);
      }
    }
    return Ok({});
  }
);
const FriendApi = [
  SendFriendNudge,
  SendProfileLike,
  DeleteFriend2,
  GetFriendRequests,
  AcceptFriendRequest,
  RejectFriendRequest
];
const SetGroupName2 = defineApi(
  "set_group_name",
  SetGroupNameInput,
  z.object({}),
  async (ctx, payload) => {
    const result = await ctx.ntGroupApi.setGroupName(payload.group_id.toString(), payload.new_group_name);
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const SetGroupAvatar = defineApi(
  "set_group_avatar",
  SetGroupAvatarInput,
  z.object({}),
  async (ctx, payload) => {
    const imageBuffer = await resolveMilkyUri(payload.image_uri);
    const tempPath = path__default.join(TEMP_DIR, `group-avatar-${randomUUID()}`);
    await writeFile(tempPath, imageBuffer);
    const result = await ctx.ntGroupApi.setGroupAvatar(payload.group_id.toString(), tempPath);
    unlink(tempPath).catch((e) => {
    });
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const SetGroupMemberCard = defineApi(
  "set_group_member_card",
  SetGroupMemberCardInput,
  z.object({}),
  async (ctx, payload) => {
    const groupCode = payload.group_id.toString();
    const memberUid = await ctx.ntUserApi.getUidByUin(payload.user_id.toString(), groupCode);
    const result = await ctx.ntGroupApi.setMemberCard(
      groupCode,
      memberUid,
      payload.card
    );
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const SetGroupMemberSpecialTitle = defineApi(
  "set_group_member_special_title",
  SetGroupMemberSpecialTitleInput,
  z.object({}),
  async (ctx, payload) => {
    const memberUid = await ctx.ntUserApi.getUidByUin(payload.user_id.toString(), payload.group_id.toString());
    await ctx.app.pmhq.setSpecialTitle(
      payload.group_id,
      memberUid,
      payload.special_title
    );
    return Ok({});
  }
);
const SetGroupMemberAdmin = defineApi(
  "set_group_member_admin",
  SetGroupMemberAdminInput,
  z.object({}),
  async (ctx, payload) => {
    const groupCode = payload.group_id.toString();
    const memberUid = await ctx.ntUserApi.getUidByUin(payload.user_id.toString(), groupCode);
    const result = await ctx.ntGroupApi.setMemberRole(
      groupCode,
      memberUid,
      payload.is_set ? 3 : 2
    );
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const SetGroupMemberMute = defineApi(
  "set_group_member_mute",
  SetGroupMemberMuteInput,
  z.object({}),
  async (ctx, payload) => {
    const groupCode = payload.group_id.toString();
    const uid = await ctx.ntUserApi.getUidByUin(payload.user_id.toString(), groupCode);
    const result = await ctx.ntGroupApi.banMember(
      groupCode,
      [{ uid, timeStamp: payload.duration }]
    );
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const SetGroupWholeMute = defineApi(
  "set_group_whole_mute",
  SetGroupWholeMuteInput,
  z.object({}),
  async (ctx, payload) => {
    const result = await ctx.ntGroupApi.banGroup(payload.group_id.toString(), payload.is_mute);
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const KickGroupMember = defineApi(
  "kick_group_member",
  KickGroupMemberInput,
  z.object({}),
  async (ctx, payload) => {
    const groupCode = payload.group_id.toString();
    const memberUid = await ctx.ntUserApi.getUidByUin(payload.user_id.toString(), groupCode);
    const result = await ctx.ntGroupApi.kickMember(
      groupCode,
      [memberUid],
      payload.reject_add_request
    );
    if (result.errCode !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const GetGroupAnnouncements = defineApi(
  "get_group_announcements",
  GetGroupAnnouncementsInput,
  GetGroupAnnouncementsOutput,
  async (ctx, payload) => {
    const data = await ctx.ntGroupApi.getGroupBulletinList(payload.group_id.toString());
    return Ok({
      announcements: data.feeds.map((e) => {
        return {
          group_id: payload.group_id,
          announcement_id: e.feedId,
          user_id: +e.uin,
          time: +e.publishTime,
          content: e.msg.text,
          image_url: e.msg.pics[0] ? `https://gdynamic.qpic.cn/gdynamic/${e.msg.pics[0].id}/0` : void 0
        };
      })
    });
  }
);
const SendGroupAnnouncement = defineApi(
  "send_group_announcement",
  SendGroupAnnouncementInput,
  z.object({}),
  async (ctx, payload) => {
    const groupCode = payload.group_id.toString();
    let picInfo;
    if (payload.image_uri) {
      const imageBuffer = await resolveMilkyUri(payload.image_uri);
      const tempPath = path__default.join(TEMP_DIR, `group-announcement-${randomUUID()}`);
      await writeFile(tempPath, imageBuffer);
      const result2 = await ctx.ntGroupApi.uploadGroupBulletinPic(groupCode, tempPath);
      unlink(tempPath).catch((e) => {
      });
      if (result2.errCode !== 0) {
        return Failed(-500, result2.errMsg);
      }
      picInfo = result2.picInfo;
    }
    const result = await ctx.ntGroupApi.publishGroupBulletin(
      groupCode,
      {
        text: encodeURIComponent(payload.content),
        oldFeedsId: "",
        pinned: 0,
        confirmRequired: 1,
        picInfo
      }
    );
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const DeleteGroupAnnouncement = defineApi(
  "delete_group_announcement",
  DeleteGroupAnnouncementInput,
  z.object({}),
  async (ctx, payload) => {
    const result = await ctx.ntGroupApi.deleteGroupBulletin(payload.group_id.toString(), payload.announcement_id);
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const GetGroupEssenceMessages = defineApi(
  "get_group_essence_messages",
  GetGroupEssenceMessagesInput,
  GetGroupEssenceMessagesOutput,
  async (ctx, payload) => {
    const groupCode = payload.group_id.toString();
    const peer = {
      guildId: "",
      chatType: 2,
      peerUid: groupCode
    };
    const essence = await ctx.ntGroupApi.queryCachedEssenceMsg(groupCode);
    let isEnd = true;
    let items = essence.items;
    let start = (payload.page_index + 1) * payload.page_size - 1;
    if (start > items.length - 1) {
      start = items.length - 1;
    }
    items = items.slice(start);
    if (items.length > payload.page_size) {
      items = items.slice(0, payload.page_size);
      isEnd = false;
    }
    const messages = [];
    for (const item of items) {
      const { msgList } = await ctx.ntMsgApi.getMsgsBySeqAndCount(
        peer,
        item.msgSeq.toString(),
        1,
        true,
        true
      );
      const sourceMsg = msgList.find((e) => e.msgRandom === item.msgRandom.toString());
      if (!sourceMsg) continue;
      messages.push({
        group_id: +item.groupCode,
        message_seq: item.msgSeq,
        message_time: +sourceMsg.msgTime,
        sender_id: +item.msgSenderUin,
        sender_name: item.msgSenderNick,
        operator_id: +item.opUin,
        operator_name: item.opNick,
        operation_time: item.opTime,
        segments: await transformIncomingSegments(ctx, sourceMsg)
      });
    }
    return Ok({
      messages,
      is_end: isEnd
    });
  }
);
const SetGroupEssenceMessage = defineApi(
  "set_group_essence_message",
  SetGroupEssenceMessageInput,
  z.object({}),
  async (ctx, payload) => {
    const groupCode = payload.group_id.toString();
    const peer = {
      guildId: "",
      chatType: 2,
      peerUid: groupCode
    };
    const msg = await ctx.ntMsgApi.getMsgsBySeqAndCount(
      peer,
      payload.message_seq.toString(),
      1,
      true,
      true
    );
    if (msg.msgList.length === 0) {
      return Failed(-404, "Message not found");
    }
    if (payload.is_set) {
      const result = await ctx.ntGroupApi.addGroupEssence(groupCode, msg.msgList[0].msgId);
      if (result.errCode !== 0) {
        return Failed(-500, result.errMsg);
      }
    } else {
      const result = await ctx.ntGroupApi.removeGroupEssence(groupCode, msg.msgList[0].msgId);
      if (result.errCode !== 0) {
        return Failed(-500, result.errMsg);
      }
    }
    return Ok({});
  }
);
const QuitGroup = defineApi(
  "quit_group",
  QuitGroupInput,
  z.object({}),
  async (ctx, payload) => {
    const result = await ctx.ntGroupApi.quitGroup(payload.group_id.toString());
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const SendGroupMessageReaction = defineApi(
  "send_group_message_reaction",
  SendGroupMessageReactionInput,
  z.object({}),
  async (ctx, payload) => {
    const peer = {
      chatType: 2,
      // ChatType.Group = 2
      peerUid: payload.group_id.toString(),
      guildId: ""
    };
    const result = await ctx.ntMsgApi.setEmojiLike(
      peer,
      payload.message_seq.toString(),
      payload.reaction,
      payload.is_add
    );
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const SendGroupNudge = defineApi(
  "send_group_nudge",
  SendGroupNudgeInput,
  z.object({}),
  async (ctx, payload) => {
    await ctx.app.pmhq.sendGroupPoke(payload.group_id, payload.user_id);
    return Ok({});
  }
);
const GetGroupNotifications = defineApi(
  "get_group_notifications",
  GetGroupNotificationsInput,
  GetGroupNotificationsOutput,
  async (ctx, payload) => {
    const result = await ctx.ntGroupApi.getSingleScreenNotifies(
      payload.is_filtered,
      payload.limit,
      payload.start_notification_seq ? payload.start_notification_seq.toString() : ""
    );
    let notifies = result.notifies;
    if (notifies.length > payload.limit) {
      notifies = notifies.slice(0, payload.limit);
    }
    const notifications = [];
    for (const notify of notifies) {
      if (notify.type === GroupNotifyType.RequestJoinNeedAdminiStratorPass) {
        notifications.push({
          type: "join_request",
          group_id: Number(notify.group.groupCode),
          notification_seq: Number(notify.seq),
          is_filtered: result.doubt,
          initiator_id: Number(await ctx.ntUserApi.getUinByUid(notify.user1.uid)),
          state: {
            [GroupNotifyStatus.Init]: "pending",
            [GroupNotifyStatus.Unhandle]: "pending",
            [GroupNotifyStatus.Agreed]: "accepted",
            [GroupNotifyStatus.Refused]: "rejected",
            [GroupNotifyStatus.Ignored]: "ignored"
          }[notify.status],
          operator_id: notify.actionUser.uid ? Number(await ctx.ntUserApi.getUinByUid(notify.actionUser.uid)) : void 0,
          comment: notify.postscript
        });
      } else if ([
        GroupNotifyType.SetAdmin,
        GroupNotifyType.CancelAdminNotifyCanceled,
        GroupNotifyType.CancelAdminNotifyAdmin
      ].includes(notify.type)) {
        notifications.push({
          type: "admin_change",
          group_id: Number(notify.group.groupCode),
          notification_seq: Number(notify.seq),
          target_user_id: Number(await ctx.ntUserApi.getUinByUid(notify.user1.uid)),
          is_set: notify.type === GroupNotifyType.SetAdmin,
          operator_id: Number(await ctx.ntUserApi.getUinByUid(notify.user2.uid))
        });
      } else if (notify.type === GroupNotifyType.KickMemberNotifyAdmin) {
        notifications.push({
          type: "kick",
          group_id: Number(notify.group.groupCode),
          notification_seq: Number(notify.seq),
          target_user_id: Number(await ctx.ntUserApi.getUinByUid(notify.user1.uid)),
          operator_id: Number(await ctx.ntUserApi.getUinByUid(notify.user2.uid))
        });
      } else if (notify.type === GroupNotifyType.MemberLeaveNotifyAdmin) {
        notifications.push({
          type: "quit",
          group_id: Number(notify.group.groupCode),
          notification_seq: Number(notify.seq),
          target_user_id: Number(await ctx.ntUserApi.getUinByUid(notify.user1.uid))
        });
      } else if (notify.type === GroupNotifyType.InvitedNeedAdminiStratorPass) {
        notifications.push({
          type: "invited_join_request",
          group_id: Number(notify.group.groupCode),
          notification_seq: Number(notify.seq),
          initiator_id: Number(await ctx.ntUserApi.getUinByUid(notify.user2.uid)),
          target_user_id: Number(await ctx.ntUserApi.getUinByUid(notify.user1.uid)),
          state: {
            [GroupNotifyStatus.Init]: "pending",
            [GroupNotifyStatus.Unhandle]: "pending",
            [GroupNotifyStatus.Agreed]: "accepted",
            [GroupNotifyStatus.Refused]: "rejected",
            [GroupNotifyStatus.Ignored]: "ignored"
          }[notify.status],
          operator_id: notify.actionUser.uid ? Number(await ctx.ntUserApi.getUinByUid(notify.actionUser.uid)) : void 0
        });
      }
    }
    return Ok({
      notifications,
      next_notification_seq: result.nextStartSeq !== "0" ? Number(result.nextStartSeq) : void 0
    });
  }
);
const AcceptGroupRequest = defineApi(
  "accept_group_request",
  AcceptGroupRequestInput,
  z.object({}),
  async (ctx, payload) => {
    const result = await ctx.ntGroupApi.operateSysNotify(
      payload.is_filtered,
      {
        operateType: 1,
        targetMsg: {
          seq: payload.notification_seq.toString(),
          type: payload.notification_type === "join_request" ? 7 : 5,
          groupCode: payload.group_id.toString(),
          postscript: ""
        }
      }
    );
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const RejectGroupRequest = defineApi(
  "reject_group_request",
  RejectGroupRequestInput,
  z.object({}),
  async (ctx, payload) => {
    const result = await ctx.ntGroupApi.operateSysNotify(
      payload.is_filtered,
      {
        operateType: 2,
        targetMsg: {
          seq: payload.notification_seq.toString(),
          type: payload.notification_type === "join_request" ? 7 : 5,
          groupCode: payload.group_id.toString(),
          postscript: payload.reason ?? ""
        }
      }
    );
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const AcceptGroupInvitation = defineApi(
  "accept_group_invitation",
  AcceptGroupInvitationInput,
  z.object({}),
  async (ctx, payload) => {
    const result = await ctx.ntGroupApi.operateSysNotify(
      false,
      {
        operateType: 1,
        targetMsg: {
          seq: payload.invitation_seq.toString(),
          type: 1,
          groupCode: payload.group_id.toString(),
          postscript: ""
        }
      }
    );
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const RejectGroupInvitation = defineApi(
  "reject_group_invitation",
  RejectGroupInvitationInput,
  z.object({}),
  async (ctx, payload) => {
    const result = await ctx.ntGroupApi.operateSysNotify(
      false,
      {
        operateType: 2,
        targetMsg: {
          seq: payload.invitation_seq.toString(),
          type: 1,
          groupCode: payload.group_id.toString(),
          postscript: ""
        }
      }
    );
    if (result.result !== 0) {
      return Failed(-500, result.errMsg);
    }
    return Ok({});
  }
);
const GroupApi = [
  SetGroupName2,
  SetGroupAvatar,
  SetGroupMemberCard,
  SetGroupMemberSpecialTitle,
  SetGroupMemberAdmin,
  SetGroupMemberMute,
  SetGroupWholeMute,
  KickGroupMember,
  GetGroupAnnouncements,
  SendGroupAnnouncement,
  DeleteGroupAnnouncement,
  GetGroupEssenceMessages,
  SetGroupEssenceMessage,
  QuitGroup,
  SendGroupMessageReaction,
  SendGroupNudge,
  GetGroupNotifications,
  AcceptGroupRequest,
  RejectGroupRequest,
  AcceptGroupInvitation,
  RejectGroupInvitation
];
const UploadPrivateFile2 = defineApi(
  "upload_private_file",
  UploadPrivateFileInput,
  UploadPrivateFileOutput,
  async (ctx, payload) => {
    const data = await resolveMilkyUri(payload.file_uri);
    const tempPath = path__default.join(TEMP_DIR, `file-${randomUUID()}`);
    await writeFile(tempPath, data);
    const file2 = await SendElement.file(ctx, tempPath, payload.file_name);
    const uid = await ctx.ntUserApi.getUidByUin(payload.user_id.toString());
    if (!uid) {
      return Failed(-404, "User not found");
    }
    const peer = { chatType: 1, peerUid: uid, guildId: "" };
    const result = await ctx.app.sendMessage(ctx, peer, [file2], [tempPath]);
    return Ok({ file_id: result.elements[0].fileElement.fileUuid });
  }
);
const UploadGroupFile2 = defineApi(
  "upload_group_file",
  UploadGroupFileInput,
  UploadGroupFileOutput,
  async (ctx, payload) => {
    const data = await resolveMilkyUri(payload.file_uri);
    const tempPath = path__default.join(TEMP_DIR, `file-${randomUUID()}`);
    await writeFile(tempPath, data);
    const file2 = await SendElement.file(ctx, tempPath, payload.file_name, payload.parent_folder_id);
    const peer = { chatType: 2, peerUid: payload.group_id.toString(), guildId: "" };
    const result = await ctx.app.sendMessage(ctx, peer, [file2], [tempPath]);
    return Ok({ file_id: result.elements[0].fileElement.fileUuid });
  }
);
const GetPrivateFileDownloadUrl = defineApi(
  "get_private_file_download_url",
  GetPrivateFileDownloadUrlInput,
  GetPrivateFileDownloadUrlOutput,
  async (ctx, payload) => {
    const url2 = await ctx.app.pmhq.getPrivateFileUrl(
      selfInfo.uid,
      payload.file_id
    );
    return Ok({ download_url: url2 });
  }
);
const GetGroupFileDownloadUrl = defineApi(
  "get_group_file_download_url",
  GetGroupFileDownloadUrlInput,
  GetGroupFileDownloadUrlOutput,
  async (ctx, payload) => {
    const url2 = await ctx.app.pmhq.getGroupFileUrl(
      Number(payload.group_id),
      payload.file_id
    );
    return Ok({ download_url: url2 });
  }
);
const GetGroupFiles = defineApi(
  "get_group_files",
  GetGroupFilesInput,
  GetGroupFilesOutput,
  async (ctx, payload) => {
    const allFiles = [];
    const allFolders = [];
    let startIndex = 0;
    let isEnd = false;
    while (!isEnd) {
      const fileListParam = {
        sortType: 1,
        fileCount: 100,
        startIndex,
        sortOrder: 2,
        showOnlinedocFolder: 0,
        folderId: payload.parent_folder_id
      };
      const data = await ctx.ntGroupApi.getGroupFileList(
        payload.group_id.toString(),
        fileListParam
      );
      const { files, folders } = transformGroupFileList(data);
      allFiles.push(...files);
      allFolders.push(...folders);
      isEnd = data.isEnd;
      if (!isEnd) {
        startIndex = data.nextIndex;
      }
    }
    return Ok({ files: allFiles, folders: allFolders });
  }
);
const MoveGroupFile2 = defineApi(
  "move_group_file",
  MoveGroupFileInput,
  z.object({}),
  async (ctx, payload) => {
    const result = await ctx.ntGroupApi.moveGroupFile(
      payload.group_id.toString(),
      [payload.file_id],
      payload.parent_folder_id,
      payload.target_folder_id
    );
    if (result.moveGroupFileResult.result.retCode !== 0) {
      return Failed(-500, result.moveGroupFileResult.result.clientWording);
    }
    return Ok({});
  }
);
const RenameGroupFile = defineApi(
  "rename_group_file",
  RenameGroupFileInput,
  z.object({}),
  async (ctx, payload) => {
    const result = await ctx.ntGroupApi.renameGroupFile(
      payload.group_id.toString(),
      payload.file_id,
      payload.parent_folder_id,
      payload.new_file_name
    );
    if (result.renameGroupFileResult.result.retCode !== 0) {
      return Failed(-500, result.renameGroupFileResult.result.clientWording);
    }
    return Ok({});
  }
);
const DeleteGroupFile2 = defineApi(
  "delete_group_file",
  DeleteGroupFileInput,
  z.object({}),
  async (ctx, payload) => {
    const result = await ctx.ntGroupApi.deleteGroupFile(
      payload.group_id.toString(),
      [payload.file_id],
      [102]
      // busId for group files
    );
    if (result.transGroupFileResult.result.retCode !== 0) {
      return Failed(-500, result.transGroupFileResult.result.clientWording);
    }
    return Ok({});
  }
);
const CreateGroupFolder = defineApi(
  "create_group_folder",
  CreateGroupFolderInput,
  CreateGroupFolderOutput,
  async (ctx, payload) => {
    const result = await ctx.ntGroupApi.createGroupFileFolder(
      payload.group_id.toString(),
      payload.folder_name
    );
    if (result.resultWithGroupItem.result.retCode !== 0) {
      return Failed(-500, result.resultWithGroupItem.result.clientWording);
    }
    return Ok({ folder_id: result.resultWithGroupItem.groupItem.folderInfo.folderId });
  }
);
const RenameGroupFolder = defineApi(
  "rename_group_folder",
  RenameGroupFolderInput,
  z.object({}),
  async (ctx, payload) => {
    const result = await ctx.ntGroupApi.renameGroupFolder(
      payload.group_id.toString(),
      payload.folder_id,
      payload.new_folder_name
    );
    if (result.resultWithGroupItem.result.retCode !== 0) {
      return Failed(-500, result.resultWithGroupItem.result.clientWording);
    }
    return Ok({});
  }
);
const DeleteGroupFolder2 = defineApi(
  "delete_group_folder",
  DeleteGroupFolderInput,
  z.object({}),
  async (ctx, payload) => {
    const result = await ctx.ntGroupApi.deleteGroupFileFolder(
      payload.group_id.toString(),
      payload.folder_id
    );
    if (result.groupFileCommonResult.retCode !== 0) {
      return Failed(-500, result.groupFileCommonResult.clientWording);
    }
    return Ok({});
  }
);
const FileApi = [
  UploadPrivateFile2,
  UploadGroupFile2,
  GetPrivateFileDownloadUrl,
  GetGroupFileDownloadUrl,
  GetGroupFiles,
  MoveGroupFile2,
  RenameGroupFile,
  DeleteGroupFile2,
  CreateGroupFolder,
  RenameGroupFolder,
  DeleteGroupFolder2
];
async function transformPrivateMessageCreated(ctx, message) {
  try {
    if (!message.senderUid) return null;
    const friend = await ctx.ntUserApi.getUserSimpleInfo(message.senderUid);
    const category = await ctx.ntFriendApi.getCategoryById(friend.baseInfo.categoryId);
    return await transformIncomingPrivateMessage(ctx, friend, category, message);
  } catch (error2) {
    ctx.logger.error("Failed to transform private message created event:", error2);
    return null;
  }
}
async function transformGroupMessageCreated(ctx, message) {
  try {
    if (!message.senderUid) return null;
    const group = await ctx.ntGroupApi.getGroupAllInfo(message.peerUid);
    const member = await ctx.ntGroupApi.getGroupMember(message.peerUin, message.senderUid);
    return await transformIncomingGroupMessage(ctx, group, member, message);
  } catch (error2) {
    ctx.logger.error("Failed to transform group message created event:", error2);
    return null;
  }
}
async function transformTempMessageCreated(ctx, message) {
  try {
    if (!message.senderUid) return null;
    const { tmpChatInfo } = await ctx.ntMsgApi.getTempChatInfo(100, message.peerUid);
    const group = await ctx.ntGroupApi.getGroupAllInfo(tmpChatInfo.groupCode);
    return await transformIncomingTempMessage(ctx, group, message);
  } catch (error2) {
    ctx.logger.error("Failed to transform temp message created event:", error2);
    return null;
  }
}
async function transformPrivateMessageDeleted(ctx, message) {
  try {
    const revokeElement = message.elements[0].grayTipElement.revokeElement;
    return {
      message_scene: "friend",
      peer_id: Number(message.peerUin),
      message_seq: Number(message.msgSeq),
      sender_id: Number(message.senderUin),
      operator_id: Number(await ctx.ntUserApi.getUinByUid(revokeElement.operatorUid)),
      display_suffix: revokeElement.wording
    };
  } catch (error2) {
    ctx.logger.error("Failed to transform private message deleted event:", error2);
    return null;
  }
}
async function transformGroupMessageDeleted(ctx, message) {
  try {
    const revokeElement = message.elements[0].grayTipElement.revokeElement;
    return {
      message_scene: "group",
      peer_id: Number(message.peerUin),
      message_seq: Number(message.msgSeq),
      sender_id: Number(message.senderUin),
      operator_id: Number(await ctx.ntUserApi.getUinByUid(revokeElement.operatorUid)),
      display_suffix: revokeElement.wording
    };
  } catch (error2) {
    ctx.logger.error("Failed to transform group message deleted event:", error2);
    return null;
  }
}
async function transformFriendRequestEvent(ctx, request2) {
  try {
    const initiatorId = Number(await ctx.ntUserApi.getUinByUid(request2.friendUid));
    let via = "";
    if (request2.sourceId === 3020) {
      via = "QQ";
    } else if (request2.sourceId === 3004) {
      const groupAll = await ctx.ntGroupApi.getGroupAllInfo(request2.groupCode);
      via = `QQ-${groupAll.groupName}`;
    } else if (request2.sourceId === 3014) {
      via = "";
    } else if (request2.sourceId === 3999) {
      via = "";
    } else if (request2.sourceId === 3022) {
      via = "";
    } else if (request2.sourceId > 10) {
      ctx.logger.info(`via , , friendId: ${initiatorId}, sourceId: ${request2.sourceId}`);
    }
    return {
      initiator_id: initiatorId,
      initiator_uid: request2.friendUid,
      comment: request2.extWords,
      via
    };
  } catch (error2) {
    ctx.logger.error("Failed to transform friend request event:", error2);
    return null;
  }
}
async function transformGroupNotify(ctx, notify, doubt) {
  try {
    if (notify.type === GroupNotifyType.RequestJoinNeedAdminiStratorPass && notify.status === GroupNotifyStatus.Unhandle) {
      return {
        eventType: "group_join_request",
        data: {
          group_id: Number(notify.group.groupCode),
          notification_seq: Number(notify.seq),
          is_filtered: doubt,
          initiator_id: Number(await ctx.ntUserApi.getUinByUid(notify.user1.uid)),
          comment: notify.postscript
        }
      };
    } else if (notify.type === GroupNotifyType.InvitedNeedAdminiStratorPass && notify.status === GroupNotifyStatus.Unhandle) {
      return {
        eventType: "group_invited_join_request",
        data: {
          group_id: Number(notify.group.groupCode),
          notification_seq: Number(notify.seq),
          initiator_id: Number(await ctx.ntUserApi.getUinByUid(notify.user2.uid)),
          target_user_id: Number(await ctx.ntUserApi.getUinByUid(notify.user1.uid))
        }
      };
    } else if (notify.type === GroupNotifyType.InvitedByMember && notify.status === GroupNotifyStatus.Unhandle) {
      return {
        eventType: "group_invitation",
        data: {
          group_id: Number(notify.group.groupCode),
          invitation_seq: Number(notify.seq),
          initiator_id: Number(await ctx.ntUserApi.getUinByUid(notify.user2.uid))
        }
      };
    } else {
      return null;
    }
  } catch (error2) {
    ctx.logger.error("Failed to transform group notify event:", error2);
    return null;
  }
}
async function transformPrivateMessageEvent(ctx, message) {
  try {
    for (const element of message.elements) {
      if (element.grayTipElement?.jsonGrayTipElement?.busiId === "1061") {
        const { templParam } = element.grayTipElement.jsonGrayTipElement.xmlToJsonParam;
        return {
          eventType: "friend_nudge",
          data: {
            user_id: +message.peerUin,
            is_self_send: templParam.get("uin_str1") === selfInfo.uin,
            is_self_receive: templParam.get("uin_str2") === selfInfo.uin,
            display_action: templParam.get("action_str"),
            display_suffix: templParam.get("suffix_str"),
            display_action_img_url: templParam.get("action_img_url")
          }
        };
      } else if (element.fileElement) {
        return {
          eventType: "friend_file_upload",
          data: {
            user_id: +message.peerUin,
            file_id: element.fileElement.fileUuid,
            file_name: element.fileElement.fileName,
            file_size: +element.fileElement.fileSize,
            file_hash: "",
            // 
            is_self: message.senderUin === selfInfo.uin
          }
        };
      } else if (element.arkElement) {
        const data = JSON.parse(element.arkElement.bytesData);
        if (data.app === "com.tencent.qun.invite" || data.app === "com.tencent.tuwen.lua" && data.bizsrc === "qun.invite") {
          const params = new URLSearchParams(data.meta.news.jumpUrl);
          const receiverUin = params.get("receiveruin");
          const senderUin = params.get("senderuin");
          if (receiverUin !== selfInfo.uin || senderUin !== message.senderUin) {
            return null;
          }
          const groupCode = params.get("groupcode");
          const seq = params.get("msgseq");
          return {
            eventType: "group_invitation",
            data: {
              group_id: +groupCode,
              invitation_seq: +seq,
              initiator_id: +senderUin
            }
          };
        }
      }
    }
    return null;
  } catch (error2) {
    ctx.logger.error("Failed to transform private message event:", error2);
    return null;
  }
}
async function transformGroupMessageEvent(ctx, message) {
  try {
    for (const element of message.elements) {
      if (element.grayTipElement?.xmlElement?.busiId === "10145" || element.grayTipElement?.xmlElement?.busiId === "10146") {
        const invitor = element.grayTipElement.xmlElement.templParam.get("invitor");
        const invitee = element.grayTipElement.xmlElement.templParam.get("invitee");
        return {
          eventType: "group_member_increase",
          data: {
            group_id: +message.peerUid,
            user_id: +invitee,
            invitor_id: +invitor
          }
        };
      } else if (element.grayTipElement?.xmlElement?.busiId === "19373") {
        const invitor = element.grayTipElement.xmlElement.templParam.get("invitor");
        const invitees = element.grayTipElement.xmlElement.templParam.get("invitees_dynamic").matchAll(/jp="([^"]+)"/g);
        return invitees.map((e) => ({
          eventType: "group_member_increase",
          data: {
            group_id: +message.peerUid,
            user_id: +e[1],
            invitor_id: +invitor
          }
        })).toArray();
      } else if (element.grayTipElement?.groupElement?.type === 8) {
        if (element.grayTipElement.groupElement.shutUp?.member.uid) {
          return {
            eventType: "group_mute",
            data: {
              group_id: Number(message.peerUid),
              user_id: Number(await ctx.ntUserApi.getUinByUid(element.grayTipElement.groupElement.shutUp.member.uid)),
              operator_id: Number(await ctx.ntUserApi.getUinByUid(element.grayTipElement.groupElement.shutUp.admin.uid)),
              duration: Number(element.grayTipElement.groupElement.shutUp.duration)
            }
          };
        } else {
          return {
            eventType: "group_whole_mute",
            data: {
              group_id: Number(message.peerUid),
              operator_id: Number(await ctx.ntUserApi.getUinByUid(element.grayTipElement.groupElement.shutUp.admin.uid)),
              is_mute: Number(element.grayTipElement.groupElement.shutUp.duration) > 0
            }
          };
        }
      } else if (element.grayTipElement?.jsonGrayTipElement?.busiId === "1061") {
        const { templParam } = element.grayTipElement.jsonGrayTipElement.xmlToJsonParam;
        return {
          eventType: "group_nudge",
          data: {
            group_id: +message.peerUid,
            sender_id: +templParam.get("uin_str1"),
            receiver_id: +templParam.get("uin_str2"),
            display_action: templParam.get("action_str"),
            display_suffix: templParam.get("suffix_str"),
            display_action_img_url: templParam.get("action_img_url")
          }
        };
      } else if (element.fileElement) {
        return {
          eventType: "group_file_upload",
          data: {
            group_id: +message.peerUid,
            user_id: +message.senderUin,
            file_id: element.fileElement.fileUuid,
            file_name: element.fileElement.fileName,
            file_size: +element.fileElement.fileSize
          }
        };
      } else if (element.grayTipElement?.groupElement?.type === 5) {
        return {
          eventType: "group_name_change",
          data: {
            group_id: Number(message.peerUid),
            new_group_name: element.grayTipElement.groupElement.groupName,
            operator_id: Number(await ctx.ntUserApi.getUinByUid(element.grayTipElement.groupElement.memberUid))
          }
        };
      }
    }
    return null;
  } catch (error2) {
    ctx.logger.error("Failed to transform group message event:", error2);
    return null;
  }
}
async function transformSystemMessageEvent(ctx, data) {
  try {
    const sysMsg = Msg.Message.decode(data);
    const { msgType, subType } = sysMsg.contentHead ?? {};
    if (msgType === 33) {
      const tip = Notify.GroupMemberChange.decode(sysMsg.body.msgContent);
      if (tip.type !== 130) return null;
      return {
        eventType: "group_member_increase",
        data: {
          group_id: tip.groupCode,
          user_id: Number(await ctx.ntUserApi.getUinByUid(tip.memberUid)),
          operator_id: Number(await ctx.ntUserApi.getUinByUid(tip.adminUid))
        }
      };
    } else if (msgType === 34) {
      const tip = Notify.GroupMemberChange.decode(sysMsg.body.msgContent);
      if (tip.type === 130) {
        return {
          eventType: "group_member_decrease",
          data: {
            group_id: tip.groupCode,
            user_id: Number(await ctx.ntUserApi.getUinByUid(tip.memberUid))
          }
        };
      } else if (tip.type === 131) {
        if (tip.memberUid === selfInfo.uid) return null;
        const memberUin = await ctx.ntUserApi.getUinByUid(tip.memberUid);
        let adminUin = "0";
        let adminUid = tip.adminUid;
        if (adminUid) {
          const adminUidMatch = tip.adminUid.match(/\x18([^\x18\x10]+)\x10/);
          if (adminUidMatch) {
            adminUid = adminUidMatch[1];
          }
          adminUin = await ctx.ntUserApi.getUinByUid(adminUid);
        }
        return {
          eventType: "group_member_decrease",
          data: {
            group_id: tip.groupCode,
            user_id: +memberUin,
            operator_id: +adminUin
          }
        };
      }
    } else if (msgType === 44) {
      const tip = Notify.GroupAdminChange.decode(sysMsg.body.msgContent);
      const adminUid = tip.isPromote ? tip.body.extraEnable?.adminUid : tip.body.extraDisable?.adminUid;
      if (!adminUid) return null;
      const groupAllInfo = await ctx.ntGroupApi.getGroupAllInfo(tip.groupCode.toString());
      return {
        eventType: "group_admin_change",
        data: {
          group_id: tip.groupCode,
          user_id: Number(await ctx.ntUserApi.getUinByUid(adminUid)),
          operator_id: Number(await ctx.ntUserApi.getUinByUid(groupAllInfo.ownerUid)),
          is_set: tip.isPromote
        }
      };
    }
    return null;
  } catch (error2) {
    ctx.logger.error("Failed to transform system message event:", error2);
    return null;
  }
}
async function transformOlpushEvent(ctx, data) {
  try {
    const pushMsg = Msg.PushMsg.decode(data);
    if (!pushMsg.message.body) {
      return null;
    }
    const { msgType, subType } = pushMsg.message?.contentHead ?? {};
    if (msgType === 732 && subType === 16) {
      const notify = Msg.NotifyMessageBody.decode(pushMsg.message.body.msgContent.subarray(7));
      if (notify.field13 === 35) {
        const info = notify.reaction.data.body.info;
        const target = notify.reaction.data.body.target;
        const userId = Number(await ctx.ntUserApi.getUinByUid(info.operatorUid));
        return {
          eventType: "group_message_reaction",
          data: {
            group_id: notify.groupCode,
            user_id: userId,
            message_seq: target.sequence,
            face_id: info.code,
            is_add: info.type === 1
          }
        };
      }
    } else if (msgType === 732 && subType === 21) {
      const notify = Msg.NotifyMessageBody.decode(pushMsg.message.body.msgContent.subarray(7));
      if (notify.type === 27) {
        return {
          eventType: "group_essence_message_change",
          data: {
            group_id: notify.groupCode,
            message_seq: notify.essenceMessage.msgSequence,
            operator_id: notify.essenceMessage.operatorUin,
            is_set: notify.essenceMessage.setFlag === 1
          }
        };
      }
    }
    return null;
  } catch (error2) {
    ctx.logger.error("Failed to transform olpush event:", error2);
    return null;
  }
}
class MilkyAdapter extends Service2 {
  constructor(ctx, config2) {
    super(ctx, "milky", true);
    this.config = config2;
    this.apiCollection = new MilkyApiCollection(ctx, [
      ...SystemApi,
      ...MessageApi,
      ...FriendApi,
      ...GroupApi,
      ...FileApi
    ]);
    this.httpHandler = new MilkyHttpHandler(this, ctx, { ...config2.http, onlyLocalhost: config2.onlyLocalhost });
    this.webhookHandler = new MilkyWebhookHandler(this, ctx, config2.webhook);
  }
  static inject = ["ntUserApi", "ntFriendApi", "ntGroupApi", "ntMsgApi", "ntFileApi", "ntSystemApi", "ntWebApi", "app"];
  apiCollection;
  httpHandler;
  webhookHandler;
  listenedEvent = false;
  async start() {
    this.ctx.on("llob/config-updated", (config2) => {
      this.httpHandler.stop();
      this.webhookHandler.stop();
      this.httpHandler.updateConfig({
        ...config2.milky.http,
        onlyLocalhost: config2.onlyLocalhost
      });
      this.webhookHandler.updateConfig(config2.milky.webhook);
      if (config2.milky.enable) {
        this.httpHandler.start();
        this.webhookHandler.start();
        this.setupEventListeners();
      }
      Object.assign(this.config, {
        ...config2.milky,
        onlyLocalhost: config2.onlyLocalhost
      });
    });
    if (!this.config.enable) {
      return;
    }
    this.httpHandler.start();
    this.webhookHandler.start();
    this.setupEventListeners();
  }
  async stop() {
    if (!this.config.enable) {
      return;
    }
    this.httpHandler.stop();
  }
  emitEvent(eventName, data) {
    const selfUin = selfInfo.uin;
    const eventString = JSON.stringify({
      time: Math.floor(Date.now() / 1e3),
      self_id: parseInt(selfUin),
      event_type: eventName,
      data
    });
    this.httpHandler.broadcast(eventString);
    this.webhookHandler.broadcast(eventString);
  }
  setupEventListeners() {
    if (this.listenedEvent) return;
    this.listenedEvent = true;
    this.ctx.on("nt/message-created", async (message) => {
      if (message.senderUid === selfInfo.uid && !this.config.reportSelfMessage) {
        return;
      }
      if (message.chatType === ChatType.C2C) {
        const eventData = await transformPrivateMessageCreated(this.ctx, message);
        if (eventData) {
          this.emitEvent("message_receive", eventData);
        }
        const result = await transformPrivateMessageEvent(this.ctx, message);
        if (result) {
          this.emitEvent(result.eventType, result.data);
        }
      } else if (message.chatType === ChatType.Group) {
        const eventData = await transformGroupMessageCreated(this.ctx, message);
        if (eventData) {
          this.emitEvent("message_receive", eventData);
        }
        const result = await transformGroupMessageEvent(this.ctx, message);
        if (result) {
          if (Array.isArray(result)) {
            for (const item of result) {
              this.emitEvent(item.eventType, item.data);
            }
          } else {
            this.emitEvent(result.eventType, result.data);
          }
        }
      } else if (message.chatType === ChatType.TempC2CFromGroup) {
        const eventData = await transformTempMessageCreated(this.ctx, message);
        if (eventData) {
          this.emitEvent("message_receive", eventData);
        }
        const result = await transformPrivateMessageEvent(this.ctx, message);
        if (result) {
          this.emitEvent(result.eventType, result.data);
        }
      }
    });
    this.ctx.on("nt/message-deleted", async (message) => {
      if (message.chatType === ChatType.C2C) {
        const eventData = await transformPrivateMessageDeleted(this.ctx, message);
        if (eventData) {
          this.emitEvent("message_recall", eventData);
        }
      } else if (message.chatType === ChatType.Group) {
        const eventData = await transformGroupMessageDeleted(this.ctx, message);
        if (eventData) {
          this.emitEvent("message_recall", eventData);
        }
      }
    });
    this.ctx.on("nt/message-sent", async (message) => {
      if (!this.config.reportSelfMessage) {
        return;
      }
      if (message.chatType === ChatType.C2C) {
        const eventData = await transformPrivateMessageCreated(this.ctx, message);
        if (eventData) {
          this.emitEvent("message_receive", eventData);
        }
      } else if (message.chatType === ChatType.Group) {
        const eventData = await transformGroupMessageCreated(this.ctx, message);
        if (eventData) {
          this.emitEvent("message_receive", eventData);
        }
      } else if (message.chatType === ChatType.TempC2CFromGroup) {
        const eventData = await transformTempMessageCreated(this.ctx, message);
        if (eventData) {
          this.emitEvent("message_receive", eventData);
        }
      }
    });
    this.ctx.on("nt/group-notify", async ({ notify, doubt }) => {
      const result = await transformGroupNotify(this.ctx, notify, doubt);
      if (result) {
        this.emitEvent(result.eventType, result.data);
      }
    });
    this.ctx.on("nt/friend-request", async (request2) => {
      const eventData = await transformFriendRequestEvent(this.ctx, request2);
      if (eventData) {
        this.emitEvent("friend_request", eventData);
      }
    });
    this.ctx.on("nt/system-message-created", async (data) => {
      const result = await transformSystemMessageEvent(this.ctx, data);
      if (result) {
        this.emitEvent(result.eventType, result.data);
      }
    });
    this.ctx.on("nt/kicked-offLine", async (info) => {
      this.emitEvent("bot_offline", {
        reason: info.tipsDesc
      });
    });
    this.ctx.app.pmhq.addResListener(async (data) => {
      if (data.type === "recv" && data.data.cmd === "trpc.msg.olpush.OlPushService.MsgPush") {
        const result = await transformOlpushEvent(this.ctx, Buffer.from(data.data.pb, "hex"));
        if (result) {
          this.emitEvent(result.eventType, result.data);
        }
      }
    });
  }
}
var __defProp$2 = Object.defineProperty;
var __name$2 = (target, value) => __defProp$2(target, "name", { value, configurable: true });
var Type;
((Type2) => {
  Type2.kType = /* @__PURE__ */ Symbol.for("minato.type");
  Type2.Any = fromField("expr");
  Type2.Boolean = fromField("boolean");
  Type2.Number = fromField("double");
  Type2.String = fromField("string");
  Type2.Object = /* @__PURE__ */ __name$2((obj) => defineProperty({
    type: "json",
    inner: globalThis.Object.keys(obj ?? {}).length ? mapValues(obj, (value) => isType(value) ? value : fromField(value)) : void 0
  }, Type2.kType, true), "Object");
  Type2.Array = /* @__PURE__ */ __name$2((type2) => defineProperty({
    type: "json",
    inner: type2,
    array: true
  }, Type2.kType, true), "Array");
  function fromPrimitive(value) {
    if (isNullable(value)) return fromField("expr");
    else if (typeof value === "number") return Type2.Number;
    else if (typeof value === "string") return Type2.String;
    else if (typeof value === "boolean") return Type2.Boolean;
    else if (typeof value === "bigint") return fromField("bigint");
    else if (value instanceof Date) return fromField("timestamp");
    else if (Binary.is(value)) return fromField("binary");
    else if (globalThis.Array.isArray(value)) return (0, Type2.Array)(value.length ? fromPrimitive(value[0]) : void 0);
    else if (typeof value === "object") return fromField("json");
    throw new TypeError(`invalid primitive: ${value}`);
  }
  Type2.fromPrimitive = fromPrimitive;
  __name$2(fromPrimitive, "fromPrimitive");
  function fromField(field) {
    if (isType(field)) return field;
    else if (field === "array") return (0, Type2.Array)();
    else if (field === "object") return (0, Type2.Object)();
    else if (typeof field === "string") return defineProperty({ type: field }, Type2.kType, true);
    else if (field.type) return field.type;
    else if (field.expr?.[Type2.kType]) return field.expr[Type2.kType];
    throw new TypeError(`invalid field: ${field}`);
  }
  Type2.fromField = fromField;
  __name$2(fromField, "fromField");
  function fromTerm(value, initial) {
    if (isEvalExpr(value)) return value[Type2.kType] ?? initial ?? fromField("expr");
    else return fromPrimitive(value);
  }
  Type2.fromTerm = fromTerm;
  __name$2(fromTerm, "fromTerm");
  function fromTerms(values, initial) {
    return values.map((x) => fromTerm(x)).find((type2) => type2.type !== "expr") ?? initial ?? fromField("expr");
  }
  Type2.fromTerms = fromTerms;
  __name$2(fromTerms, "fromTerms");
  function isType(value) {
    return value?.[Type2.kType] === true;
  }
  Type2.isType = isType;
  __name$2(isType, "isType");
  function isArray(type2) {
    return type2?.type === "json" && type2?.array;
  }
  Type2.isArray = isArray;
  __name$2(isArray, "isArray");
  function getInner(type2, key2) {
    if (!type2?.inner) return;
    if (isArray(type2)) return type2.inner;
    if (isNullable(key2)) return;
    if (type2.inner[key2]) return type2.inner[key2];
    if (key2.includes(".")) return key2.split(".").reduce((t, k) => getInner(t, k), type2);
    const fields = globalThis.Object.entries(type2.inner).filter(([k]) => k.startsWith(`${key2}.`)).map(([k, v]) => [k.slice(key2.length + 1), v]);
    return fields.length ? (0, Type2.Object)(globalThis.Object.fromEntries(fields)) : void 0;
  }
  Type2.getInner = getInner;
  __name$2(getInner, "getInner");
  function transform2(value, type2, callback) {
    if (!isNullable(value) && type2?.inner) {
      if (Type2.isArray(type2)) {
        return value.map((x) => callback(x, Type2.getInner(type2))).filter((x) => !type2.ignoreNull || !isEmpty(x));
      } else {
        if (type2.ignoreNull && isEmpty(value)) return null;
        return mapValues(value, (x, k) => callback(x, Type2.getInner(type2, k)));
      }
    }
    return value;
  }
  Type2.transform = transform2;
  __name$2(transform2, "transform");
})(Type || (Type = {}));
var Relation;
((Relation4) => {
  Relation4.Type = ["oneToOne", "oneToMany", "manyToOne", "manyToMany"];
  function buildAssociationTable(...tables) {
    return "_" + tables.sort().join("_");
  }
  Relation4.buildAssociationTable = buildAssociationTable;
  __name$2(buildAssociationTable, "buildAssociationTable");
  function buildAssociationKey(key2, table) {
    return `${table}.${key2}`;
  }
  Relation4.buildAssociationKey = buildAssociationKey;
  __name$2(buildAssociationKey, "buildAssociationKey");
  function buildSharedKey(field, reference) {
    return [field, reference].sort().join("_");
  }
  Relation4.buildSharedKey = buildSharedKey;
  __name$2(buildSharedKey, "buildSharedKey");
  function parse3(def, key2, model, relmodel, subprimary) {
    const shared = !def.shared ? {} : typeof def.shared === "string" ? { [def.shared]: def.shared } : Array.isArray(def.shared) ? Object.fromEntries(def.shared.map((x) => [x, x])) : def.shared;
    const fields = def.fields ?? (subprimary || def.type === "manyToOne" || def.type === "oneToOne" && (model.name === relmodel.name || !makeArray(relmodel.primary).every((key22) => !relmodel.fields[key22]?.nullable)) ? makeArray(relmodel.primary).map((x) => `${key2}.${x}`) : model.primary);
    const relation = {
      type: def.type,
      table: def.table ?? relmodel.name,
      fields: makeArray(fields),
      shared,
      references: makeArray(def.references ?? relmodel.primary),
      required: def.type !== "manyToOne" && model.name !== relmodel.name && makeArray(fields).every((key22) => !model.fields[key22]?.nullable || makeArray(model.primary).includes(key22))
    };
    Object.entries(shared).forEach(([k, v]) => {
      relation.fields = relation.fields.filter((x) => x !== k);
      relation.references = relation.references.filter((x) => x !== v);
    });
    const inverse = {
      type: relation.type === "oneToMany" ? "manyToOne" : relation.type === "manyToOne" ? "oneToMany" : relation.type,
      table: model.name,
      fields: relation.references,
      references: relation.fields,
      shared: Object.fromEntries(Object.entries(shared).map(([k, v]) => [v, k])),
      required: relation.type !== "oneToMany" && relation.references.every((key22) => !relmodel.fields[key22]?.nullable || makeArray(relmodel.primary).includes(key22))
    };
    if (inverse.required) relation.required = false;
    return [relation, inverse];
  }
  Relation4.parse = parse3;
  __name$2(parse3, "parse");
})(Relation || (Relation = {}));
var Field;
((Field2) => {
  Field2.number = ["integer", "unsigned", "float", "double", "decimal"];
  Field2.string = ["char", "string", "text"];
  Field2.boolean = ["boolean"];
  Field2.date = ["timestamp", "date", "time"];
  Field2.object = ["list", "json"];
  const regexp = /^(\w+)(?:\((.+)\))?$/;
  function parse3(source2) {
    if (typeof source2 === "function") throw new TypeError("view field is not supported");
    if (typeof source2 !== "string") {
      return {
        initial: null,
        deftype: source2.type,
        ...source2,
        type: Type.fromField(source2.type)
      };
    }
    const capture = regexp.exec(source2);
    if (!capture) throw new TypeError("invalid field definition");
    const type2 = capture[1];
    const args = (capture[2] || "").split(",");
    const field = { deftype: type2, type: Type.fromField(type2) };
    if (field.initial === void 0) field.initial = getInitial(type2);
    if (type2 === "decimal") {
      field.precision = +args[0];
      field.scale = +args[1];
    } else if (args[0]) {
      field.length = +args[0];
    }
    return field;
  }
  Field2.parse = parse3;
  __name$2(parse3, "parse");
  function getInitial(type2, initial) {
    if (initial === void 0) {
      if (Field2.number.includes(type2)) return 0;
      if (Field2.string.includes(type2)) return "";
      if (type2 === "list") return [];
      if (type2 === "json") return {};
    }
    return initial;
  }
  Field2.getInitial = getInitial;
  __name$2(getInitial, "getInitial");
  function available(field) {
    return !!field && !field.deprecated && !field.relation && field.deftype !== "expr";
  }
  Field2.available = available;
  __name$2(available, "available");
})(Field || (Field = {}));
var Model = class {
  constructor(name) {
    this.name = name;
    this.autoInc = false;
    this.primary = "id";
    this.unique = [];
    this.indexes = [];
    this.foreign = {};
  }
  static {
    __name$2(this, "Model");
  }
  fields = {};
  migrations = /* @__PURE__ */ new Map();
  extend(fields = {}, config2 = {}) {
    const { primary, autoInc, unique = [], indexes = [], foreign, callback } = config2;
    this.primary = primary || this.primary;
    this.autoInc = autoInc || this.autoInc;
    unique.forEach((key2) => this.unique.includes(key2) || this.unique.push(key2));
    indexes.map((x) => this.parseIndex(x)).forEach((index2) => this.indexes.some((ind) => deepEqual(ind, index2)) || this.indexes.push(index2));
    Object.assign(this.foreign, foreign);
    if (callback) this.migrations.set(callback, Object.keys(fields));
    for (const key2 in fields) {
      this.fields[key2] = Field.parse(fields[key2]);
      this.fields[key2].deprecated = !!callback;
    }
    if (typeof this.primary === "string" && this.fields[this.primary]?.deftype === "primary") {
      this.autoInc = true;
    }
    this.checkIndex(this.primary);
    this.unique.forEach((index2) => this.checkIndex(index2));
    this.indexes.forEach((index2) => this.checkIndex(index2));
  }
  parseIndex(index2) {
    if (typeof index2 === "string" || Array.isArray(index2)) {
      return {
        name: `index:${this.name}:` + makeArray(index2).join("+"),
        unique: false,
        keys: Object.fromEntries(makeArray(index2).map((key2) => [key2, "asc"]))
      };
    } else {
      return {
        name: index2.name ?? `index:${this.name}:` + Object.keys(index2.keys).join("+"),
        unique: index2.unique ?? false,
        keys: index2.keys
      };
    }
  }
  checkIndex(index2) {
    for (const key2 of typeof index2 === "string" || Array.isArray(index2) ? makeArray(index2) : Object.keys(index2.keys)) {
      if (!this.fields[key2]) {
        throw new TypeError(`missing field definition for index key "${key2}"`);
      }
    }
  }
  resolveValue(field, value) {
    if (isNullable(value)) return value;
    if (typeof field === "string") field = this.fields[field];
    if (field) field = Type.fromField(field);
    if (field?.type === "time") {
      const date2 = /* @__PURE__ */ new Date(0);
      date2.setHours(value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds());
      return date2;
    } else if (field?.type === "date") {
      const date2 = new Date(value);
      date2.setHours(0, 0, 0, 0);
      return date2;
    }
    return value;
  }
  resolveModel(obj, model) {
    if (!model) model = this.getType();
    if (isNullable(obj) || !model.inner) return obj;
    if (Type.isArray(model) && Array.isArray(obj)) {
      return obj.map((x) => this.resolveModel(x, Type.getInner(model)));
    }
    const result = {};
    for (const key2 in obj) {
      const type2 = Type.getInner(model, key2);
      if (!type2 || isNullable(obj[key2])) {
        result[key2] = obj[key2];
      } else if (type2.type !== "json") {
        result[key2] = this.resolveValue(type2, obj[key2]);
      } else if (isEvalExpr(obj[key2])) {
        result[key2] = obj[key2];
      } else if (type2.inner && Type.isArray(type2) && Array.isArray(obj[key2])) {
        result[key2] = obj[key2].map((x) => this.resolveModel(x, Type.getInner(type2)));
      } else if (type2.inner) {
        result[key2] = this.resolveModel(obj[key2], type2);
      } else {
        result[key2] = obj[key2];
      }
    }
    return result;
  }
  format(source2, strict = true, prefix = "", result = {}) {
    const fields = Object.keys(this.fields).filter((key2) => !this.fields[key2].relation);
    Object.entries(source2).map(([key2, value]) => {
      key2 = prefix + key2;
      if (value === void 0) return;
      if (fields.includes(key2)) {
        result[key2] = value;
        return;
      }
      const field = fields.find((field2) => key2.startsWith(field2 + "."));
      if (field) {
        result[key2] = value;
      } else if (isFlat(value)) {
        if (strict && (typeof value !== "object" || Object.keys(value).length)) {
          throw new TypeError(`unknown field "${key2}" in model ${this.name}`);
        }
      } else {
        this.format(value, strict, key2 + ".", result);
      }
    });
    return strict && prefix === "" ? this.resolveModel(result) : result;
  }
  parse(source2, strict = true, prefix = "", result = {}) {
    const fields = Object.keys(this.fields).filter((key2) => !this.fields[key2].relation);
    if (strict && prefix === "") {
      Object.assign(result, unravel(
        Object.fromEntries(fields.filter((key2) => key2.includes(".")).map((key2) => [key2.slice(0, key2.lastIndexOf(".")), {}]))
      ));
    }
    for (const key2 in source2) {
      let node = result;
      const segments = key2.split(".").reverse();
      for (let index2 = segments.length - 1; index2 > 0; index2--) {
        const segment = segments[index2];
        node = node[segment] ??= {};
      }
      if (key2 in source2) {
        const fullKey = prefix + key2, value = source2[key2];
        const field = fields.find((field2) => fullKey === field2 || fullKey.startsWith(field2 + "."));
        if (field) {
          node[segments[0]] = value;
        } else if (isFlat(value)) {
          if (strict) {
            throw new TypeError(`unknown field "${fullKey}" in model ${this.name}`);
          } else {
            node[segments[0]] = value;
          }
        } else {
          this.parse(value, strict, fullKey + ".", node[segments[0]] ??= {});
        }
      }
    }
    return strict && prefix === "" ? this.resolveModel(result) : result;
  }
  create(data) {
    const result = {};
    const keys = makeArray(this.primary);
    for (const key2 in this.fields) {
      if (!Field.available(this.fields[key2])) continue;
      const { initial } = this.fields[key2];
      if (!keys.includes(key2) && !isNullable(initial)) {
        result[key2] = clone$1(initial);
      }
    }
    return this.parse({ ...result, ...data });
  }
  availableFields() {
    return filterKeys(this.fields, (_, field) => Field.available(field));
  }
  getType(key2) {
    if (!this.type) defineProperty(this, "type", Type.Object(mapValues(this.fields, (field) => Type.fromField(field))));
    return key2 ? Type.getInner(this.type, key2) : this.type;
  }
};
function isEvalExpr(value) {
  return value && Object.keys(value).some((key2) => key2.startsWith("$"));
}
__name$2(isEvalExpr, "isEvalExpr");
var isUpdateExpr = isEvalExpr;
function isAggrExpr(expr) {
  return expr["$"] || expr["$select"];
}
__name$2(isAggrExpr, "isAggrExpr");
function hasSubquery(value) {
  if (!isEvalExpr(value)) return false;
  return Object.entries(value).filter(([k]) => k.startsWith("$")).some(([k, v]) => {
    if (isNullable(v) || isComparable(v)) return false;
    if (k === "$exec") return true;
    if (isEvalExpr(v)) return hasSubquery(v);
    if (Array.isArray(v)) return v.some((x) => hasSubquery(x));
    if (typeof v === "object") return Object.values(v).some((x) => hasSubquery(x));
    return false;
  });
}
__name$2(hasSubquery, "hasSubquery");
var kExpr = /* @__PURE__ */ Symbol("expr");
var Eval3 = /* @__PURE__ */ __name$2((key2, value, type2) => defineProperty(defineProperty({ ["$" + key2]: value }, kExpr, true), Type.kType, type2), "Eval");
var operators = /* @__PURE__ */ Object.create(null);
operators["$"] = getRecursive;
function unary(key2, callback, type2) {
  operators[`$${key2}`] = callback;
  return (value) => Eval3(key2, value, typeof type2 === "function" ? type2(value) : type2);
}
__name$2(unary, "unary");
function multary(key2, callback, type2) {
  operators[`$${key2}`] = callback;
  return (...args) => Eval3(key2, args, typeof type2 === "function" ? type2(...args) : type2);
}
__name$2(multary, "multary");
function comparator(key2, callback) {
  operators[`$${key2}`] = (args, data) => {
    const left = executeEval(data, args[0]);
    const right = executeEval(data, args[1]);
    if (isNullable(left) || isNullable(right)) return true;
    return callback(left.valueOf(), right.valueOf());
  };
  return (...args) => Eval3(key2, args, Type.Boolean);
}
__name$2(comparator, "comparator");
Eval3.switch = (branches, vDefault) => Eval3("switch", { branches, default: vDefault }, Type.fromTerm(branches[0]));
operators.$switch = (args, data) => {
  for (const branch of args.branches) {
    if (executeEval(data, branch.case)) return executeEval(data, branch.then);
  }
  return executeEval(data, args.default);
};
Eval3.ignoreNull = (expr) => (expr["$ignoreNull"] = true, expr[Type.kType].ignoreNull = true, expr);
Eval3.select = multary("select", (args, table) => args.map((arg) => executeEval(table, arg)), Type.Array());
Eval3.query = (row, query, expr = true) => ({ $expr: expr, ...query });
Eval3.exec = unary("exec", (expr, data) => expr.driver.executeSelection(expr, data), (expr) => Type.fromTerm(expr.args[0]));
Eval3.if = multary("if", ([cond, vThen, vElse], data) => executeEval(data, cond) ? executeEval(data, vThen) : executeEval(data, vElse), (cond, vThen, vElse) => Type.fromTerm(vThen));
Eval3.ifNull = multary("ifNull", ([value, fallback], data) => executeEval(data, value) ?? executeEval(data, fallback), (value) => Type.fromTerm(value));
Eval3.add = multary("add", (args, data) => args.reduce((prev, curr) => prev + executeEval(data, curr), 0), Type.Number);
Eval3.mul = Eval3.multiply = multary("multiply", (args, data) => args.reduce((prev, curr) => prev * executeEval(data, curr), 1), Type.Number);
Eval3.sub = Eval3.subtract = multary("subtract", ([left, right], data) => executeEval(data, left) - executeEval(data, right), Type.Number);
Eval3.div = Eval3.divide = multary("divide", ([left, right], data) => executeEval(data, left) / executeEval(data, right), Type.Number);
Eval3.mod = Eval3.modulo = multary("modulo", ([left, right], data) => executeEval(data, left) % executeEval(data, right), Type.Number);
Eval3.abs = unary("abs", (arg, data) => Math.abs(executeEval(data, arg)), Type.Number);
Eval3.floor = unary("floor", (arg, data) => Math.floor(executeEval(data, arg)), Type.Number);
Eval3.ceil = unary("ceil", (arg, data) => Math.ceil(executeEval(data, arg)), Type.Number);
Eval3.round = unary("round", (arg, data) => Math.round(executeEval(data, arg)), Type.Number);
Eval3.exp = unary("exp", (arg, data) => Math.exp(executeEval(data, arg)), Type.Number);
Eval3.log = multary("log", ([left, right], data) => Math.log(executeEval(data, left)) / Math.log(executeEval(data, right ?? Math.E)), Type.Number);
Eval3.pow = Eval3.power = multary("power", ([left, right], data) => Math.pow(executeEval(data, left), executeEval(data, right)), Type.Number);
Eval3.random = () => Eval3("random", {}, Type.Number);
operators.$random = () => Math.random();
Eval3.eq = comparator("eq", (left, right) => left === right);
Eval3.ne = comparator("ne", (left, right) => left !== right);
Eval3.gt = comparator("gt", (left, right) => left > right);
Eval3.ge = Eval3.gte = comparator("gte", (left, right) => left >= right);
Eval3.lt = comparator("lt", (left, right) => left < right);
Eval3.le = Eval3.lte = comparator("lte", (left, right) => left <= right);
Eval3.in = (value, array2) => Eval3("in", [Array.isArray(value) ? Eval3.select(...value) : value, array2], Type.Boolean);
operators.$in = ([value, array2], data) => {
  const val = executeEval(data, value), arr = executeEval(data, array2);
  if (typeof val === "object") return arr.includes(val) || arr.map(JSON.stringify).includes(JSON.stringify(val));
  return arr.includes(val);
};
Eval3.nin = (value, array2) => Eval3("nin", [Array.isArray(value) ? Eval3.select(...value) : value, array2], Type.Boolean);
operators.$nin = ([value, array2], data) => {
  const val = executeEval(data, value), arr = executeEval(data, array2);
  if (typeof val === "object") return !arr.includes(val) && !arr.map(JSON.stringify).includes(JSON.stringify(val));
  return !arr.includes(val);
};
Eval3.concat = multary("concat", (args, data) => args.map((arg) => executeEval(data, arg)).join(""), Type.String);
Eval3.regex = multary("regex", ([value, regex, flags], data) => makeRegExp(executeEval(data, regex), flags).test(executeEval(data, value)), Type.Boolean);
Eval3.and = multary("and", (args, data) => {
  const type2 = Type.fromTerms(args, Type.Boolean);
  if (Field.boolean.includes(type2.type)) return args.every((arg) => executeEval(data, arg));
  else if (Field.number.includes(type2.type)) return args.map((arg) => executeEval(data, arg)).reduce((prev, curr) => prev & curr);
  else if (type2.type === "bigint") return args.map((arg) => BigInt(executeEval(data, arg) ?? 0)).reduce((prev, curr) => prev & curr);
}, (...args) => Type.fromTerms(args, Type.Boolean));
Eval3.or = multary("or", (args, data) => {
  const type2 = Type.fromTerms(args, Type.Boolean);
  if (Field.boolean.includes(type2.type)) return args.some((arg) => executeEval(data, arg));
  else if (Field.number.includes(type2.type)) return args.map((arg) => executeEval(data, arg)).reduce((prev, curr) => prev | curr);
  else if (type2.type === "bigint") return args.map((arg) => BigInt(executeEval(data, arg) ?? 0)).reduce((prev, curr) => prev | curr);
}, (...args) => Type.fromTerms(args, Type.Boolean));
Eval3.not = unary("not", (value, data) => {
  const type2 = Type.fromTerms([value], Type.Boolean);
  if (Field.boolean.includes(type2.type)) return !executeEval(data, value);
  else if (Field.number.includes(type2.type)) return ~executeEval(data, value);
  else if (type2.type === "bigint") return ~BigInt(executeEval(data, value) ?? 0);
}, (value) => Type.fromTerms([value], Type.Boolean));
Eval3.xor = multary("xor", (args, data) => {
  const type2 = Type.fromTerms(args, Type.Boolean);
  if (Field.boolean.includes(type2.type)) return args.map((arg) => executeEval(data, arg)).reduce((prev, curr) => prev !== curr);
  else if (Field.number.includes(type2.type)) return args.map((arg) => executeEval(data, arg)).reduce((prev, curr) => prev ^ curr);
  else if (type2.type === "bigint") return args.map((arg) => BigInt(executeEval(data, arg) ?? 0)).reduce((prev, curr) => prev ^ curr);
}, (...args) => Type.fromTerms(args, Type.Boolean));
Eval3.literal = multary("literal", ([value, type2]) => value, (value, type2) => type2 ? Type.fromField(type2) : Type.fromTerm(value));
Eval3.number = unary("number", (arg, data) => {
  const value = executeEval(data, arg);
  return value instanceof Date ? Math.floor(value.valueOf() / 1e3) : Number(value);
}, Type.Number);
var unwrapAggr = /* @__PURE__ */ __name$2((expr, def) => {
  let type2 = Type.fromTerm(expr);
  type2 = Type.getInner(type2) ?? type2;
  return def && type2.type === "expr" ? def : type2;
}, "unwrapAggr");
Eval3.sum = unary("sum", (expr, table) => Array.isArray(table) ? table.reduce((prev, curr) => prev + executeAggr(expr, curr), 0) : Array.from(executeEval(table, expr)).reduce((prev, curr) => prev + curr, 0), Type.Number);
Eval3.avg = unary("avg", (expr, table) => {
  if (Array.isArray(table)) return table.reduce((prev, curr) => prev + executeAggr(expr, curr), 0) / table.length;
  else {
    const array2 = Array.from(executeEval(table, expr));
    return array2.reduce((prev, curr) => prev + curr, 0) / array2.length;
  }
}, Type.Number);
Eval3.max = unary("max", (expr, table) => Array.isArray(table) ? table.map((data) => executeAggr(expr, data)).reduce((x, y) => x > y ? x : y, -Infinity) : Array.from(executeEval(table, expr)).reduce((x, y) => x > y ? x : y, -Infinity), (expr) => unwrapAggr(expr, Type.Number));
Eval3.min = unary("min", (expr, table) => Array.isArray(table) ? table.map((data) => executeAggr(expr, data)).reduce((x, y) => x < y ? x : y, Infinity) : Array.from(executeEval(table, expr)).reduce((x, y) => x < y ? x : y, Infinity), (expr) => unwrapAggr(expr, Type.Number));
Eval3.count = unary("count", (expr, table) => new Set(table.map((data) => executeAggr(expr, data))).size, Type.Number);
defineProperty(Eval3, "length", unary("length", (expr, table) => Array.isArray(table) ? table.map((data) => executeAggr(expr, data)).length : Array.from(executeEval(table, expr)).length, Type.Number));
operators.$object = (field, table) => mapValues(field, (value) => executeAggr(value, table));
Eval3.object = (fields) => {
  if (fields.$model) {
    const modelFields = Object.entries(fields.$model.fields);
    const prefix = fields.$prefix;
    fields = Object.fromEntries(modelFields.filter(([, field]) => Field.available(field)).filter(([path2]) => path2.startsWith(prefix)).map(([k]) => [k.slice(prefix.length), fields[k.slice(prefix.length)]]));
    return Object.assign(Eval3("object", fields, Type.Object(mapValues(fields, (value) => Type.fromTerm(value)))), fields);
  }
  fields = filterKeys(fields, (key2) => key2 !== "$object");
  return Object.assign(Eval3("object", fields, Type.Object(mapValues(fields, (value) => Type.fromTerm(value)))), fields);
};
Eval3.array = unary("array", (expr, table) => Array.isArray(table) ? table.map((data) => executeAggr(expr, data)).filter((x) => !expr[Type.kType]?.ignoreNull || !isEmpty(x)) : Array.from(executeEval(table, expr)).filter((x) => !expr[Type.kType]?.ignoreNull || !isEmpty(x)), (expr) => Type.Array(Type.fromTerm(expr)));
Eval3.get = multary("get", ([x, key2], data) => executeEval(data, x)?.[executeEval(data, key2)], (x, key2) => Type.getInner(Type.fromTerm(x), key2) ?? Type.Any);
function getRecursive(args, data) {
  if (typeof args === "string") {
    return getRecursive(["_", args], data);
  }
  const [ref2, path2] = args;
  let value = data[ref2];
  if (!value) return value;
  if (path2 in value) return value[path2];
  const prefix = Object.keys(value).find((s) => path2.startsWith(s + ".")) || path2.split(".", 1)[0];
  const rest = path2.slice(prefix.length + 1).split(".").filter(Boolean);
  rest.unshift(prefix);
  for (const key2 of rest) {
    value = value[key2];
    if (!value) return value;
  }
  return value;
}
__name$2(getRecursive, "getRecursive");
function executeEvalExpr(expr, data) {
  for (const key2 in expr) {
    if (key2 in operators) {
      return operators[key2](expr[key2], data);
    }
  }
  return expr;
}
__name$2(executeEvalExpr, "executeEvalExpr");
function executeAggr(expr, data) {
  if (typeof expr === "string") {
    return getRecursive(expr, data);
  }
  return executeEvalExpr(expr, data);
}
__name$2(executeAggr, "executeAggr");
function executeEval(data, expr) {
  if (isComparable(expr) || isNullable(expr)) {
    return expr;
  }
  if (Array.isArray(expr)) {
    return expr.map((item) => executeEval(data, item));
  }
  return executeEvalExpr(expr, data);
}
__name$2(executeEval, "executeEval");
function executeUpdate(data, update, ref2) {
  for (const key2 in update) {
    let root2 = data;
    const path2 = key2.split(".");
    const last = path2.pop();
    for (const key22 of path2) {
      root2 = root2[key22] ||= {};
    }
    root2[last] = executeEval({ [ref2]: data, _: data }, update[key2]);
  }
  return data;
}
__name$2(executeUpdate, "executeUpdate");
function isComparable(value) {
  return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "bigint" || value instanceof Date;
}
__name$2(isComparable, "isComparable");
function isFlat(value) {
  return !value || typeof value !== "object" || isEvalExpr(value) || Object.keys(value).length === 0 || Array.isArray(value) || value instanceof Date || value instanceof RegExp || Binary.isSource(value);
}
__name$2(isFlat, "isFlat");
var letters = "abcdefghijklmnopqrstuvwxyz";
function randomId() {
  return Array(8).fill(0).map(() => letters[Math.floor(Math.random() * letters.length)]).join("");
}
__name$2(randomId, "randomId");
function makeRegExp(source2, flags) {
  return source2 instanceof RegExp && !flags ? source2 : new RegExp(source2.source ?? source2, flags ?? source2.flags);
}
__name$2(makeRegExp, "makeRegExp");
function unravel(source2, init2) {
  const result = {};
  for (const key2 in source2) {
    let node = result;
    const segments = key2.split(".").reverse();
    for (let index2 = segments.length - 1; index2 > 0; index2--) {
      const segment = segments[index2];
      node = node[segment] ??= {};
      if (init2) node = init2(node);
    }
    node[segments[0]] = source2[key2];
  }
  return result;
}
__name$2(unravel, "unravel");
function flatten(source2, prefix = "", ignore = isFlat) {
  const result = {};
  for (const key2 in source2) {
    const value = source2[key2];
    if (ignore(value)) {
      result[`${prefix}${key2}`] = value;
    } else {
      Object.assign(result, flatten(value, `${prefix}${key2}.`, ignore));
    }
  }
  return result;
}
__name$2(flatten, "flatten");
function getCell(row, path2) {
  if (path2 in row) return row[path2];
  if (path2.includes(".")) {
    const index2 = path2.indexOf(".");
    return getCell(row[path2.slice(0, index2)] ?? {}, path2.slice(index2 + 1));
  } else {
    return row[path2];
  }
}
__name$2(getCell, "getCell");
function isEmpty(value) {
  if (isNullable(value)) return true;
  if (typeof value !== "object") return false;
  for (const key2 in value) {
    if (!isEmpty(value[key2])) return false;
  }
  return true;
}
__name$2(isEmpty, "isEmpty");
var createRow = /* @__PURE__ */ __name$2((ref2, expr = {}, prefix = "", model, intermediate) => new Proxy(expr, {
  get(target, key2) {
    if (key2 === "$prefix") return prefix;
    if (key2 === "$model") return model;
    if (typeof key2 === "symbol" || key2 in target || key2.startsWith("$")) return Reflect.get(target, key2);
    if (intermediate) {
      if (Type.isArray(expr?.[Type.kType]) && Number.isInteger(+key2)) {
        return createRow(ref2, Eval3.get(expr, +key2), "", model, Eval3.get(expr, +key2));
      } else {
        return createRow(ref2, Eval3.get(intermediate, `${prefix}${key2}`), `${prefix}${key2}.`, model, intermediate);
      }
    }
    let type2;
    const field = model?.fields[prefix + key2];
    if (Type.isArray(expr?.[Type.kType]) && Number.isInteger(+key2)) {
      type2 = Type.getInner(expr?.[Type.kType]) ?? Type.fromField("expr");
      return createRow(ref2, Eval3.get(expr, +key2), "", model, Eval3.get(expr, +key2));
    } else if (Type.getInner(expr?.[Type.kType], key2)) {
      type2 = Type.getInner(expr?.[Type.kType], key2);
    } else if (field) {
      type2 = Type.fromField(field);
    } else if (Object.keys(model?.fields).some((k) => k.startsWith(`${prefix}${key2}.`))) {
      type2 = Type.Object(Object.fromEntries(Object.entries(model?.fields).filter(([k]) => k.startsWith(`${prefix}${key2}`)).map(([k, field2]) => [k.slice(prefix.length + key2.length + 1), Type.fromField(field2)])));
    } else {
      type2 = model?.getType(`${prefix}${key2}`) ?? Type.fromField("expr");
    }
    const row = createRow(ref2, Eval3("", [ref2, `${prefix}${key2}`], type2), `${prefix}${key2}.`, model);
    if (!field && Object.keys(model?.fields).some((k) => k.startsWith(`${prefix}${key2}.`))) {
      return createRow(ref2, Eval3.object(row), `${prefix}${key2}.`, model);
    } else {
      return row;
    }
  }
}), "createRow");
var Executable = class {
  static {
    __name$2(this, "Executable");
  }
  row;
  model;
  driver;
  constructor(driver, payload) {
    Object.assign(this, payload);
    defineProperty(this, "driver", driver);
    defineProperty(this, "model", driver.model(this.table));
    defineProperty(this, "row", createRow(this.ref, Eval3.object(createRow(this.ref, {}, "", this.model)), "", this.model));
  }
  isCallaback(query) {
    if (typeof query !== "function") return false;
    const fields = query(this.row);
    return isEvalExpr(omit$1(fields, ["$object"]));
  }
  resolveQuery(query = {}) {
    if (typeof query === "function") {
      const expr = query(this.row);
      return expr["$expr"] ? expr : isEvalExpr(expr) ? { $expr: expr } : expr;
    }
    if (Array.isArray(query) || query instanceof RegExp || ["string", "number", "bigint"].includes(typeof query)) {
      const { primary } = this.model;
      if (Array.isArray(primary)) {
        throw new TypeError("invalid shorthand for composite primary key");
      }
      return { [primary]: query };
    }
    return query;
  }
  resolveField(field) {
    if (typeof field === "string") {
      return this.row[field];
    } else if (typeof field === "function") {
      return field(this.row);
    } else if (isEvalExpr(field)) {
      return field;
    } else {
      throw new TypeError("invalid field definition");
    }
  }
  resolveFields(fields) {
    if (typeof fields === "function") fields = fields(this.row);
    if (typeof fields === "string") fields = [fields];
    if (Array.isArray(fields)) {
      const modelFields = Object.keys(this.model.fields);
      const entries = fields.flatMap((key2) => {
        if (this.model.fields[key2]) return [[key2, this.row[key2]]];
        else if (modelFields.some((path2) => path2.startsWith(key2 + "."))) {
          return modelFields.filter((path2) => path2.startsWith(key2 + ".")).map((path2) => [path2, this.row[path2]]);
        }
        return [[key2, key2.split(".").reduce((row, k) => row[k], this.row)]];
      });
      return Object.fromEntries(entries);
    } else {
      const entries = Object.entries(fields).flatMap(([key2, field]) => {
        if (key2.startsWith("$")) return [];
        const expr = this.resolveField(field);
        if (expr["$object"] && !Type.fromTerm(expr).ignoreNull) {
          return Object.entries(expr["$object"]).map(([key22, expr2]) => [`${key2}.${key22}`, expr2]);
        }
        return [[key2, expr]];
      });
      return Object.fromEntries(entries);
    }
  }
  async execute() {
    await this.driver.database.prepared();
    await this.driver._ensureSession();
    return this.driver[this.type](this, ...this.args);
  }
};
var Selection = class _Selection extends Executable {
  static {
    __name$2(this, "Selection");
  }
  tables = {};
  constructor(driver, table, query) {
    super(driver, {
      type: "get",
      ref: randomId(),
      table,
      query: null,
      args: [{ sort: [], limit: Infinity, offset: 0, group: void 0, having: Eval3.and(), optional: {} }]
    });
    this.tables[this.ref] = this.model;
    this.query = this.resolveQuery(query);
    if (typeof table !== "string") {
      Object.assign(this.tables, table.tables);
    }
  }
  where(query) {
    this.query.$and ||= [];
    this.query.$and.push(this.resolveQuery(query));
    return this;
  }
  limit(...args) {
    if (args.length > 1) this.offset(args.shift());
    this.args[0].limit = args[0];
    return this;
  }
  offset(offset) {
    this.args[0].offset = offset;
    return this;
  }
  orderBy(field, direction = "asc") {
    this.args[0].sort.push([this.resolveField(field), direction]);
    return this;
  }
  groupBy(fields, ...args) {
    this.args[0].fields = this.resolveFields(fields);
    this.args[0].group = Object.keys(this.args[0].fields);
    const extra = this.isCallaback(args[0]) ? void 0 : args.shift();
    Object.assign(this.args[0].fields, this.resolveFields(extra || {}));
    if (args[0]) this.having(args[0]);
    return new _Selection(this.driver, this);
  }
  having(query) {
    this.args[0].having["$and"].push(this.resolveField(query));
    return this;
  }
  project(fields) {
    this.args[0].fields = this.resolveFields(fields);
    return new _Selection(this.driver, this);
  }
  join(name, selection, callback = () => Eval3.and(), optional2 = false) {
    const fields = Object.fromEntries(Object.entries(this.model.fields).filter(([key2, field]) => Field.available(field) && !key2.startsWith(name + ".")).map(([key2]) => [key2, (row) => getCell(row[this.ref], key2)]));
    const joinFields = Object.fromEntries(Object.entries(selection.model.fields).filter(([key2, field]) => Field.available(field) || Field.available(this.model.fields[`${name}.${key2}`])).map(([key2]) => [
      key2,
      (row) => Field.available(this.model.fields[`${name}.${key2}`]) ? getCell(row[this.ref], `${name}.${key2}`) : getCell(row[name], key2)
    ]));
    if (optional2) {
      return this.driver.database.join({ [this.ref]: this, [name]: selection }, (t) => callback(t[this.ref], t[name]), { [this.ref]: false, [name]: true }).project({ ...fields, [name]: (row) => Eval3.ignoreNull(Eval3.object(mapValues(joinFields, (x) => x(row)))) });
    } else {
      return this.driver.database.join({ [this.ref]: this, [name]: selection }, (t) => callback(t[this.ref], t[name])).project({ ...fields, [name]: (row) => Eval3.ignoreNull(Eval3.object(mapValues(joinFields, (x) => x(row)))) });
    }
  }
  _action(type2, ...args) {
    return new Executable(this.driver, { ...this, type: type2, args });
  }
  evaluate(callback) {
    const selection = new _Selection(this.driver, this);
    if (!callback) callback = /* @__PURE__ */ __name$2((row) => Eval3.array(Eval3.object(row)), "callback");
    const expr = Array.isArray(callback) ? Eval3.select(...callback.map((x) => this.resolveField(x))) : this.resolveField(callback);
    if (isAggrExpr(expr)) defineProperty(expr, Type.kType, Type.Array(Type.fromTerm(expr)));
    return Eval3.exec(selection._action("eval", expr));
  }
  async execute(cursor) {
    if (typeof cursor === "function") {
      const selection = new _Selection(this.driver, this);
      return selection._action("eval", this.resolveField(cursor)).execute();
    }
    if (Array.isArray(cursor)) {
      cursor = { fields: cursor };
    } else if (!cursor) {
      cursor = {};
    }
    if (cursor.fields) this.project(cursor.fields);
    if (cursor.limit !== void 0) this.limit(cursor.limit);
    if (cursor.offset !== void 0) this.offset(cursor.offset);
    if (cursor.sort) {
      for (const field in cursor.sort) {
        this.orderBy(field, cursor.sort[field]);
      }
    }
    const rows = await super.execute();
    if (!cursor.fields) return rows;
    return rows.map((row) => {
      return filterKeys(row, (key2) => {
        return cursor.fields.some((k) => k === key2 || k.startsWith(`${key2}.`));
      });
    });
  }
};
((Selection2) => {
  function is2(sel) {
    return sel && !!sel.tables;
  }
  Selection2.is = is2;
  __name$2(is2, "is");
})(Selection || (Selection = {}));
function executeSort(data, modifier, name) {
  const { limit, offset, sort } = modifier;
  data.sort((a, b) => {
    for (const [field, direction] of sort) {
      const sign2 = direction === "asc" ? 1 : -1;
      const x = executeEval({ [name]: a, _: a }, field);
      const y = executeEval({ [name]: b, _: b }, field);
      if (x < y) return -sign2;
      if (x > y) return sign2;
    }
    return 0;
  });
  return data.slice(offset, offset + limit);
}
__name$2(executeSort, "executeSort");
function mergeQuery(base, query) {
  if (typeof query === "function") {
    return (row) => {
      const q = query(row);
      return { $expr: true, ...base, ...q.$expr ? q : { $expr: q } };
    };
  } else {
    return (_) => ({ $expr: true, ...base, ...query });
  }
}
__name$2(mergeQuery, "mergeQuery");
var Database = class _Database extends Service2 {
  static {
    __name$2(this, "Database");
  }
  static [Service2.provide] = "model";
  static [Service2.immediate] = true;
  static transact = /* @__PURE__ */ Symbol("minato.transact");
  static migrate = /* @__PURE__ */ Symbol("minato.migrate");
  tables = /* @__PURE__ */ Object.create(null);
  drivers = [];
  types = /* @__PURE__ */ Object.create(null);
  _driver;
  stashed = /* @__PURE__ */ new Set();
  prepareTasks = /* @__PURE__ */ Object.create(null);
  migrateTasks = /* @__PURE__ */ Object.create(null);
  async connect(driver, ...args) {
    this.ctx.plugin(driver, args[0]);
    await this.ctx.start();
  }
  refresh() {
    for (const name in this.tables) {
      this.prepareTasks[name] = this.prepare(name);
    }
  }
  async prepared() {
    if (this[_Database.migrate]) return;
    await Promise.all(Object.values(this.prepareTasks));
  }
  getDriver(table) {
    if (Selection.is(table)) return table.driver;
    const model = this.tables[table];
    if (!model) throw new Error(`cannot resolve table "${table}"`);
    return model.ctx?.get("database")?._driver;
  }
  async prepare(name) {
    this.stashed.add(name);
    await this.prepareTasks[name];
    await Promise.resolve();
    if (!this.stashed.delete(name)) return;
    const driver = this.getDriver(name);
    if (!driver) return;
    const { fields } = driver.model(name);
    Object.values(fields).forEach((field) => field?.transformers?.forEach((x) => driver.define(x)));
    await driver.prepare(name);
    await driver.prepareIndexes(name);
  }
  extend(name, fields, config2 = {}) {
    let model = this.tables[name];
    if (!model) {
      model = this.tables[name] = new Model(name);
    }
    Object.entries(fields).forEach(([key2, field]) => {
      const transformer = [];
      this.parseField(field, transformer, void 0, (value) => field = fields[key2] = value);
      if (typeof field === "object") field.transformers = transformer;
    });
    model.extend(fields, config2);
    if (makeArray(model.primary).every((key2) => key2 in fields)) {
      defineProperty(model, "ctx", this.ctx);
    }
    Object.entries(fields).forEach(([key2, def]) => {
      if (!Relation.Type.includes(def.type)) return;
      const subprimary = !def.fields && makeArray(model.primary).includes(key2);
      const [relation, inverse] = Relation.parse(def, key2, model, this.tables[def.table ?? key2], subprimary);
      const relmodel = this.tables[relation.table];
      if (!relmodel) throw new Error(`relation table ${relation.table} does not exist`);
      (model.fields[key2] = Field.parse("expr")).relation = relation;
      if (def.target) {
        (relmodel.fields[def.target] ??= Field.parse("expr")).relation = inverse;
      }
      if (relation.type === "oneToOne" || relation.type === "manyToOne") {
        relation.fields.forEach((x, i) => {
          model.fields[x] ??= { ...relmodel.fields[relation.references[i]] };
          if (!relation.required) {
            model.fields[x].nullable = true;
            model.fields[x].initial = null;
          }
        });
      } else if (relation.type === "manyToMany") {
        const assocTable = Relation.buildAssociationTable(relation.table, name);
        if (this.tables[assocTable]) return;
        const shared = Object.entries(relation.shared).map(([x, y]) => [Relation.buildSharedKey(x, y), model.fields[x].deftype]);
        const fields2 = relation.fields.map((x) => [Relation.buildAssociationKey(x, name), model.fields[x].deftype]);
        const references = relation.references.map((x) => [Relation.buildAssociationKey(x, relation.table), relmodel.fields[x]?.deftype]);
        this.extend(assocTable, {
          ...Object.fromEntries([...shared, ...fields2, ...references]),
          [name]: {
            type: "manyToOne",
            table: name,
            fields: [...shared, ...fields2].map((x) => x[0]),
            references: [...Object.keys(relation.shared), ...relation.fields]
          },
          [relation.table]: {
            type: "manyToOne",
            table: relation.table,
            fields: [...shared, ...references].map((x) => x[0]),
            references: [...Object.values(relation.shared), ...relation.references]
          }
        }, {
          primary: [...shared, ...fields2, ...references].map((x) => x[0])
        });
      }
    });
    if (Array.isArray(model.primary) || model.fields[model.primary].relation) {
      model.primary = deduplicate(makeArray(model.primary).map((key2) => model.fields[key2].relation?.fields || key2).flat());
    }
    model.unique = model.unique.map((keys) => typeof keys === "string" ? model.fields[keys].relation?.fields || keys : keys.map((key2) => model.fields[key2].relation?.fields || key2).flat());
    this.prepareTasks[name] = this.prepare(name);
    this.ctx.emit("model", name);
  }
  _parseField(field, transformers = [], setInitial, setField) {
    if (field === "object") {
      setInitial?.({});
      setField?.({ initial: {}, deftype: "json", type: Type.Object() });
      return Type.Object();
    } else if (field === "array") {
      setInitial?.([]);
      setField?.({ initial: [], deftype: "json", type: Type.Array() });
      return Type.Array();
    } else if (typeof field === "string" && this.types[field]) {
      transformers.push({
        types: [field],
        load: this.types[field].load,
        dump: this.types[field].dump
      }, ...this.types[field].transformers ?? []);
      setInitial?.(this.types[field].initial);
      setField?.({ ...this.types[field], type: field });
      return Type.fromField(field);
    } else if (typeof field === "string") {
      setInitial?.(Field.getInitial(field.split("(")[0]));
      setField?.(field);
      return Type.fromField(field.split("(")[0]);
    } else if (typeof field === "object" && field.type === "object") {
      const inner = field.inner ? unravel(field.inner, (value) => (value.type = "object", value.inner ??= {})) : /* @__PURE__ */ Object.create(null);
      const initial = /* @__PURE__ */ Object.create(null);
      const res = Type.Object(mapValues(inner, (x, k) => this.parseField(x, transformers, (value) => initial[k] = value)));
      setInitial?.(Field.getInitial("json", initial));
      setField?.({ initial: Field.getInitial("json", initial), ...field, deftype: "json", type: res });
      return res;
    } else if (typeof field === "object" && field.type === "array") {
      const res = field.inner ? Type.Array(this.parseField(field.inner, transformers)) : Type.Array();
      setInitial?.([]);
      setField?.({ initial: [], ...field, deftype: "json", type: res });
      return res;
    } else if (typeof field === "object" && this.types[field.type]) {
      transformers.push({
        types: [field.type],
        load: this.types[field.type].load,
        dump: this.types[field.type].dump
      }, ...this.types[field.type].transformers ?? []);
      setInitial?.(field.initial === void 0 ? this.types[field.type].initial : field.initial);
      setField?.({ initial: this.types[field.type].initial, ...field });
      return Type.fromField(field.type);
    } else {
      setInitial?.(Field.getInitial(field.type, field.initial));
      setField?.(field);
      return Type.fromField(field.type);
    }
  }
  parseField(field, transformers = [], setInitial, setField) {
    let midfield;
    let type2 = this._parseField(field, transformers, setInitial, (value) => (midfield = value, setField?.(value)));
    if (typeof field === "object" && field.load && field.dump) {
      if (type2.inner) type2 = Type.fromField(this.define({ ...omit$1(midfield, ["load", "dump"]), type: type2 }));
      const name = this.define({ ...field, deftype: midfield.deftype, type: type2.type });
      transformers.push({
        types: [name],
        load: field.load,
        dump: field.dump
      });
      setInitial?.(field.initial);
      setField?.({ ...field, deftype: midfield.deftype ?? this.types[type2.type]?.deftype ?? type2.type, initial: midfield.initial, type: name });
      return Type.fromField(name);
    }
    if (typeof midfield === "object") setField?.({ ...midfield, deftype: midfield.deftype ?? this.types[type2.type]?.deftype ?? type2?.type });
    return type2;
  }
  define(name, field) {
    if (typeof name === "object") {
      field = name;
      name = void 0;
    }
    if (name && this.types[name]) throw new Error(`type "${name}" already defined`);
    if (!name) while (this.types[name = "_define_" + randomId()]) ;
    const transformers = [];
    const type2 = this._parseField(field, transformers, void 0, (value) => field = value);
    field.transformers = transformers;
    this.ctx.effect(() => {
      this.types[name] = { ...field };
      this.types[name].deftype ??= this.types[field.type]?.deftype ?? type2.type;
      return () => delete this.types[name];
    });
    return name;
  }
  migrate(name, fields, callback) {
    this.extend(name, fields, { callback });
  }
  select(table, query, include) {
    let sel = new Selection(this.getDriver(table), table, query);
    if (typeof table !== "string") return sel;
    const whereOnly = include === null, isAssoc = !!include?.$assoc;
    const rawquery = typeof query === "function" ? query : () => query;
    const modelFields = this.tables[table].fields;
    if (include) include = filterKeys(include, (key2) => !!modelFields[key2]?.relation);
    for (const key2 in { ...sel.query, ...sel.query.$not }) {
      if (modelFields[key2]?.relation) {
        if (sel.query[key2] === null && !modelFields[key2].relation.required) {
          sel.query[key2] = Object.fromEntries(modelFields[key2].relation.references.map((k) => [k, null]));
        }
        if (sel.query[key2] && typeof sel.query[key2] !== "function" && typeof sel.query[key2] === "object" && Object.keys(sel.query[key2]).every((x) => modelFields[key2].relation.fields.includes(`${key2}.${x}`))) {
          Object.entries(sel.query[key2]).forEach(([k, v]) => sel.query[`${key2}.${k}`] = v);
          delete sel.query[key2];
        }
        if (sel.query.$not?.[key2] === null && !modelFields[key2].relation.required) {
          sel.query.$not[key2] = Object.fromEntries(modelFields[key2].relation.references.map((k) => [k, null]));
        }
        if (sel.query.$not?.[key2] && typeof sel.query.$not[key2] !== "function" && typeof sel.query.$not[key2] === "object" && Object.keys(sel.query.$not[key2]).every((x) => modelFields[key2].relation.fields.includes(`${key2}.${x}`))) {
          Object.entries(sel.query.$not[key2]).forEach(([k, v]) => sel.query.$not[`${key2}.${k}`] = v);
          delete sel.query.$not[key2];
        }
        if (!include || !Object.getOwnPropertyNames(include).includes(key2)) {
          (include ??= {})[key2] = true;
        }
      }
    }
    sel.query = omit$1(sel.query, Object.keys(include ?? {}));
    if (Object.keys(sel.query.$not ?? {}).length) {
      sel.query.$not = omit$1(sel.query.$not, Object.keys(include ?? {}));
      if (Object.keys(sel.query.$not).length === 0) Reflect.deleteProperty(sel.query, "$not");
    }
    if (include && typeof include === "object") {
      if (typeof table !== "string") throw new Error("cannot include relations on derived selection");
      const extraFields = [];
      const applyQuery = /* @__PURE__ */ __name$2((sel2, key2) => {
        const query2 = rawquery(sel2.row);
        const relquery = query2[key2] !== void 0 ? query2[key2] : query2.$not?.[key2] !== void 0 ? { $not: query2.$not?.[key2] } : void 0;
        return relquery === void 0 ? sel2 : sel2.where(this.transformRelationQuery(table, sel2.row, key2, relquery));
      }, "applyQuery");
      for (const key2 in include) {
        if (!include[key2] || !modelFields[key2]?.relation) continue;
        const relation = modelFields[key2].relation;
        const relmodel = this.tables[relation.table];
        if (relation.type === "oneToOne" || relation.type === "manyToOne") {
          sel = whereOnly ? sel : sel.join(key2, this.select(
            relation.table,
            typeof include[key2] === "object" ? filterKeys(include[key2], (k) => !relmodel.fields[k]?.relation) : {},
            typeof include[key2] === "object" ? filterKeys(include[key2], (k) => !!relmodel.fields[k]?.relation) : include[key2]
          ), (self2, other) => Eval3.and(
            ...relation.fields.map((k, i) => Eval3.eq(self2[k], other[relation.references[i]]))
          ), !isAssoc);
          sel = applyQuery(sel, key2);
        } else if (relation.type === "oneToMany") {
          sel = whereOnly ? sel : sel.join(key2, this.select(
            relation.table,
            typeof include[key2] === "object" ? filterKeys(include[key2], (k) => !relmodel.fields[k]?.relation) : {},
            typeof include[key2] === "object" ? filterKeys(include[key2], (k) => !!relmodel.fields[k]?.relation) : include[key2]
          ), (self2, other) => Eval3.and(
            ...relation.fields.map((k, i) => Eval3.eq(self2[k], other[relation.references[i]]))
          ), true);
          sel = applyQuery(sel, key2);
          sel = whereOnly ? sel : sel.groupBy([
            ...Object.entries(modelFields).filter(([k, field]) => !extraFields.some((x) => k.startsWith(`${x}.`)) && Field.available(field)).map(([k]) => k),
            ...extraFields
          ], {
            [key2]: (row) => Eval3.ignoreNull(Eval3.array(row[key2]))
          });
        } else if (relation.type === "manyToMany") {
          const assocTable = Relation.buildAssociationTable(relation.table, table);
          const references = relation.fields.map((x) => Relation.buildAssociationKey(x, table));
          const shared = Object.entries(relation.shared).map(([x, y]) => [Relation.buildSharedKey(x, y), {
            field: x,
            reference: y
          }]);
          sel = whereOnly ? sel : sel.join(
            key2,
            this.select(assocTable, {}, { $assoc: true, [relation.table]: include[key2] }),
            (self2, other) => Eval3.and(
              ...shared.map(([k, v]) => Eval3.eq(self2[v.field], other[k])),
              ...relation.fields.map((k, i) => Eval3.eq(self2[k], other[references[i]]))
            ),
            true
          );
          sel = applyQuery(sel, key2);
          sel = whereOnly ? sel : sel.groupBy([
            ...Object.entries(modelFields).filter(([k, field]) => !extraFields.some((x) => k.startsWith(`${x}.`)) && Field.available(field)).map(([k]) => k),
            ...extraFields
          ], {
            [key2]: (row) => Eval3.ignoreNull(Eval3.array(row[key2][relation.table]))
          });
        }
        extraFields.push(key2);
      }
    }
    return sel;
  }
  join(tables, query = (...args) => Eval3.and(), optional2) {
    const oldTables = tables;
    if (Array.isArray(oldTables)) {
      tables = Object.fromEntries(oldTables.map((name) => [name, this.select(name)]));
    }
    let sels = mapValues(tables, (t) => {
      return typeof t === "string" ? this.select(t) : t;
    });
    if (Object.keys(sels).length === 0) throw new Error("no tables to join");
    const drivers = new Set(Object.values(sels).map((sel2) => sel2.driver[_Database.transact] ?? sel2.driver));
    if (drivers.size !== 1) throw new Error("cannot join tables from different drivers");
    if (Object.keys(sels).length === 2 && (optional2?.[0] || optional2?.[Object.keys(sels)[0]])) {
      if (optional2[1] || optional2[Object.keys(sels)[1]]) throw new Error("full join is not supported");
      sels = Object.fromEntries(Object.entries(sels).reverse());
    }
    const sel = new Selection([...drivers][0], sels);
    if (Array.isArray(oldTables)) {
      sel.args[0].having = Eval3.and(query(...oldTables.map((name) => sel.row[name])));
      sel.args[0].optional = Object.fromEntries(oldTables.map((name, index2) => [name, optional2?.[index2]]));
    } else {
      sel.args[0].having = Eval3.and(query(sel.row));
      sel.args[0].optional = optional2;
    }
    return this.select(sel);
  }
  async get(table, query, cursor) {
    let fields = Array.isArray(cursor) ? cursor : cursor?.fields;
    fields = fields ? Object.fromEntries(fields.map((x) => [x, true])) : cursor?.include;
    return this.select(table, query, fields).execute(cursor);
  }
  async eval(table, expr, query) {
    return this.select(table, query).execute(typeof expr === "function" ? expr : () => expr);
  }
  async set(table, query, update) {
    const rawupdate = typeof update === "function" ? update : () => update;
    let sel = this.select(table, query, null);
    if (typeof update === "function") update = update(sel.row);
    const primary = makeArray(sel.model.primary);
    if (primary.some((key2) => key2 in update)) {
      throw new TypeError(`cannot modify primary key`);
    }
    const relations = Object.entries(sel.model.fields).filter(([key2, field]) => key2 in update && field.relation).map(([key2, field]) => [key2, field.relation]);
    if (relations.length) {
      return await this.ensureTransaction(async (database) => {
        const rows = await database.get(table, query);
        sel = database.select(table, query, null);
        let baseUpdate = omit$1(rawupdate(sel.row), relations.map(([key2]) => key2));
        baseUpdate = sel.model.format(baseUpdate);
        for (const [key2] of relations) {
          await Promise.all(rows.map((row) => database.processRelationUpdate(table, row, key2, rawupdate(row)[key2])));
        }
        return Object.keys(baseUpdate).length === 0 ? {} : await sel._action("set", baseUpdate).execute();
      });
    }
    update = sel.model.format(update);
    if (Object.keys(update).length === 0) return {};
    return sel._action("set", update).execute();
  }
  async remove(table, query) {
    const sel = this.select(table, query, null);
    return sel._action("remove").execute();
  }
  async create(table, data) {
    const sel = this.select(table);
    if (!this.hasRelation(table, data)) {
      const { primary, autoInc } = sel.model;
      if (!autoInc) {
        const keys = makeArray(primary);
        if (keys.some((key2) => getCell(data, key2) === void 0)) {
          throw new Error("missing primary key");
        }
      }
      return sel._action("create", sel.model.create(data)).execute();
    } else {
      return this.ensureTransaction((database) => database.createOrUpdate(table, data, false));
    }
  }
  async upsert(table, upsert, keys) {
    const sel = this.select(table);
    if (typeof upsert === "function") upsert = upsert(sel.row);
    upsert = upsert.map((item) => sel.model.format(item));
    keys = makeArray(keys || sel.model.primary);
    return sel._action("upsert", upsert, keys).execute();
  }
  makeProxy(marker, getDriver) {
    const drivers = /* @__PURE__ */ new Map();
    const database = new Proxy(this, {
      get: /* @__PURE__ */ __name$2((target, p, receiver) => {
        if (p === marker) return true;
        if (p !== "getDriver") return Reflect.get(target, p, receiver);
        return (name) => {
          const original = this.getDriver(name);
          let driver = drivers.get(original);
          if (!driver) {
            driver = getDriver?.(original, database) ?? new Proxy(original, {
              get: /* @__PURE__ */ __name$2((target2, p2, receiver2) => {
                if (p2 === "database") return database;
                return Reflect.get(target2, p2, receiver2);
              }, "get")
            });
            drivers.set(original, driver);
          }
          return driver;
        };
      }, "get")
    });
    return database;
  }
  withTransaction(callback) {
    return this.transact(callback);
  }
  async transact(callback) {
    if (this[_Database.transact]) throw new Error("nested transactions are not supported");
    const finalTasks = [];
    const database = this.makeProxy(_Database.transact, (driver) => {
      let initialized = false, session;
      let _resolve;
      const sessionTask = new Promise((resolve2) => _resolve = resolve2);
      driver = new Proxy(driver, {
        get: /* @__PURE__ */ __name$2((target, p, receiver) => {
          if (p === _Database.transact) return target;
          if (p === "database") return database;
          if (p === "session") return session;
          if (p === "_ensureSession") return () => sessionTask;
          return Reflect.get(target, p, receiver);
        }, "get")
      });
      finalTasks.push(driver.withTransaction((_session) => {
        if (initialized) initialTask = initialTaskFactory();
        initialized = true;
        _resolve(session = _session);
        return initialTask;
      }));
      return driver;
    });
    const initialTaskFactory = /* @__PURE__ */ __name$2(() => Promise.resolve().then(() => callback(database)), "initialTaskFactory");
    let initialTask = initialTaskFactory();
    return initialTask.catch(noop).finally(() => Promise.all(finalTasks));
  }
  async stopAll() {
    await Promise.all(this.drivers.splice(0, Infinity).map((driver) => driver.stop()));
  }
  async drop(table) {
    if (this[_Database.transact]) throw new Error("cannot drop table in transaction");
    await this.getDriver(table).drop(table);
  }
  async dropAll() {
    if (this[_Database.transact]) throw new Error("cannot drop table in transaction");
    await Promise.all(Object.values(this.drivers).map((driver) => driver.dropAll()));
  }
  async stats() {
    await this.prepared();
    const stats = { size: 0, tables: {} };
    await Promise.all(Object.values(this.drivers).map(async (driver) => {
      const { size = 0, tables } = await driver.stats();
      stats.size += size;
      Object.assign(stats.tables, tables);
    }));
    return stats;
  }
  ensureTransaction(callback) {
    if (this[_Database.transact]) {
      return callback(this);
    } else {
      return this.transact(callback);
    }
  }
  transformRelationQuery(table, row, key2, query) {
    const relation = this.tables[table].fields[key2].relation;
    const results = [];
    if (relation.type === "oneToOne" || relation.type === "manyToOne") {
      if (query === null) {
        results.push(Eval3.nin(
          relation.fields.map((x) => row[x]),
          this.select(relation.table).evaluate(relation.references)
        ));
      } else {
        results.push(Eval3.in(
          relation.fields.map((x) => row[x]),
          this.select(relation.table, query).evaluate(relation.references)
        ));
      }
    } else if (relation.type === "oneToMany") {
      if (query.$or) results.push(Eval3.or(...query.$or.map((q) => this.transformRelationQuery(table, row, key2, q).$expr)));
      if (query.$and) results.push(...query.$and.map((q) => this.transformRelationQuery(table, row, key2, q).$expr));
      if (query.$not) results.push(Eval3.not(this.transformRelationQuery(table, row, key2, query.$not).$expr));
      if (query.$some) {
        results.push(Eval3.in(
          relation.fields.map((x) => row[x]),
          this.select(relation.table, query.$some).evaluate(relation.references)
        ));
      }
      if (query.$none) {
        results.push(Eval3.nin(
          relation.fields.map((x) => row[x]),
          this.select(relation.table, query.$none).evaluate(relation.references)
        ));
      }
      if (query.$every) {
        results.push(Eval3.nin(
          relation.fields.map((x) => row[x]),
          this.select(relation.table, Eval3.not(query.$every)).evaluate(relation.references)
        ));
      }
    } else if (relation.type === "manyToMany") {
      const assocTable = Relation.buildAssociationTable(table, relation.table);
      const fields = relation.fields.map((x) => Relation.buildAssociationKey(x, table));
      const references = relation.references.map((x) => Relation.buildAssociationKey(x, relation.table));
      if (query.$or) results.push(Eval3.or(...query.$or.map((q) => this.transformRelationQuery(table, row, key2, q).$expr)));
      if (query.$and) results.push(...query.$and.map((q) => this.transformRelationQuery(table, row, key2, q).$expr));
      if (query.$not) results.push(Eval3.not(this.transformRelationQuery(table, row, key2, query.$not).$expr));
      if (query.$some) {
        const innerTable = this.select(relation.table, query.$some).evaluate(relation.references);
        const relTable = this.select(assocTable, (r) => Eval3.in(references.map((x) => r[x]), innerTable)).evaluate(fields);
        results.push(Eval3.in(relation.fields.map((x) => row[x]), relTable));
      }
      if (query.$none) {
        const innerTable = this.select(relation.table, query.$none).evaluate(relation.references);
        const relTable = this.select(assocTable, (r) => Eval3.in(references.map((x) => r[x]), innerTable)).evaluate(fields);
        results.push(Eval3.nin(relation.fields.map((x) => row[x]), relTable));
      }
      if (query.$every) {
        const innerTable = this.select(relation.table, Eval3.not(query.$every)).evaluate(relation.references);
        const relTable = this.select(assocTable, (r) => Eval3.in(references.map((x) => r[x]), innerTable)).evaluate(fields);
        results.push(Eval3.nin(relation.fields.map((x) => row[x]), relTable));
      }
    }
    return { $expr: Eval3.and(...results) };
  }
  async createOrUpdate(table, data, upsert = true) {
    const sel = this.select(table);
    data = { ...data };
    const tasks = [""];
    for (const key2 in data) {
      if (data[key2] !== void 0 && this.tables[table].fields[key2]?.relation) {
        const relation = this.tables[table].fields[key2].relation;
        if (relation.type === "oneToOne" && relation.required) tasks.push(key2);
        else if (relation.type === "oneToOne") tasks.unshift(key2);
        else if (relation.type === "oneToMany") tasks.push(key2);
        else if (relation.type === "manyToOne") tasks.unshift(key2);
        else if (relation.type === "manyToMany") tasks.push(key2);
      }
    }
    for (const key2 of [...tasks]) {
      if (!key2) {
        const { primary, autoInc } = sel.model;
        const keys = makeArray(primary);
        if (keys.some((key22) => isNullable(getCell(data, key22)))) {
          if (!autoInc) {
            throw new Error("missing primary key");
          } else {
            delete data[primary];
            upsert = false;
          }
        }
        if (upsert) {
          await sel._action("upsert", [sel.model.format(omit$1(data, tasks))], keys).execute();
        } else {
          Object.assign(data, await sel._action("create", sel.model.create(omit$1(data, tasks))).execute());
        }
        continue;
      }
      const value = data[key2];
      const relation = this.tables[table].fields[key2].relation;
      if (relation.type === "oneToOne") {
        if (value.$literal) {
          data[key2] = value.$literal;
          remove(tasks, key2);
        } else if (value.$create || !isUpdateExpr(value)) {
          const result = await this.createOrUpdate(relation.table, {
            ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(data, relation.fields[i])])),
            ...value.$create ?? value
          });
          if (!relation.required) {
            relation.references.forEach((k, i) => data[relation.fields[i]] = getCell(result, k));
          }
        } else if (value.$upsert) {
          await this.upsert(relation.table, [{
            ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(data, relation.fields[i])])),
            ...value.$upsert
          }]);
          if (!relation.required) {
            relation.references.forEach((k, i) => data[relation.fields[i]] = getCell(value.$upsert, k));
          }
        } else if (value.$connect) {
          if (relation.required) {
            await this.set(
              relation.table,
              value.$connect,
              Object.fromEntries(relation.references.map((k, i) => [k, getCell(data, relation.fields[i])]))
            );
          } else {
            const result = relation.references.every((k) => value.$connect[k] !== void 0) ? [value.$connect] : await this.get(relation.table, value.$connect);
            if (result.length !== 1) throw new Error("related row not found or not unique");
            relation.references.forEach((k, i) => data[relation.fields[i]] = getCell(result[0], k));
          }
        }
      } else if (relation.type === "manyToOne") {
        if (value.$literal) {
          data[key2] = value.$literal;
          remove(tasks, key2);
        } else if (value.$create || !isUpdateExpr(value)) {
          const result = await this.createOrUpdate(relation.table, value.$create ?? value);
          relation.references.forEach((k, i) => data[relation.fields[i]] = getCell(result, k));
        } else if (value.$upsert) {
          await this.upsert(relation.table, [value.$upsert]);
          relation.references.forEach((k, i) => data[relation.fields[i]] = getCell(value.$upsert, k));
        } else if (value.$connect) {
          const result = relation.references.every((k) => value.$connect[k] !== void 0) ? [value.$connect] : await this.get(relation.table, value.$connect);
          if (result.length !== 1) throw new Error("related row not found or not unique");
          relation.references.forEach((k, i) => data[relation.fields[i]] = getCell(result[0], k));
        }
      } else if (relation.type === "oneToMany") {
        if (value.$create || Array.isArray(value)) {
          for (const item of makeArray(value.$create ?? value)) {
            await this.createOrUpdate(relation.table, {
              ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(data, relation.fields[i])])),
              ...item
            });
          }
        }
        if (value.$upsert) {
          await this.upsert(relation.table, makeArray(value.$upsert).map((r) => ({
            ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(data, relation.fields[i])])),
            ...r
          })));
        }
        if (value.$connect) {
          await this.set(
            relation.table,
            value.$connect,
            Object.fromEntries(relation.references.map((k, i) => [k, getCell(data, relation.fields[i])]))
          );
        }
      } else if (relation.type === "manyToMany") {
        const assocTable = Relation.buildAssociationTable(relation.table, table);
        const fields = relation.fields.map((x) => Relation.buildAssociationKey(x, table));
        const references = relation.references.map((x) => Relation.buildAssociationKey(x, relation.table));
        const shared = Object.entries(relation.shared).map(([x, y]) => [Relation.buildSharedKey(x, y), {
          field: x,
          reference: y
        }]);
        const result = [];
        if (value.$create || Array.isArray(value)) {
          for (const item of makeArray(value.$create ?? value)) {
            result.push(await this.createOrUpdate(relation.table, {
              ...Object.fromEntries(shared.map(([, v]) => [v.reference, getCell(item, v.reference) ?? getCell(data, v.field)])),
              ...item
            }));
          }
        }
        if (value.$upsert) {
          const upsert2 = makeArray(value.$upsert).map((r) => ({
            ...Object.fromEntries(shared.map(([, v]) => [v.reference, getCell(r, v.reference) ?? getCell(data, v.field)])),
            ...r
          }));
          await this.upsert(relation.table, upsert2);
          result.push(...upsert2);
        }
        if (value.$connect) {
          for (const item of makeArray(value.$connect)) {
            if (references.every((k) => item[k] !== void 0)) result.push(item);
            else result.push(...await this.get(relation.table, item));
          }
        }
        await this.upsert(assocTable, result.map((r) => ({
          ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(r, v.reference) ?? getCell(data, v.field)])),
          ...Object.fromEntries(fields.map((k, i) => [k, getCell(data, relation.fields[i])])),
          ...Object.fromEntries(references.map((k, i) => [k, getCell(r, relation.references[i])]))
        })));
      }
    }
    return data;
  }
  async processRelationUpdate(table, row, key2, value) {
    const model = this.tables[table], update = /* @__PURE__ */ Object.create(null);
    const relation = this.tables[table].fields[key2].relation;
    if (relation.type === "oneToOne") {
      if (value === null) {
        value = relation.required ? { $remove: {} } : { $disconnect: {} };
      }
      if (typeof value === "object" && !isUpdateExpr(value)) {
        value = { $create: value };
      }
      if (value.$remove) {
        await this.remove(relation.table, Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])));
      }
      if (value.$disconnect) {
        if (relation.required) {
          await this.set(
            relation.table,
            mergeQuery(Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])), value.$disconnect),
            Object.fromEntries(relation.references.map((k, i) => [k, null]))
          );
        } else {
          Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, null])));
        }
      }
      if (value.$set || typeof value === "function") {
        await this.set(
          relation.table,
          Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          value.$set ?? value
        );
      }
      if (value.$create) {
        const result = await this.createOrUpdate(relation.table, {
          ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          ...value.$create
        });
        if (!relation.required) {
          Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, getCell(result, relation.references[i])])));
        }
      }
      if (value.$upsert) {
        await this.upsert(relation.table, makeArray(value.$upsert).map((r) => ({
          ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          ...r
        })));
        if (!relation.required) {
          Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, getCell(value.$upsert, relation.references[i])])));
        }
      }
      if (value.$connect) {
        if (relation.required) {
          await this.set(
            relation.table,
            value.$connect,
            Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])]))
          );
        } else {
          const result = await this.get(relation.table, value.$connect);
          if (result.length !== 1) throw new Error("related row not found or not unique");
          Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, getCell(result[0], relation.references[i])])));
        }
      }
    } else if (relation.type === "manyToOne") {
      if (value === null) {
        value = { $disconnect: {} };
      }
      if (typeof value === "object" && !isUpdateExpr(value)) {
        value = { $create: value };
      }
      if (value.$remove) {
        await this.remove(relation.table, Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])));
      }
      if (value.$disconnect) {
        Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, null])));
      }
      if (value.$set || typeof value === "function") {
        await this.set(
          relation.table,
          Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          value.$set ?? value
        );
      }
      if (value.$create) {
        const result = await this.createOrUpdate(relation.table, {
          ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          ...value.$create
        });
        Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, getCell(result, relation.references[i])])));
      }
      if (value.$upsert) {
        await this.upsert(relation.table, makeArray(value.$upsert).map((r) => ({
          ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          ...r
        })));
        Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, getCell(value.$upsert, relation.references[i])])));
      }
      if (value.$connect) {
        const result = await this.get(relation.table, value.$connect);
        if (result.length !== 1) throw new Error("related row not found or not unique");
        Object.assign(update, Object.fromEntries(relation.fields.map((k, i) => [k, getCell(result[0], relation.references[i])])));
      }
    } else if (relation.type === "oneToMany") {
      if (Array.isArray(value)) {
        const $create = [], $upsert = [];
        value.forEach((item) => this.hasRelation(relation.table, item) ? $create.push(item) : $upsert.push(item));
        value = { $remove: {}, $create, $upsert };
      }
      if (value.$remove) {
        await this.remove(relation.table, mergeQuery(Object.fromEntries(relation.references.map((k, i) => [k, row[relation.fields[i]]])), value.$remove));
      }
      if (value.$disconnect) {
        await this.set(
          relation.table,
          mergeQuery(Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])), value.$disconnect),
          Object.fromEntries(relation.references.map((k, i) => [k, null]))
        );
      }
      if (value.$set || typeof value === "function") {
        for (const setexpr of makeArray(value.$set ?? value)) {
          const [query, update2] = setexpr.update ? [setexpr.where, setexpr.update] : [{}, setexpr];
          await this.set(
            relation.table,
            mergeQuery(Object.fromEntries(relation.references.map((k, i) => [k, row[relation.fields[i]]])), query),
            update2
          );
        }
      }
      if (value.$create) {
        for (const item of makeArray(value.$create)) {
          await this.createOrUpdate(relation.table, {
            ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
            ...item
          });
        }
      }
      if (value.$upsert) {
        await this.upsert(relation.table, makeArray(value.$upsert).map((r) => ({
          ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          ...r
        })));
      }
      if (value.$connect) {
        await this.set(
          relation.table,
          value.$connect,
          Object.fromEntries(relation.references.map((k, i) => [k, row[relation.fields[i]]]))
        );
      }
    } else if (relation.type === "manyToMany") {
      const assocTable = Relation.buildAssociationTable(table, relation.table);
      const fields = relation.fields.map((x) => Relation.buildAssociationKey(x, table));
      const references = relation.references.map((x) => Relation.buildAssociationKey(x, relation.table));
      const shared = Object.entries(relation.shared).map(([x, y]) => [Relation.buildSharedKey(x, y), {
        field: x,
        reference: y
      }]);
      if (Array.isArray(value)) {
        const $create = [], $upsert = [];
        value.forEach((item) => this.hasRelation(relation.table, item) ? $create.push(item) : $upsert.push(item));
        value = { $disconnect: {}, $create, $upsert };
      }
      if (value.$remove) {
        const rows = await this.select(assocTable, {
          ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(row, v.field)])),
          ...Object.fromEntries(fields.map((k, i) => [k, getCell(row, relation.fields[i])])),
          [relation.table]: value.$remove
        }, null).execute();
        await this.remove(assocTable, (r) => Eval3.in(
          [...shared.map(([k, v]) => r[k]), ...fields.map((x) => r[x]), ...references.map((x) => r[x])],
          rows.map((r2) => [...shared.map(([k, v]) => getCell(r2, k)), ...fields.map((x) => getCell(r2, x)), ...references.map((x) => getCell(r2, x))])
        ));
        await this.remove(relation.table, (r) => Eval3.in(
          [...shared.map(([k, v]) => r[v.reference]), ...relation.references.map((x) => r[x])],
          rows.map((r2) => [...shared.map(([k, v]) => getCell(r2, k)), ...references.map((x) => getCell(r2, x))])
        ));
      }
      if (value.$disconnect) {
        const rows = await this.select(assocTable, {
          ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(row, v.field)])),
          ...Object.fromEntries(fields.map((k, i) => [k, getCell(row, relation.fields[i])])),
          [relation.table]: value.$disconnect
        }, null).execute();
        await this.remove(assocTable, (r) => Eval3.in(
          [...shared.map(([k, v]) => r[k]), ...fields.map((x) => r[x]), ...references.map((x) => r[x])],
          rows.map((r2) => [...shared.map(([k, v]) => getCell(r2, k)), ...fields.map((x) => getCell(r2, x)), ...references.map((x) => getCell(r2, x))])
        ));
      }
      if (value.$set) {
        for (const setexpr of makeArray(value.$set)) {
          const [query, update2] = setexpr.update ? [setexpr.where, setexpr.update] : [{}, setexpr];
          const rows = await this.select(assocTable, (r) => ({
            ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(row, v.field)])),
            ...Object.fromEntries(fields.map((k, i) => [k, getCell(row, relation.fields[i])])),
            [relation.table]: query
          }), null).execute();
          await this.set(
            relation.table,
            (r) => Eval3.in(
              [...shared.map(([k, v]) => r[v.reference]), ...relation.references.map((x) => r[x])],
              rows.map((r2) => [...shared.map(([k, v]) => getCell(r2, k)), ...references.map((x) => getCell(r2, x))])
            ),
            update2
          );
        }
      }
      if (value.$create) {
        const result = [];
        for (const item of makeArray(value.$create)) {
          result.push(await this.createOrUpdate(relation.table, {
            ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
            ...item
          }));
        }
        await this.upsert(assocTable, result.map((r) => ({
          ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(row, v.field)])),
          ...Object.fromEntries(fields.map((k, i) => [k, row[relation.fields[i]]])),
          ...Object.fromEntries(references.map((k, i) => [k, r[relation.references[i]]]))
        })));
      }
      if (value.$upsert) {
        await this.upsert(relation.table, makeArray(value.$upsert).map((r) => ({
          ...Object.fromEntries(relation.references.map((k, i) => [k, getCell(row, relation.fields[i])])),
          ...r
        })));
        await this.upsert(assocTable, makeArray(value.$upsert).map((r) => ({
          ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(row, v.field)])),
          ...Object.fromEntries(fields.map((k, i) => [k, row[relation.fields[i]]])),
          ...Object.fromEntries(references.map((k, i) => [k, r[relation.references[i]]]))
        })));
      }
      if (value.$connect) {
        const rows = await this.get(
          relation.table,
          mergeQuery(Object.fromEntries(shared.map(([k, v]) => [v.reference, getCell(row, v.field)])), value.$connect)
        );
        await this.upsert(assocTable, rows.map((r) => ({
          ...Object.fromEntries(shared.map(([k, v]) => [k, getCell(row, v.field)])),
          ...Object.fromEntries(fields.map((k, i) => [k, row[relation.fields[i]]])),
          ...Object.fromEntries(references.map((k, i) => [k, r[relation.references[i]]]))
        })));
      }
    }
    if (Object.keys(update).length) {
      await this.set(table, pick$1(model.format(row), makeArray(model.primary)), update);
    }
  }
  hasRelation(table, data) {
    for (const key2 in data) {
      if (data[key2] !== void 0 && this.tables[table].fields[key2]?.relation) return true;
    }
    return false;
  }
};
var Driver = class {
  constructor(ctx, config2) {
    this.ctx = ctx;
    this.config = config2;
    this.database = ctx.model;
    this.logger = ctx.logger(this.constructor.name);
    ctx.on("ready", async () => {
      await Promise.resolve();
      await this.start();
      ctx.model.drivers.push(this);
      ctx.model.refresh();
      const database = Object.create(ctx.model);
      defineProperty(database, "ctx", ctx);
      database._driver = this;
      database[Service2.tracker] = {
        associate: "database",
        property: "ctx"
      };
      ctx.set("database", Context2.associate(database, "database"));
    });
    ctx.on("dispose", async () => {
      remove(ctx.model.drivers, this);
      await this.stop();
    });
  }
  static {
    __name$2(this, "Driver");
  }
  static inject = ["model"];
  database;
  logger;
  types = /* @__PURE__ */ Object.create(null);
  model(table) {
    if (typeof table === "string") {
      const model2 = this.database.tables[table];
      if (model2) return model2;
      throw new TypeError(`unknown table name "${table}"`);
    }
    if (Selection.is(table)) {
      if (!table.args[0].fields && (typeof table.table === "string" || Selection.is(table.table))) {
        return table.model;
      }
      const model2 = new Model("temp");
      if (table.args[0].fields) {
        model2.fields = mapValues(table.args[0].fields, (expr) => ({
          type: Type.fromTerm(expr)
        }));
      } else {
        model2.fields = mapValues(table.model.fields, (field) => ({
          type: Type.fromField(field)
        }));
      }
      return model2;
    }
    const model = new Model("temp");
    for (const key2 in table) {
      const submodel = this.model(table[key2]);
      for (const field in submodel.fields) {
        if (!Field.available(submodel.fields[field])) continue;
        model.fields[`${key2}.${field}`] = {
          expr: Eval3("", [table[key2].ref, field], Type.fromField(submodel.fields[field])),
          type: Type.fromField(submodel.fields[field])
        };
      }
    }
    return model;
  }
  async migrate(name, hooks) {
    const database = this.database.makeProxy(Database.migrate);
    const model = this.model(name);
    await (database.migrateTasks[name] = Promise.resolve(database.migrateTasks[name]).then(() => {
      return Promise.all([...model.migrations].map(async ([migrate, keys]) => {
        try {
          if (!hooks.before(keys)) return;
          await migrate(database);
          hooks.after(keys);
        } catch (reason) {
          hooks.error(reason);
        }
      }));
    }).then(hooks.finalize).catch(hooks.error));
  }
  define(converter) {
    converter.types.forEach((type2) => this.types[type2] = converter);
  }
  async _ensureSession() {
  }
  async prepareIndexes(table) {
    const oldIndexes = await this.getIndexes(table);
    const { indexes } = this.model(table);
    for (const index2 of indexes) {
      const oldIndex = oldIndexes.find((info) => info.name === index2.name);
      if (!oldIndex) {
        await this.createIndex(table, index2);
      } else if (!deepEqual(oldIndex, index2)) {
        await this.dropIndex(table, index2.name);
        await this.createIndex(table, index2);
      }
    }
  }
};
(class _RuntimeError extends Error {
  constructor(code, message) {
    super(message || code.replace("-", " "));
    this.code = code;
  }
  static {
    __name$2(this, "RuntimeError");
  }
  name = "RuntimeError";
  static check(error2, code) {
    if (!(error2 instanceof _RuntimeError)) return false;
    return !code || error2.message === code;
  }
});
var queryOperators = {
  // logical
  $or: /* @__PURE__ */ __name$2((query, data) => query.reduce((prev, query2) => prev || executeFieldQuery(query2, data), false), "$or"),
  $and: /* @__PURE__ */ __name$2((query, data) => query.reduce((prev, query2) => prev && executeFieldQuery(query2, data), true), "$and"),
  $not: /* @__PURE__ */ __name$2((query, data) => !executeFieldQuery(query, data), "$not"),
  // existence
  $exists: /* @__PURE__ */ __name$2((query, data) => query !== isNullable(data), "$exists"),
  // comparison
  $eq: /* @__PURE__ */ __name$2((query, data) => data.valueOf() === query.valueOf(), "$eq"),
  $ne: /* @__PURE__ */ __name$2((query, data) => data.valueOf() !== query.valueOf(), "$ne"),
  $gt: /* @__PURE__ */ __name$2((query, data) => data.valueOf() > query.valueOf(), "$gt"),
  $gte: /* @__PURE__ */ __name$2((query, data) => data.valueOf() >= query.valueOf(), "$gte"),
  $lt: /* @__PURE__ */ __name$2((query, data) => data.valueOf() < query.valueOf(), "$lt"),
  $lte: /* @__PURE__ */ __name$2((query, data) => data.valueOf() <= query.valueOf(), "$lte"),
  // membership
  $in: /* @__PURE__ */ __name$2((query, data) => query.includes(data), "$in"),
  $nin: /* @__PURE__ */ __name$2((query, data) => !query.includes(data), "$nin"),
  // regexp
  $regex: /* @__PURE__ */ __name$2((query, data) => makeRegExp(query).test(data), "$regex"),
  $regexFor: /* @__PURE__ */ __name$2((query, data) => typeof query === "string" ? makeRegExp(data).test(query) : makeRegExp(data, query.flags).test(query.input), "$regexFor"),
  // bitwise
  $bitsAllSet: /* @__PURE__ */ __name$2((query, data) => (query & data) === query, "$bitsAllSet"),
  $bitsAllClear: /* @__PURE__ */ __name$2((query, data) => (query & data) === 0, "$bitsAllClear"),
  $bitsAnySet: /* @__PURE__ */ __name$2((query, data) => (query & data) !== 0, "$bitsAnySet"),
  $bitsAnyClear: /* @__PURE__ */ __name$2((query, data) => (query & data) !== query, "$bitsAnyClear"),
  // list
  $el: /* @__PURE__ */ __name$2((query, data) => data.some((item) => executeFieldQuery(query, item)), "$el"),
  $size: /* @__PURE__ */ __name$2((query, data) => data.length === query, "$size")
};
function executeFieldQuery(query, data) {
  if (Array.isArray(query)) {
    return query.includes(data);
  } else if (query instanceof RegExp) {
    return query.test(data);
  } else if (isComparable(query)) {
    return data.valueOf() === query.valueOf();
  } else if (isNullable(query)) {
    return isNullable(data);
  }
  for (const key2 in query) {
    if (key2 in queryOperators) {
      if (!queryOperators[key2](query[key2], data)) return false;
    }
  }
  return true;
}
__name$2(executeFieldQuery, "executeFieldQuery");
function executeQuery(data, query, ref2, env = {}) {
  const entries = Object.entries(query);
  return entries.every(([key2, value]) => {
    if (key2 === "$and") {
      return value.reduce((prev, query2) => prev && executeQuery(data, query2, ref2, env), true);
    } else if (key2 === "$or") {
      return value.reduce((prev, query2) => prev || executeQuery(data, query2, ref2, env), false);
    } else if (key2 === "$not") {
      return !executeQuery(data, value, ref2, env);
    } else if (key2 === "$expr") {
      return executeEval({ ...env, [ref2]: data, _: data }, value);
    }
    try {
      const flattenQuery = isFlat(query[key2]) ? { [key2]: query[key2] } : flatten(query[key2], `${key2}.`);
      return Object.entries(flattenQuery).every(([key22, value2]) => executeFieldQuery(value2, getCell(data, key22)));
    } catch {
      return false;
    }
  });
}
__name$2(executeQuery, "executeQuery");
var src_default$1 = Database;
var __defProp$1 = Object.defineProperty;
var __name$1 = (target, value) => __defProp$1(target, "name", { value, configurable: true });
function escapeId(value) {
  return "`" + value + "`";
}
__name$1(escapeId, "escapeId");
function isBracketed(value) {
  return value.startsWith("(") && value.endsWith(")");
}
__name$1(isBracketed, "isBracketed");
function isSqlJson(type2) {
  return type2 ? type2.type === "json" || !!type2.inner : false;
}
__name$1(isSqlJson, "isSqlJson");
var Builder = class {
  constructor(driver, tables) {
    this.driver = driver;
    this.state.tables = tables;
    this.queryOperators = {
      // logical
      $or: /* @__PURE__ */ __name$1((key2, value) => this.logicalOr(value.map((value2) => this.parseFieldQuery(key2, value2))), "$or"),
      $and: /* @__PURE__ */ __name$1((key2, value) => this.logicalAnd(value.map((value2) => this.parseFieldQuery(key2, value2))), "$and"),
      $not: /* @__PURE__ */ __name$1((key2, value) => this.logicalNot(this.parseFieldQuery(key2, value)), "$not"),
      // existence
      $exists: /* @__PURE__ */ __name$1((key2, value) => this.createNullQuery(key2, value), "$exists"),
      // comparison
      $eq: this.createEqualQuery,
      $ne: this.comparator("!="),
      $gt: this.comparator(">"),
      $gte: this.comparator(">="),
      $lt: this.comparator("<"),
      $lte: this.comparator("<="),
      // membership
      $in: /* @__PURE__ */ __name$1((key2, value) => this.createMemberQuery(key2, value, ""), "$in"),
      $nin: /* @__PURE__ */ __name$1((key2, value) => this.createMemberQuery(key2, value, " NOT"), "$nin"),
      // regexp
      $regex: /* @__PURE__ */ __name$1((key2, value) => this.createRegExpQuery(key2, value), "$regex"),
      $regexFor: /* @__PURE__ */ __name$1((key2, value) => typeof value === "string" ? `${this.escape(value)} collate utf8mb4_bin regexp ${key2}` : `${this.escape(value.input)} ${value.flags?.includes("i") ? "regexp" : "collate utf8mb4_bin regexp"} ${key2}`, "$regexFor"),
      // bitwise
      $bitsAllSet: /* @__PURE__ */ __name$1((key2, value) => `${key2} & ${this.escape(value)} = ${this.escape(value)}`, "$bitsAllSet"),
      $bitsAllClear: /* @__PURE__ */ __name$1((key2, value) => `${key2} & ${this.escape(value)} = 0`, "$bitsAllClear"),
      $bitsAnySet: /* @__PURE__ */ __name$1((key2, value) => `${key2} & ${this.escape(value)} != 0`, "$bitsAnySet"),
      $bitsAnyClear: /* @__PURE__ */ __name$1((key2, value) => `${key2} & ${this.escape(value)} != ${this.escape(value)}`, "$bitsAnyClear"),
      // list
      $el: /* @__PURE__ */ __name$1((key2, value) => {
        if (Array.isArray(value)) {
          return this.logicalOr(value.map((value2) => this.createElementQuery(key2, value2)));
        } else if (typeof value !== "number" && typeof value !== "string") {
          throw new TypeError("query expr under $el is not supported");
        } else {
          return this.createElementQuery(key2, value);
        }
      }, "$el"),
      $size: /* @__PURE__ */ __name$1((key2, value) => {
        if (this.isJsonQuery(key2)) {
          return `${this.jsonLength(key2)} = ${this.escape(value)}`;
        } else {
          if (!value) return this.logicalNot(key2);
          return `${key2} AND LENGTH(${key2}) - LENGTH(REPLACE(${key2}, ${this.escape(",")}, ${this.escape("")})) = ${this.escape(value)} - 1`;
        }
      }, "$size")
    };
    this.evalOperators = {
      // universal
      $: /* @__PURE__ */ __name$1((key2) => this.getRecursive(key2), "$"),
      $select: /* @__PURE__ */ __name$1((args) => `${args.map((arg) => this.parseEval(arg)).join(", ")}`, "$select"),
      $if: /* @__PURE__ */ __name$1((args) => `if(${args.map((arg) => this.parseEval(arg)).join(", ")})`, "$if"),
      $ifNull: /* @__PURE__ */ __name$1((args) => `ifnull(${args.map((arg) => this.parseEval(arg)).join(", ")})`, "$ifNull"),
      // number
      $add: /* @__PURE__ */ __name$1((args) => `(${args.map((arg) => this.parseEval(arg)).join(" + ")})`, "$add"),
      $multiply: /* @__PURE__ */ __name$1((args) => `(${args.map((arg) => this.parseEval(arg)).join(" * ")})`, "$multiply"),
      $subtract: this.binary("-"),
      $divide: this.binary("/"),
      $modulo: this.binary("%"),
      // mathemetic
      $abs: /* @__PURE__ */ __name$1((arg) => `abs(${this.parseEval(arg)})`, "$abs"),
      $floor: /* @__PURE__ */ __name$1((arg) => `floor(${this.parseEval(arg)})`, "$floor"),
      $ceil: /* @__PURE__ */ __name$1((arg) => `ceil(${this.parseEval(arg)})`, "$ceil"),
      $round: /* @__PURE__ */ __name$1((arg) => `round(${this.parseEval(arg)})`, "$round"),
      $exp: /* @__PURE__ */ __name$1((arg) => `exp(${this.parseEval(arg)})`, "$exp"),
      $log: /* @__PURE__ */ __name$1((args) => `log(${args.filter((x) => !isNullable(x)).map((arg) => this.parseEval(arg)).reverse().join(", ")})`, "$log"),
      $power: /* @__PURE__ */ __name$1((args) => `power(${args.map((arg) => this.parseEval(arg)).join(", ")})`, "$power"),
      $random: /* @__PURE__ */ __name$1(() => `rand()`, "$random"),
      // string
      $concat: /* @__PURE__ */ __name$1((args) => `concat(${args.map((arg) => this.parseEval(arg)).join(", ")})`, "$concat"),
      $regex: /* @__PURE__ */ __name$1(([key2, value, flags]) => `(${this.parseEval(key2)} ${flags?.includes("i") || value instanceof RegExp && value.flags.includes("i") ? "regexp" : "collate utf8mb4_bin regexp"} ${this.parseEval(value)})`, "$regex"),
      // logical / bitwise
      $or: /* @__PURE__ */ __name$1((args) => {
        const type2 = Type.fromTerm(this.state.expr, Type.Boolean);
        if (Field.boolean.includes(type2.type)) return this.logicalOr(args.map((arg) => this.parseEval(arg)));
        else return `(${args.map((arg) => this.parseEval(arg)).join(" | ")})`;
      }, "$or"),
      $and: /* @__PURE__ */ __name$1((args) => {
        const type2 = Type.fromTerm(this.state.expr, Type.Boolean);
        if (Field.boolean.includes(type2.type)) return this.logicalAnd(args.map((arg) => this.parseEval(arg)));
        else return `(${args.map((arg) => this.parseEval(arg)).join(" & ")})`;
      }, "$and"),
      $not: /* @__PURE__ */ __name$1((arg) => {
        const type2 = Type.fromTerm(this.state.expr, Type.Boolean);
        if (Field.boolean.includes(type2.type)) return this.logicalNot(this.parseEval(arg));
        else return `(~(${this.parseEval(arg)}))`;
      }, "$not"),
      // boolean
      $eq: this.binary("="),
      $ne: this.binary("!="),
      $gt: this.binary(">"),
      $gte: this.binary(">="),
      $lt: this.binary("<"),
      $lte: this.binary("<="),
      // membership
      $in: /* @__PURE__ */ __name$1(([key2, value]) => this.asEncoded(this.createMemberQuery(this.parseEval(key2, false), value, ""), false), "$in"),
      $nin: /* @__PURE__ */ __name$1(([key2, value]) => this.asEncoded(this.createMemberQuery(this.parseEval(key2, false), value, " NOT"), false), "$nin"),
      // typecast
      $literal: /* @__PURE__ */ __name$1(([value, type2]) => this.escape(value, type2), "$literal"),
      // aggregation
      $sum: /* @__PURE__ */ __name$1((expr) => this.createAggr(expr, (value) => `ifnull(sum(${value}), 0)`), "$sum"),
      $avg: /* @__PURE__ */ __name$1((expr) => this.createAggr(expr, (value) => `avg(${value})`), "$avg"),
      $min: /* @__PURE__ */ __name$1((expr) => this.createAggr(expr, (value) => `min(${value})`), "$min"),
      $max: /* @__PURE__ */ __name$1((expr) => this.createAggr(expr, (value) => `max(${value})`), "$max"),
      $count: /* @__PURE__ */ __name$1((expr) => this.createAggr(expr, (value) => `count(distinct ${value})`), "$count"),
      $length: /* @__PURE__ */ __name$1((expr) => this.createAggr(expr, (value) => `count(${value})`, (value) => this.isEncoded() ? this.jsonLength(value) : this.asEncoded(`if(${value}, LENGTH(${value}) - LENGTH(REPLACE(${value}, ${this.escape(",")}, ${this.escape("")})) + 1, 0)`, false)), "$length"),
      $object: /* @__PURE__ */ __name$1((fields) => this.groupObject(fields), "$object"),
      $array: /* @__PURE__ */ __name$1((expr) => this.groupArray(this.transform(this.parseEval(expr, false), expr, "encode")), "$array"),
      $get: /* @__PURE__ */ __name$1(([x, key2]) => typeof key2 === "string" ? this.asEncoded(`json_extract(${this.parseEval(x, false)}, '$.${key2}')`, true) : this.asEncoded(`json_extract(${this.parseEval(x, false)}, concat('$[', ${this.parseEval(key2)}, ']'))`, true), "$get"),
      $exec: /* @__PURE__ */ __name$1((sel) => this.parseSelection(sel), "$exec")
    };
  }
  static {
    __name$1(this, "Builder");
  }
  escapeMap = {};
  escapeRegExp;
  createEqualQuery = this.comparator("=");
  queryOperators;
  evalOperators;
  state = {};
  $true = "1";
  $false = "0";
  modifiedTable;
  transformers = /* @__PURE__ */ Object.create(null);
  createNullQuery(key2, value) {
    return `${key2} is ${value ? "not " : ""}null`;
  }
  createMemberQuery(key2, value, notStr = "") {
    if (Array.isArray(value)) {
      if (!value.length) return notStr ? this.$true : this.$false;
      if (Array.isArray(value[0])) {
        return `(${key2})${notStr} in (${value.map((val) => `(${val.map((x) => this.escape(x)).join(", ")})`).join(", ")})`;
      }
      return `${key2}${notStr} in (${value.map((val) => this.escape(val)).join(", ")})`;
    } else if (value.$exec) {
      return `(${key2})${notStr} in ${this.parseSelection(value.$exec, true)}`;
    } else if (Type.fromTerm(value)?.type === "list") {
      const res = this.listContains(this.parseEval(value), key2);
      return notStr ? this.logicalNot(res) : res;
    } else {
      const res = this.jsonContains(this.parseEval(value, false), this.encode(key2, true, true));
      return notStr ? this.logicalNot(res) : res;
    }
  }
  createRegExpQuery(key2, value) {
    if (typeof value !== "string" && value.flags?.includes("i")) {
      return `${key2} regexp ${this.escape(value.source)}`;
    } else {
      return `${key2} collate utf8mb4_bin regexp ${this.escape(typeof value === "string" ? value : value.source)}`;
    }
  }
  listContains(list, value) {
    return `find_in_set(${value}, ${list})`;
  }
  createElementQuery(key2, value) {
    if (this.isJsonQuery(key2)) {
      return this.jsonContains(key2, this.encode(this.escape(value), true, true));
    } else {
      return `find_in_set(${this.escape(value)}, ${key2})`;
    }
  }
  isJsonQuery(key2) {
    return Type.fromTerm(this.state.expr)?.type === "json" || this.isEncoded(key2);
  }
  comparator(operator) {
    return (key2, value) => {
      return `${key2} ${operator} ${this.escape(value)}`;
    };
  }
  binary(operator) {
    return ([left, right]) => {
      return `(${this.parseEval(left)} ${operator} ${this.parseEval(right)})`;
    };
  }
  logicalAnd(conditions) {
    if (!conditions.length) return this.$true;
    if (conditions.includes(this.$false)) return this.$false;
    return conditions.join(" AND ");
  }
  logicalOr(conditions) {
    if (!conditions.length) return this.$false;
    if (conditions.includes(this.$true)) return this.$true;
    return `(${conditions.join(" OR ")})`;
  }
  logicalNot(condition) {
    return `NOT(${condition})`;
  }
  parseSelection(sel, inline = false) {
    const { args: [expr], ref: ref2, table, tables } = sel;
    const restore = this.saveState({ tables });
    const inner = this.get(table, true, true);
    const output2 = this.parseEval(expr, false);
    const fields = expr["$select"]?.map((x) => this.getRecursive(x["$"]));
    const where = fields && this.logicalAnd(fields.map((x) => `(${x} is not null)`));
    restore();
    if (inline || !isAggrExpr(expr)) {
      return `(SELECT ${output2} FROM ${inner} ${isBracketed(inner) ? ref2 : ""}${where ? ` WHERE ${where}` : ""})`;
    } else {
      return [
        `(ifnull((SELECT ${this.groupArray(this.transform(output2, Type.getInner(Type.fromTerm(expr)), "encode"))}`,
        `FROM ${inner} ${isBracketed(inner) ? ref2 : ""}), json_array()))`
      ].join(" ");
    }
  }
  jsonLength(value) {
    return this.asEncoded(`json_length(${value})`, false);
  }
  jsonContains(obj, value) {
    return this.asEncoded(`json_contains(${obj}, ${value})`, false);
  }
  asEncoded(value, encoded) {
    if (encoded !== void 0) this.state.encoded = encoded;
    return value;
  }
  encode(value, encoded, pure = false, type2) {
    return this.asEncoded(encoded === this.isEncoded() && !pure ? value : encoded ? `cast(${this.transform(value, type2, "encode")} as json)` : this.transform(`json_unquote(${value})`, type2, "decode"), pure ? void 0 : encoded);
  }
  isEncoded(key2) {
    return key2 ? this.state.encodedMap?.[key2] : this.state.encoded;
  }
  createAggr(expr, aggr, nonaggr) {
    if (this.state.group) {
      this.state.group = false;
      const value = aggr(this.parseEval(expr, false));
      this.state.group = true;
      return value;
    } else {
      const value = this.parseEval(expr, false);
      const res = nonaggr ? nonaggr(value) : `(select ${aggr(`json_unquote(${this.escapeId("value")})`)} from json_table(${value}, '$[*]' columns (value json path '$')) ${randomId()})`;
      return res;
    }
  }
  /**
   * Convert value from SQL field to JSON field
   */
  transform(value, type2, method, miss) {
    type2 = Type.isType(type2) ? type2 : Type.fromTerm(type2);
    const transformer = this.transformers[type2.type] ?? this.transformers[this.driver.database.types[type2.type]?.type];
    return transformer?.[method] ? transformer[method](value) : miss ?? value;
  }
  groupObject(_fields) {
    const _groupObject = /* @__PURE__ */ __name$1((fields, type2, prefix = "") => {
      const parse3 = /* @__PURE__ */ __name$1((expr, key2) => {
        const value = !_fields[`${prefix}${key2}`] && type2 && Type.getInner(type2, key2)?.inner ? _groupObject(expr, Type.getInner(type2, key2), `${prefix}${key2}.`) : this.parseEval(expr, false);
        return this.isEncoded() ? `json_extract(${value}, '$')` : this.transform(value, expr, "encode");
      }, "parse");
      return `json_object(` + Object.entries(fields).map(([key2, expr]) => `'${key2}', ${parse3(expr, key2)}`).join(",") + `)`;
    }, "_groupObject");
    return this.asEncoded(_groupObject(unravel(_fields), Type.fromTerm(this.state.expr), ""), true);
  }
  groupArray(value) {
    return this.asEncoded(`ifnull(json_arrayagg(${value}), json_array())`, true);
  }
  parseFieldQuery(key2, query) {
    const conditions = [];
    if (Array.isArray(query)) {
      conditions.push(this.createMemberQuery(key2, query));
    } else if (query instanceof RegExp) {
      conditions.push(this.createRegExpQuery(key2, query));
    } else if (isComparable(query)) {
      conditions.push(this.createEqualQuery(key2, query));
    } else if (isNullable(query)) {
      conditions.push(this.createNullQuery(key2, false));
    } else {
      for (const prop in query) {
        if (prop in this.queryOperators) {
          conditions.push(this.queryOperators[prop](key2, query[prop]));
        }
      }
    }
    return this.logicalAnd(conditions);
  }
  parseQuery(query) {
    const conditions = [];
    for (const key2 in query) {
      if (key2 === "$not") {
        conditions.push(this.logicalNot(this.parseQuery(query.$not)));
      } else if (key2 === "$and") {
        conditions.push(this.logicalAnd(query.$and.map(this.parseQuery.bind(this))));
      } else if (key2 === "$or") {
        conditions.push(this.logicalOr(query.$or.map(this.parseQuery.bind(this))));
      } else if (key2 === "$expr") {
        conditions.push(this.parseEval(query.$expr));
      } else {
        const flattenQuery = isFlat(query[key2]) ? { [key2]: query[key2] } : flatten(query[key2], `${key2}.`);
        for (const key22 in flattenQuery) {
          const model = this.state.tables[this.state.table] ?? Object.values(this.state.tables)[0];
          const expr = Eval3("", [this.state.table ?? Object.keys(this.state.tables)[0], key22], model.getType(key22));
          conditions.push(this.parseFieldQuery(this.parseEval(expr), flattenQuery[key22]));
        }
      }
    }
    return this.logicalAnd(conditions);
  }
  parseEvalExpr(expr) {
    this.state.encoded = false;
    for (const key2 in expr) {
      if (key2 in this.evalOperators) {
        this.state.expr = expr;
        return this.evalOperators[key2](expr[key2]);
      }
    }
    return this.escape(expr);
  }
  transformJsonField(obj, path2) {
    return this.asEncoded(`json_extract(${obj}, '$${path2}')`, true);
  }
  transformKey(key2, fields, prefix) {
    if (key2 in fields || !key2.includes(".")) {
      return this.asEncoded(prefix + this.escapeId(key2), this.isEncoded(key2) ?? isSqlJson(fields[key2]?.type));
    }
    const field = Object.keys(fields).find((k) => key2.startsWith(k + ".")) || key2.split(".")[0];
    const rest = key2.slice(field.length + 1).split(".");
    return this.transformJsonField(`${prefix}${this.escapeId(field)}`, rest.map((key22) => `.${this.escapeKey(key22)}`).join(""));
  }
  getRecursive(args) {
    if (typeof args === "string") {
      return this.getRecursive(["_", args]);
    }
    const [table, key2] = args;
    const fields = this.state.tables?.[table]?.fields || {};
    const fkey = Object.keys(fields).find((field) => key2 === field || key2.startsWith(field + "."));
    if (fkey && fields[fkey]?.expr) {
      if (key2 === fkey) {
        return this.parseEvalExpr(fields[fkey]?.expr);
      } else {
        const field = this.parseEvalExpr(fields[fkey]?.expr);
        const rest = key2.slice(fkey.length + 1).split(".");
        return this.transformJsonField(`${field}`, rest.map((key22) => `.${this.escapeKey(key22)}`).join(""));
      }
    }
    const prefix = this.modifiedTable ? `${this.escapeId(this.state.tables?.[table]?.name ?? this.modifiedTable)}.` : !this.state.tables || table === "_" || key2 in fields || table in this.state.tables ? "" : `${this.escapeId(table)}.`;
    if (!(table in (this.state.tables || {})) && table in (this.state.innerTables || {})) {
      const fields2 = this.state.innerTables?.[table]?.fields || {};
      const res = fields2[key2]?.expr ? this.parseEvalExpr(fields2[key2]?.expr) : this.transformKey(key2, fields2, `${this.escapeId(table)}.`);
      return res;
    }
    if (!(table in (this.state.tables || {})) && table in (this.state.refTables || {})) {
      const fields2 = this.state.refTables?.[table]?.fields || {};
      const res = fields2[key2]?.expr ? this.parseEvalExpr(fields2[key2]?.expr) : this.transformKey(key2, fields2, `${this.escapeId(table)}.`);
      if (this.state.wrappedSubquery) {
        if (res in (this.state.refFields ?? {})) return this.state.refFields[res];
        const key22 = `minato_tvar_${randomId()}`;
        (this.state.refFields ??= {})[res] = key22;
        return this.asEncoded(this.escapeId(key22), true);
      } else return res;
    }
    return this.transformKey(key2, fields, prefix);
  }
  parseEval(expr, unquote = true) {
    this.state.encoded = false;
    if (typeof expr === "string" || typeof expr === "number" || typeof expr === "boolean" || expr instanceof Date || expr instanceof RegExp) {
      return this.escape(expr);
    }
    return unquote ? this.encode(this.parseEvalExpr(expr), false, false, Type.fromTerm(expr)) : this.parseEvalExpr(expr);
  }
  saveState(extra = {}) {
    const thisState = this.state;
    this.state = { refTables: { ...this.state.refTables || {}, ...this.state.tables || {} }, ...extra };
    return () => {
      thisState.encoded = this.state.encoded;
      this.state = thisState;
    };
  }
  suffix(modifier) {
    const { limit, offset, sort, group, having } = modifier;
    let sql = "";
    if (group?.length) {
      sql += ` GROUP BY ${group.map(this.escapeId).join(", ")}`;
      const filter = this.parseEval(having);
      if (filter !== this.$true) sql += ` HAVING ${filter}`;
    }
    if (sort.length) {
      sql += " ORDER BY " + sort.map(([expr, dir]) => {
        return `${this.parseEval(expr)} ${dir.toUpperCase()}`;
      }).join(", ");
    }
    if (limit < Infinity) sql += " LIMIT " + limit;
    if (offset > 0) sql += " OFFSET " + offset;
    return sql;
  }
  get(sel, inline = false, group = false, addref = true) {
    const { args, table, query, ref: ref2, model } = sel;
    this.state.table = ref2;
    let prefix;
    if (typeof table === "string") {
      prefix = this.escapeId(table);
    } else if (Selection.is(table)) {
      prefix = this.get(table, true);
      if (!prefix) return;
    } else {
      this.state.innerTables = Object.fromEntries(Object.values(table).map((t) => [t.ref, t.model]));
      const joins = Object.entries(table).map(([key2, table2]) => {
        const restore = this.saveState({ tables: { ...table2.tables } });
        const t = `${this.get(table2, true, false, false)} AS ${this.escapeId(table2.ref)}`;
        restore();
        return [key2, t];
      });
      prefix = [
        // the leading space is to prevent from being parsed as bracketed and added ref
        " ",
        joins[0][1],
        ...joins.slice(1, -1).map(([key2, join]) => `${args[0].optional?.[key2] ? "LEFT" : ""} JOIN ${join} ON ${this.$true}`),
        `${args[0].optional?.[joins.at(-1)[0]] ? "LEFT " : ""}JOIN`,
        joins.at(-1)[1]
      ].join(" ");
      const filter2 = this.parseEval(args[0].having);
      prefix += ` ON ${filter2}`;
    }
    const filter = this.parseQuery(query);
    if (filter === this.$false) return;
    this.state.group = group || !!args[0].group;
    const encodedMap = {};
    const fields = args[0].fields ?? Object.fromEntries(Object.entries(model.fields).filter(([, field]) => Field.available(field)).map(([key2, field]) => [key2, field.expr ? field.expr : Eval3("", [ref2, key2], Type.fromField(field))]));
    const keys = Object.entries(fields).map(([key2, value]) => {
      value = this.parseEval(value, false);
      encodedMap[key2] = this.state.encoded;
      return this.escapeId(key2) === value ? this.escapeId(key2) : `${value} AS ${this.escapeId(key2)}`;
    }).join(", ");
    let suffix = this.suffix(args[0]);
    this.state.encodedMap = encodedMap;
    if (filter !== this.$true) {
      suffix = ` WHERE ${filter}` + suffix;
    }
    if (inline && !args[0].fields && !suffix && (typeof table === "string" || Selection.is(table))) {
      return addref && isBracketed(prefix) ? `${prefix} ${ref2}` : prefix;
    }
    if (!prefix.includes(" ") || isBracketed(prefix)) {
      suffix = ` ${ref2}` + suffix;
    }
    const result = `SELECT ${keys} FROM ${prefix}${suffix}`;
    return inline ? `(${result})` : result;
  }
  /**
   * Convert value from Type to Field.Type.
   * @param root indicate whether the context is inside json
   */
  dump(value, type2, root2 = true) {
    if (!type2) return value;
    if (Type.isType(type2) || isEvalExpr(type2)) {
      type2 = Type.isType(type2) ? type2 : Type.fromTerm(type2);
      const converter = type2.inner || type2.type === "json" ? root2 ? this.driver.types["json"] : void 0 : this.driver.types[type2.type];
      if (type2.inner || type2.type === "json") root2 = false;
      let res = value;
      res = Type.transform(res, type2, (value2, type22) => this.dump(value2, type22, root2));
      res = converter?.dump ? converter.dump(res) : res;
      const ancestor = this.driver.database.types[type2.type]?.type;
      if (!root2 && !ancestor) res = this.transform(res, type2, "dump");
      res = this.dump(res, ancestor ? Type.fromField(ancestor) : void 0, root2);
      return res;
    }
    value = type2.format(value);
    const result = {};
    for (const key2 in value) {
      const { type: ftype } = type2.fields[key2];
      result[key2] = this.dump(value[key2], ftype);
    }
    return result;
  }
  /**
   * Convert value from Field.Type to Type.
   */
  load(value, type2, root2 = true) {
    if (!type2) return value;
    if (Type.isType(type2) || isEvalExpr(type2)) {
      type2 = Type.isType(type2) ? type2 : Type.fromTerm(type2);
      const converter = this.driver.types[root2 && value && type2.type === "json" ? "json" : type2.type];
      const ancestor = this.driver.database.types[type2.type]?.type;
      let res = this.load(value, ancestor ? Type.fromField(ancestor) : void 0, root2);
      res = this.transform(res, type2, "load");
      res = converter?.load ? converter.load(res) : res;
      res = Type.transform(res, type2, (value2, type22) => this.load(value2, type22, false));
      return !isNullable(res) && type2.inner && !Type.isArray(type2) ? unravel(res) : res;
    }
    const result = {};
    for (const key2 in value) {
      if (!(key2 in type2.fields)) continue;
      result[key2] = value[key2];
      let subroot = root2;
      if (subroot && result[key2] && this.isEncoded(key2)) {
        subroot = false;
        result[key2] = this.driver.types["json"].load(result[key2]);
      }
      result[key2] = this.load(result[key2], type2.fields[key2].type, subroot);
    }
    return type2.parse(result);
  }
  /**
   * Convert value from Type to SQL.
   */
  escape(value, type2) {
    type2 &&= Type.fromField(type2);
    return this.escapePrimitive(type2 ? this.dump(value, type2) : value, type2);
  }
  /**
   * Convert value from Field.Type to SQL.
   */
  escapePrimitive(value, type2) {
    if (isNullable(value)) return "NULL";
    switch (typeof value) {
      case "boolean":
      case "number":
      case "bigint":
        return value + "";
      case "object":
        return this.quote(JSON.stringify(value));
      default:
        return this.quote(value);
    }
  }
  escapeId(value) {
    return escapeId(value);
  }
  escapeKey(value) {
    return `"${value}"`;
  }
  quote(value) {
    this.escapeRegExp ??= new RegExp(`[${Object.values(this.escapeMap).join("")}]`, "g");
    let chunkIndex = this.escapeRegExp.lastIndex = 0;
    let escapedVal = "";
    let match;
    while (match = this.escapeRegExp.exec(value)) {
      escapedVal += value.slice(chunkIndex, match.index) + this.escapeMap[match[0]];
      chunkIndex = this.escapeRegExp.lastIndex;
    }
    if (chunkIndex === 0) {
      return "'" + value + "'";
    }
    if (chunkIndex < value.length) {
      return "'" + escapedVal + value.slice(chunkIndex) + "'";
    }
    return "'" + escapedVal + "'";
  }
};
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var en_US_default = { path: "Database path." };
var zh_CN_default = { path: "" };
var SQLiteBuilder = class extends Builder {
  constructor(driver, tables) {
    super(driver, tables);
    this.driver = driver;
    this.queryOperators.$regexFor = (key2, value) => typeof value === "string" ? `${this.escape(value)} regexp ${key2}` : value.flags?.includes("i") ? `regexp2(${key2}, ${this.escape(value.input)}, 'i')` : `${this.escape(value.input)} regexp ${key2}`;
    this.evalOperators.$if = (args) => `iif(${args.map((arg) => this.parseEval(arg)).join(", ")})`;
    this.evalOperators.$regex = ([key2, value, flags]) => flags?.includes("i") || value instanceof RegExp && value.flags?.includes("i") ? `regexp2(${this.parseEval(value)}, ${this.parseEval(key2)}, ${this.escape(flags ?? value.flags)})` : `regexp(${this.parseEval(value)}, ${this.parseEval(key2)})`;
    this.evalOperators.$concat = (args) => `(${args.map((arg) => this.parseEval(arg)).join("||")})`;
    this.evalOperators.$modulo = ([left, right]) => `modulo(${this.parseEval(left)}, ${this.parseEval(right)})`;
    this.evalOperators.$log = ([left, right]) => isNullable(right) ? `log(${this.parseEval(left)})` : `log(${this.parseEval(left)}) / log(${this.parseEval(right)})`;
    this.evalOperators.$length = (expr) => this.createAggr(expr, (value) => `count(${value})`, (value) => this.isEncoded() ? this.jsonLength(value) : this.asEncoded(`iif(${value}, LENGTH(${value}) - LENGTH(REPLACE(${value}, ${this.escape(",")}, ${this.escape("")})) + 1, 0)`, false));
    this.evalOperators.$number = (arg) => {
      const type2 = Type.fromTerm(arg);
      const value = this.parseEval(arg);
      const res = Field.date.includes(type2.type) ? `cast(${value} / 1000 as integer)` : `cast(${this.parseEval(arg)} as double)`;
      return this.asEncoded(`ifnull(${res}, 0)`, false);
    };
    this.evalOperators.$in = ([key2, value]) => this.asEncoded(this.createMemberEval(key2, value, ""), false);
    this.evalOperators.$nin = ([key2, value]) => this.asEncoded(this.createMemberEval(key2, value, " NOT"), false);
    const binaryXor = /* @__PURE__ */ __name((left, right) => `((${left} & ~${right}) | (~${left} & ${right}))`, "binaryXor");
    this.evalOperators.$xor = (args) => {
      const type2 = Type.fromTerm(this.state.expr, Type.Boolean);
      if (Field.boolean.includes(type2.type)) return args.map((arg) => this.parseEval(arg)).reduce((prev, curr) => `(${prev} != ${curr})`);
      else return args.map((arg) => this.parseEval(arg)).reduce((prev, curr) => binaryXor(prev, curr));
    };
    this.evalOperators.$get = ([x, key2]) => typeof key2 === "string" ? this.asEncoded(`(${this.parseEval(x, false)} -> '$.${key2}')`, true) : this.asEncoded(`(${this.parseEval(x, false)} -> ('$[' || ${this.parseEval(key2)} || ']'))`, true);
    this.transformers["bigint"] = {
      encode: /* @__PURE__ */ __name((value) => `cast(${value} as text)`, "encode"),
      decode: /* @__PURE__ */ __name((value) => `cast(${value} as integer)`, "decode"),
      load: /* @__PURE__ */ __name((value) => isNullable(value) ? value : BigInt(value), "load"),
      dump: /* @__PURE__ */ __name((value) => isNullable(value) ? value : `${value}`, "dump")
    };
    this.transformers["binary"] = {
      encode: /* @__PURE__ */ __name((value) => `hex(${value})`, "encode"),
      decode: /* @__PURE__ */ __name((value) => `unhex(${value})`, "decode"),
      load: /* @__PURE__ */ __name((value) => isNullable(value) || typeof value === "object" ? value : Binary.fromHex(value), "load"),
      dump: /* @__PURE__ */ __name((value) => isNullable(value) || typeof value === "string" ? value : Binary.toHex(value), "dump")
    };
  }
  static {
    __name(this, "SQLiteBuilder");
  }
  escapeMap = {
    "'": "''"
  };
  escapePrimitive(value, type2) {
    if (value instanceof Date) value = +value;
    else if (value instanceof RegExp) value = value.source;
    else if (Binary.is(value)) return `X'${Binary.toHex(value)}'`;
    else if (Binary.isSource(value)) return `X'${Binary.toHex(Binary.fromSource(value))}'`;
    return super.escapePrimitive(value, type2);
  }
  createMemberEval(rawKey, value, notStr = "") {
    const key2 = this.parseEval(rawKey, false);
    if (Array.isArray(value)) {
      if (!value.length) return notStr ? this.$true : this.$false;
      if (Array.isArray(value[0])) {
        return `(${key2})${notStr} in (${value.map((val) => `(${val.map((x) => this.escape(x)).join(", ")})`).join(", ")})`;
      }
      return `${key2}${notStr} in (${value.map((val) => this.escape(val)).join(", ")})`;
    } else if (value.$exec) {
      return `(${key2})${notStr} in ${this.parseSelection(value.$exec, true)}`;
    } else if (Type.fromTerm(value)?.type === "list") {
      const res = this.listContains(this.parseEval(value), key2);
      return notStr ? this.logicalNot(res) : res;
    } else {
      const res = this.jsonContains(this.parseEval(value, false), isEvalExpr(rawKey) ? this.encode(key2, true, true) : this.escape(rawKey, "json"));
      return notStr ? this.logicalNot(res) : res;
    }
  }
  createElementQuery(key2, value) {
    if (this.isJsonQuery(key2)) {
      return this.jsonContains(key2, this.escape(value, "json"));
    } else {
      return `(',' || ${key2} || ',') LIKE ${this.escape("%," + value + ",%")}`;
    }
  }
  createRegExpQuery(key2, value) {
    if (typeof value !== "string" && value.flags?.includes("i")) {
      return `regexp2(${this.escape(typeof value === "string" ? value : value.source)}, ${key2}, ${this.escape(value.flags)})`;
    } else {
      return `regexp(${this.escape(typeof value === "string" ? value : value.source)}, ${key2})`;
    }
  }
  listContains(list, value) {
    return `(',' || ${list} || ',') LIKE '%,' || ${value} || ',%'`;
  }
  jsonLength(value) {
    return this.asEncoded(`json_array_length(${value})`, false);
  }
  jsonContains(obj, value) {
    return this.asEncoded(`json_array_contains(${obj}, ${value})`, false);
  }
  encode(value, encoded, pure = false, type2) {
    return encoded ? super.encode(value, encoded, pure, type2) : encoded === this.isEncoded() && !pure ? value : this.asEncoded(this.transform(`(${value} ->> '$')`, type2, "decode"), pure ? void 0 : false);
  }
  createAggr(expr, aggr, nonaggr) {
    if (!this.state.group && !nonaggr) {
      const value = this.parseEval(expr, false);
      return `(select ${aggr(escapeId("value"))} from json_each(${value}) ${randomId()})`;
    } else {
      return super.createAggr(expr, aggr, nonaggr);
    }
  }
  groupArray(value) {
    const res = this.isEncoded() ? `('[' || group_concat(${value}) || ']')` : `('[' || group_concat(json_quote(${value})) || ']')`;
    return this.asEncoded(`ifnull(${res}, json_array())`, true);
  }
  transformJsonField(obj, path2) {
    return this.asEncoded(`(${obj} -> '$${path2}')`, true);
  }
};
function getTypeDef({ deftype: type2 }) {
  switch (type2) {
    case "primary":
    case "boolean":
    case "integer":
    case "unsigned":
    case "bigint":
    case "date":
    case "time":
    case "timestamp":
      return `INTEGER`;
    case "float":
    case "double":
    case "decimal":
      return `REAL`;
    case "char":
    case "string":
    case "text":
    case "list":
    case "json":
      return `TEXT`;
    case "binary":
      return `BLOB`;
    default:
      throw new Error(`unsupported type: ${type2}`);
  }
}
__name(getTypeDef, "getTypeDef");
var SQLiteDriver = class extends Driver {
  static name = "sqlite";
  path;
  db;
  sql = new SQLiteBuilder(this);
  beforeUnload;
  _transactionTask;
  /** synchronize table schema */
  async prepare(table, dropKeys) {
    const columns = this._all(`PRAGMA table_info(${escapeId(table)})`);
    const model = this.model(table);
    const columnDefs = [];
    const indexDefs = [];
    const alter = [];
    const mapping = {};
    let shouldMigrate = false;
    for (const key2 in model.fields) {
      if (!Field.available(model.fields[key2])) {
        if (dropKeys?.includes(key2)) shouldMigrate = true;
        continue;
      }
      const legacy = [key2, ...model.fields[key2].legacy || []];
      const column2 = columns.find(({ name }) => legacy.includes(name));
      const { initial, nullable: nullable2 = true } = model.fields[key2];
      const typedef = getTypeDef(model.fields[key2]);
      let def = `${escapeId(key2)} ${typedef}`;
      if (key2 === model.primary && model.autoInc) {
        def += " NOT NULL PRIMARY KEY AUTOINCREMENT";
      } else {
        def += (nullable2 ? " " : " NOT ") + "NULL";
        if (!isNullable(initial)) {
          def += " DEFAULT " + this.sql.escape(this.sql.dump({ [key2]: initial }, model)[key2]);
        }
      }
      columnDefs.push(def);
      if (!column2) {
        alter.push("ADD " + def);
      } else {
        mapping[column2.name] = key2;
        shouldMigrate ||= column2.name !== key2 || column2.type !== typedef;
      }
    }
    if (model.primary && !model.autoInc) {
      indexDefs.push(`PRIMARY KEY (${this._joinKeys(makeArray(model.primary))})`);
    }
    if (model.unique) {
      indexDefs.push(...model.unique.map((keys) => `UNIQUE (${this._joinKeys(makeArray(keys))})`));
    }
    if (model.foreign) {
      indexDefs.push(...Object.entries(model.foreign).map(([key2, value]) => {
        const [table2, key22] = value;
        return `FOREIGN KEY (\`${key2}\`) REFERENCES ${escapeId(table2)} (\`${key22}\`)`;
      }));
    }
    if (!columns.length) {
      this.logger.info("auto creating table %c", table);
      this._run(`CREATE TABLE ${escapeId(table)} (${[...columnDefs, ...indexDefs].join(", ")})`);
    } else if (shouldMigrate) {
      for (const { name, type: type2, notnull, pk, dflt_value: value } of columns) {
        if (mapping[name] || dropKeys?.includes(name)) continue;
        let def = `${escapeId(name)} ${type2}`;
        def += (notnull ? " NOT " : " ") + "NULL";
        if (pk) def += " PRIMARY KEY";
        if (value !== null) def += " DEFAULT " + this.sql.escape(value);
        columnDefs.push(def);
        mapping[name] = name;
      }
      const temp = table + "_temp";
      const fields = Object.keys(mapping).map(escapeId).join(", ");
      this.logger.info("auto migrating table %c", table);
      this._run(`CREATE TABLE ${escapeId(temp)} (${[...columnDefs, ...indexDefs].join(", ")})`);
      try {
        this._run(`INSERT INTO ${escapeId(temp)} SELECT ${fields} FROM ${escapeId(table)}`);
        this._run(`DROP TABLE ${escapeId(table)}`);
      } catch (error2) {
        this._run(`DROP TABLE ${escapeId(temp)}`);
        throw error2;
      }
      this._run(`ALTER TABLE ${escapeId(temp)} RENAME TO ${escapeId(table)}`);
    } else if (alter.length) {
      this.logger.info("auto updating table %c", table);
      for (const def of alter) {
        this._run(`ALTER TABLE ${escapeId(table)} ${def}`);
      }
    }
    if (dropKeys) return;
    dropKeys = [];
    await this.migrate(table, {
      error: this.logger.warn,
      before: /* @__PURE__ */ __name((keys) => keys.every((key2) => columns.some(({ name }) => name === key2)), "before"),
      after: /* @__PURE__ */ __name((keys) => dropKeys.push(...keys), "after"),
      finalize: /* @__PURE__ */ __name(() => {
        if (!dropKeys.length) return;
        this.prepare(table, dropKeys);
      }, "finalize")
    });
  }
  async start() {
    this.path = this.config.path;
    if (this.path !== ":memory:") {
      this.path = resolve(this.ctx.baseDir, this.path);
    }
    const isBrowser = process.env.KOISHI_ENV === "browser";
    const sqlite = await init({
      locateFile: /* @__PURE__ */ __name((file2) => process.env.KOISHI_BASE ? process.env.KOISHI_BASE + "/" + file2 : isBrowser ? "/modules/@koishijs/plugin-database-sqlite/" + file2 : createRequire(import.meta.url || pathToFileURL(__filename).href).resolve("@minatojs/sql.js/dist/" + file2), "locateFile")
    });
    if (this.path !== ":memory:") {
      const dir = resolve(this.path, "..");
      try {
        await access(dir);
      } catch {
        throw new Error(`The database directory '${resolve(this.path, "..")}' is not accessible. You may have to create it first.`);
      }
    }
    if (!isBrowser || this.path === ":memory:") {
      this.db = new sqlite.Database(this.path);
    } else {
      const buffer2 = await readFile(this.path).catch(() => null);
      this.db = new sqlite.Database(this.path, buffer2);
      if (isBrowser) {
        window.addEventListener("beforeunload", this.beforeUnload = () => {
          this._export();
        });
      }
    }
    this.db.create_function("regexp", (pattern2, str) => +new RegExp(pattern2).test(str));
    this.db.create_function("regexp2", (pattern2, str, flags) => +new RegExp(pattern2, flags).test(str));
    this.db.create_function("json_array_contains", (array2, value) => +JSON.parse(array2).includes(JSON.parse(value)));
    this.db.create_function("modulo", (left, right) => left % right);
    this.db.create_function("rand", () => Math.random());
    this.define({
      types: ["boolean"],
      dump: /* @__PURE__ */ __name((value) => isNullable(value) ? value : +value, "dump"),
      load: /* @__PURE__ */ __name((value) => isNullable(value) ? value : !!value, "load")
    });
    this.define({
      types: ["json"],
      dump: /* @__PURE__ */ __name((value) => JSON.stringify(value), "dump"),
      load: /* @__PURE__ */ __name((value) => typeof value === "string" ? JSON.parse(value) : value, "load")
    });
    this.define({
      types: ["list"],
      dump: /* @__PURE__ */ __name((value) => Array.isArray(value) ? value.join(",") : value, "dump"),
      load: /* @__PURE__ */ __name((value) => value ? value.split(",") : [], "load")
    });
    this.define({
      types: ["date", "time", "timestamp"],
      dump: /* @__PURE__ */ __name((value) => isNullable(value) ? value : +new Date(value), "dump"),
      load: /* @__PURE__ */ __name((value) => isNullable(value) ? value : new Date(Number(value)), "load")
    });
    this.define({
      types: ["binary"],
      dump: /* @__PURE__ */ __name((value) => isNullable(value) ? value : new Uint8Array(value), "dump"),
      load: /* @__PURE__ */ __name((value) => isNullable(value) ? value : Binary.fromSource(value), "load")
    });
    this.define({
      types: ["primary", ...Field.number],
      dump: /* @__PURE__ */ __name((value) => value, "dump"),
      load: /* @__PURE__ */ __name((value) => isNullable(value) ? value : Number(value), "load")
    });
  }
  _joinKeys(keys) {
    return keys?.length ? keys.map((key2) => `\`${key2}\``).join(", ") : "*";
  }
  async stop() {
    await new Promise((resolve2) => setTimeout(resolve2, 0));
    this.db?.close();
    if (this.beforeUnload) {
      this.beforeUnload();
      window.removeEventListener("beforeunload", this.beforeUnload);
    }
  }
  _exec(sql, params, callback) {
    try {
      const stmt = this.db.prepare(sql);
      const result = callback(stmt);
      stmt.free();
      this.logger.debug("> %s", sql, params);
      return result;
    } catch (e) {
      this.logger.warn("> %s", sql, params);
      throw e;
    }
  }
  _all(sql, params = [], config2) {
    return this._exec(sql, params, (stmt) => {
      stmt.bind(params);
      const result = [];
      while (stmt.step()) {
        result.push(stmt.getAsObject(null, config2));
      }
      return result;
    });
  }
  _get(sql, params = [], config2) {
    return this._exec(sql, params, (stmt) => stmt.getAsObject(params, config2));
  }
  _export() {
    const data = this.db.export();
    return writeFile(this.path, data);
  }
  _run(sql, params = [], callback) {
    this._exec(sql, params, (stmt) => stmt.run(params));
    const result = callback?.();
    return result;
  }
  async drop(table) {
    this._run(`DROP TABLE ${escapeId(table)}`);
  }
  async dropAll() {
    const tables = Object.keys(this.database.tables);
    for (const table of tables) {
      this._run(`DROP TABLE ${escapeId(table)}`);
    }
  }
  async stats() {
    const stats = { size: this.db.size(), tables: {} };
    const tableNames = this._all('SELECT name FROM sqlite_master WHERE type="table" ORDER BY name;');
    const dbstats = this._all('SELECT name, pgsize as size FROM "dbstat" WHERE aggregate=TRUE;');
    tableNames.forEach((tbl) => {
      stats.tables[tbl.name] = this._get(`SELECT COUNT(*) as count FROM ${escapeId(tbl.name)};`);
      stats.tables[tbl.name].size = dbstats.find((o) => o.name === tbl.name).size;
    });
    return stats;
  }
  async remove(sel) {
    const { query, table, tables } = sel;
    const builder = new SQLiteBuilder(this, tables);
    const filter = builder.parseQuery(query);
    if (filter === "0") return {};
    const result = this._run(`DELETE FROM ${escapeId(table)} WHERE ${filter}`, [], () => this._get(`SELECT changes() AS count`));
    return { matched: result.count, removed: result.count };
  }
  async get(sel) {
    const { model, tables } = sel;
    const builder = new SQLiteBuilder(this, tables);
    const sql = builder.get(sel);
    if (!sql) return [];
    const rows = this._all(sql, [], { useBigInt: true });
    return rows.map((row) => builder.load(row, model));
  }
  async eval(sel, expr) {
    const builder = new SQLiteBuilder(this, sel.tables);
    const inner = builder.get(sel.table, true, true);
    const output2 = builder.parseEval(expr, false);
    const { value } = this._get(`SELECT ${output2} AS value FROM ${inner}`, [], { useBigInt: true });
    return builder.load(value, expr);
  }
  _update(sel, indexFields, updateFields, update, data) {
    const { ref: ref2, table, tables, model } = sel;
    const builder = new SQLiteBuilder(this, tables);
    executeUpdate(data, update, ref2);
    const row = builder.dump(data, model);
    const assignment = updateFields.map((key2) => `${escapeId(key2)} = ?`).join(",");
    const query = Object.fromEntries(indexFields.map((key2) => [key2, row[key2]]));
    const filter = builder.parseQuery(query);
    this._run(`UPDATE ${escapeId(table)} SET ${assignment} WHERE ${filter}`, updateFields.map((key2) => row[key2] ?? null));
  }
  async set(sel, update) {
    const { model, table, query } = sel;
    const { primary } = model, fields = model.availableFields();
    const updateFields = [...new Set(Object.keys(update).map((key2) => {
      return Object.keys(fields).find((field) => field === key2 || key2.startsWith(field + "."));
    }))];
    const primaryFields = makeArray(primary);
    if (query.$expr || hasSubquery(sel.query) || Object.values(update).some((x) => hasSubquery(x))) {
      const sel2 = this.database.select(table, query);
      sel2.tables[sel.ref] = sel2.tables[sel2.ref];
      delete sel2.tables[sel2.ref];
      sel2.ref = sel.ref;
      const project = mapValues(update, (value, key2) => () => isEvalExpr(value) ? value : Eval3.literal(value, model.getType(key2)));
      const rawUpsert = await sel2.project({
        ...project,
        // do not touch sel2.row since it is not patched
        ...Object.fromEntries(primaryFields.map((x) => [x, () => Eval3("", [sel.ref, x], sel2.model.getType(x))]))
      }).execute();
      const upsert = rawUpsert.map((row) => ({
        ...mapValues(update, (_, key2) => getCell(row, key2)),
        ...Object.fromEntries(primaryFields.map((x) => [x, getCell(row, x)]))
      }));
      return this.database.upsert(table, upsert);
    } else {
      const data = await this.database.get(table, query);
      for (const row of data) {
        this._update(sel, primaryFields, updateFields, update, row);
      }
      return { matched: data.length };
    }
  }
  _create(table, data) {
    const model = this.model(table);
    data = this.sql.dump(data, model);
    const keys = Object.keys(data);
    const sql = `INSERT INTO ${escapeId(table)} (${this._joinKeys(keys)}) VALUES (${Array(keys.length).fill("?").join(", ")})`;
    return this._run(sql, keys.map((key2) => data[key2] ?? null), () => this._get(`SELECT last_insert_rowid() AS id`));
  }
  async create(sel, data) {
    const { model, table } = sel;
    const { id: id2 } = this._create(table, data);
    const { autoInc, primary } = model;
    if (!autoInc || Array.isArray(primary)) return data;
    return { ...data, [primary]: id2 };
  }
  async upsert(sel, data, keys) {
    if (!data.length) return {};
    const { model, table, ref: ref2 } = sel;
    const fields = model.availableFields();
    const result = { inserted: 0, matched: 0, modified: 0 };
    const dataFields = [...new Set(Object.keys(Object.assign({}, ...data)).map((key2) => {
      return Object.keys(fields).find((field) => field === key2 || key2.startsWith(field + "."));
    }))];
    let updateFields = difference(dataFields, keys);
    if (!updateFields.length) updateFields = [dataFields[0]];
    const step = Math.floor(960 / keys.length);
    for (let i = 0; i < data.length; i += step) {
      const chunk = data.slice(i, i + step);
      const results = await this.database.get(table, {
        $or: chunk.map((item) => Object.fromEntries(keys.map((key2) => [key2, item[key2]])))
      });
      for (const item of chunk) {
        const row = results.find((row2) => {
          row2 = model.format(row2);
          return keys.every((key2) => deepEqual(row2[key2], item[key2], true));
        });
        if (row) {
          this._update(sel, keys, updateFields, item, row);
          result.matched++;
        } else {
          this._create(table, executeUpdate(model.create(), item, ref2));
          result.inserted++;
        }
      }
    }
    return result;
  }
  async withTransaction(callback) {
    if (this._transactionTask) await this._transactionTask.catch(() => {
    });
    return this._transactionTask = new Promise((resolve2, reject) => {
      this._run("BEGIN TRANSACTION");
      callback().then(
        () => resolve2(this._run("COMMIT")),
        (e) => (this._run("ROLLBACK"), reject(e))
      );
    });
  }
  async getIndexes(table) {
    const indexes = this._all(`SELECT type,name,tbl_name,sql FROM sqlite_master WHERE type = 'index' AND tbl_name = ?`, [table]);
    const result = [];
    for (const { name, sql } of indexes) {
      result.push({
        name,
        unique: !sql || sql.toUpperCase().startsWith("CREATE UNIQUE"),
        keys: this._parseIndexDef(sql)
      });
    }
    return result;
  }
  async createIndex(table, index2) {
    const name = index2.name ?? Object.entries(index2.keys).map(([key2, direction]) => `${key2}_${direction ?? "asc"}`).join("+");
    const keyFields = Object.entries(index2.keys).map(([key2, direction]) => `${escapeId(key2)} ${direction ?? "asc"}`).join(", ");
    await this._run(`create ${index2.unique ? "UNIQUE" : ""} index ${escapeId(name)} ON ${escapeId(table)} (${keyFields})`);
  }
  async dropIndex(table, name) {
    await this._run(`DROP INDEX ${escapeId(name)}`);
  }
  _parseIndexDef(def) {
    if (!def) return {};
    try {
      const keys = {}, matches = def.match(/\((.*)\)/);
      matches[1].split(",").forEach((key2) => {
        const [name, direction] = key2.trim().split(" ");
        keys[name.startsWith("`") ? name.slice(1, -1) : name] = direction?.toLowerCase() === "desc" ? "desc" : "asc";
      });
      return keys;
    } catch {
      return {};
    }
  }
};
((SQLiteDriver2) => {
  SQLiteDriver2.Config = z$2.object({
    path: z$2.string().role("path").required()
  }).i18n({
    "en-US": en_US_default,
    "zh-CN": zh_CN_default
  });
})(SQLiteDriver || (SQLiteDriver = {}));
var src_default = SQLiteDriver;
class BidiMap {
  key2Value = /* @__PURE__ */ new Map();
  value2Key = /* @__PURE__ */ new Map();
  maxSize;
  constructor(maxSize) {
    this.maxSize = maxSize;
  }
  set(key2, value) {
    this.key2Value.set(key2, value);
    this.value2Key.set(value, key2);
    if (this.maxSize !== -1 && this.key2Value.size > this.maxSize) {
      const oldestKey = this.key2Value.keys().next().value;
      this.value2Key.delete(this.key2Value.get(oldestKey));
      this.key2Value.delete(oldestKey);
    }
  }
  get(key2) {
    return this.key2Value.get(key2);
  }
  getValue(key2) {
    return this.key2Value.get(key2);
  }
  getKey(value) {
    return this.value2Key.get(value);
  }
}
class Store extends Service2 {
  constructor(ctx, config2) {
    super(ctx, "store", true);
    this.ctx = ctx;
    this.config = config2;
    this.cache = new BidiMap(1e3);
    this.messages = /* @__PURE__ */ new Map();
    this.initDatabase().then().catch(console.error);
  }
  static inject = ["database", "model"];
  cache;
  messages;
  async initDatabase() {
    this.ctx.model.extend("message", {
      shortId: "integer(10)",
      chatType: "unsigned",
      msgId: "string(24)",
      uniqueMsgId: "string(64)",
      peerUid: "string(24)"
    }, {
      primary: "shortId"
    });
    this.ctx.model.extend("file_v2", {
      fileName: "string",
      fileSize: "string",
      fileUuid: "string(128)",
      msgId: "string(24)",
      msgTime: "unsigned(10)",
      peerUid: "string(24)",
      chatType: "unsigned",
      elementId: "string(24)",
      elementType: "unsigned"
    }, {
      primary: "fileUuid",
      indexes: ["fileName"]
    });
    this.ctx.model.extend("forward", {
      rootMsgId: "string(24)",
      parentMsgId: "string(24)",
      chatType: "unsigned",
      peerUid: "string(24)"
    }, {
      primary: "parentMsgId"
    });
  }
  getUniqueMsgId(msg) {
    return `${msg.chatType}-${msg.peerUid}-${msg.msgSeq}-${msg.msgRandom}-${msg.msgTime}`;
  }
  createMsgShortId(msg) {
    const peer = {
      chatType: msg.chatType,
      peerUid: msg.peerUid,
      guildId: ""
    };
    const existingShortId = this.getShortIdByMsgInfo(peer, msg.msgId);
    if (existingShortId) {
      return existingShortId;
    }
    const uniqueMsgId = this.getUniqueMsgId(msg);
    const hash2 = createHash("md5").update(uniqueMsgId).digest();
    const shortId = hash2.readInt32BE();
    const cacheKey = `${msg.msgId}|${peer.chatType}|${peer.peerUid}`;
    this.cache.set(cacheKey, shortId);
    this.ctx.database.upsert("message", [{
      msgId: msg.msgId,
      uniqueMsgId,
      shortId,
      chatType: peer.chatType,
      peerUid: peer.peerUid
    }], ["shortId"]).then().catch((e) => this.ctx.logger.error("createMsgShortId database error:", e));
    return shortId;
  }
  async getMsgInfoByShortId(shortId) {
    const data = this.cache.getKey(shortId);
    if (data) {
      const [msgId, chatTypeStr, peerUid] = data.split("|");
      return {
        msgId,
        peer: {
          chatType: +chatTypeStr,
          peerUid,
          guildId: ""
        }
      };
    }
    const items = await this.ctx.database.get("message", { shortId });
    if (items?.length) {
      const { msgId, chatType, peerUid } = items[0];
      return {
        msgId,
        peer: {
          chatType,
          peerUid,
          guildId: ""
        }
      };
    }
  }
  async getShortIdByMsgId(msgId) {
    return (await this.ctx.database.get("message", { msgId }))[0]?.shortId;
  }
  async getShortIdByUniqueMsgId(uniqueMsgId) {
    return (await this.ctx.database.get("message", { uniqueMsgId }))[0]?.shortId;
  }
  async checkMsgExist(msg) {
    const uniqueMsgId = this.getUniqueMsgId(msg);
    const existingShortId = await this.getShortIdByUniqueMsgId(uniqueMsgId);
    return !!existingShortId;
  }
  getShortIdByMsgInfo(peer, msgId) {
    const cacheKey = `${msgId}|${peer.chatType}|${peer.peerUid}`;
    return this.cache.getValue(cacheKey);
  }
  async addFileCache(data) {
    const existingFile = await this.ctx.database.get("file_v2", { fileUuid: data.fileUuid });
    if (existingFile.length) {
      return existingFile;
    }
    this.ctx.database.upsert("file_v2", [data], "fileUuid").then().catch((e) => this.ctx.logger.error("addFileCache database error:", e));
  }
  getFileCacheByName(fileName) {
    return this.ctx.database.get("file_v2", { fileName }, {
      sort: { msgTime: "desc" }
    });
  }
  getFileCacheById(fileUuid) {
    return this.ctx.database.get("file_v2", { fileUuid });
  }
  async addMsgCache(msg) {
    const expire = this.config.msgCacheExpire;
    if (expire === 0) {
      return;
    }
    const id2 = msg.msgId;
    this.messages.set(id2, msg);
    if (this.messages.size > 1e4) {
      const firstKey = this.messages.keys().next().value;
      if (firstKey) {
        this.messages.delete(firstKey);
      }
    }
    setTimeout(() => {
      this.messages.delete(id2);
    }, expire);
  }
  getMsgCache(msgId) {
    return this.messages.get(msgId);
  }
  addMultiMsgInfo(rootMsgId, parentMsgId, peer) {
    this.ctx.database.upsert("forward", [{
      rootMsgId,
      parentMsgId,
      chatType: peer.chatType,
      peerUid: peer.peerUid
    }]).then().catch((e) => this.ctx.logger.error("addMultiMsgInfo database error:", e));
  }
  getMultiMsgInfo(parentMsgId) {
    return this.ctx.database.get("forward", { parentMsgId });
  }
}
var NTMethod = /* @__PURE__ */ ((NTMethod2) => {
  NTMethod2["ACTIVE_CHAT_PREVIEW"] = "nodeIKernelMsgService/getAioFirstViewLatestMsgsAndAddActiveChat";
  NTMethod2["ACTIVE_CHAT_HISTORY"] = "nodeIKernelMsgService/getMsgsIncludeSelfAndAddActiveChat";
  NTMethod2["HISTORY_MSG"] = "nodeIKernelMsgService/getMsgsIncludeSelf";
  NTMethod2["GET_MULTI_MSG"] = "nodeIKernelMsgService/getMultiMsg";
  NTMethod2["DELETE_ACTIVE_CHAT"] = "nodeIKernelMsgService/deleteActiveChatByUid";
  NTMethod2["MEDIA_FILE_PATH"] = "nodeIKernelMsgService/getRichMediaFilePathForGuild";
  NTMethod2["RECALL_MSG"] = "nodeIKernelMsgService/recallMsg";
  NTMethod2["EMOJI_LIKE"] = "nodeIKernelMsgService/setMsgEmojiLikes";
  NTMethod2["GROUP_MEMBER_SCENE"] = "nodeIKernelGroupService/createMemberListScene";
  NTMethod2["GROUP_MEMBERS"] = "nodeIKernelGroupService/getAllMemberList";
  NTMethod2["HANDLE_GROUP_REQUEST"] = "nodeIKernelGroupService/operateSysNotify";
  NTMethod2["QUIT_GROUP"] = "nodeIKernelGroupService/quitGroup";
  NTMethod2["GROUP_AT_ALL_REMAIN_COUNT"] = "nodeIKernelGroupService/getGroupRemainAtTimes";
  NTMethod2["KICK_MEMBER"] = "nodeIKernelGroupService/kickMember";
  NTMethod2["MUTE_MEMBER"] = "nodeIKernelGroupService/setMemberShutUp";
  NTMethod2["MUTE_GROUP"] = "nodeIKernelGroupService/setGroupShutUp";
  NTMethod2["SET_MEMBER_CARD"] = "nodeIKernelGroupService/modifyMemberCardName";
  NTMethod2["SET_MEMBER_ROLE"] = "nodeIKernelGroupService/modifyMemberRole";
  NTMethod2["SET_GROUP_NAME"] = "nodeIKernelGroupService/modifyGroupName";
  NTMethod2["HANDLE_FRIEND_REQUEST"] = "nodeIKernelBuddyService/approvalFriendRequest";
  NTMethod2["CACHE_SET_SILENCE"] = "nodeIKernelStorageCleanService/setSilentScan";
  NTMethod2["CACHE_ADD_SCANNED_PATH"] = "nodeIKernelStorageCleanService/addCacheScanedPaths";
  NTMethod2["CACHE_SCAN"] = "nodeIKernelStorageCleanService/scanCache";
  NTMethod2["CACHE_CLEAR"] = "nodeIKernelStorageCleanService/clearCacheDataByKeys";
  NTMethod2["CACHE_CHAT_GET"] = "nodeIKernelStorageCleanService/getChatCacheInfo";
  NTMethod2["CACHE_FILE_GET"] = "nodeIKernelStorageCleanService/getFileCacheInfo";
  NTMethod2["CACHE_CHAT_CLEAR"] = "nodeIKernelStorageCleanService/clearChatCacheInfo";
  return NTMethod2;
})(NTMethod || {});
const NT_SERVICE_TO_PMHQ = {
  "nodeIKernelBuddyService": "getBuddyService",
  "nodeIKernelProfileService": "getProfileService",
  "nodeIKernelGroupService": "getGroupService",
  "nodeIKernelProfileLikeService": "getProfileLikeService",
  "nodeIKernelMsgService": "getMsgService",
  "nodeIKernelMSFService": "getMSFService",
  "nodeIKernelUixConvertService": "getUixConvertService",
  "nodeIKernelRichMediaService": "getRichMediaService",
  "nodeIKernelTicketService": "getTicketService",
  "nodeIKernelTipOffService": "getTipOffService",
  "nodeIKernelRobotService": "getRobotService",
  "nodeIKernelNodeMiscService": "getNodeMiscService",
  "nodeIKernelRecentContactService": "getRecentContactService",
  "nodeIKernelFlashTransferService": "getFlashTransferService",
  "nodeIKernelLoginService": "loginService",
  "nodeIKernelAlbumService": "getAlbumService"
};
const NOT_SESSION_SERVICES = ["nodeIKernelLoginService"];
function invoke(method, args, options = {}) {
  const splitMethod = method.split("/");
  const serviceName = splitMethod[0];
  const methodName = splitMethod.slice(1).join("/");
  const pmhqService = NT_SERVICE_TO_PMHQ[serviceName];
  let funcName = "";
  if (pmhqService) {
    if (NOT_SESSION_SERVICES.includes(serviceName))
      funcName = `${pmhqService}.${methodName}`;
    else {
      funcName = `wrapperSession.${pmhqService}().${methodName}`;
    }
  } else {
    funcName = method;
  }
  let timeout2 = options.timeout ?? 15e3;
  return new Promise((resolve2, reject) => {
    let timeoutId = null;
    let hookId = "";
    if (timeout2) {
      timeoutId = setTimeout(() => {
        removeReceiveHook(hookId);
        const display = inspect(args, {
          depth: 10,
          compact: true,
          breakLength: Infinity,
          maxArrayLength: 220
        });
        reject(new Error(`invoke timeout, ${funcName}, ${display}`));
      }, timeout2);
    }
    if (options.resultCmd) {
      let firstResult = void 0;
      hookId = registerReceiveHook(options.resultCmd, (data) => {
        if (options.resultCb && !options.resultCb(data, firstResult)) {
          return;
        }
        resolve2(data);
        removeReceiveHook(hookId);
        timeoutId && clearTimeout(timeoutId);
      });
      pmhq.call(funcName, args, timeout2).then((r) => {
        firstResult = r;
        if (r && Object.hasOwn(r, "result") && parseInt(r.result) !== 0) {
          const displayReq = inspect(args, {
            depth: 10,
            compact: true,
            breakLength: Infinity,
            maxArrayLength: 220
          });
          const displayRes = inspect(r, {
            depth: 10,
            compact: true,
            breakLength: Infinity,
            maxArrayLength: 220
          });
          reject(new DetailedError(`invoke failed, ${funcName}, ${displayReq}, ${displayRes}`, r));
          removeReceiveHook(hookId);
          timeoutId && clearTimeout(timeoutId);
        }
      }).catch(reject);
    } else {
      pmhq.call(funcName, args, timeout2).then((r) => {
        resolve2(r);
        timeoutId && clearTimeout(timeoutId);
      }).catch(reject);
    }
  });
}
class RkeyManager {
  constructor(ctx, serverUrl) {
    this.ctx = ctx;
    this.serverUrl = serverUrl;
  }
  serverUrl = "";
  rkeyData = {
    group_rkey: "",
    private_rkey: "",
    expired_time: 0
  };
  async getRkey(refresh = false) {
    if (this.isExpired() || refresh) {
      try {
        await this.refreshRkey();
      } catch (e) {
        this.ctx.logger.error("rkey", e);
      }
    }
    return this.rkeyData;
  }
  isExpired() {
    const now = (/* @__PURE__ */ new Date()).getTime() / 1e3;
    return now > this.rkeyData.expired_time;
  }
  async refreshRkey() {
    try {
      const { privateRKey, groupRKey, expiredTime } = await this.ctx.get("app").pmhq.getRKey();
      if (privateRKey && groupRKey) {
        this.ctx.logger.info(`rkey, private:${privateRKey}, group:${groupRKey}`);
        this.rkeyData = {
          private_rkey: privateRKey,
          group_rkey: groupRKey,
          expired_time: expiredTime
        };
      }
    } catch (e) {
      this.ctx.logger.warn(`rkey ${e}rkey`);
      try {
        this.rkeyData = await this.fetchServerRkey();
      } catch (e2) {
        this.ctx.logger.error("rkey", e2);
      }
    }
  }
  async fetchServerRkey() {
    const response2 = await fetch(this.serverUrl);
    if (!response2.ok) {
      throw new Error(response2.statusText);
    }
    return response2.json();
  }
}
class NTQQFileApi extends Service2 {
  constructor(ctx) {
    super(ctx, "ntFileApi", true);
    this.ctx = ctx;
    this.rkeyManager = new RkeyManager(ctx, "https://llob.linyuchen.net/rkey");
  }
  rkeyManager;
  async getVideoUrlByPacket(fileUuid, isGroup) {
    if (isGroup) {
      return await this.ctx.get("app").pmhq.getGroupVideoUrl(fileUuid);
    } else {
      return await this.ctx.get("app").pmhq.getPrivateVideoUrl(fileUuid);
    }
  }
  async getPttUrl(fileUuid, isGroup) {
    if (isGroup) {
      return await this.ctx.get("app").pmhq.getGroupPttUrl(fileUuid);
    } else {
      return await this.ctx.get("app").pmhq.getPrivatePttUrl(fileUuid);
    }
  }
  async getVideoUrl(peer, msgId, elementId) {
    try {
      const data = await invoke("nodeIKernelRichMediaService/getVideoPlayUrlV2", [
        peer,
        msgId,
        elementId,
        0,
        // video code format, 0: H264, 1: H265 ?
        {
          downSourceType: 1,
          triggerType: 0
          // 
        }
      ]);
      if (data.result !== 0) {
        this.ctx.logger.warn("getVideoUrl", data);
      }
      return data.urlResult.domainUrl[0]?.url ?? "";
    } catch (e) {
      this.ctx.logger.warn("getVideoUrl error", e);
      return "";
    }
  }
  async getFileType(filePath) {
    return await getFileType(filePath);
  }
  /**  QQ  */
  async uploadFile(filePath, elementType = ElementType.Pic, elementSubType = 0) {
    const fileMd5 = await calculateFileMD5(filePath);
    let fileName = path__default.basename(filePath);
    if (!fileName.includes(".")) {
      const ext = (await this.getFileType(filePath))?.ext;
      fileName += ext ? "." + ext : "";
    }
    const mediaPath = await invoke(NTMethod.MEDIA_FILE_PATH, [
      {
        md5HexStr: fileMd5,
        fileName,
        elementType,
        elementSubType,
        thumbSize: 0,
        needCreate: true,
        downloadType: 1,
        file_uuid: ""
      }
    ]);
    await copyFile(filePath, mediaPath);
    const fileSize = (await stat(filePath)).size;
    return {
      md5: fileMd5,
      fileName,
      path: mediaPath,
      fileSize
    };
  }
  async downloadMedia(msgId, chatType, peerUid, elementId, thumbPath = "", sourcePath = "", timeout2 = 1e3 * 60 * 30, force = false) {
    if (sourcePath && existsSync(sourcePath)) {
      if (force) {
        unlink(sourcePath).then().catch((e) => {
        });
      } else {
        return sourcePath;
      }
    }
    const data = await invoke(
      "nodeIKernelMsgService/downloadRichMedia",
      [{
        fileModelId: "0",
        downloadSourceType: 0,
        triggerType: 1,
        msgId,
        chatType,
        peerUid,
        elementId,
        thumbSize: 0,
        downloadType: 1,
        filePath: thumbPath
      }],
      {
        resultCmd: ReceiveCmdS.MEDIA_DOWNLOAD_COMPLETE,
        resultCb: (payload) => payload.msgId === msgId,
        timeout: timeout2
      }
    );
    return data.filePath;
  }
  async getImageSize(filePath) {
    const fileType2 = await getFileType(filePath);
    const size = await getImageSize(filePath);
    return {
      type: fileType2.ext,
      ...size
    };
  }
  async getImageUrl(element) {
    const url2 = element.originImageUrl;
    const md5HexStr = element.md5HexStr;
    if (url2) {
      const parsedUrl = new URL(IMAGE_HTTP_HOST + url2);
      const imageAppid = parsedUrl.searchParams.get("appid");
      const isNTPic = imageAppid && ["1406", "1407"].includes(imageAppid);
      if (isNTPic) {
        let rkey = parsedUrl.searchParams.get("rkey");
        if (rkey) {
          return IMAGE_HTTP_HOST_NT + url2;
        }
        const rkeyData = await this.rkeyManager.getRkey();
        rkey = imageAppid === "1406" ? rkeyData.private_rkey : rkeyData.group_rkey;
        return IMAGE_HTTP_HOST_NT + url2 + rkey;
      } else if (url2.startsWith("/offpic_new/")) {
        return `${IMAGE_HTTP_HOST}/gchatpic_new/0/0-0-${md5HexStr.toUpperCase()}/0`;
      } else {
        return IMAGE_HTTP_HOST + url2;
      }
    } else {
      return `${IMAGE_HTTP_HOST}/gchatpic_new/0/0-0-${md5HexStr.toUpperCase()}/0`;
    }
  }
  async downloadFileForModelId(peer, fileModelId, timeout2 = 2 * Time.minute) {
    const data = await invoke(
      "nodeIKernelRichMediaService/downloadFileForModelId",
      [
        peer,
        [fileModelId],
        ""
        // savePath
      ],
      {
        resultCmd: ReceiveCmdS.MEDIA_DOWNLOAD_COMPLETE,
        resultCb: (payload) => payload.fileModelId === fileModelId,
        timeout: timeout2
      }
    );
    return data.filePath;
  }
  async ocrImage(path2) {
    return await invoke(
      "nodeIKernelNodeMiscService/wantWinScreenOCR",
      [
        path2
      ],
      {
        timeout: 2 * Time.minute
      }
    );
  }
  async uploadRMFileWithoutMsg(filePath, bizType, peerUid) {
    const data = await invoke(
      "nodeIKernelRichMediaService/uploadRMFileWithoutMsg",
      [
        {
          filePath,
          bizType,
          peerUid,
          useNTV2: true
        }
      ],
      {
        resultCmd: ReceiveCmdS.MEDIA_UPLOAD_COMPLETE,
        resultCb: (payload) => payload.filePath === filePath,
        timeout: 10 * Time.second
      }
    );
    return data;
  }
  async uploadFlashFile(title, filePaths) {
    return await invoke(
      "nodeIKernelFlashTransferService/createFlashTransferUploadTask",
      [
        (/* @__PURE__ */ new Date()).getTime(),
        {
          "scene": 1,
          "name": title,
          "uploaders": [
            {
              "uin": selfInfo.uin,
              "nickname": selfInfo.nick,
              "uid": selfInfo.uid,
              "sendEntrance": ""
            }
          ],
          "permission": {},
          "coverPath": "",
          "paths": filePaths,
          "excludePaths": [],
          "expireLeftTime": 0,
          "isNeedDelExif": true,
          "coverOriginalInfos": [
            {
              "path": "",
              "thumbnailPath": ""
            }
          ],
          "uploadSceneType": 1
        }
      ]
    );
  }
  async downloadFlashFile(fileSetId, sceneType = 1) {
    return await invoke(
      "nodeIKernelFlashTransferService/startFileSetDownload",
      [
        fileSetId,
        sceneType,
        { isIncludeCompressInnerFiles: false }
      ]
    );
  }
  flashFileListCache = /* @__PURE__ */ new Map();
  async getFlashFileList(fileSetId, force = true) {
    if (!force) {
      const cachedList = this.flashFileListCache.get(fileSetId);
      if (cachedList) {
        return cachedList;
      }
    }
    const res = await invoke(
      "nodeIKernelFlashTransferService/getFileList",
      [
        {
          seq: 0,
          fileSetId,
          isUseCache: false,
          sceneType: 1,
          reqInfos: [
            {
              count: 18,
              paginationInfo: new Uint8Array(),
              parentId: "",
              reqIndexPath: "",
              reqDepth: 1,
              filterCondition: {
                fileCategory: 0,
                filterType: 0
              },
              sortConditions: [
                {
                  sortField: 0,
                  sortOrder: 0
                }
              ],
              isNeedPhysicalInfoReady: false
            }
          ]
        }
      ]
    );
    if (res.rsp.result !== 0) {
      throw new Error(`: ${res.rsp.errMs}`);
    }
    if (this.flashFileListCache.size > 100) {
      const oldestKey = this.flashFileListCache.keys().next().value;
      this.flashFileListCache.delete(oldestKey);
    }
    this.flashFileListCache.set(fileSetId, res.rsp.fileLists);
    return res.rsp.fileLists;
  }
  async getFlashFileSetIdByCode(code) {
    return await invoke(
      "nodeIKernelFlashTransferService/getFileSetIdByCode",
      [code]
    );
  }
  flashFileInfoCache = /* @__PURE__ */ new Map();
  async getFlashFileInfo(fileSetId, force = true) {
    if (!force) {
      const cachedInfo = this.flashFileInfoCache.get(fileSetId);
      if (cachedInfo) {
        return cachedInfo;
      }
    }
    const res = await invoke(
      "nodeIKernelFlashTransferService/getFileSet",
      [
        { seq: 0, fileSetId, isUseCache: false, isNoReqSvr: false, sceneType: 1 }
      ]
    );
    if (res.result !== 0) {
      throw new Error(`: ${res.errMsg}`);
    }
    if (this.flashFileInfoCache.size > 100) {
      const oldestKey = this.flashFileInfoCache.keys().next().value;
      this.flashFileInfoCache.delete(oldestKey);
    }
    this.flashFileInfoCache.set(fileSetId, res.fileSet);
    return res.fileSet;
  }
}
class NTQQFileCacheApi extends Service2 {
  constructor(ctx) {
    super(ctx, "ntFileCacheApi", true);
    this.ctx = ctx;
  }
  async setCacheSilentScan(isSilent = true) {
    return await invoke(NTMethod.CACHE_SET_SILENCE, [{ isSilent }]);
  }
  getCacheSessionPathList() {
  }
  scanCache() {
    invoke(ReceiveCmdS.CACHE_SCAN_FINISH, []);
    return invoke(NTMethod.CACHE_SCAN, [], { timeout: 300 * Time.second });
  }
  getHotUpdateCachePath() {
  }
  getDesktopTmpPath() {
  }
  getFileCacheInfo(fileType2, pageSize = 1e3, lastRecord) {
    const _lastRecord = lastRecord ? lastRecord : { fileType: fileType2 };
    return invoke(NTMethod.CACHE_FILE_GET, [{
      fileType: fileType2,
      restart: true,
      pageSize,
      order: 1,
      lastRecord: _lastRecord
    }]);
  }
  async clearChatCache(chats = [], fileKeys = []) {
    return await invoke(NTMethod.CACHE_CHAT_CLEAR, [{
      chats,
      fileKeys
    }]);
  }
}
class NTQQFriendApi extends Service2 {
  constructor(ctx) {
    super(ctx, "ntFriendApi", true);
    this.ctx = ctx;
  }
  static inject = ["ntUserApi", "ntSystemApi"];
  /** reqTime  0 */
  async handleFriendRequest(friendUid, reqTime, accept) {
    return await invoke(NTMethod.HANDLE_FRIEND_REQUEST, [
      {
        friendUid,
        reqTime,
        accept
      }
    ]);
  }
  async getBuddyList() {
    const data = await invoke(
      "getBuddyList",
      [],
      {}
    );
    return data;
  }
  async getBuddyV2(forceRefresh) {
    const deviceInfo = await this.ctx.ntSystemApi.getDeviceInfo();
    const version2 = +deviceInfo.buildVer.split("-")[1];
    if (version2 >= 41679) {
      return await invoke("nodeIKernelBuddyService/getBuddyListV2", ["", forceRefresh, 0]);
    } else {
      return await invoke("nodeIKernelBuddyService/getBuddyListV2", [forceRefresh, 0]);
    }
  }
  async isBuddy(uid) {
    return await invoke("nodeIKernelBuddyService/isBuddy", [uid]);
  }
  async getBuddyRecommendContact(uin) {
    const ret = await invoke("nodeIKernelBuddyService/getBuddyRecommendContactArkJson", [uin, "-"]);
    return ret.arkMsg;
  }
  async setBuddyRemark(uid, remark = "") {
    return await invoke("nodeIKernelBuddyService/setBuddyRemark", [
      { uid, remark }
    ]);
  }
  async delBuddy(friendUid) {
    return await invoke("nodeIKernelBuddyService/delBuddy", [{
      friendUid,
      tempBlock: false,
      tempBothDel: true
    }]);
  }
  async setBuddyCategory(uid, categoryId) {
    return await invoke("nodeIKernelBuddyService/setBuddyCategory", [uid, categoryId]);
  }
  async clearBuddyReqUnreadCnt() {
    return await invoke("nodeIKernelBuddyService/clearBuddyReqUnreadCnt", []);
  }
  async getDoubtBuddyReq(reqNum) {
    const reqId = Date.now().toString();
    return await invoke(
      "nodeIKernelBuddyService/getDoubtBuddyReq",
      [reqId, reqNum, ""],
      {
        resultCmd: "nodeIKernelBuddyListener/onDoubtBuddyReqChange",
        resultCb: (payload) => payload.reqId === reqId
      }
    );
  }
  async approvalDoubtBuddyReq(uid) {
    return await invoke("nodeIKernelBuddyService/approvalDoubtBuddyReq", [uid, "", ""]);
  }
  async getBuddyReq() {
    return await invoke(
      "nodeIKernelBuddyService/getBuddyReq",
      [],
      {
        resultCmd: "nodeIKernelBuddyListener/onBuddyReqChange"
      }
    );
  }
  async getCategoryById(categoryId) {
    return await invoke("nodeIKernelBuddyService/getCategoryById", [categoryId]);
  }
}
class NTQQGroupApi extends Service2 {
  constructor(ctx) {
    super(ctx, "ntGroupApi", true);
    this.ctx = ctx;
  }
  async getGroups(forceFetch = true) {
    const result = await invoke(
      "nodeIKernelGroupService/getGroupList",
      [forceFetch],
      {
        resultCmd: "nodeIKernelGroupListener/onGroupListUpdate"
      }
    );
    return result[1];
  }
  async getGroupMembers(groupCode, forceFetch = true) {
    return await invoke(NTMethod.GROUP_MEMBERS, [groupCode, forceFetch]);
  }
  async getGroupMember(groupCode, uid, forceUpdate = false) {
    const data = await invoke(
      "nodeIKernelGroupService/getMemberInfo",
      [
        groupCode,
        [uid],
        forceUpdate
      ],
      {
        resultCmd: "nodeIKernelGroupListener/onMemberInfoChange",
        resultCb: (result) => {
          return result[0] === groupCode && result[2].has(uid);
        }
      }
    );
    return data[2].get(uid);
  }
  async getSingleScreenNotifies(doubt, number2, startSeq = "") {
    const data = await invoke(
      "nodeIKernelGroupService/getSingleScreenNotifies",
      [doubt, startSeq, number2],
      {
        resultCmd: ReceiveCmdS.GROUP_NOTIFY,
        resultCb: (result) => {
          return result[0] === doubt && (startSeq !== "" ? startSeq === result[2][0].seq : true);
        }
      }
    );
    return {
      doubt: data[0],
      nextStartSeq: data[1],
      notifies: data[2]
    };
  }
  async getGroupRequest() {
    const normal = await this.getSingleScreenNotifies(false, 50);
    const normalCount = normal.notifies.length;
    const doubt = await this.getSingleScreenNotifies(true, 50);
    normal.notifies.push(...doubt.notifies);
    return { notifies: normal.notifies, normalCount };
  }
  async operateSysNotify(doubt, operateMsg) {
    return await invoke(NTMethod.HANDLE_GROUP_REQUEST, [doubt, operateMsg]);
  }
  async handleGroupRequest(flag, operateType, reason) {
    const flagitem = flag.split("|");
    const groupCode = flagitem[0];
    const seq = flagitem[1];
    const type2 = parseInt(flagitem[2]);
    const doubt = flagitem[3] === "1";
    return await this.operateSysNotify(doubt, {
      operateType,
      targetMsg: {
        seq,
        type: type2,
        groupCode,
        postscript: reason || " "
        // 
      }
    });
  }
  async quitGroup(groupCode) {
    return await invoke(NTMethod.QUIT_GROUP, [groupCode]);
  }
  async kickMember(groupCode, kickUids, refuseForever = false, kickReason = "") {
    return await invoke(NTMethod.KICK_MEMBER, [groupCode, kickUids, refuseForever, kickReason]);
  }
  /** timeStamp, 0 */
  async banMember(groupCode, memList) {
    return await invoke(NTMethod.MUTE_MEMBER, [groupCode, memList]);
  }
  async banGroup(groupCode, shutUp) {
    return await invoke(NTMethod.MUTE_GROUP, [groupCode, shutUp]);
  }
  async setMemberCard(groupCode, memberUid, cardName) {
    return await invoke(NTMethod.SET_MEMBER_CARD, [groupCode, memberUid, cardName]);
  }
  async setMemberRole(groupCode, memberUid, role) {
    return await invoke(NTMethod.SET_MEMBER_ROLE, [groupCode, memberUid, role]);
  }
  async setGroupName(groupCode, groupName) {
    return await invoke(NTMethod.SET_GROUP_NAME, [groupCode, groupName, true]);
  }
  async getGroupRemainAtTimes(groupCode) {
    return await invoke(NTMethod.GROUP_AT_ALL_REMAIN_COUNT, [groupCode]);
  }
  async removeGroupEssence(groupCode, msgId) {
    const ntMsgApi = this.ctx.get("ntMsgApi");
    const data = await ntMsgApi.getMsgHistory({ chatType: 2, guildId: "", peerUid: groupCode }, msgId, 1, false);
    return await invoke("nodeIKernelGroupService/removeGroupEssence", [{
      groupCode,
      msgRandom: Number(data?.msgList[0].msgRandom),
      msgSeq: Number(data?.msgList[0].msgSeq)
    }]);
  }
  async addGroupEssence(groupCode, msgId) {
    const ntMsgApi = this.ctx.get("ntMsgApi");
    const data = await ntMsgApi.getMsgHistory({ chatType: 2, guildId: "", peerUid: groupCode }, msgId, 1, false);
    return await invoke("nodeIKernelGroupService/addGroupEssence", [
      {
        groupCode,
        msgRandom: Number(data?.msgList[0].msgRandom),
        msgSeq: Number(data?.msgList[0].msgSeq)
      }
    ]);
  }
  async createGroupFileFolder(groupId, folderName) {
    return await invoke("nodeIKernelRichMediaService/createGroupFolder", [groupId, folderName]);
  }
  async deleteGroupFileFolder(groupId, folderId) {
    return await invoke("nodeIKernelRichMediaService/deleteGroupFolder", [groupId, folderId]);
  }
  async deleteGroupFile(groupId, fileIdList, busIdList) {
    return await invoke("nodeIKernelRichMediaService/deleteGroupFile", [groupId, busIdList, fileIdList]);
  }
  async getGroupFileList(groupId, fileListForm) {
    const data = await invoke(
      "nodeIKernelRichMediaService/getGroupFileList",
      [
        groupId,
        fileListForm
      ],
      {
        resultCmd: "nodeIKernelMsgListener/onGroupFileInfoUpdate",
        resultCb: (payload, reqId) => {
          return payload.reqId === reqId;
        }
      }
    );
    return data;
  }
  async publishGroupBulletin(groupCode, req) {
    const ntUserApi = this.ctx.get("ntUserApi");
    const psKey = (await ntUserApi.getPSkey(["qun.qq.com"])).domainPskeyMap.get("qun.qq.com");
    return await invoke("nodeIKernelGroupService/publishGroupBulletin", [groupCode, psKey, req]);
  }
  async uploadGroupBulletinPic(groupCode, path2) {
    const ntUserApi = this.ctx.get("ntUserApi");
    const psKey = (await ntUserApi.getPSkey(["qun.qq.com"])).domainPskeyMap.get("qun.qq.com");
    return await invoke("nodeIKernelGroupService/uploadGroupBulletinPic", [groupCode, psKey, path2]);
  }
  async getGroupRecommendContact(groupCode) {
    const ret = await invoke("nodeIKernelGroupService/getGroupRecommendContactArkJson", [groupCode]);
    return ret.arkJson;
  }
  async queryCachedEssenceMsg(groupCode, msgSeq = "0", msgRandom = "0") {
    return await invoke("nodeIKernelGroupService/queryCachedEssenceMsg", [
      {
        groupCode,
        msgSeq: +msgSeq,
        msgRandom: +msgRandom
      }
    ]);
  }
  async getGroupHonorList(groupCode) {
    return await invoke("nodeIKernelGroupService/getGroupHonorList", [{
      groupCode: [+groupCode]
    }]);
  }
  async getGroupAllInfo(groupCode) {
    return await invoke(
      "nodeIKernelGroupService/getGroupAllInfo",
      [
        groupCode,
        4
      ],
      {
        resultCmd: "nodeIKernelGroupListener/onGroupAllInfoChange",
        resultCb: (payload) => {
          return payload.groupCode === groupCode;
        }
      }
    );
  }
  async getGroupBulletinList(groupCode) {
    const ntUserApi = this.ctx.get("ntUserApi");
    const psKey = (await ntUserApi.getPSkey(["qun.qq.com"])).domainPskeyMap.get("qun.qq.com");
    const result = await invoke(
      "nodeIKernelGroupService/getGroupBulletinList",
      [
        groupCode,
        psKey,
        "",
        {
          startIndex: -1,
          num: 20,
          needInstructionsForJoinGroup: 1,
          needPublisherInfo: 1
        }
      ],
      {
        resultCmd: "nodeIKernelGroupListener/onGetGroupBulletinListResult",
        resultCb: (payload) => payload[0] === groupCode
      }
    );
    return result[2];
  }
  async setGroupAvatar(groupCode, path2) {
    return await invoke("nodeIKernelGroupService/setHeader", [path2, groupCode]);
  }
  async searchMember(groupCode, keyword) {
    const sceneId = await invoke(NTMethod.GROUP_MEMBER_SCENE, [
      groupCode,
      "groupMemberList_MainWindow"
    ]);
    const data = await invoke(
      "nodeIKernelGroupService/searchMember",
      [sceneId, keyword],
      {
        resultCmd: "nodeIKernelGroupListener/onSearchMemberChange",
        resultCb: (payload) => {
          return payload[0] === sceneId && payload[1] === keyword;
        }
      }
    );
    return data[3];
  }
  async getGroupFileCount(groupId) {
    return await invoke(
      "nodeIKernelRichMediaService/batchGetGroupFileCount",
      [[groupId]]
    );
  }
  async getGroupFileSpace(groupId) {
    return await invoke(
      "nodeIKernelRichMediaService/getGroupSpace",
      [groupId]
    );
  }
  async setGroupMsgMask(groupCode, msgMask) {
    return await invoke("nodeIKernelGroupService/setGroupMsgMask", [groupCode, msgMask]);
  }
  async setGroupRemark(groupCode, groupRemark = "") {
    return await invoke("nodeIKernelGroupService/modifyGroupRemark", [groupCode, groupRemark]);
  }
  async moveGroupFile(groupId, fileIdList, curFolderId, dstFolderId) {
    return await invoke("nodeIKernelRichMediaService/moveGroupFile", [
      groupId,
      [102],
      fileIdList,
      curFolderId,
      dstFolderId
    ]);
  }
  async getGroupShutUpMemberList(groupCode) {
    const res = await invoke(
      "nodeIKernelGroupService/getGroupShutUpMemberList",
      [groupCode],
      {
        resultCmd: "nodeIKernelGroupListener/onShutUpMemberListChanged",
        resultCb: (payload) => payload[0] === groupCode
      }
    );
    return res[1];
  }
  async renameGroupFolder(groupId, folderId, newFolderName) {
    return await invoke("nodeIKernelRichMediaService/renameGroupFolder", [
      groupId,
      folderId,
      newFolderName
    ]);
  }
  async setGroupFileForever(groupId, fileId) {
    return await invoke("nodeIKernelRichMediaService/transGroupFile", [
      groupId,
      fileId
    ]);
  }
  async getGroupAlbumList(groupId) {
    return await invoke("nodeIKernelAlbumService/getAlbumList", [{
      qun_id: groupId,
      seq: 0,
      attach_info: "",
      request_time_line: {
        request_invoke_time: "0"
      }
    }]);
  }
  async createGroupAlbum(groupId, name, desc) {
    const seq = Date.now();
    return await invoke("nodeIKernelAlbumService/addAlbum", [seq, {
      owner: groupId,
      name,
      desc,
      createTime: "0"
    }]);
  }
  async deleteGroupAlbum(groupId, albumId) {
    return await invoke("nodeIKernelAlbumService/deleteAlbum", [Date.now(), groupId, albumId]);
  }
  async deleteGroupBulletin(groupCode, feedsId) {
    const ntUserApi = this.ctx.get("ntUserApi");
    const psKey = (await ntUserApi.getPSkey(["qun.qq.com"])).domainPskeyMap.get("qun.qq.com");
    return await invoke("nodeIKernelGroupService/deleteGroupBulletin", [groupCode, psKey, feedsId]);
  }
  async renameGroupFile(groupId, fileId, parentFolderId, newFileName) {
    return await invoke("nodeIKernelRichMediaService/renameGroupFile", [
      groupId,
      102,
      fileId,
      parentFolderId,
      newFileName
    ]);
  }
}
class NTLoginApi extends Service2 {
  constructor(ctx) {
    super(ctx, "ntLoginApi", true);
    this.ctx = ctx;
  }
  static inject = [];
  async getQuickLoginList() {
    return await invoke("nodeIKernelLoginService/getLoginList", []);
  }
  async quickLoginWithUin(uin) {
    return await invoke("nodeIKernelLoginService/quickLoginWithUin", [uin], {});
  }
  async getLoginQrCode() {
    return await invoke("nodeIKernelLoginService/getQRCodePicture", [], {
      resultCmd: ReceiveCmdS.LOGIN_QR_CODE
    });
  }
}
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise2 = Promise.resolve();
  if (deps && deps.length > 0) {
    let allSettled = function(promises$2) {
      return Promise.all(promises$2.map((p) => Promise.resolve(p).then((value$1) => ({
        status: "fulfilled",
        value: value$1
      }), (reason) => ({
        status: "rejected",
        reason
      }))));
    };
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
    promise2 = allSettled(deps.map((dep) => {
      dep = assetsURL(dep);
      if (dep in seen) return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
      const link = document.createElement("link");
      link.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) link.as = "script";
      link.crossOrigin = "";
      link.href = dep;
      if (cspNonce) link.setAttribute("nonce", cspNonce);
      document.head.appendChild(link);
      if (isCss) return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(/* @__PURE__ */ new Error(`Unable to preload CSS for ${dep}`)));
      });
    }));
  }
  function handlePreloadError(err$2) {
    const e$1 = new Event("vite:preloadError", { cancelable: true });
    e$1.payload = err$2;
    window.dispatchEvent(e$1);
    if (!e$1.defaultPrevented) throw err$2;
  }
  return promise2.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
class NTQQMsgApi extends Service2 {
  constructor(ctx) {
    super(ctx, "ntMsgApi", true);
    this.ctx = ctx;
  }
  static inject = ["ntUserApi"];
  async getTempChatInfo(chatType, peerUid) {
    return await invoke("nodeIKernelMsgService/getTempChatInfo", [chatType, peerUid]);
  }
  getEmojiIdType(emojiId) {
    return emojiId.length > 3 ? "2" : "1";
  }
  async setEmojiLike(peer, msgSeq, emojiId, setEmoji) {
    return await invoke(NTMethod.EMOJI_LIKE, [peer, msgSeq, emojiId, this.getEmojiIdType(emojiId), setEmoji]);
  }
  async getMultiMsg(peer, rootMsgId, parentMsgId) {
    return await invoke(NTMethod.GET_MULTI_MSG, [peer, rootMsgId, parentMsgId]);
  }
  async activateChat(peer) {
    return await invoke(NTMethod.ACTIVE_CHAT_PREVIEW, [peer, 0]);
  }
  async activateChatAndGetHistory(peer, cnt) {
    return await invoke(NTMethod.ACTIVE_CHAT_HISTORY, [peer, cnt, "0", true]);
  }
  async getAioFirstViewLatestMsgs(peer, cnt) {
    return await invoke("nodeIKernelMsgService/getAioFirstViewLatestMsgs", [peer, cnt]);
  }
  async getMsgsByMsgId(peer, msgIds) {
    return await invoke("nodeIKernelMsgService/getMsgsByMsgId", [peer, msgIds]);
  }
  async getMsgHistory(peer, msgId, cnt, queryOrder = false) {
    return await invoke(NTMethod.HISTORY_MSG, [peer, msgId, cnt, queryOrder]);
  }
  async recallMsg(peer, msgIds) {
    return await invoke(NTMethod.RECALL_MSG, [peer, msgIds]);
  }
  async sendMsg(peer, msgElements, timeout2 = 1e4) {
    const uniqueId = await this.generateMsgUniqueId(peer.chatType);
    const msgAttributeInfos = /* @__PURE__ */ new Map();
    msgAttributeInfos.set(0, {
      attrType: 0,
      attrId: uniqueId,
      vasMsgInfo: {
        msgNamePlateInfo: {},
        bubbleInfo: {},
        avatarPendantInfo: {},
        vasFont: {},
        iceBreakInfo: {}
      }
    });
    let sentMsgId;
    const data = await invoke(
      "nodeIKernelMsgService/sendMsg",
      [
        "0",
        peer,
        msgElements,
        msgAttributeInfos
      ],
      {
        resultCmd: "nodeIKernelMsgListener/onMsgInfoListUpdate",
        resultCb: (payload) => {
          for (const msgRecord of payload) {
            if (msgRecord.msgAttrs.get(0)?.attrId === uniqueId && msgRecord.sendStatus === 2) {
              sentMsgId = msgRecord.msgId;
              return true;
            }
          }
          return false;
        },
        timeout: timeout2
      }
    );
    return data.find((msgRecord) => msgRecord.msgId === sentMsgId);
  }
  async forwardMsg(srcPeer, destPeer, msgIds) {
    const uniqueId = await this.generateMsgUniqueId(destPeer.chatType);
    destPeer.guildId = uniqueId;
    const commentElements = [];
    const msgAttributeInfos = /* @__PURE__ */ new Map();
    const data = await invoke(
      "nodeIKernelMsgService/forwardMsgWithComment",
      [
        msgIds,
        srcPeer,
        [destPeer],
        commentElements,
        msgAttributeInfos
      ],
      {
        resultCmd: "nodeIKernelMsgListener/onMsgInfoListUpdate",
        resultCb: (payload) => {
          for (const msgRecord of payload) {
            if (msgRecord.guildId === uniqueId && msgRecord.sendStatus === 2) {
              return true;
            }
          }
          return false;
        },
        timeout: 3e3
      }
    );
    destPeer.guildId = "";
    return data.find((msgRecord) => msgRecord.guildId === uniqueId);
  }
  async forwardMultiMsg(srcPeer, destPeer, msgIds) {
    const data = await invoke(
      "nodeIKernelMsgService/forwardMsgWithComment",
      [
        msgIds,
        srcPeer,
        [destPeer],
        [],
        /* @__PURE__ */ new Map()
      ],
      {
        resultCmd: "nodeIKernelMsgListener/onMsgInfoListUpdate",
        resultCb: (payload) => {
          for (const msgRecord of payload) {
            if (msgRecord.msgType === 11 && msgRecord.subMsgType === 7 && msgRecord.peerUid === destPeer.peerUid && msgRecord.senderUid === selfInfo.uid) {
              const element = msgRecord.elements[0];
              const data2 = JSON.parse(element.arkElement.bytesData);
              if (data2.app !== "com.tencent.multimsg" || !data2.meta.detail.resid) {
                continue;
              }
              return true;
            }
          }
          return false;
        },
        timeout: 3e3
      }
    );
    return data.find((msgRecord) => {
      if (msgRecord.msgType === 11 && msgRecord.subMsgType === 7 && msgRecord.peerUid === destPeer.peerUid && msgRecord.senderUid === selfInfo.uid) {
        const element = msgRecord.elements[0];
        const data2 = JSON.parse(element.arkElement.bytesData);
        if (data2.app !== "com.tencent.multimsg" || !data2.meta.detail.resid) {
          return false;
        }
        return true;
      }
      return false;
    });
  }
  async multiForwardMsg(srcPeer, destPeer, msgIds) {
    const senderShowName = await this.ctx.ntUserApi.getSelfNick(false);
    const msgInfos = msgIds.map((id2) => {
      return { msgId: id2, senderShowName };
    });
    const commentElements = [];
    const msgAttributeInfos = /* @__PURE__ */ new Map();
    const data = await invoke(
      "nodeIKernelMsgService/multiForwardMsgWithComment",
      [
        msgInfos,
        srcPeer,
        destPeer,
        commentElements,
        msgAttributeInfos
      ],
      {
        resultCmd: "nodeIKernelMsgListener/onMsgInfoListUpdate",
        resultCb: (payload) => {
          for (const msgRecord of payload) {
            if (msgRecord.msgType === 11 && msgRecord.subMsgType === 7 && msgRecord.peerUid === destPeer.peerUid && msgRecord.senderUid === selfInfo.uid) {
              const element = msgRecord.elements[0];
              const data2 = JSON.parse(element.arkElement.bytesData);
              if (data2.app !== "com.tencent.multimsg" || !data2.meta.detail.resid) {
                continue;
              }
              return true;
            }
          }
          return false;
        }
      }
    );
    return data.find((msgRecord) => {
      if (msgRecord.msgType === 11 && msgRecord.subMsgType === 7 && msgRecord.peerUid === destPeer.peerUid && msgRecord.senderUid === selfInfo.uid) {
        const element = msgRecord.elements[0];
        const data2 = JSON.parse(element.arkElement.bytesData);
        if (data2.app !== "com.tencent.multimsg" || !data2.meta.detail.resid) {
          return false;
        }
        return true;
      }
      return false;
    });
  }
  async getSingleMsg(peer, msgSeq) {
    return await invoke("nodeIKernelMsgService/getSingleMsg", [peer, msgSeq]);
  }
  async queryFirstMsgBySeq(peer, msgSeq) {
    return await invoke("nodeIKernelMsgService/queryMsgsWithFilterEx", [
      "0",
      // msgId
      "0",
      // msgTime
      msgSeq,
      {
        chatInfo: peer,
        filterMsgType: [],
        filterSendersUid: [],
        filterMsgToTime: "0",
        filterMsgFromTime: "0",
        isReverseOrder: true,
        isIncludeCurrent: true,
        pageLimit: 1
      }
    ]);
  }
  async queryMsgsWithFilterExBySeq(peer, msgSeq, filterMsgTime, filterSendersUid = []) {
    return await invoke("nodeIKernelMsgService/queryMsgsWithFilterEx", [
      "0",
      "0",
      msgSeq,
      {
        chatInfo: peer,
        filterMsgType: [],
        filterSendersUid,
        filterMsgToTime: filterMsgTime,
        filterMsgFromTime: filterMsgTime,
        isIncludeCurrent: true,
        pageLimit: 1
      }
    ]);
  }
  async setMsgRead(peer) {
    return await invoke("nodeIKernelMsgService/setMsgRead", [peer]);
  }
  async getMsgEmojiLikesList(peer, msgSeq, emojiId, count) {
    return await invoke("nodeIKernelMsgService/getMsgEmojiLikesList", [
      peer,
      msgSeq,
      emojiId,
      this.getEmojiIdType(emojiId),
      "",
      false,
      count
    ]);
  }
  async fetchFavEmojiList(count) {
    return await invoke("nodeIKernelMsgService/fetchFavEmojiList", [
      "",
      // resId
      count,
      true,
      // backwardFetch
      true
      // forceRefresh
    ]);
  }
  async generateMsgUniqueId(chatType) {
    const time2 = await this.getServerTime();
    return await invoke("nodeIKernelMsgService/generateMsgUniqueId", [chatType, time2]);
  }
  async queryMsgsById(chatType, msgId) {
    const msgTime = this.getMsgTimeFromId(msgId);
    return await invoke("nodeIKernelMsgService/queryMsgsWithFilterEx", [
      msgId,
      "0",
      "0",
      {
        chatInfo: {
          chatType,
          peerUid: "",
          guildId: ""
        },
        filterMsgToTime: msgTime,
        filterMsgFromTime: msgTime,
        isIncludeCurrent: true,
        pageLimit: 1
      }
    ]);
  }
  getMsgTimeFromId(msgId) {
    return String(BigInt(msgId) >> 32n);
  }
  async getServerTime() {
    return await invoke("nodeIKernelMSFService/getServerTime", []);
  }
  async getMsgsBySeqAndCount(peer, msgSeq, cnt, queryOrder, includeDeleteMsg) {
    try {
      return await invoke(
        "nodeIKernelMsgService/getMsgsBySeqAndCount",
        [
          peer,
          msgSeq,
          cnt,
          queryOrder,
          includeDeleteMsg
        ],
        {
          timeout: Math.max(1e3 * cnt, 3e3)
        }
      );
    } catch (e) {
      this.ctx.logger.error("getMsgsBySeqAndCount error", e);
      return { msgList: [] };
    }
  }
  async getSourceOfReplyMsgByClientSeqAndTime(peer, clientSeq, msgTime, sourceMsgIdInRecords) {
    return await invoke("nodeIKernelMsgService/getSourceOfReplyMsgByClientSeqAndTime", [peer, clientSeq, msgTime, sourceMsgIdInRecords]);
  }
  async translatePtt2Text(msgId, peer, voiceMsgElement) {
    const res = await invoke(
      "nodeIKernelMsgService/translatePtt2Text",
      [msgId, peer, voiceMsgElement],
      {
        resultCmd: ReceiveCmdS.UPDATE_MSG,
        resultCb: (msgList) => {
          const voiceMsg = msgList[0];
          if (voiceMsg && voiceMsg.msgId === msgId && voiceMsg.elements.length > 0) {
            const pttElement = voiceMsg.elements[0].pttElement;
            if (pttElement && pttElement.text) {
              return true;
            }
          }
          return false;
        }
      }
    );
    return res[0]?.elements[0]?.pttElement?.text || "";
  }
  async fetchGetHitEmotionsByWord(word, count) {
    return await invoke("nodeIKernelMsgService/fetchGetHitEmotionsByWord", [{
      word,
      uid: selfInfo.uid,
      count,
      age: 0,
      gender: 1,
      uiVersion: ""
    }]);
  }
  async addFavEmoji(emojiPath) {
    const fs2 = await __vitePreload(() => import("fs"), true ? [] : void 0);
    const path2 = await __vitePreload(() => import("path"), true ? [] : void 0);
    const crypto2 = await __vitePreload(() => import("crypto"), true ? [] : void 0);
    const stat2 = fs2.statSync(emojiPath);
    const fileSize = String(stat2.size);
    const fileName = path2.basename(emojiPath).toUpperCase();
    const fileBuffer = fs2.readFileSync(emojiPath);
    const md5 = crypto2.createHash("md5").update(fileBuffer).digest("hex");
    return await invoke("nodeIKernelMsgService/addFavEmoji", [{
      isMarkFace: false,
      emojiPath,
      fileSize,
      fileName,
      md5,
      isOrigin: true,
      emojiId: "",
      packageId: 0
    }]);
  }
  async deleteFavEmoji(emojiIds) {
    return await invoke("nodeIKernelMsgService/deleteFavEmoji", [emojiIds]);
  }
}
class HttpUtil {
  static async getCookies(url2) {
    const client = url2.startsWith("https") ? https : require$$2$2;
    return new Promise((resolve2, reject) => {
      client.get(url2, (res) => {
        let cookies = {};
        const handleRedirect = (res2) => {
          if (res2.statusCode === 301 || res2.statusCode === 302) {
            if (res2.headers.location) {
              const redirectUrl = new URL(res2.headers.location, url2);
              HttpUtil.getCookies(redirectUrl.href).then((redirectCookies) => {
                cookies = { ...cookies, ...redirectCookies };
                resolve2(cookies);
              }).catch(reject);
            } else {
              resolve2(cookies);
            }
          } else {
            resolve2(cookies);
          }
        };
        res.on("data", () => {
        });
        res.on("end", () => {
          handleRedirect(res);
        });
        if (res.headers["set-cookie"]) {
          res.headers["set-cookie"].forEach((cookie2) => {
            const parts = cookie2.split(";")[0].split("=");
            const key2 = parts[0];
            const value = parts[1];
            if (key2 && value && key2.length > 0 && value.length > 0) {
              cookies[key2] = value;
            }
          });
        }
      }).on("error", (err) => {
        reject(err);
      });
    });
  }
  static async getJson(url2, method = "GET", data, headers = {}, isJsonRet = true, isArgJson = true) {
    const option = new URL(url2);
    const protocol = url2.startsWith("https://") ? https : require$$2$2;
    const options = {
      hostname: option.hostname,
      port: option.port,
      path: option.href,
      method,
      headers
    };
    return new Promise((resolve2, reject) => {
      const req = protocol.request(options, (res) => {
        let responseBody = "";
        res.on("data", (chunk) => {
          responseBody += chunk.toString();
        });
        res.on("end", () => {
          try {
            if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
              if (isJsonRet) {
                const responseJson = JSON.parse(responseBody);
                resolve2(responseJson);
              } else {
                resolve2(responseBody);
              }
            } else {
              reject(new Error(`Unexpected status code: ${res.statusCode}`));
            }
          } catch (parseError) {
            reject(parseError);
          }
        });
      });
      req.on("error", (error2) => {
        reject(error2);
      });
      if (method === "POST" || method === "PUT" || method === "PATCH") {
        if (isArgJson) {
          req.write(JSON.stringify(data));
        } else {
          req.write(data);
        }
      }
      req.end();
    });
  }
  static async getText(url2, method = "GET", data, headers = {}) {
    return this.getJson(url2, method, data, headers, false, false);
  }
  static async post(url2, data = {}, cookies = "", headers = {}) {
    const _headers = {
      "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) QQ/9.9.23-41857 Chrome/138.0.7204.35 Electron/37.1.0 Safari/537.36 OS/win32,x64,10.0.26100,Windows 11 Pro QQAppId/537320161",
      "Cookie": cookies,
      "Content-Type": "application/json",
      "origin": url2.startsWith("https") ? "https://" + new URL(url2).hostname : "http://" + new URL(url2).hostname,
      ...headers
    };
    try {
      const response2 = await fetch(url2, {
        method: "POST",
        headers: _headers,
        body: JSON.stringify(data)
      });
      if (!response2.ok) {
        throw new Error(`HTTP error! status: ${response2.status} statusText: ${response2.statusText}`);
      }
      return response2;
    } catch (error2) {
      throw error2;
    }
  }
}
class NTQQUserApi extends Service2 {
  constructor(ctx) {
    super(ctx, "ntUserApi", true);
    this.ctx = ctx;
  }
  static inject = ["ntGroupApi"];
  async setSelfAvatar(path2) {
    return await invoke(
      "nodeIKernelProfileService/setHeader",
      [path2],
      {
        timeout: 10 * Time.second
        // 10
      }
    );
  }
  async getUidByUin(uin, groupCode) {
    const funcs = [
      async () => {
        return (await invoke("nodeIKernelUixConvertService/getUid", [[uin]])).uidInfo.get(uin);
      },
      async () => {
        return (await invoke("nodeIKernelGroupService/getUidByUins", [[uin]])).uids.get(uin);
      },
      async () => {
        return (await invoke("nodeIKernelProfileService/getUidByUin", ["FriendsServiceImpl", [uin]])).get(uin);
      },
      async () => {
        return (await this.getUserDetailInfoByUin(uin)).detail.uid;
      },
      async () => {
        if (groupCode) {
          const groupMembers = await this.ctx.ntGroupApi.getGroupMembers(groupCode);
          return groupMembers.result.infos.values().find((e) => e.uin === uin)?.uid;
        }
      }
    ];
    for (const f of funcs) {
      try {
        const uid = await f();
        if (uid && !uid.includes("****")) {
          return uid;
        }
      } catch (e) {
        this.ctx.logger.error("get uid by uin filed", e);
      }
    }
    return "";
  }
  async getUserDetailInfoByUin(uin) {
    return await invoke("nodeIKernelProfileService/getUserDetailInfoByUin", [uin]);
  }
  async getUinByUid(uid) {
    const funcs = [
      async () => {
        return (await invoke("nodeIKernelUixConvertService/getUin", [[uid]])).uinInfo.get(uid);
      },
      async () => {
        return (await this.fetchUserDetailInfo(uid)).detail.get(uid)?.uin;
      }
    ];
    for (const f of funcs) {
      try {
        const result = await f();
        if (result) {
          return result;
        }
      } catch (e) {
        this.ctx.logger.error("get uin filed", e);
      }
    }
    return "";
  }
  // 
  async fetchUserDetailInfo(uid) {
    return await invoke(
      "nodeIKernelProfileService/fetchUserDetailInfo",
      [
        "BuddyProfileStore",
        // callFrom
        [uid],
        UserDetailSource.KSERVER,
        // source
        [ProfileBizType.KALL]
        //bizList
      ]
    );
  }
  async getUserDetailInfoWithBizInfo(uid) {
    const result = await invoke(
      "nodeIKernelProfileService/getUserDetailInfoWithBizInfo",
      [
        uid,
        [0]
      ],
      {
        resultCmd: "nodeIKernelProfileListener/onUserDetailInfoChanged",
        resultCb: (payload) => payload.simpleInfo.uid === uid
      }
    );
    return result;
  }
  async getUserSimpleInfo(uid, force = true) {
    const data = await invoke(
      "nodeIKernelProfileService/getUserSimpleInfo",
      [
        force,
        [uid]
      ],
      {
        resultCmd: ReceiveCmdS.USER_INFO,
        resultCb: (payload) => payload.has(uid)
      }
    );
    return data.get(uid);
  }
  async getCoreAndBaseInfo(uids) {
    return await invoke(
      "nodeIKernelProfileService/getCoreAndBaseInfo",
      [
        "nodeStore",
        uids
      ]
    );
  }
  async getBuddyNick(uid) {
    const data = await invoke("nodeIKernelBuddyService/getBuddyNick", [[uid]]);
    const nick = data.get(uid);
    if (!nick) {
      this.ctx.logger.warn(`, uid: ${uid}`);
    }
    return nick ?? "";
  }
  async getCookies(domain2) {
    const clientKeyData = await this.forceFetchClientKey();
    if (clientKeyData?.result !== 0) {
      throw new Error("clientKey");
    }
    const uin = selfInfo.uin;
    const requestUrl = "https://ssl.ptlogin2.qq.com/jump?ptlang=1033&clientuin=" + uin + "&clientkey=" + clientKeyData.clientKey + "&u1=https%3A%2F%2F" + domain2 + "%2F" + uin + "%2Finfocenter&keyindex=19%27";
    const cookies = await HttpUtil.getCookies(requestUrl);
    return cookies;
  }
  async getPSkey(domains) {
    return await invoke("nodeIKernelTipOffService/getPskey", [
      domains,
      true
      // isFromNewPCQQ
    ]);
  }
  async like(uid, count = 1) {
    return await invoke(
      "nodeIKernelProfileLikeService/setBuddyProfileLike",
      [{
        friendUid: uid,
        sourceId: 71,
        doLikeCount: count,
        doLikeTollCount: 0
      }]
    );
  }
  async forceFetchClientKey() {
    return await invoke("nodeIKernelTicketService/forceFetchClientKey", [""]);
  }
  async getSelfNick(refresh = true) {
    if ((refresh || !selfInfo.nick) && selfInfo.uid) {
      selfInfo.nick = await this.getBuddyNick(selfInfo.uid);
    }
    return selfInfo.nick;
  }
  async setSelfStatus(status, extStatus, batteryStatus) {
    return await invoke("nodeIKernelMsgService/setStatus", [
      {
        status,
        extStatus,
        batteryStatus
      }
    ]);
  }
  async getProfileLike(uid, start = 0, limit = 20) {
    return await invoke("nodeIKernelProfileLikeService/getBuddyProfileLike", [
      {
        friendUids: [uid],
        basic: 1,
        vote: 0,
        favorite: 1,
        userProfile: 1,
        type: 3,
        start,
        limit
      }
    ]);
  }
  async getProfileLikeMe(uid, start = 0, limit = 20) {
    return await invoke("nodeIKernelProfileLikeService/getBuddyProfileLike", [
      {
        friendUids: [uid],
        basic: 1,
        vote: 1,
        favorite: 0,
        userProfile: 1,
        type: 2,
        start,
        limit
      }
    ]);
  }
  async getRobotUinRange() {
    return await invoke(
      "nodeIKernelRobotService/getRobotUinRange",
      [
        {
          justFetchMsgConfig: "1",
          type: 1,
          version: 0,
          aioKeywordVersion: 0
        }
      ]
    );
  }
  async quitAccount() {
    return await invoke(
      "quitAccount",
      []
    );
  }
  async modifySelfProfile(profile) {
    return await invoke("nodeIKernelProfileService/modifyDesktopMiniProfile", [profile]);
  }
  async getRecentContactListSnapShot(count) {
    return await invoke("nodeIKernelRecentContactService/getRecentContactListSnapShot", [count]);
  }
  async getUserInfoCompatible(uid) {
    const funcs = [
      () => this.getUserSimpleInfo(uid, false),
      () => this.getUserSimpleInfo(uid, true),
      async () => (await this.fetchUserDetailInfo(uid)).detail.get(uid)?.simpleInfo,
      async () => (await this.getUserDetailInfoWithBizInfo(uid)).simpleInfo,
      async () => (await this.getCoreAndBaseInfo([uid])).get(uid)
    ];
    for (const func of funcs) {
      try {
        const res = await func();
        if (res) return res;
      } catch (e) {
      }
    }
    throw new Error(`, uid: ${uid}`);
  }
}
class NTQQWebApi extends Service2 {
  constructor(ctx) {
    super(ctx, "ntWebApi", true);
    this.ctx = ctx;
  }
  static inject = ["ntUserApi"];
  genBkn(key2) {
    key2 = key2 || "";
    let hash2 = 5381;
    for (let i = 0; i < key2.length; i++) {
      const code = key2.charCodeAt(i);
      hash2 = hash2 + (hash2 << 5) + code;
    }
    return (hash2 & 2147483647).toString();
  }
  cookieToString(cookieObject) {
    return Object.entries(cookieObject).map(([key2, value]) => `${key2}=${value}`).join("; ");
  }
  async getGroupHonorInfo(groupCode, getType) {
    const getDataInternal = async (groupCode2, type2) => {
      const url2 = "https://qun.qq.com/interactive/honorlist?gc=" + groupCode2 + "&type=" + type2;
      let resJson;
      try {
        const res = await HttpUtil.getText(url2, "GET", "", { "Cookie": cookieStr });
        const match = res.match(/window\.__INITIAL_STATE__=(.*?);/);
        if (match) {
          resJson = JSON.parse(match[1].trim());
        }
        if (type2 === 1) {
          return resJson?.talkativeList;
        } else {
          return resJson?.actorList;
        }
      } catch (e) {
        this.ctx.logger.error("", url2, e);
      }
      return void 0;
    };
    const honorInfo = { group_id: groupCode };
    const cookieObject = await this.ctx.ntUserApi.getCookies("qun.qq.com");
    const cookieStr = this.cookieToString(cookieObject);
    if (getType === "talkative" || getType === "all") {
      try {
        const RetInternal = await getDataInternal(groupCode, 1);
        if (!RetInternal) {
          throw new Error("");
        }
        honorInfo.current_talkative = {
          user_id: RetInternal[0]?.uin,
          avatar: RetInternal[0]?.avatar,
          nickname: RetInternal[0]?.name,
          day_count: 0,
          description: RetInternal[0]?.desc
        };
        honorInfo.talkative_list = [];
        for (const talkative_ele of RetInternal) {
          honorInfo.talkative_list.push({
            user_id: talkative_ele?.uin,
            avatar: talkative_ele?.avatar,
            description: talkative_ele?.desc,
            day_count: 0,
            nickname: talkative_ele?.name
          });
        }
      } catch (e) {
        this.ctx.logger.error(e);
      }
    }
    if (getType === "performer" || getType === "all") {
      try {
        const RetInternal = await getDataInternal(groupCode, 2);
        if (!RetInternal) {
          throw new Error("");
        }
        honorInfo.performer_list = [];
        for (const performer_ele of RetInternal) {
          honorInfo.performer_list.push({
            user_id: performer_ele?.uin,
            nickname: performer_ele?.name,
            avatar: performer_ele?.avatar,
            description: performer_ele?.desc
          });
        }
      } catch (e) {
        this.ctx.logger.error(e);
      }
    }
    if (getType === "performer" || getType === "all") {
      try {
        const RetInternal = await getDataInternal(groupCode, 3);
        if (!RetInternal) {
          throw new Error("");
        }
        honorInfo.legend_list = [];
        for (const legend_ele of RetInternal) {
          honorInfo.legend_list.push({
            user_id: legend_ele?.uin,
            nickname: legend_ele?.name,
            avatar: legend_ele?.avatar,
            desc: legend_ele?.description
          });
        }
      } catch (e) {
        this.ctx.logger.error("", e);
      }
    }
    if (getType === "emotion" || getType === "all") {
      try {
        const RetInternal = await getDataInternal(groupCode, 6);
        if (!RetInternal) {
          throw new Error("");
        }
        honorInfo.emotion_list = [];
        for (const emotion_ele of RetInternal) {
          honorInfo.emotion_list.push({
            user_id: emotion_ele?.uin,
            nickname: emotion_ele?.name,
            avatar: emotion_ele?.avatar,
            desc: emotion_ele?.description
          });
        }
      } catch (e) {
        this.ctx.logger.error("", e);
      }
    }
    if (getType === "emotion" || getType === "all") {
      honorInfo.strong_newbie_list = [];
    }
    return honorInfo;
  }
  async batchDeleteGroupMember(groupCode, memberUinList) {
    const cookieObject = await this.ctx.ntUserApi.getCookies("qun.qq.com");
    const bkn = this.genBkn(cookieObject.skey);
    const url2 = `https://qun.qq.com/cgi-bin/qun_mgr/delete_group_member?bkn=${bkn}&ts=${Date.now()}`;
    const cookieStr = this.cookieToString(cookieObject);
    const formData = new FormData();
    formData.append("gc", groupCode);
    formData.append("ul", memberUinList.join("|"));
    formData.append("flag", "0");
    formData.append("bkn", bkn);
    const response2 = await fetch(url2, {
      method: "POST",
      headers: {
        "Cookie": cookieStr
      },
      body: formData
    });
    const responseText = await response2.text();
    return JSON.parse(responseText);
  }
  async getExpertInfo(uin) {
    const pSkey = (await this.ctx.ntUserApi.getPSkey(["vip.qq.com"])).domainPskeyMap.get("vip.qq.com");
    const bkn = this.genBkn(pSkey);
    const url2 = `https://cgi.vip.qq.com/card/getExpertInfo?ps_tk=${bkn}&fuin=${uin}&g_tk=${bkn}`;
    const cookie2 = `p_uin=o${selfInfo.uin}; p_skey=${pSkey}; uin=o${selfInfo.uin}`;
    const response2 = await fetch(url2, {
      headers: {
        "User-Agent": "Reqable/2.30.1",
        "Referer": "https://cgi.vip.qq.com/",
        "Cookie": cookie2
      }
    });
    return await response2.json();
  }
  async uploadGroupAlbum(groupCode, filePathList, albumID) {
    const domain2 = "h5.qzone.qq.com";
    const cookiesObject = await this.ctx.ntUserApi.getCookies(domain2);
    const gtk = this.genBkn(cookiesObject.skey);
    const errIndexList = [];
    const fileLen = filePathList.length.toString();
    const iBatchID = Math.floor(Date.now() / 1e3);
    for (let i = 0; i < filePathList.length; i++) {
      const filePath = filePathList[i];
      const fileBuffer = await fsPromise.readFile(filePath);
      const fileSize = fileBuffer.length;
      const checksum = await calculateFileMD5(filePath);
      const getSessionUrl = `https://${domain2}/webapp/json/sliceUpload/FileBatchControl/${checksum}?g_tk=${gtk}`;
      const timestamp = Math.floor(Date.now() / 1e3);
      const getSessionPostData = {
        "control_req": [{
          "uin": selfInfo.uin,
          "token": {
            "type": 4,
            "data": cookiesObject.p_skey,
            "appid": 5
          },
          "appid": "qun",
          "checksum": checksum,
          "check_type": 0,
          "file_len": fileSize,
          "env": { "refer": "qzone", "deviceInfo": "h5" },
          "model": 0,
          "biz_req": {
            "sPicTitle": "",
            "sPicDesc": "",
            // 'sAlbumName': albumName,
            "sAlbumName": "",
            "sAlbumID": albumID,
            "iAlbumTypeID": 0,
            "iBitmap": 0,
            "iUploadType": 0,
            "iUpPicType": 0,
            "iBatchID": iBatchID,
            "sPicPath": "",
            "iPicWidth": 0,
            "iPicHight": 0,
            "iWaterType": 0,
            "iDistinctUse": 0,
            "iNeedFeeds": 1,
            "iUploadTime": timestamp,
            "mapExt": { "appid": "qun", "userid": groupCode },
            "stExtendInfo": {
              "mapParams": {
                "photo_num": fileLen,
                "video_num": "0",
                "batch_num": fileLen
              }
            },
            "mutliPicInfo": {
              "iBatUploadNum": fileLen,
              "iCurUpload": i,
              "iSuccNum": 0,
              "iFailNum": 0
            }
          },
          "session": "",
          "asy_upload": 0,
          "cmd": "FileUpload"
        }]
      };
      const res = await HttpUtil.post(getSessionUrl, getSessionPostData, this.cookieToString(cookiesObject));
      const resJson = await res.json();
      if (resJson.ret !== 0) {
        this.ctx.logger.error(` session : ${resJson.msg}`);
        errIndexList.push(i);
        continue;
      }
      const sessionId = resJson.data.session;
      const sliceSize = resJson.data.slice_size;
      let offset = 0;
      let seq = 1;
      const concurrency2 = 10;
      const slices = [];
      while (offset < fileSize) {
        const end = Math.min(offset + sliceSize, fileSize);
        const chunk = fileBuffer.subarray(offset, end);
        slices.push({ offset, end, seq, chunk });
        offset = end;
        seq++;
      }
      const uploadSlice = async (slice) => {
        const uploadUrl = `https://${domain2}/webapp/json/sliceUpload/FileUpload?seq=${slice.seq}&retry=0&offset=${slice.offset}&end=${slice.end}&total=${fileSize}&type=form&g_tk=${gtk}`;
        const formData = new FormData();
        formData.append("uin", selfInfo.uin);
        formData.append("appid", "qun");
        formData.append("data", new Blob([Uint8Array.from(slice.chunk)]));
        formData.append("session", sessionId);
        formData.append("offset", slice.offset.toString());
        formData.append("checksum", "");
        formData.append("check_type", "0");
        formData.append("retry", "0");
        formData.append("seq", slice.seq.toString());
        formData.append("end", slice.end.toString());
        formData.append("cmd", "FileUpload");
        formData.append("slice_size", sliceSize.toString());
        formData.append("biz_req.iUploadType", "0");
        const uploadRes = await fetch(uploadUrl, {
          method: "POST",
          headers: {
            "Cookie": this.cookieToString(cookiesObject)
          },
          body: formData
        });
        const uploadResJson = await uploadRes.json();
        if (uploadResJson.ret !== 0) {
          if (!errIndexList.includes(i)) {
            errIndexList.push(i);
          }
          throw new Error(` (seq: ${slice.seq}): ${uploadResJson.msg}, file: ${filePath}`);
        }
      };
      for (let i2 = 0; i2 < slices.length; i2 += concurrency2) {
        const batch = slices.slice(i2, i2 + concurrency2);
        try {
          await Promise.all(batch.map((slice) => uploadSlice(slice)));
        } catch (e) {
          this.ctx.logger.error(e);
        }
      }
    }
    this.ctx.logger.info("");
    return {
      success_count: filePathList.length - errIndexList.length,
      fail_count: errIndexList.length,
      fail_indexes: errIndexList
    };
  }
}
class NTQQSystemApi extends Service2 {
  constructor(ctx) {
    super(ctx, "ntSystemApi", true);
    this.ctx = ctx;
  }
  async restart() {
    await this.setSettingAutoLogin(true);
  }
  async getSettingAutoLogin() {
    return invoke("nodeIKernelNodeMiscService/queryAutoRun", []);
  }
  async setSettingAutoLogin(state2) {
    await invoke("nodeIKernelSettingService/setNeedConfirmSwitch", [1]);
    await invoke("nodeIKernelSettingService/setAutoLoginSwitch", [state2]);
  }
  async getDeviceInfo() {
    return await invoke("getDeviceInfo", []);
  }
  async scanQRCode(path2) {
    return await invoke("nodeIKernelNodeMiscService/scanQBar", [path2]);
  }
}
function hashPassword(password) {
  return crypto$1.createHash("sha256").update(password).digest("hex");
}
var multer$1 = { exports: {} };
var typeIs = { exports: {} };
var mediaTyper = {};
var hasRequiredMediaTyper;
function requireMediaTyper() {
  if (hasRequiredMediaTyper) return mediaTyper;
  hasRequiredMediaTyper = 1;
  var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
  var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
  var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
  var qescRegExp = /\\([\u0000-\u007f])/g;
  var quoteRegExp = /([\\"])/g;
  var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
  var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
  var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
  mediaTyper.format = format;
  mediaTyper.parse = parse3;
  function format(obj) {
    if (!obj || typeof obj !== "object") {
      throw new TypeError("argument obj is required");
    }
    var parameters = obj.parameters;
    var subtype = obj.subtype;
    var suffix = obj.suffix;
    var type2 = obj.type;
    if (!type2 || !typeNameRegExp.test(type2)) {
      throw new TypeError("invalid type");
    }
    if (!subtype || !subtypeNameRegExp.test(subtype)) {
      throw new TypeError("invalid subtype");
    }
    var string2 = type2 + "/" + subtype;
    if (suffix) {
      if (!typeNameRegExp.test(suffix)) {
        throw new TypeError("invalid suffix");
      }
      string2 += "+" + suffix;
    }
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0; i < params.length; i++) {
        param = params[i];
        if (!tokenRegExp.test(param)) {
          throw new TypeError("invalid parameter name");
        }
        string2 += "; " + param + "=" + qstring(parameters[param]);
      }
    }
    return string2;
  }
  function parse3(string2) {
    if (!string2) {
      throw new TypeError("argument string is required");
    }
    if (typeof string2 === "object") {
      string2 = getcontenttype(string2);
    }
    if (typeof string2 !== "string") {
      throw new TypeError("argument string is required to be a string");
    }
    var index2 = string2.indexOf(";");
    var type2 = index2 !== -1 ? string2.substr(0, index2) : string2;
    var key2;
    var match;
    var obj = splitType(type2);
    var params = {};
    var value;
    paramRegExp.lastIndex = index2;
    while (match = paramRegExp.exec(string2)) {
      if (match.index !== index2) {
        throw new TypeError("invalid parameter format");
      }
      index2 += match[0].length;
      key2 = match[1].toLowerCase();
      value = match[2];
      if (value[0] === '"') {
        value = value.substr(1, value.length - 2).replace(qescRegExp, "$1");
      }
      params[key2] = value;
    }
    if (index2 !== -1 && index2 !== string2.length) {
      throw new TypeError("invalid parameter format");
    }
    obj.parameters = params;
    return obj;
  }
  function getcontenttype(obj) {
    if (typeof obj.getHeader === "function") {
      return obj.getHeader("content-type");
    }
    if (typeof obj.headers === "object") {
      return obj.headers && obj.headers["content-type"];
    }
  }
  function qstring(val) {
    var str = String(val);
    if (tokenRegExp.test(str)) {
      return str;
    }
    if (str.length > 0 && !textRegExp.test(str)) {
      throw new TypeError("invalid parameter value");
    }
    return '"' + str.replace(quoteRegExp, "\\$1") + '"';
  }
  function splitType(string2) {
    var match = typeRegExp.exec(string2.toLowerCase());
    if (!match) {
      throw new TypeError("invalid media type");
    }
    var type2 = match[1];
    var subtype = match[2];
    var suffix;
    var index2 = subtype.lastIndexOf("+");
    if (index2 !== -1) {
      suffix = subtype.substr(index2 + 1);
      subtype = subtype.substr(0, index2);
    }
    var obj = {
      type: type2,
      subtype,
      suffix
    };
    return obj;
  }
  return mediaTyper;
}
var mimeTypes = {};
const require$$0 = {
  "application/1d-interleaved-parityfec": { "source": "iana" },
  "application/3gpdash-qoe-report+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/3gpp-ims+xml": { "source": "iana", "compressible": true },
  "application/3gpphal+json": { "source": "iana", "compressible": true },
  "application/3gpphalforms+json": { "source": "iana", "compressible": true },
  "application/a2l": { "source": "iana" },
  "application/ace+cbor": { "source": "iana" },
  "application/activemessage": { "source": "iana" },
  "application/activity+json": { "source": "iana", "compressible": true },
  "application/alto-costmap+json": { "source": "iana", "compressible": true },
  "application/alto-costmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-directory+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcost+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcostparams+json": { "source": "iana", "compressible": true },
  "application/alto-endpointprop+json": { "source": "iana", "compressible": true },
  "application/alto-endpointpropparams+json": { "source": "iana", "compressible": true },
  "application/alto-error+json": { "source": "iana", "compressible": true },
  "application/alto-networkmap+json": { "source": "iana", "compressible": true },
  "application/alto-networkmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamcontrol+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamparams+json": { "source": "iana", "compressible": true },
  "application/aml": { "source": "iana" },
  "application/andrew-inset": { "source": "iana", "extensions": ["ez"] },
  "application/applefile": { "source": "iana" },
  "application/applixware": { "source": "apache", "extensions": ["aw"] },
  "application/at+jwt": { "source": "iana" },
  "application/atf": { "source": "iana" },
  "application/atfx": { "source": "iana" },
  "application/atom+xml": { "source": "iana", "compressible": true, "extensions": ["atom"] },
  "application/atomcat+xml": { "source": "iana", "compressible": true, "extensions": ["atomcat"] },
  "application/atomdeleted+xml": { "source": "iana", "compressible": true, "extensions": ["atomdeleted"] },
  "application/atomicmail": { "source": "iana" },
  "application/atomsvc+xml": { "source": "iana", "compressible": true, "extensions": ["atomsvc"] },
  "application/atsc-dwd+xml": { "source": "iana", "compressible": true, "extensions": ["dwd"] },
  "application/atsc-dynamic-event-message": { "source": "iana" },
  "application/atsc-held+xml": { "source": "iana", "compressible": true, "extensions": ["held"] },
  "application/atsc-rdt+json": { "source": "iana", "compressible": true },
  "application/atsc-rsat+xml": { "source": "iana", "compressible": true, "extensions": ["rsat"] },
  "application/atxml": { "source": "iana" },
  "application/auth-policy+xml": { "source": "iana", "compressible": true },
  "application/bacnet-xdd+zip": { "source": "iana", "compressible": false },
  "application/batch-smtp": { "source": "iana" },
  "application/bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/beep+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/calendar+json": { "source": "iana", "compressible": true },
  "application/calendar+xml": { "source": "iana", "compressible": true, "extensions": ["xcs"] },
  "application/call-completion": { "source": "iana" },
  "application/cals-1840": { "source": "iana" },
  "application/captive+json": { "source": "iana", "compressible": true },
  "application/cbor": { "source": "iana" },
  "application/cbor-seq": { "source": "iana" },
  "application/cccex": { "source": "iana" },
  "application/ccmp+xml": { "source": "iana", "compressible": true },
  "application/ccxml+xml": { "source": "iana", "compressible": true, "extensions": ["ccxml"] },
  "application/cdfx+xml": { "source": "iana", "compressible": true, "extensions": ["cdfx"] },
  "application/cdmi-capability": { "source": "iana", "extensions": ["cdmia"] },
  "application/cdmi-container": { "source": "iana", "extensions": ["cdmic"] },
  "application/cdmi-domain": { "source": "iana", "extensions": ["cdmid"] },
  "application/cdmi-object": { "source": "iana", "extensions": ["cdmio"] },
  "application/cdmi-queue": { "source": "iana", "extensions": ["cdmiq"] },
  "application/cdni": { "source": "iana" },
  "application/cea": { "source": "iana" },
  "application/cea-2018+xml": { "source": "iana", "compressible": true },
  "application/cellml+xml": { "source": "iana", "compressible": true },
  "application/cfw": { "source": "iana" },
  "application/city+json": { "source": "iana", "compressible": true },
  "application/clr": { "source": "iana" },
  "application/clue+xml": { "source": "iana", "compressible": true },
  "application/clue_info+xml": { "source": "iana", "compressible": true },
  "application/cms": { "source": "iana" },
  "application/cnrp+xml": { "source": "iana", "compressible": true },
  "application/coap-group+json": { "source": "iana", "compressible": true },
  "application/coap-payload": { "source": "iana" },
  "application/commonground": { "source": "iana" },
  "application/conference-info+xml": { "source": "iana", "compressible": true },
  "application/cose": { "source": "iana" },
  "application/cose-key": { "source": "iana" },
  "application/cose-key-set": { "source": "iana" },
  "application/cpl+xml": { "source": "iana", "compressible": true, "extensions": ["cpl"] },
  "application/csrattrs": { "source": "iana" },
  "application/csta+xml": { "source": "iana", "compressible": true },
  "application/cstadata+xml": { "source": "iana", "compressible": true },
  "application/csvm+json": { "source": "iana", "compressible": true },
  "application/cu-seeme": { "source": "apache", "extensions": ["cu"] },
  "application/cwt": { "source": "iana" },
  "application/cybercash": { "source": "iana" },
  "application/dart": { "compressible": true },
  "application/dash+xml": { "source": "iana", "compressible": true, "extensions": ["mpd"] },
  "application/dash-patch+xml": { "source": "iana", "compressible": true, "extensions": ["mpp"] },
  "application/dashdelta": { "source": "iana" },
  "application/davmount+xml": { "source": "iana", "compressible": true, "extensions": ["davmount"] },
  "application/dca-rft": { "source": "iana" },
  "application/dcd": { "source": "iana" },
  "application/dec-dx": { "source": "iana" },
  "application/dialog-info+xml": { "source": "iana", "compressible": true },
  "application/dicom": { "source": "iana" },
  "application/dicom+json": { "source": "iana", "compressible": true },
  "application/dicom+xml": { "source": "iana", "compressible": true },
  "application/dii": { "source": "iana" },
  "application/dit": { "source": "iana" },
  "application/dns": { "source": "iana" },
  "application/dns+json": { "source": "iana", "compressible": true },
  "application/dns-message": { "source": "iana" },
  "application/docbook+xml": { "source": "apache", "compressible": true, "extensions": ["dbk"] },
  "application/dots+cbor": { "source": "iana" },
  "application/dskpp+xml": { "source": "iana", "compressible": true },
  "application/dssc+der": { "source": "iana", "extensions": ["dssc"] },
  "application/dssc+xml": { "source": "iana", "compressible": true, "extensions": ["xdssc"] },
  "application/dvcs": { "source": "iana" },
  "application/ecmascript": { "source": "iana", "compressible": true, "extensions": ["es", "ecma"] },
  "application/edi-consent": { "source": "iana" },
  "application/edi-x12": { "source": "iana", "compressible": false },
  "application/edifact": { "source": "iana", "compressible": false },
  "application/efi": { "source": "iana" },
  "application/elm+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/elm+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.cap+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/emergencycalldata.comment+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.control+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.deviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.ecall.msd": { "source": "iana" },
  "application/emergencycalldata.providerinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.serviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.subscriberinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.veds+xml": { "source": "iana", "compressible": true },
  "application/emma+xml": { "source": "iana", "compressible": true, "extensions": ["emma"] },
  "application/emotionml+xml": { "source": "iana", "compressible": true, "extensions": ["emotionml"] },
  "application/encaprtp": { "source": "iana" },
  "application/epp+xml": { "source": "iana", "compressible": true },
  "application/epub+zip": { "source": "iana", "compressible": false, "extensions": ["epub"] },
  "application/eshop": { "source": "iana" },
  "application/exi": { "source": "iana", "extensions": ["exi"] },
  "application/expect-ct-report+json": { "source": "iana", "compressible": true },
  "application/express": { "source": "iana", "extensions": ["exp"] },
  "application/fastinfoset": { "source": "iana" },
  "application/fastsoap": { "source": "iana" },
  "application/fdt+xml": { "source": "iana", "compressible": true, "extensions": ["fdt"] },
  "application/fhir+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fhir+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fido.trusted-apps+json": { "compressible": true },
  "application/fits": { "source": "iana" },
  "application/flexfec": { "source": "iana" },
  "application/font-sfnt": { "source": "iana" },
  "application/font-tdpfr": { "source": "iana", "extensions": ["pfr"] },
  "application/font-woff": { "source": "iana", "compressible": false },
  "application/framework-attributes+xml": { "source": "iana", "compressible": true },
  "application/geo+json": { "source": "iana", "compressible": true, "extensions": ["geojson"] },
  "application/geo+json-seq": { "source": "iana" },
  "application/geopackage+sqlite3": { "source": "iana" },
  "application/geoxacml+xml": { "source": "iana", "compressible": true },
  "application/gltf-buffer": { "source": "iana" },
  "application/gml+xml": { "source": "iana", "compressible": true, "extensions": ["gml"] },
  "application/gpx+xml": { "source": "apache", "compressible": true, "extensions": ["gpx"] },
  "application/gxf": { "source": "apache", "extensions": ["gxf"] },
  "application/gzip": { "source": "iana", "compressible": false, "extensions": ["gz"] },
  "application/h224": { "source": "iana" },
  "application/held+xml": { "source": "iana", "compressible": true },
  "application/hjson": { "extensions": ["hjson"] },
  "application/http": { "source": "iana" },
  "application/hyperstudio": { "source": "iana", "extensions": ["stk"] },
  "application/ibe-key-request+xml": { "source": "iana", "compressible": true },
  "application/ibe-pkg-reply+xml": { "source": "iana", "compressible": true },
  "application/ibe-pp-data": { "source": "iana" },
  "application/iges": { "source": "iana" },
  "application/im-iscomposing+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/index": { "source": "iana" },
  "application/index.cmd": { "source": "iana" },
  "application/index.obj": { "source": "iana" },
  "application/index.response": { "source": "iana" },
  "application/index.vnd": { "source": "iana" },
  "application/inkml+xml": { "source": "iana", "compressible": true, "extensions": ["ink", "inkml"] },
  "application/iotp": { "source": "iana" },
  "application/ipfix": { "source": "iana", "extensions": ["ipfix"] },
  "application/ipp": { "source": "iana" },
  "application/isup": { "source": "iana" },
  "application/its+xml": { "source": "iana", "compressible": true, "extensions": ["its"] },
  "application/java-archive": { "source": "apache", "compressible": false, "extensions": ["jar", "war", "ear"] },
  "application/java-serialized-object": { "source": "apache", "compressible": false, "extensions": ["ser"] },
  "application/java-vm": { "source": "apache", "compressible": false, "extensions": ["class"] },
  "application/javascript": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["js", "mjs"] },
  "application/jf2feed+json": { "source": "iana", "compressible": true },
  "application/jose": { "source": "iana" },
  "application/jose+json": { "source": "iana", "compressible": true },
  "application/jrd+json": { "source": "iana", "compressible": true },
  "application/jscalendar+json": { "source": "iana", "compressible": true },
  "application/json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["json", "map"] },
  "application/json-patch+json": { "source": "iana", "compressible": true },
  "application/json-seq": { "source": "iana" },
  "application/json5": { "extensions": ["json5"] },
  "application/jsonml+json": { "source": "apache", "compressible": true, "extensions": ["jsonml"] },
  "application/jwk+json": { "source": "iana", "compressible": true },
  "application/jwk-set+json": { "source": "iana", "compressible": true },
  "application/jwt": { "source": "iana" },
  "application/kpml-request+xml": { "source": "iana", "compressible": true },
  "application/kpml-response+xml": { "source": "iana", "compressible": true },
  "application/ld+json": { "source": "iana", "compressible": true, "extensions": ["jsonld"] },
  "application/lgr+xml": { "source": "iana", "compressible": true, "extensions": ["lgr"] },
  "application/link-format": { "source": "iana" },
  "application/load-control+xml": { "source": "iana", "compressible": true },
  "application/lost+xml": { "source": "iana", "compressible": true, "extensions": ["lostxml"] },
  "application/lostsync+xml": { "source": "iana", "compressible": true },
  "application/lpf+zip": { "source": "iana", "compressible": false },
  "application/lxf": { "source": "iana" },
  "application/mac-binhex40": { "source": "iana", "extensions": ["hqx"] },
  "application/mac-compactpro": { "source": "apache", "extensions": ["cpt"] },
  "application/macwriteii": { "source": "iana" },
  "application/mads+xml": { "source": "iana", "compressible": true, "extensions": ["mads"] },
  "application/manifest+json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["webmanifest"] },
  "application/marc": { "source": "iana", "extensions": ["mrc"] },
  "application/marcxml+xml": { "source": "iana", "compressible": true, "extensions": ["mrcx"] },
  "application/mathematica": { "source": "iana", "extensions": ["ma", "nb", "mb"] },
  "application/mathml+xml": { "source": "iana", "compressible": true, "extensions": ["mathml"] },
  "application/mathml-content+xml": { "source": "iana", "compressible": true },
  "application/mathml-presentation+xml": { "source": "iana", "compressible": true },
  "application/mbms-associated-procedure-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-deregister+xml": { "source": "iana", "compressible": true },
  "application/mbms-envelope+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-protection-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-reception-report+xml": { "source": "iana", "compressible": true },
  "application/mbms-register+xml": { "source": "iana", "compressible": true },
  "application/mbms-register-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-schedule+xml": { "source": "iana", "compressible": true },
  "application/mbms-user-service-description+xml": { "source": "iana", "compressible": true },
  "application/mbox": { "source": "iana", "extensions": ["mbox"] },
  "application/media-policy-dataset+xml": { "source": "iana", "compressible": true, "extensions": ["mpf"] },
  "application/media_control+xml": { "source": "iana", "compressible": true },
  "application/mediaservercontrol+xml": { "source": "iana", "compressible": true, "extensions": ["mscml"] },
  "application/merge-patch+json": { "source": "iana", "compressible": true },
  "application/metalink+xml": { "source": "apache", "compressible": true, "extensions": ["metalink"] },
  "application/metalink4+xml": { "source": "iana", "compressible": true, "extensions": ["meta4"] },
  "application/mets+xml": { "source": "iana", "compressible": true, "extensions": ["mets"] },
  "application/mf4": { "source": "iana" },
  "application/mikey": { "source": "iana" },
  "application/mipc": { "source": "iana" },
  "application/missing-blocks+cbor-seq": { "source": "iana" },
  "application/mmt-aei+xml": { "source": "iana", "compressible": true, "extensions": ["maei"] },
  "application/mmt-usd+xml": { "source": "iana", "compressible": true, "extensions": ["musd"] },
  "application/mods+xml": { "source": "iana", "compressible": true, "extensions": ["mods"] },
  "application/moss-keys": { "source": "iana" },
  "application/moss-signature": { "source": "iana" },
  "application/mosskey-data": { "source": "iana" },
  "application/mosskey-request": { "source": "iana" },
  "application/mp21": { "source": "iana", "extensions": ["m21", "mp21"] },
  "application/mp4": { "source": "iana", "extensions": ["mp4s", "m4p"] },
  "application/mpeg4-generic": { "source": "iana" },
  "application/mpeg4-iod": { "source": "iana" },
  "application/mpeg4-iod-xmt": { "source": "iana" },
  "application/mrb-consumer+xml": { "source": "iana", "compressible": true },
  "application/mrb-publish+xml": { "source": "iana", "compressible": true },
  "application/msc-ivr+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msc-mixer+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msword": { "source": "iana", "compressible": false, "extensions": ["doc", "dot"] },
  "application/mud+json": { "source": "iana", "compressible": true },
  "application/multipart-core": { "source": "iana" },
  "application/mxf": { "source": "iana", "extensions": ["mxf"] },
  "application/n-quads": { "source": "iana", "extensions": ["nq"] },
  "application/n-triples": { "source": "iana", "extensions": ["nt"] },
  "application/nasdata": { "source": "iana" },
  "application/news-checkgroups": { "source": "iana", "charset": "US-ASCII" },
  "application/news-groupinfo": { "source": "iana", "charset": "US-ASCII" },
  "application/news-transmission": { "source": "iana" },
  "application/nlsml+xml": { "source": "iana", "compressible": true },
  "application/node": { "source": "iana", "extensions": ["cjs"] },
  "application/nss": { "source": "iana" },
  "application/oauth-authz-req+jwt": { "source": "iana" },
  "application/oblivious-dns-message": { "source": "iana" },
  "application/ocsp-request": { "source": "iana" },
  "application/ocsp-response": { "source": "iana" },
  "application/octet-stream": { "source": "iana", "compressible": false, "extensions": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"] },
  "application/oda": { "source": "iana", "extensions": ["oda"] },
  "application/odm+xml": { "source": "iana", "compressible": true },
  "application/odx": { "source": "iana" },
  "application/oebps-package+xml": { "source": "iana", "compressible": true, "extensions": ["opf"] },
  "application/ogg": { "source": "iana", "compressible": false, "extensions": ["ogx"] },
  "application/omdoc+xml": { "source": "apache", "compressible": true, "extensions": ["omdoc"] },
  "application/onenote": { "source": "apache", "extensions": ["onetoc", "onetoc2", "onetmp", "onepkg"] },
  "application/opc-nodeset+xml": { "source": "iana", "compressible": true },
  "application/oscore": { "source": "iana" },
  "application/oxps": { "source": "iana", "extensions": ["oxps"] },
  "application/p21": { "source": "iana" },
  "application/p21+zip": { "source": "iana", "compressible": false },
  "application/p2p-overlay+xml": { "source": "iana", "compressible": true, "extensions": ["relo"] },
  "application/parityfec": { "source": "iana" },
  "application/passport": { "source": "iana" },
  "application/patch-ops-error+xml": { "source": "iana", "compressible": true, "extensions": ["xer"] },
  "application/pdf": { "source": "iana", "compressible": false, "extensions": ["pdf"] },
  "application/pdx": { "source": "iana" },
  "application/pem-certificate-chain": { "source": "iana" },
  "application/pgp-encrypted": { "source": "iana", "compressible": false, "extensions": ["pgp"] },
  "application/pgp-keys": { "source": "iana", "extensions": ["asc"] },
  "application/pgp-signature": { "source": "iana", "extensions": ["asc", "sig"] },
  "application/pics-rules": { "source": "apache", "extensions": ["prf"] },
  "application/pidf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pidf-diff+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pkcs10": { "source": "iana", "extensions": ["p10"] },
  "application/pkcs12": { "source": "iana" },
  "application/pkcs7-mime": { "source": "iana", "extensions": ["p7m", "p7c"] },
  "application/pkcs7-signature": { "source": "iana", "extensions": ["p7s"] },
  "application/pkcs8": { "source": "iana", "extensions": ["p8"] },
  "application/pkcs8-encrypted": { "source": "iana" },
  "application/pkix-attr-cert": { "source": "iana", "extensions": ["ac"] },
  "application/pkix-cert": { "source": "iana", "extensions": ["cer"] },
  "application/pkix-crl": { "source": "iana", "extensions": ["crl"] },
  "application/pkix-pkipath": { "source": "iana", "extensions": ["pkipath"] },
  "application/pkixcmp": { "source": "iana", "extensions": ["pki"] },
  "application/pls+xml": { "source": "iana", "compressible": true, "extensions": ["pls"] },
  "application/poc-settings+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/postscript": { "source": "iana", "compressible": true, "extensions": ["ai", "eps", "ps"] },
  "application/ppsp-tracker+json": { "source": "iana", "compressible": true },
  "application/problem+json": { "source": "iana", "compressible": true },
  "application/problem+xml": { "source": "iana", "compressible": true },
  "application/provenance+xml": { "source": "iana", "compressible": true, "extensions": ["provx"] },
  "application/prs.alvestrand.titrax-sheet": { "source": "iana" },
  "application/prs.cww": { "source": "iana", "extensions": ["cww"] },
  "application/prs.cyn": { "source": "iana", "charset": "7-BIT" },
  "application/prs.hpub+zip": { "source": "iana", "compressible": false },
  "application/prs.nprend": { "source": "iana" },
  "application/prs.plucker": { "source": "iana" },
  "application/prs.rdf-xml-crypt": { "source": "iana" },
  "application/prs.xsf+xml": { "source": "iana", "compressible": true },
  "application/pskc+xml": { "source": "iana", "compressible": true, "extensions": ["pskcxml"] },
  "application/pvd+json": { "source": "iana", "compressible": true },
  "application/qsig": { "source": "iana" },
  "application/raml+yaml": { "compressible": true, "extensions": ["raml"] },
  "application/raptorfec": { "source": "iana" },
  "application/rdap+json": { "source": "iana", "compressible": true },
  "application/rdf+xml": { "source": "iana", "compressible": true, "extensions": ["rdf", "owl"] },
  "application/reginfo+xml": { "source": "iana", "compressible": true, "extensions": ["rif"] },
  "application/relax-ng-compact-syntax": { "source": "iana", "extensions": ["rnc"] },
  "application/remote-printing": { "source": "iana" },
  "application/reputon+json": { "source": "iana", "compressible": true },
  "application/resource-lists+xml": { "source": "iana", "compressible": true, "extensions": ["rl"] },
  "application/resource-lists-diff+xml": { "source": "iana", "compressible": true, "extensions": ["rld"] },
  "application/rfc+xml": { "source": "iana", "compressible": true },
  "application/riscos": { "source": "iana" },
  "application/rlmi+xml": { "source": "iana", "compressible": true },
  "application/rls-services+xml": { "source": "iana", "compressible": true, "extensions": ["rs"] },
  "application/route-apd+xml": { "source": "iana", "compressible": true, "extensions": ["rapd"] },
  "application/route-s-tsid+xml": { "source": "iana", "compressible": true, "extensions": ["sls"] },
  "application/route-usd+xml": { "source": "iana", "compressible": true, "extensions": ["rusd"] },
  "application/rpki-ghostbusters": { "source": "iana", "extensions": ["gbr"] },
  "application/rpki-manifest": { "source": "iana", "extensions": ["mft"] },
  "application/rpki-publication": { "source": "iana" },
  "application/rpki-roa": { "source": "iana", "extensions": ["roa"] },
  "application/rpki-updown": { "source": "iana" },
  "application/rsd+xml": { "source": "apache", "compressible": true, "extensions": ["rsd"] },
  "application/rss+xml": { "source": "apache", "compressible": true, "extensions": ["rss"] },
  "application/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "application/rtploopback": { "source": "iana" },
  "application/rtx": { "source": "iana" },
  "application/samlassertion+xml": { "source": "iana", "compressible": true },
  "application/samlmetadata+xml": { "source": "iana", "compressible": true },
  "application/sarif+json": { "source": "iana", "compressible": true },
  "application/sarif-external-properties+json": { "source": "iana", "compressible": true },
  "application/sbe": { "source": "iana" },
  "application/sbml+xml": { "source": "iana", "compressible": true, "extensions": ["sbml"] },
  "application/scaip+xml": { "source": "iana", "compressible": true },
  "application/scim+json": { "source": "iana", "compressible": true },
  "application/scvp-cv-request": { "source": "iana", "extensions": ["scq"] },
  "application/scvp-cv-response": { "source": "iana", "extensions": ["scs"] },
  "application/scvp-vp-request": { "source": "iana", "extensions": ["spq"] },
  "application/scvp-vp-response": { "source": "iana", "extensions": ["spp"] },
  "application/sdp": { "source": "iana", "extensions": ["sdp"] },
  "application/secevent+jwt": { "source": "iana" },
  "application/senml+cbor": { "source": "iana" },
  "application/senml+json": { "source": "iana", "compressible": true },
  "application/senml+xml": { "source": "iana", "compressible": true, "extensions": ["senmlx"] },
  "application/senml-etch+cbor": { "source": "iana" },
  "application/senml-etch+json": { "source": "iana", "compressible": true },
  "application/senml-exi": { "source": "iana" },
  "application/sensml+cbor": { "source": "iana" },
  "application/sensml+json": { "source": "iana", "compressible": true },
  "application/sensml+xml": { "source": "iana", "compressible": true, "extensions": ["sensmlx"] },
  "application/sensml-exi": { "source": "iana" },
  "application/sep+xml": { "source": "iana", "compressible": true },
  "application/sep-exi": { "source": "iana" },
  "application/session-info": { "source": "iana" },
  "application/set-payment": { "source": "iana" },
  "application/set-payment-initiation": { "source": "iana", "extensions": ["setpay"] },
  "application/set-registration": { "source": "iana" },
  "application/set-registration-initiation": { "source": "iana", "extensions": ["setreg"] },
  "application/sgml": { "source": "iana" },
  "application/sgml-open-catalog": { "source": "iana" },
  "application/shf+xml": { "source": "iana", "compressible": true, "extensions": ["shf"] },
  "application/sieve": { "source": "iana", "extensions": ["siv", "sieve"] },
  "application/simple-filter+xml": { "source": "iana", "compressible": true },
  "application/simple-message-summary": { "source": "iana" },
  "application/simplesymbolcontainer": { "source": "iana" },
  "application/sipc": { "source": "iana" },
  "application/slate": { "source": "iana" },
  "application/smil": { "source": "iana" },
  "application/smil+xml": { "source": "iana", "compressible": true, "extensions": ["smi", "smil"] },
  "application/smpte336m": { "source": "iana" },
  "application/soap+fastinfoset": { "source": "iana" },
  "application/soap+xml": { "source": "iana", "compressible": true },
  "application/sparql-query": { "source": "iana", "extensions": ["rq"] },
  "application/sparql-results+xml": { "source": "iana", "compressible": true, "extensions": ["srx"] },
  "application/spdx+json": { "source": "iana", "compressible": true },
  "application/spirits-event+xml": { "source": "iana", "compressible": true },
  "application/sql": { "source": "iana" },
  "application/srgs": { "source": "iana", "extensions": ["gram"] },
  "application/srgs+xml": { "source": "iana", "compressible": true, "extensions": ["grxml"] },
  "application/sru+xml": { "source": "iana", "compressible": true, "extensions": ["sru"] },
  "application/ssdl+xml": { "source": "apache", "compressible": true, "extensions": ["ssdl"] },
  "application/ssml+xml": { "source": "iana", "compressible": true, "extensions": ["ssml"] },
  "application/stix+json": { "source": "iana", "compressible": true },
  "application/swid+xml": { "source": "iana", "compressible": true, "extensions": ["swidtag"] },
  "application/tamp-apex-update": { "source": "iana" },
  "application/tamp-apex-update-confirm": { "source": "iana" },
  "application/tamp-community-update": { "source": "iana" },
  "application/tamp-community-update-confirm": { "source": "iana" },
  "application/tamp-error": { "source": "iana" },
  "application/tamp-sequence-adjust": { "source": "iana" },
  "application/tamp-sequence-adjust-confirm": { "source": "iana" },
  "application/tamp-status-query": { "source": "iana" },
  "application/tamp-status-response": { "source": "iana" },
  "application/tamp-update": { "source": "iana" },
  "application/tamp-update-confirm": { "source": "iana" },
  "application/tar": { "compressible": true },
  "application/taxii+json": { "source": "iana", "compressible": true },
  "application/td+json": { "source": "iana", "compressible": true },
  "application/tei+xml": { "source": "iana", "compressible": true, "extensions": ["tei", "teicorpus"] },
  "application/tetra_isi": { "source": "iana" },
  "application/thraud+xml": { "source": "iana", "compressible": true, "extensions": ["tfi"] },
  "application/timestamp-query": { "source": "iana" },
  "application/timestamp-reply": { "source": "iana" },
  "application/timestamped-data": { "source": "iana", "extensions": ["tsd"] },
  "application/tlsrpt+gzip": { "source": "iana" },
  "application/tlsrpt+json": { "source": "iana", "compressible": true },
  "application/tnauthlist": { "source": "iana" },
  "application/token-introspection+jwt": { "source": "iana" },
  "application/toml": { "compressible": true, "extensions": ["toml"] },
  "application/trickle-ice-sdpfrag": { "source": "iana" },
  "application/trig": { "source": "iana", "extensions": ["trig"] },
  "application/ttml+xml": { "source": "iana", "compressible": true, "extensions": ["ttml"] },
  "application/tve-trigger": { "source": "iana" },
  "application/tzif": { "source": "iana" },
  "application/tzif-leap": { "source": "iana" },
  "application/ubjson": { "compressible": false, "extensions": ["ubj"] },
  "application/ulpfec": { "source": "iana" },
  "application/urc-grpsheet+xml": { "source": "iana", "compressible": true },
  "application/urc-ressheet+xml": { "source": "iana", "compressible": true, "extensions": ["rsheet"] },
  "application/urc-targetdesc+xml": { "source": "iana", "compressible": true, "extensions": ["td"] },
  "application/urc-uisocketdesc+xml": { "source": "iana", "compressible": true },
  "application/vcard+json": { "source": "iana", "compressible": true },
  "application/vcard+xml": { "source": "iana", "compressible": true },
  "application/vemmi": { "source": "iana" },
  "application/vividence.scriptfile": { "source": "apache" },
  "application/vnd.1000minds.decision-model+xml": { "source": "iana", "compressible": true, "extensions": ["1km"] },
  "application/vnd.3gpp-prose+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3ch+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-v2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.5gnas": { "source": "iana" },
  "application/vnd.3gpp.access-transfer-events+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.bsf+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gmop+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gtpc": { "source": "iana" },
  "application/vnd.3gpp.interworking-data": { "source": "iana" },
  "application/vnd.3gpp.lpp": { "source": "iana" },
  "application/vnd.3gpp.mc-signalling-ear": { "source": "iana" },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-payload": { "source": "iana" },
  "application/vnd.3gpp.mcdata-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-signalling": { "source": "iana" },
  "application/vnd.3gpp.mcdata-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-floor-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-signed+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mid-call+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ngap": { "source": "iana" },
  "application/vnd.3gpp.pfcp": { "source": "iana" },
  "application/vnd.3gpp.pic-bw-large": { "source": "iana", "extensions": ["plb"] },
  "application/vnd.3gpp.pic-bw-small": { "source": "iana", "extensions": ["psb"] },
  "application/vnd.3gpp.pic-bw-var": { "source": "iana", "extensions": ["pvb"] },
  "application/vnd.3gpp.s1ap": { "source": "iana" },
  "application/vnd.3gpp.sms": { "source": "iana" },
  "application/vnd.3gpp.sms+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-ext+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.state-and-event-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ussd+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.bcmcsinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.sms": { "source": "iana" },
  "application/vnd.3gpp2.tcap": { "source": "iana", "extensions": ["tcap"] },
  "application/vnd.3lightssoftware.imagescal": { "source": "iana" },
  "application/vnd.3m.post-it-notes": { "source": "iana", "extensions": ["pwn"] },
  "application/vnd.accpac.simply.aso": { "source": "iana", "extensions": ["aso"] },
  "application/vnd.accpac.simply.imp": { "source": "iana", "extensions": ["imp"] },
  "application/vnd.acucobol": { "source": "iana", "extensions": ["acu"] },
  "application/vnd.acucorp": { "source": "iana", "extensions": ["atc", "acutc"] },
  "application/vnd.adobe.air-application-installer-package+zip": { "source": "apache", "compressible": false, "extensions": ["air"] },
  "application/vnd.adobe.flash.movie": { "source": "iana" },
  "application/vnd.adobe.formscentral.fcdt": { "source": "iana", "extensions": ["fcdt"] },
  "application/vnd.adobe.fxp": { "source": "iana", "extensions": ["fxp", "fxpl"] },
  "application/vnd.adobe.partial-upload": { "source": "iana" },
  "application/vnd.adobe.xdp+xml": { "source": "iana", "compressible": true, "extensions": ["xdp"] },
  "application/vnd.adobe.xfdf": { "source": "iana", "extensions": ["xfdf"] },
  "application/vnd.aether.imp": { "source": "iana" },
  "application/vnd.afpc.afplinedata": { "source": "iana" },
  "application/vnd.afpc.afplinedata-pagedef": { "source": "iana" },
  "application/vnd.afpc.cmoca-cmresource": { "source": "iana" },
  "application/vnd.afpc.foca-charset": { "source": "iana" },
  "application/vnd.afpc.foca-codedfont": { "source": "iana" },
  "application/vnd.afpc.foca-codepage": { "source": "iana" },
  "application/vnd.afpc.modca": { "source": "iana" },
  "application/vnd.afpc.modca-cmtable": { "source": "iana" },
  "application/vnd.afpc.modca-formdef": { "source": "iana" },
  "application/vnd.afpc.modca-mediummap": { "source": "iana" },
  "application/vnd.afpc.modca-objectcontainer": { "source": "iana" },
  "application/vnd.afpc.modca-overlay": { "source": "iana" },
  "application/vnd.afpc.modca-pagesegment": { "source": "iana" },
  "application/vnd.age": { "source": "iana", "extensions": ["age"] },
  "application/vnd.ah-barcode": { "source": "iana" },
  "application/vnd.ahead.space": { "source": "iana", "extensions": ["ahead"] },
  "application/vnd.airzip.filesecure.azf": { "source": "iana", "extensions": ["azf"] },
  "application/vnd.airzip.filesecure.azs": { "source": "iana", "extensions": ["azs"] },
  "application/vnd.amadeus+json": { "source": "iana", "compressible": true },
  "application/vnd.amazon.ebook": { "source": "apache", "extensions": ["azw"] },
  "application/vnd.amazon.mobi8-ebook": { "source": "iana" },
  "application/vnd.americandynamics.acc": { "source": "iana", "extensions": ["acc"] },
  "application/vnd.amiga.ami": { "source": "iana", "extensions": ["ami"] },
  "application/vnd.amundsen.maze+xml": { "source": "iana", "compressible": true },
  "application/vnd.android.ota": { "source": "iana" },
  "application/vnd.android.package-archive": { "source": "apache", "compressible": false, "extensions": ["apk"] },
  "application/vnd.anki": { "source": "iana" },
  "application/vnd.anser-web-certificate-issue-initiation": { "source": "iana", "extensions": ["cii"] },
  "application/vnd.anser-web-funds-transfer-initiation": { "source": "apache", "extensions": ["fti"] },
  "application/vnd.antix.game-component": { "source": "iana", "extensions": ["atx"] },
  "application/vnd.apache.arrow.file": { "source": "iana" },
  "application/vnd.apache.arrow.stream": { "source": "iana" },
  "application/vnd.apache.thrift.binary": { "source": "iana" },
  "application/vnd.apache.thrift.compact": { "source": "iana" },
  "application/vnd.apache.thrift.json": { "source": "iana" },
  "application/vnd.api+json": { "source": "iana", "compressible": true },
  "application/vnd.aplextor.warrp+json": { "source": "iana", "compressible": true },
  "application/vnd.apothekende.reservation+json": { "source": "iana", "compressible": true },
  "application/vnd.apple.installer+xml": { "source": "iana", "compressible": true, "extensions": ["mpkg"] },
  "application/vnd.apple.keynote": { "source": "iana", "extensions": ["key"] },
  "application/vnd.apple.mpegurl": { "source": "iana", "extensions": ["m3u8"] },
  "application/vnd.apple.numbers": { "source": "iana", "extensions": ["numbers"] },
  "application/vnd.apple.pages": { "source": "iana", "extensions": ["pages"] },
  "application/vnd.apple.pkpass": { "compressible": false, "extensions": ["pkpass"] },
  "application/vnd.arastra.swi": { "source": "iana" },
  "application/vnd.aristanetworks.swi": { "source": "iana", "extensions": ["swi"] },
  "application/vnd.artisan+json": { "source": "iana", "compressible": true },
  "application/vnd.artsquare": { "source": "iana" },
  "application/vnd.astraea-software.iota": { "source": "iana", "extensions": ["iota"] },
  "application/vnd.audiograph": { "source": "iana", "extensions": ["aep"] },
  "application/vnd.autopackage": { "source": "iana" },
  "application/vnd.avalon+json": { "source": "iana", "compressible": true },
  "application/vnd.avistar+xml": { "source": "iana", "compressible": true },
  "application/vnd.balsamiq.bmml+xml": { "source": "iana", "compressible": true, "extensions": ["bmml"] },
  "application/vnd.balsamiq.bmpr": { "source": "iana" },
  "application/vnd.banana-accounting": { "source": "iana" },
  "application/vnd.bbf.usp.error": { "source": "iana" },
  "application/vnd.bbf.usp.msg": { "source": "iana" },
  "application/vnd.bbf.usp.msg+json": { "source": "iana", "compressible": true },
  "application/vnd.bekitzur-stech+json": { "source": "iana", "compressible": true },
  "application/vnd.bint.med-content": { "source": "iana" },
  "application/vnd.biopax.rdf+xml": { "source": "iana", "compressible": true },
  "application/vnd.blink-idb-value-wrapper": { "source": "iana" },
  "application/vnd.blueice.multipass": { "source": "iana", "extensions": ["mpm"] },
  "application/vnd.bluetooth.ep.oob": { "source": "iana" },
  "application/vnd.bluetooth.le.oob": { "source": "iana" },
  "application/vnd.bmi": { "source": "iana", "extensions": ["bmi"] },
  "application/vnd.bpf": { "source": "iana" },
  "application/vnd.bpf3": { "source": "iana" },
  "application/vnd.businessobjects": { "source": "iana", "extensions": ["rep"] },
  "application/vnd.byu.uapi+json": { "source": "iana", "compressible": true },
  "application/vnd.cab-jscript": { "source": "iana" },
  "application/vnd.canon-cpdl": { "source": "iana" },
  "application/vnd.canon-lips": { "source": "iana" },
  "application/vnd.capasystems-pg+json": { "source": "iana", "compressible": true },
  "application/vnd.cendio.thinlinc.clientconf": { "source": "iana" },
  "application/vnd.century-systems.tcp_stream": { "source": "iana" },
  "application/vnd.chemdraw+xml": { "source": "iana", "compressible": true, "extensions": ["cdxml"] },
  "application/vnd.chess-pgn": { "source": "iana" },
  "application/vnd.chipnuts.karaoke-mmd": { "source": "iana", "extensions": ["mmd"] },
  "application/vnd.ciedi": { "source": "iana" },
  "application/vnd.cinderella": { "source": "iana", "extensions": ["cdy"] },
  "application/vnd.cirpack.isdn-ext": { "source": "iana" },
  "application/vnd.citationstyles.style+xml": { "source": "iana", "compressible": true, "extensions": ["csl"] },
  "application/vnd.claymore": { "source": "iana", "extensions": ["cla"] },
  "application/vnd.cloanto.rp9": { "source": "iana", "extensions": ["rp9"] },
  "application/vnd.clonk.c4group": { "source": "iana", "extensions": ["c4g", "c4d", "c4f", "c4p", "c4u"] },
  "application/vnd.cluetrust.cartomobile-config": { "source": "iana", "extensions": ["c11amc"] },
  "application/vnd.cluetrust.cartomobile-config-pkg": { "source": "iana", "extensions": ["c11amz"] },
  "application/vnd.coffeescript": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet-template": { "source": "iana" },
  "application/vnd.collection+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.doc+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.next+json": { "source": "iana", "compressible": true },
  "application/vnd.comicbook+zip": { "source": "iana", "compressible": false },
  "application/vnd.comicbook-rar": { "source": "iana" },
  "application/vnd.commerce-battelle": { "source": "iana" },
  "application/vnd.commonspace": { "source": "iana", "extensions": ["csp"] },
  "application/vnd.contact.cmsg": { "source": "iana", "extensions": ["cdbcmsg"] },
  "application/vnd.coreos.ignition+json": { "source": "iana", "compressible": true },
  "application/vnd.cosmocaller": { "source": "iana", "extensions": ["cmc"] },
  "application/vnd.crick.clicker": { "source": "iana", "extensions": ["clkx"] },
  "application/vnd.crick.clicker.keyboard": { "source": "iana", "extensions": ["clkk"] },
  "application/vnd.crick.clicker.palette": { "source": "iana", "extensions": ["clkp"] },
  "application/vnd.crick.clicker.template": { "source": "iana", "extensions": ["clkt"] },
  "application/vnd.crick.clicker.wordbank": { "source": "iana", "extensions": ["clkw"] },
  "application/vnd.criticaltools.wbs+xml": { "source": "iana", "compressible": true, "extensions": ["wbs"] },
  "application/vnd.cryptii.pipe+json": { "source": "iana", "compressible": true },
  "application/vnd.crypto-shade-file": { "source": "iana" },
  "application/vnd.cryptomator.encrypted": { "source": "iana" },
  "application/vnd.cryptomator.vault": { "source": "iana" },
  "application/vnd.ctc-posml": { "source": "iana", "extensions": ["pml"] },
  "application/vnd.ctct.ws+xml": { "source": "iana", "compressible": true },
  "application/vnd.cups-pdf": { "source": "iana" },
  "application/vnd.cups-postscript": { "source": "iana" },
  "application/vnd.cups-ppd": { "source": "iana", "extensions": ["ppd"] },
  "application/vnd.cups-raster": { "source": "iana" },
  "application/vnd.cups-raw": { "source": "iana" },
  "application/vnd.curl": { "source": "iana" },
  "application/vnd.curl.car": { "source": "apache", "extensions": ["car"] },
  "application/vnd.curl.pcurl": { "source": "apache", "extensions": ["pcurl"] },
  "application/vnd.cyan.dean.root+xml": { "source": "iana", "compressible": true },
  "application/vnd.cybank": { "source": "iana" },
  "application/vnd.cyclonedx+json": { "source": "iana", "compressible": true },
  "application/vnd.cyclonedx+xml": { "source": "iana", "compressible": true },
  "application/vnd.d2l.coursepackage1p0+zip": { "source": "iana", "compressible": false },
  "application/vnd.d3m-dataset": { "source": "iana" },
  "application/vnd.d3m-problem": { "source": "iana" },
  "application/vnd.dart": { "source": "iana", "compressible": true, "extensions": ["dart"] },
  "application/vnd.data-vision.rdz": { "source": "iana", "extensions": ["rdz"] },
  "application/vnd.datapackage+json": { "source": "iana", "compressible": true },
  "application/vnd.dataresource+json": { "source": "iana", "compressible": true },
  "application/vnd.dbf": { "source": "iana", "extensions": ["dbf"] },
  "application/vnd.debian.binary-package": { "source": "iana" },
  "application/vnd.dece.data": { "source": "iana", "extensions": ["uvf", "uvvf", "uvd", "uvvd"] },
  "application/vnd.dece.ttml+xml": { "source": "iana", "compressible": true, "extensions": ["uvt", "uvvt"] },
  "application/vnd.dece.unspecified": { "source": "iana", "extensions": ["uvx", "uvvx"] },
  "application/vnd.dece.zip": { "source": "iana", "extensions": ["uvz", "uvvz"] },
  "application/vnd.denovo.fcselayout-link": { "source": "iana", "extensions": ["fe_launch"] },
  "application/vnd.desmume.movie": { "source": "iana" },
  "application/vnd.dir-bi.plate-dl-nosuffix": { "source": "iana" },
  "application/vnd.dm.delegation+xml": { "source": "iana", "compressible": true },
  "application/vnd.dna": { "source": "iana", "extensions": ["dna"] },
  "application/vnd.document+json": { "source": "iana", "compressible": true },
  "application/vnd.dolby.mlp": { "source": "apache", "extensions": ["mlp"] },
  "application/vnd.dolby.mobile.1": { "source": "iana" },
  "application/vnd.dolby.mobile.2": { "source": "iana" },
  "application/vnd.doremir.scorecloud-binary-document": { "source": "iana" },
  "application/vnd.dpgraph": { "source": "iana", "extensions": ["dpg"] },
  "application/vnd.dreamfactory": { "source": "iana", "extensions": ["dfac"] },
  "application/vnd.drive+json": { "source": "iana", "compressible": true },
  "application/vnd.ds-keypoint": { "source": "apache", "extensions": ["kpxx"] },
  "application/vnd.dtg.local": { "source": "iana" },
  "application/vnd.dtg.local.flash": { "source": "iana" },
  "application/vnd.dtg.local.html": { "source": "iana" },
  "application/vnd.dvb.ait": { "source": "iana", "extensions": ["ait"] },
  "application/vnd.dvb.dvbisl+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.dvbj": { "source": "iana" },
  "application/vnd.dvb.esgcontainer": { "source": "iana" },
  "application/vnd.dvb.ipdcdftnotifaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess2": { "source": "iana" },
  "application/vnd.dvb.ipdcesgpdd": { "source": "iana" },
  "application/vnd.dvb.ipdcroaming": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-base": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-enhancement": { "source": "iana" },
  "application/vnd.dvb.notif-aggregate-root+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-container+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-generic+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-msglist+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-response+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-init+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.pfr": { "source": "iana" },
  "application/vnd.dvb.service": { "source": "iana", "extensions": ["svc"] },
  "application/vnd.dxr": { "source": "iana" },
  "application/vnd.dynageo": { "source": "iana", "extensions": ["geo"] },
  "application/vnd.dzr": { "source": "iana" },
  "application/vnd.easykaraoke.cdgdownload": { "source": "iana" },
  "application/vnd.ecdis-update": { "source": "iana" },
  "application/vnd.ecip.rlp": { "source": "iana" },
  "application/vnd.eclipse.ditto+json": { "source": "iana", "compressible": true },
  "application/vnd.ecowin.chart": { "source": "iana", "extensions": ["mag"] },
  "application/vnd.ecowin.filerequest": { "source": "iana" },
  "application/vnd.ecowin.fileupdate": { "source": "iana" },
  "application/vnd.ecowin.series": { "source": "iana" },
  "application/vnd.ecowin.seriesrequest": { "source": "iana" },
  "application/vnd.ecowin.seriesupdate": { "source": "iana" },
  "application/vnd.efi.img": { "source": "iana" },
  "application/vnd.efi.iso": { "source": "iana" },
  "application/vnd.emclient.accessrequest+xml": { "source": "iana", "compressible": true },
  "application/vnd.enliven": { "source": "iana", "extensions": ["nml"] },
  "application/vnd.enphase.envoy": { "source": "iana" },
  "application/vnd.eprints.data+xml": { "source": "iana", "compressible": true },
  "application/vnd.epson.esf": { "source": "iana", "extensions": ["esf"] },
  "application/vnd.epson.msf": { "source": "iana", "extensions": ["msf"] },
  "application/vnd.epson.quickanime": { "source": "iana", "extensions": ["qam"] },
  "application/vnd.epson.salt": { "source": "iana", "extensions": ["slt"] },
  "application/vnd.epson.ssf": { "source": "iana", "extensions": ["ssf"] },
  "application/vnd.ericsson.quickcall": { "source": "iana" },
  "application/vnd.espass-espass+zip": { "source": "iana", "compressible": false },
  "application/vnd.eszigno3+xml": { "source": "iana", "compressible": true, "extensions": ["es3", "et3"] },
  "application/vnd.etsi.aoc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.asic-e+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.asic-s+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.cug+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvcommand+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-bc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-cod+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-npvr+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvservice+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsync+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mcid+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mheg5": { "source": "iana" },
  "application/vnd.etsi.overload-control-policy-dataset+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.pstn+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.sci+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.simservs+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.timestamp-token": { "source": "iana" },
  "application/vnd.etsi.tsl+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.tsl.der": { "source": "iana" },
  "application/vnd.eu.kasparian.car+json": { "source": "iana", "compressible": true },
  "application/vnd.eudora.data": { "source": "iana" },
  "application/vnd.evolv.ecig.profile": { "source": "iana" },
  "application/vnd.evolv.ecig.settings": { "source": "iana" },
  "application/vnd.evolv.ecig.theme": { "source": "iana" },
  "application/vnd.exstream-empower+zip": { "source": "iana", "compressible": false },
  "application/vnd.exstream-package": { "source": "iana" },
  "application/vnd.ezpix-album": { "source": "iana", "extensions": ["ez2"] },
  "application/vnd.ezpix-package": { "source": "iana", "extensions": ["ez3"] },
  "application/vnd.f-secure.mobile": { "source": "iana" },
  "application/vnd.familysearch.gedcom+zip": { "source": "iana", "compressible": false },
  "application/vnd.fastcopy-disk-image": { "source": "iana" },
  "application/vnd.fdf": { "source": "iana", "extensions": ["fdf"] },
  "application/vnd.fdsn.mseed": { "source": "iana", "extensions": ["mseed"] },
  "application/vnd.fdsn.seed": { "source": "iana", "extensions": ["seed", "dataless"] },
  "application/vnd.ffsns": { "source": "iana" },
  "application/vnd.ficlab.flb+zip": { "source": "iana", "compressible": false },
  "application/vnd.filmit.zfc": { "source": "iana" },
  "application/vnd.fints": { "source": "iana" },
  "application/vnd.firemonkeys.cloudcell": { "source": "iana" },
  "application/vnd.flographit": { "source": "iana", "extensions": ["gph"] },
  "application/vnd.fluxtime.clip": { "source": "iana", "extensions": ["ftc"] },
  "application/vnd.font-fontforge-sfd": { "source": "iana" },
  "application/vnd.framemaker": { "source": "iana", "extensions": ["fm", "frame", "maker", "book"] },
  "application/vnd.frogans.fnc": { "source": "iana", "extensions": ["fnc"] },
  "application/vnd.frogans.ltf": { "source": "iana", "extensions": ["ltf"] },
  "application/vnd.fsc.weblaunch": { "source": "iana", "extensions": ["fsc"] },
  "application/vnd.fujifilm.fb.docuworks": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.binder": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.container": { "source": "iana" },
  "application/vnd.fujifilm.fb.jfi+xml": { "source": "iana", "compressible": true },
  "application/vnd.fujitsu.oasys": { "source": "iana", "extensions": ["oas"] },
  "application/vnd.fujitsu.oasys2": { "source": "iana", "extensions": ["oa2"] },
  "application/vnd.fujitsu.oasys3": { "source": "iana", "extensions": ["oa3"] },
  "application/vnd.fujitsu.oasysgp": { "source": "iana", "extensions": ["fg5"] },
  "application/vnd.fujitsu.oasysprs": { "source": "iana", "extensions": ["bh2"] },
  "application/vnd.fujixerox.art-ex": { "source": "iana" },
  "application/vnd.fujixerox.art4": { "source": "iana" },
  "application/vnd.fujixerox.ddd": { "source": "iana", "extensions": ["ddd"] },
  "application/vnd.fujixerox.docuworks": { "source": "iana", "extensions": ["xdw"] },
  "application/vnd.fujixerox.docuworks.binder": { "source": "iana", "extensions": ["xbd"] },
  "application/vnd.fujixerox.docuworks.container": { "source": "iana" },
  "application/vnd.fujixerox.hbpl": { "source": "iana" },
  "application/vnd.fut-misnet": { "source": "iana" },
  "application/vnd.futoin+cbor": { "source": "iana" },
  "application/vnd.futoin+json": { "source": "iana", "compressible": true },
  "application/vnd.fuzzysheet": { "source": "iana", "extensions": ["fzs"] },
  "application/vnd.genomatix.tuxedo": { "source": "iana", "extensions": ["txd"] },
  "application/vnd.gentics.grd+json": { "source": "iana", "compressible": true },
  "application/vnd.geo+json": { "source": "iana", "compressible": true },
  "application/vnd.geocube+xml": { "source": "iana", "compressible": true },
  "application/vnd.geogebra.file": { "source": "iana", "extensions": ["ggb"] },
  "application/vnd.geogebra.slides": { "source": "iana" },
  "application/vnd.geogebra.tool": { "source": "iana", "extensions": ["ggt"] },
  "application/vnd.geometry-explorer": { "source": "iana", "extensions": ["gex", "gre"] },
  "application/vnd.geonext": { "source": "iana", "extensions": ["gxt"] },
  "application/vnd.geoplan": { "source": "iana", "extensions": ["g2w"] },
  "application/vnd.geospace": { "source": "iana", "extensions": ["g3w"] },
  "application/vnd.gerber": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt-response": { "source": "iana" },
  "application/vnd.gmx": { "source": "iana", "extensions": ["gmx"] },
  "application/vnd.google-apps.document": { "compressible": false, "extensions": ["gdoc"] },
  "application/vnd.google-apps.presentation": { "compressible": false, "extensions": ["gslides"] },
  "application/vnd.google-apps.spreadsheet": { "compressible": false, "extensions": ["gsheet"] },
  "application/vnd.google-earth.kml+xml": { "source": "iana", "compressible": true, "extensions": ["kml"] },
  "application/vnd.google-earth.kmz": { "source": "iana", "compressible": false, "extensions": ["kmz"] },
  "application/vnd.gov.sk.e-form+xml": { "source": "iana", "compressible": true },
  "application/vnd.gov.sk.e-form+zip": { "source": "iana", "compressible": false },
  "application/vnd.gov.sk.xmldatacontainer+xml": { "source": "iana", "compressible": true },
  "application/vnd.grafeq": { "source": "iana", "extensions": ["gqf", "gqs"] },
  "application/vnd.gridmp": { "source": "iana" },
  "application/vnd.groove-account": { "source": "iana", "extensions": ["gac"] },
  "application/vnd.groove-help": { "source": "iana", "extensions": ["ghf"] },
  "application/vnd.groove-identity-message": { "source": "iana", "extensions": ["gim"] },
  "application/vnd.groove-injector": { "source": "iana", "extensions": ["grv"] },
  "application/vnd.groove-tool-message": { "source": "iana", "extensions": ["gtm"] },
  "application/vnd.groove-tool-template": { "source": "iana", "extensions": ["tpl"] },
  "application/vnd.groove-vcard": { "source": "iana", "extensions": ["vcg"] },
  "application/vnd.hal+json": { "source": "iana", "compressible": true },
  "application/vnd.hal+xml": { "source": "iana", "compressible": true, "extensions": ["hal"] },
  "application/vnd.handheld-entertainment+xml": { "source": "iana", "compressible": true, "extensions": ["zmm"] },
  "application/vnd.hbci": { "source": "iana", "extensions": ["hbci"] },
  "application/vnd.hc+json": { "source": "iana", "compressible": true },
  "application/vnd.hcl-bireports": { "source": "iana" },
  "application/vnd.hdt": { "source": "iana" },
  "application/vnd.heroku+json": { "source": "iana", "compressible": true },
  "application/vnd.hhe.lesson-player": { "source": "iana", "extensions": ["les"] },
  "application/vnd.hl7cda+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.hl7v2+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.hp-hpgl": { "source": "iana", "extensions": ["hpgl"] },
  "application/vnd.hp-hpid": { "source": "iana", "extensions": ["hpid"] },
  "application/vnd.hp-hps": { "source": "iana", "extensions": ["hps"] },
  "application/vnd.hp-jlyt": { "source": "iana", "extensions": ["jlt"] },
  "application/vnd.hp-pcl": { "source": "iana", "extensions": ["pcl"] },
  "application/vnd.hp-pclxl": { "source": "iana", "extensions": ["pclxl"] },
  "application/vnd.httphone": { "source": "iana" },
  "application/vnd.hydrostatix.sof-data": { "source": "iana", "extensions": ["sfd-hdstx"] },
  "application/vnd.hyper+json": { "source": "iana", "compressible": true },
  "application/vnd.hyper-item+json": { "source": "iana", "compressible": true },
  "application/vnd.hyperdrive+json": { "source": "iana", "compressible": true },
  "application/vnd.hzn-3d-crossword": { "source": "iana" },
  "application/vnd.ibm.afplinedata": { "source": "iana" },
  "application/vnd.ibm.electronic-media": { "source": "iana" },
  "application/vnd.ibm.minipay": { "source": "iana", "extensions": ["mpy"] },
  "application/vnd.ibm.modcap": { "source": "iana", "extensions": ["afp", "listafp", "list3820"] },
  "application/vnd.ibm.rights-management": { "source": "iana", "extensions": ["irm"] },
  "application/vnd.ibm.secure-container": { "source": "iana", "extensions": ["sc"] },
  "application/vnd.iccprofile": { "source": "iana", "extensions": ["icc", "icm"] },
  "application/vnd.ieee.1905": { "source": "iana" },
  "application/vnd.igloader": { "source": "iana", "extensions": ["igl"] },
  "application/vnd.imagemeter.folder+zip": { "source": "iana", "compressible": false },
  "application/vnd.imagemeter.image+zip": { "source": "iana", "compressible": false },
  "application/vnd.immervision-ivp": { "source": "iana", "extensions": ["ivp"] },
  "application/vnd.immervision-ivu": { "source": "iana", "extensions": ["ivu"] },
  "application/vnd.ims.imsccv1p1": { "source": "iana" },
  "application/vnd.ims.imsccv1p2": { "source": "iana" },
  "application/vnd.ims.imsccv1p3": { "source": "iana" },
  "application/vnd.ims.lis.v2.result+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy.id+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": { "source": "iana", "compressible": true },
  "application/vnd.informedcontrol.rms+xml": { "source": "iana", "compressible": true },
  "application/vnd.informix-visionary": { "source": "iana" },
  "application/vnd.infotech.project": { "source": "iana" },
  "application/vnd.infotech.project+xml": { "source": "iana", "compressible": true },
  "application/vnd.innopath.wamp.notification": { "source": "iana" },
  "application/vnd.insors.igm": { "source": "iana", "extensions": ["igm"] },
  "application/vnd.intercon.formnet": { "source": "iana", "extensions": ["xpw", "xpx"] },
  "application/vnd.intergeo": { "source": "iana", "extensions": ["i2g"] },
  "application/vnd.intertrust.digibox": { "source": "iana" },
  "application/vnd.intertrust.nncp": { "source": "iana" },
  "application/vnd.intu.qbo": { "source": "iana", "extensions": ["qbo"] },
  "application/vnd.intu.qfx": { "source": "iana", "extensions": ["qfx"] },
  "application/vnd.iptc.g2.catalogitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.conceptitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.knowledgeitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.packageitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.planningitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.ipunplugged.rcprofile": { "source": "iana", "extensions": ["rcprofile"] },
  "application/vnd.irepository.package+xml": { "source": "iana", "compressible": true, "extensions": ["irp"] },
  "application/vnd.is-xpr": { "source": "iana", "extensions": ["xpr"] },
  "application/vnd.isac.fcs": { "source": "iana", "extensions": ["fcs"] },
  "application/vnd.iso11783-10+zip": { "source": "iana", "compressible": false },
  "application/vnd.jam": { "source": "iana", "extensions": ["jam"] },
  "application/vnd.japannet-directory-service": { "source": "iana" },
  "application/vnd.japannet-jpnstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-payment-wakeup": { "source": "iana" },
  "application/vnd.japannet-registration": { "source": "iana" },
  "application/vnd.japannet-registration-wakeup": { "source": "iana" },
  "application/vnd.japannet-setstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-verification": { "source": "iana" },
  "application/vnd.japannet-verification-wakeup": { "source": "iana" },
  "application/vnd.jcp.javame.midlet-rms": { "source": "iana", "extensions": ["rms"] },
  "application/vnd.jisp": { "source": "iana", "extensions": ["jisp"] },
  "application/vnd.joost.joda-archive": { "source": "iana", "extensions": ["joda"] },
  "application/vnd.jsk.isdn-ngn": { "source": "iana" },
  "application/vnd.kahootz": { "source": "iana", "extensions": ["ktz", "ktr"] },
  "application/vnd.kde.karbon": { "source": "iana", "extensions": ["karbon"] },
  "application/vnd.kde.kchart": { "source": "iana", "extensions": ["chrt"] },
  "application/vnd.kde.kformula": { "source": "iana", "extensions": ["kfo"] },
  "application/vnd.kde.kivio": { "source": "iana", "extensions": ["flw"] },
  "application/vnd.kde.kontour": { "source": "iana", "extensions": ["kon"] },
  "application/vnd.kde.kpresenter": { "source": "iana", "extensions": ["kpr", "kpt"] },
  "application/vnd.kde.kspread": { "source": "iana", "extensions": ["ksp"] },
  "application/vnd.kde.kword": { "source": "iana", "extensions": ["kwd", "kwt"] },
  "application/vnd.kenameaapp": { "source": "iana", "extensions": ["htke"] },
  "application/vnd.kidspiration": { "source": "iana", "extensions": ["kia"] },
  "application/vnd.kinar": { "source": "iana", "extensions": ["kne", "knp"] },
  "application/vnd.koan": { "source": "iana", "extensions": ["skp", "skd", "skt", "skm"] },
  "application/vnd.kodak-descriptor": { "source": "iana", "extensions": ["sse"] },
  "application/vnd.las": { "source": "iana" },
  "application/vnd.las.las+json": { "source": "iana", "compressible": true },
  "application/vnd.las.las+xml": { "source": "iana", "compressible": true, "extensions": ["lasxml"] },
  "application/vnd.laszip": { "source": "iana" },
  "application/vnd.leap+json": { "source": "iana", "compressible": true },
  "application/vnd.liberty-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.llamagraphics.life-balance.desktop": { "source": "iana", "extensions": ["lbd"] },
  "application/vnd.llamagraphics.life-balance.exchange+xml": { "source": "iana", "compressible": true, "extensions": ["lbe"] },
  "application/vnd.logipipe.circuit+zip": { "source": "iana", "compressible": false },
  "application/vnd.loom": { "source": "iana" },
  "application/vnd.lotus-1-2-3": { "source": "iana", "extensions": ["123"] },
  "application/vnd.lotus-approach": { "source": "iana", "extensions": ["apr"] },
  "application/vnd.lotus-freelance": { "source": "iana", "extensions": ["pre"] },
  "application/vnd.lotus-notes": { "source": "iana", "extensions": ["nsf"] },
  "application/vnd.lotus-organizer": { "source": "iana", "extensions": ["org"] },
  "application/vnd.lotus-screencam": { "source": "iana", "extensions": ["scm"] },
  "application/vnd.lotus-wordpro": { "source": "iana", "extensions": ["lwp"] },
  "application/vnd.macports.portpkg": { "source": "iana", "extensions": ["portpkg"] },
  "application/vnd.mapbox-vector-tile": { "source": "iana", "extensions": ["mvt"] },
  "application/vnd.marlin.drm.actiontoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.conftoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.license+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.mdcf": { "source": "iana" },
  "application/vnd.mason+json": { "source": "iana", "compressible": true },
  "application/vnd.maxar.archive.3tz+zip": { "source": "iana", "compressible": false },
  "application/vnd.maxmind.maxmind-db": { "source": "iana" },
  "application/vnd.mcd": { "source": "iana", "extensions": ["mcd"] },
  "application/vnd.medcalcdata": { "source": "iana", "extensions": ["mc1"] },
  "application/vnd.mediastation.cdkey": { "source": "iana", "extensions": ["cdkey"] },
  "application/vnd.meridian-slingshot": { "source": "iana" },
  "application/vnd.mfer": { "source": "iana", "extensions": ["mwf"] },
  "application/vnd.mfmp": { "source": "iana", "extensions": ["mfm"] },
  "application/vnd.micro+json": { "source": "iana", "compressible": true },
  "application/vnd.micrografx.flo": { "source": "iana", "extensions": ["flo"] },
  "application/vnd.micrografx.igx": { "source": "iana", "extensions": ["igx"] },
  "application/vnd.microsoft.portable-executable": { "source": "iana" },
  "application/vnd.microsoft.windows.thumbnail-cache": { "source": "iana" },
  "application/vnd.miele+json": { "source": "iana", "compressible": true },
  "application/vnd.mif": { "source": "iana", "extensions": ["mif"] },
  "application/vnd.minisoft-hp3000-save": { "source": "iana" },
  "application/vnd.mitsubishi.misty-guard.trustweb": { "source": "iana" },
  "application/vnd.mobius.daf": { "source": "iana", "extensions": ["daf"] },
  "application/vnd.mobius.dis": { "source": "iana", "extensions": ["dis"] },
  "application/vnd.mobius.mbk": { "source": "iana", "extensions": ["mbk"] },
  "application/vnd.mobius.mqy": { "source": "iana", "extensions": ["mqy"] },
  "application/vnd.mobius.msl": { "source": "iana", "extensions": ["msl"] },
  "application/vnd.mobius.plc": { "source": "iana", "extensions": ["plc"] },
  "application/vnd.mobius.txf": { "source": "iana", "extensions": ["txf"] },
  "application/vnd.mophun.application": { "source": "iana", "extensions": ["mpn"] },
  "application/vnd.mophun.certificate": { "source": "iana", "extensions": ["mpc"] },
  "application/vnd.motorola.flexsuite": { "source": "iana" },
  "application/vnd.motorola.flexsuite.adsi": { "source": "iana" },
  "application/vnd.motorola.flexsuite.fis": { "source": "iana" },
  "application/vnd.motorola.flexsuite.gotap": { "source": "iana" },
  "application/vnd.motorola.flexsuite.kmr": { "source": "iana" },
  "application/vnd.motorola.flexsuite.ttc": { "source": "iana" },
  "application/vnd.motorola.flexsuite.wem": { "source": "iana" },
  "application/vnd.motorola.iprm": { "source": "iana" },
  "application/vnd.mozilla.xul+xml": { "source": "iana", "compressible": true, "extensions": ["xul"] },
  "application/vnd.ms-3mfdocument": { "source": "iana" },
  "application/vnd.ms-artgalry": { "source": "iana", "extensions": ["cil"] },
  "application/vnd.ms-asf": { "source": "iana" },
  "application/vnd.ms-cab-compressed": { "source": "iana", "extensions": ["cab"] },
  "application/vnd.ms-color.iccprofile": { "source": "apache" },
  "application/vnd.ms-excel": { "source": "iana", "compressible": false, "extensions": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"] },
  "application/vnd.ms-excel.addin.macroenabled.12": { "source": "iana", "extensions": ["xlam"] },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": { "source": "iana", "extensions": ["xlsb"] },
  "application/vnd.ms-excel.sheet.macroenabled.12": { "source": "iana", "extensions": ["xlsm"] },
  "application/vnd.ms-excel.template.macroenabled.12": { "source": "iana", "extensions": ["xltm"] },
  "application/vnd.ms-fontobject": { "source": "iana", "compressible": true, "extensions": ["eot"] },
  "application/vnd.ms-htmlhelp": { "source": "iana", "extensions": ["chm"] },
  "application/vnd.ms-ims": { "source": "iana", "extensions": ["ims"] },
  "application/vnd.ms-lrm": { "source": "iana", "extensions": ["lrm"] },
  "application/vnd.ms-office.activex+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-officetheme": { "source": "iana", "extensions": ["thmx"] },
  "application/vnd.ms-opentype": { "source": "apache", "compressible": true },
  "application/vnd.ms-outlook": { "compressible": false, "extensions": ["msg"] },
  "application/vnd.ms-package.obfuscated-opentype": { "source": "apache" },
  "application/vnd.ms-pki.seccat": { "source": "apache", "extensions": ["cat"] },
  "application/vnd.ms-pki.stl": { "source": "apache", "extensions": ["stl"] },
  "application/vnd.ms-playready.initiator+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-powerpoint": { "source": "iana", "compressible": false, "extensions": ["ppt", "pps", "pot"] },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": { "source": "iana", "extensions": ["ppam"] },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": { "source": "iana", "extensions": ["pptm"] },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": { "source": "iana", "extensions": ["sldm"] },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": { "source": "iana", "extensions": ["ppsm"] },
  "application/vnd.ms-powerpoint.template.macroenabled.12": { "source": "iana", "extensions": ["potm"] },
  "application/vnd.ms-printdevicecapabilities+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-printing.printticket+xml": { "source": "apache", "compressible": true },
  "application/vnd.ms-printschematicket+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-project": { "source": "iana", "extensions": ["mpp", "mpt"] },
  "application/vnd.ms-tnef": { "source": "iana" },
  "application/vnd.ms-windows.devicepairing": { "source": "iana" },
  "application/vnd.ms-windows.nwprinting.oob": { "source": "iana" },
  "application/vnd.ms-windows.printerpairing": { "source": "iana" },
  "application/vnd.ms-windows.wsd.oob": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-resp": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-resp": { "source": "iana" },
  "application/vnd.ms-word.document.macroenabled.12": { "source": "iana", "extensions": ["docm"] },
  "application/vnd.ms-word.template.macroenabled.12": { "source": "iana", "extensions": ["dotm"] },
  "application/vnd.ms-works": { "source": "iana", "extensions": ["wps", "wks", "wcm", "wdb"] },
  "application/vnd.ms-wpl": { "source": "iana", "extensions": ["wpl"] },
  "application/vnd.ms-xpsdocument": { "source": "iana", "compressible": false, "extensions": ["xps"] },
  "application/vnd.msa-disk-image": { "source": "iana" },
  "application/vnd.mseq": { "source": "iana", "extensions": ["mseq"] },
  "application/vnd.msign": { "source": "iana" },
  "application/vnd.multiad.creator": { "source": "iana" },
  "application/vnd.multiad.creator.cif": { "source": "iana" },
  "application/vnd.music-niff": { "source": "iana" },
  "application/vnd.musician": { "source": "iana", "extensions": ["mus"] },
  "application/vnd.muvee.style": { "source": "iana", "extensions": ["msty"] },
  "application/vnd.mynfc": { "source": "iana", "extensions": ["taglet"] },
  "application/vnd.nacamar.ybrid+json": { "source": "iana", "compressible": true },
  "application/vnd.ncd.control": { "source": "iana" },
  "application/vnd.ncd.reference": { "source": "iana" },
  "application/vnd.nearst.inv+json": { "source": "iana", "compressible": true },
  "application/vnd.nebumind.line": { "source": "iana" },
  "application/vnd.nervana": { "source": "iana" },
  "application/vnd.netfpx": { "source": "iana" },
  "application/vnd.neurolanguage.nlu": { "source": "iana", "extensions": ["nlu"] },
  "application/vnd.nimn": { "source": "iana" },
  "application/vnd.nintendo.nitro.rom": { "source": "iana" },
  "application/vnd.nintendo.snes.rom": { "source": "iana" },
  "application/vnd.nitf": { "source": "iana", "extensions": ["ntf", "nitf"] },
  "application/vnd.noblenet-directory": { "source": "iana", "extensions": ["nnd"] },
  "application/vnd.noblenet-sealer": { "source": "iana", "extensions": ["nns"] },
  "application/vnd.noblenet-web": { "source": "iana", "extensions": ["nnw"] },
  "application/vnd.nokia.catalogs": { "source": "iana" },
  "application/vnd.nokia.conml+wbxml": { "source": "iana" },
  "application/vnd.nokia.conml+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.iptv.config+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.isds-radio-presets": { "source": "iana" },
  "application/vnd.nokia.landmark+wbxml": { "source": "iana" },
  "application/vnd.nokia.landmark+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.landmarkcollection+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.n-gage.ac+xml": { "source": "iana", "compressible": true, "extensions": ["ac"] },
  "application/vnd.nokia.n-gage.data": { "source": "iana", "extensions": ["ngdat"] },
  "application/vnd.nokia.n-gage.symbian.install": { "source": "iana", "extensions": ["n-gage"] },
  "application/vnd.nokia.ncd": { "source": "iana" },
  "application/vnd.nokia.pcd+wbxml": { "source": "iana" },
  "application/vnd.nokia.pcd+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.radio-preset": { "source": "iana", "extensions": ["rpst"] },
  "application/vnd.nokia.radio-presets": { "source": "iana", "extensions": ["rpss"] },
  "application/vnd.novadigm.edm": { "source": "iana", "extensions": ["edm"] },
  "application/vnd.novadigm.edx": { "source": "iana", "extensions": ["edx"] },
  "application/vnd.novadigm.ext": { "source": "iana", "extensions": ["ext"] },
  "application/vnd.ntt-local.content-share": { "source": "iana" },
  "application/vnd.ntt-local.file-transfer": { "source": "iana" },
  "application/vnd.ntt-local.ogw_remote-access": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_remote": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_tcp_stream": { "source": "iana" },
  "application/vnd.oasis.opendocument.chart": { "source": "iana", "extensions": ["odc"] },
  "application/vnd.oasis.opendocument.chart-template": { "source": "iana", "extensions": ["otc"] },
  "application/vnd.oasis.opendocument.database": { "source": "iana", "extensions": ["odb"] },
  "application/vnd.oasis.opendocument.formula": { "source": "iana", "extensions": ["odf"] },
  "application/vnd.oasis.opendocument.formula-template": { "source": "iana", "extensions": ["odft"] },
  "application/vnd.oasis.opendocument.graphics": { "source": "iana", "compressible": false, "extensions": ["odg"] },
  "application/vnd.oasis.opendocument.graphics-template": { "source": "iana", "extensions": ["otg"] },
  "application/vnd.oasis.opendocument.image": { "source": "iana", "extensions": ["odi"] },
  "application/vnd.oasis.opendocument.image-template": { "source": "iana", "extensions": ["oti"] },
  "application/vnd.oasis.opendocument.presentation": { "source": "iana", "compressible": false, "extensions": ["odp"] },
  "application/vnd.oasis.opendocument.presentation-template": { "source": "iana", "extensions": ["otp"] },
  "application/vnd.oasis.opendocument.spreadsheet": { "source": "iana", "compressible": false, "extensions": ["ods"] },
  "application/vnd.oasis.opendocument.spreadsheet-template": { "source": "iana", "extensions": ["ots"] },
  "application/vnd.oasis.opendocument.text": { "source": "iana", "compressible": false, "extensions": ["odt"] },
  "application/vnd.oasis.opendocument.text-master": { "source": "iana", "extensions": ["odm"] },
  "application/vnd.oasis.opendocument.text-template": { "source": "iana", "extensions": ["ott"] },
  "application/vnd.oasis.opendocument.text-web": { "source": "iana", "extensions": ["oth"] },
  "application/vnd.obn": { "source": "iana" },
  "application/vnd.ocf+cbor": { "source": "iana" },
  "application/vnd.oci.image.manifest.v1+json": { "source": "iana", "compressible": true },
  "application/vnd.oftn.l10n+json": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessdownload+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessstreaming+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.cspg-hexbinary": { "source": "iana" },
  "application/vnd.oipf.dae.svg+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.dae.xhtml+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.mippvcontrolmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.pae.gem": { "source": "iana" },
  "application/vnd.oipf.spdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.spdlist+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.ueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.userprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.olpc-sugar": { "source": "iana", "extensions": ["xo"] },
  "application/vnd.oma-scws-config": { "source": "iana" },
  "application/vnd.oma-scws-http-request": { "source": "iana" },
  "application/vnd.oma-scws-http-response": { "source": "iana" },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.drm-trigger+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.imd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.ltkm": { "source": "iana" },
  "application/vnd.oma.bcast.notification+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.provisioningtrigger": { "source": "iana" },
  "application/vnd.oma.bcast.sgboot": { "source": "iana" },
  "application/vnd.oma.bcast.sgdd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.sgdu": { "source": "iana" },
  "application/vnd.oma.bcast.simple-symbol-container": { "source": "iana" },
  "application/vnd.oma.bcast.smartcard-trigger+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.sprov+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.stkm": { "source": "iana" },
  "application/vnd.oma.cab-address-book+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-feature-handler+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-pcc+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-subs-invite+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-user-prefs+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.dcd": { "source": "iana" },
  "application/vnd.oma.dcdc": { "source": "iana" },
  "application/vnd.oma.dd2+xml": { "source": "iana", "compressible": true, "extensions": ["dd2"] },
  "application/vnd.oma.drm.risd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.group-usage-list+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+cbor": { "source": "iana" },
  "application/vnd.oma.lwm2m+json": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+tlv": { "source": "iana" },
  "application/vnd.oma.pal+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.detailed-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.final-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.groups+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.invocation-descriptor+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.optimized-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.push": { "source": "iana" },
  "application/vnd.oma.scidm.messages+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.xcap-directory+xml": { "source": "iana", "compressible": true },
  "application/vnd.omads-email+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-file+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-folder+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omaloc-supl-init": { "source": "iana" },
  "application/vnd.onepager": { "source": "iana" },
  "application/vnd.onepagertamp": { "source": "iana" },
  "application/vnd.onepagertamx": { "source": "iana" },
  "application/vnd.onepagertat": { "source": "iana" },
  "application/vnd.onepagertatp": { "source": "iana" },
  "application/vnd.onepagertatx": { "source": "iana" },
  "application/vnd.openblox.game+xml": { "source": "iana", "compressible": true, "extensions": ["obgx"] },
  "application/vnd.openblox.game-binary": { "source": "iana" },
  "application/vnd.openeye.oeb": { "source": "iana" },
  "application/vnd.openofficeorg.extension": { "source": "apache", "extensions": ["oxt"] },
  "application/vnd.openstreetmap.data+xml": { "source": "iana", "compressible": true, "extensions": ["osm"] },
  "application/vnd.opentimestamps.ots": { "source": "iana" },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawing+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": { "source": "iana", "compressible": false, "extensions": ["pptx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": { "source": "iana", "extensions": ["sldx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": { "source": "iana", "extensions": ["ppsx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.template": { "source": "iana", "extensions": ["potx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": { "source": "iana", "compressible": false, "extensions": ["xlsx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": { "source": "iana", "extensions": ["xltx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.theme+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.vmldrawing": { "source": "iana" },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": { "source": "iana", "compressible": false, "extensions": ["docx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": { "source": "iana", "extensions": ["dotx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.core-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.relationships+xml": { "source": "iana", "compressible": true },
  "application/vnd.oracle.resource+json": { "source": "iana", "compressible": true },
  "application/vnd.orange.indata": { "source": "iana" },
  "application/vnd.osa.netdeploy": { "source": "iana" },
  "application/vnd.osgeo.mapguide.package": { "source": "iana", "extensions": ["mgp"] },
  "application/vnd.osgi.bundle": { "source": "iana" },
  "application/vnd.osgi.dp": { "source": "iana", "extensions": ["dp"] },
  "application/vnd.osgi.subsystem": { "source": "iana", "extensions": ["esa"] },
  "application/vnd.otps.ct-kip+xml": { "source": "iana", "compressible": true },
  "application/vnd.oxli.countgraph": { "source": "iana" },
  "application/vnd.pagerduty+json": { "source": "iana", "compressible": true },
  "application/vnd.palm": { "source": "iana", "extensions": ["pdb", "pqa", "oprc"] },
  "application/vnd.panoply": { "source": "iana" },
  "application/vnd.paos.xml": { "source": "iana" },
  "application/vnd.patentdive": { "source": "iana" },
  "application/vnd.patientecommsdoc": { "source": "iana" },
  "application/vnd.pawaafile": { "source": "iana", "extensions": ["paw"] },
  "application/vnd.pcos": { "source": "iana" },
  "application/vnd.pg.format": { "source": "iana", "extensions": ["str"] },
  "application/vnd.pg.osasli": { "source": "iana", "extensions": ["ei6"] },
  "application/vnd.piaccess.application-licence": { "source": "iana" },
  "application/vnd.picsel": { "source": "iana", "extensions": ["efif"] },
  "application/vnd.pmi.widget": { "source": "iana", "extensions": ["wg"] },
  "application/vnd.poc.group-advertisement+xml": { "source": "iana", "compressible": true },
  "application/vnd.pocketlearn": { "source": "iana", "extensions": ["plf"] },
  "application/vnd.powerbuilder6": { "source": "iana", "extensions": ["pbd"] },
  "application/vnd.powerbuilder6-s": { "source": "iana" },
  "application/vnd.powerbuilder7": { "source": "iana" },
  "application/vnd.powerbuilder7-s": { "source": "iana" },
  "application/vnd.powerbuilder75": { "source": "iana" },
  "application/vnd.powerbuilder75-s": { "source": "iana" },
  "application/vnd.preminet": { "source": "iana" },
  "application/vnd.previewsystems.box": { "source": "iana", "extensions": ["box"] },
  "application/vnd.proteus.magazine": { "source": "iana", "extensions": ["mgz"] },
  "application/vnd.psfs": { "source": "iana" },
  "application/vnd.publishare-delta-tree": { "source": "iana", "extensions": ["qps"] },
  "application/vnd.pvi.ptid1": { "source": "iana", "extensions": ["ptid"] },
  "application/vnd.pwg-multiplexed": { "source": "iana" },
  "application/vnd.pwg-xhtml-print+xml": { "source": "iana", "compressible": true },
  "application/vnd.qualcomm.brew-app-res": { "source": "iana" },
  "application/vnd.quarantainenet": { "source": "iana" },
  "application/vnd.quark.quarkxpress": { "source": "iana", "extensions": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"] },
  "application/vnd.quobject-quoxdocument": { "source": "iana" },
  "application/vnd.radisys.moml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conn+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-stream+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-base+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-group+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-speech+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-transform+xml": { "source": "iana", "compressible": true },
  "application/vnd.rainstor.data": { "source": "iana" },
  "application/vnd.rapid": { "source": "iana" },
  "application/vnd.rar": { "source": "iana", "extensions": ["rar"] },
  "application/vnd.realvnc.bed": { "source": "iana", "extensions": ["bed"] },
  "application/vnd.recordare.musicxml": { "source": "iana", "extensions": ["mxl"] },
  "application/vnd.recordare.musicxml+xml": { "source": "iana", "compressible": true, "extensions": ["musicxml"] },
  "application/vnd.renlearn.rlprint": { "source": "iana" },
  "application/vnd.resilient.logic": { "source": "iana" },
  "application/vnd.restful+json": { "source": "iana", "compressible": true },
  "application/vnd.rig.cryptonote": { "source": "iana", "extensions": ["cryptonote"] },
  "application/vnd.rim.cod": { "source": "apache", "extensions": ["cod"] },
  "application/vnd.rn-realmedia": { "source": "apache", "extensions": ["rm"] },
  "application/vnd.rn-realmedia-vbr": { "source": "apache", "extensions": ["rmvb"] },
  "application/vnd.route66.link66+xml": { "source": "iana", "compressible": true, "extensions": ["link66"] },
  "application/vnd.rs-274x": { "source": "iana" },
  "application/vnd.ruckus.download": { "source": "iana" },
  "application/vnd.s3sms": { "source": "iana" },
  "application/vnd.sailingtracker.track": { "source": "iana", "extensions": ["st"] },
  "application/vnd.sar": { "source": "iana" },
  "application/vnd.sbm.cid": { "source": "iana" },
  "application/vnd.sbm.mid2": { "source": "iana" },
  "application/vnd.scribus": { "source": "iana" },
  "application/vnd.sealed.3df": { "source": "iana" },
  "application/vnd.sealed.csf": { "source": "iana" },
  "application/vnd.sealed.doc": { "source": "iana" },
  "application/vnd.sealed.eml": { "source": "iana" },
  "application/vnd.sealed.mht": { "source": "iana" },
  "application/vnd.sealed.net": { "source": "iana" },
  "application/vnd.sealed.ppt": { "source": "iana" },
  "application/vnd.sealed.tiff": { "source": "iana" },
  "application/vnd.sealed.xls": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.html": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.pdf": { "source": "iana" },
  "application/vnd.seemail": { "source": "iana", "extensions": ["see"] },
  "application/vnd.seis+json": { "source": "iana", "compressible": true },
  "application/vnd.sema": { "source": "iana", "extensions": ["sema"] },
  "application/vnd.semd": { "source": "iana", "extensions": ["semd"] },
  "application/vnd.semf": { "source": "iana", "extensions": ["semf"] },
  "application/vnd.shade-save-file": { "source": "iana" },
  "application/vnd.shana.informed.formdata": { "source": "iana", "extensions": ["ifm"] },
  "application/vnd.shana.informed.formtemplate": { "source": "iana", "extensions": ["itp"] },
  "application/vnd.shana.informed.interchange": { "source": "iana", "extensions": ["iif"] },
  "application/vnd.shana.informed.package": { "source": "iana", "extensions": ["ipk"] },
  "application/vnd.shootproof+json": { "source": "iana", "compressible": true },
  "application/vnd.shopkick+json": { "source": "iana", "compressible": true },
  "application/vnd.shp": { "source": "iana" },
  "application/vnd.shx": { "source": "iana" },
  "application/vnd.sigrok.session": { "source": "iana" },
  "application/vnd.simtech-mindmapper": { "source": "iana", "extensions": ["twd", "twds"] },
  "application/vnd.siren+json": { "source": "iana", "compressible": true },
  "application/vnd.smaf": { "source": "iana", "extensions": ["mmf"] },
  "application/vnd.smart.notebook": { "source": "iana" },
  "application/vnd.smart.teacher": { "source": "iana", "extensions": ["teacher"] },
  "application/vnd.snesdev-page-table": { "source": "iana" },
  "application/vnd.software602.filler.form+xml": { "source": "iana", "compressible": true, "extensions": ["fo"] },
  "application/vnd.software602.filler.form-xml-zip": { "source": "iana" },
  "application/vnd.solent.sdkm+xml": { "source": "iana", "compressible": true, "extensions": ["sdkm", "sdkd"] },
  "application/vnd.spotfire.dxp": { "source": "iana", "extensions": ["dxp"] },
  "application/vnd.spotfire.sfs": { "source": "iana", "extensions": ["sfs"] },
  "application/vnd.sqlite3": { "source": "iana" },
  "application/vnd.sss-cod": { "source": "iana" },
  "application/vnd.sss-dtf": { "source": "iana" },
  "application/vnd.sss-ntf": { "source": "iana" },
  "application/vnd.stardivision.calc": { "source": "apache", "extensions": ["sdc"] },
  "application/vnd.stardivision.draw": { "source": "apache", "extensions": ["sda"] },
  "application/vnd.stardivision.impress": { "source": "apache", "extensions": ["sdd"] },
  "application/vnd.stardivision.math": { "source": "apache", "extensions": ["smf"] },
  "application/vnd.stardivision.writer": { "source": "apache", "extensions": ["sdw", "vor"] },
  "application/vnd.stardivision.writer-global": { "source": "apache", "extensions": ["sgl"] },
  "application/vnd.stepmania.package": { "source": "iana", "extensions": ["smzip"] },
  "application/vnd.stepmania.stepchart": { "source": "iana", "extensions": ["sm"] },
  "application/vnd.street-stream": { "source": "iana" },
  "application/vnd.sun.wadl+xml": { "source": "iana", "compressible": true, "extensions": ["wadl"] },
  "application/vnd.sun.xml.calc": { "source": "apache", "extensions": ["sxc"] },
  "application/vnd.sun.xml.calc.template": { "source": "apache", "extensions": ["stc"] },
  "application/vnd.sun.xml.draw": { "source": "apache", "extensions": ["sxd"] },
  "application/vnd.sun.xml.draw.template": { "source": "apache", "extensions": ["std"] },
  "application/vnd.sun.xml.impress": { "source": "apache", "extensions": ["sxi"] },
  "application/vnd.sun.xml.impress.template": { "source": "apache", "extensions": ["sti"] },
  "application/vnd.sun.xml.math": { "source": "apache", "extensions": ["sxm"] },
  "application/vnd.sun.xml.writer": { "source": "apache", "extensions": ["sxw"] },
  "application/vnd.sun.xml.writer.global": { "source": "apache", "extensions": ["sxg"] },
  "application/vnd.sun.xml.writer.template": { "source": "apache", "extensions": ["stw"] },
  "application/vnd.sus-calendar": { "source": "iana", "extensions": ["sus", "susp"] },
  "application/vnd.svd": { "source": "iana", "extensions": ["svd"] },
  "application/vnd.swiftview-ics": { "source": "iana" },
  "application/vnd.sycle+xml": { "source": "iana", "compressible": true },
  "application/vnd.syft+json": { "source": "iana", "compressible": true },
  "application/vnd.symbian.install": { "source": "apache", "extensions": ["sis", "sisx"] },
  "application/vnd.syncml+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xsm"] },
  "application/vnd.syncml.dm+wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["bdm"] },
  "application/vnd.syncml.dm+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xdm"] },
  "application/vnd.syncml.dm.notification": { "source": "iana" },
  "application/vnd.syncml.dmddf+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmddf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["ddf"] },
  "application/vnd.syncml.dmtnds+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmtnds+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.syncml.ds.notification": { "source": "iana" },
  "application/vnd.tableschema+json": { "source": "iana", "compressible": true },
  "application/vnd.tao.intent-module-archive": { "source": "iana", "extensions": ["tao"] },
  "application/vnd.tcpdump.pcap": { "source": "iana", "extensions": ["pcap", "cap", "dmp"] },
  "application/vnd.think-cell.ppttc+json": { "source": "iana", "compressible": true },
  "application/vnd.tmd.mediaflex.api+xml": { "source": "iana", "compressible": true },
  "application/vnd.tml": { "source": "iana" },
  "application/vnd.tmobile-livetv": { "source": "iana", "extensions": ["tmo"] },
  "application/vnd.tri.onesource": { "source": "iana" },
  "application/vnd.trid.tpt": { "source": "iana", "extensions": ["tpt"] },
  "application/vnd.triscape.mxs": { "source": "iana", "extensions": ["mxs"] },
  "application/vnd.trueapp": { "source": "iana", "extensions": ["tra"] },
  "application/vnd.truedoc": { "source": "iana" },
  "application/vnd.ubisoft.webplayer": { "source": "iana" },
  "application/vnd.ufdl": { "source": "iana", "extensions": ["ufd", "ufdl"] },
  "application/vnd.uiq.theme": { "source": "iana", "extensions": ["utz"] },
  "application/vnd.umajin": { "source": "iana", "extensions": ["umj"] },
  "application/vnd.unity": { "source": "iana", "extensions": ["unityweb"] },
  "application/vnd.uoml+xml": { "source": "iana", "compressible": true, "extensions": ["uoml"] },
  "application/vnd.uplanet.alert": { "source": "iana" },
  "application/vnd.uplanet.alert-wbxml": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice-wbxml": { "source": "iana" },
  "application/vnd.uplanet.cacheop": { "source": "iana" },
  "application/vnd.uplanet.cacheop-wbxml": { "source": "iana" },
  "application/vnd.uplanet.channel": { "source": "iana" },
  "application/vnd.uplanet.channel-wbxml": { "source": "iana" },
  "application/vnd.uplanet.list": { "source": "iana" },
  "application/vnd.uplanet.list-wbxml": { "source": "iana" },
  "application/vnd.uplanet.listcmd": { "source": "iana" },
  "application/vnd.uplanet.listcmd-wbxml": { "source": "iana" },
  "application/vnd.uplanet.signal": { "source": "iana" },
  "application/vnd.uri-map": { "source": "iana" },
  "application/vnd.valve.source.material": { "source": "iana" },
  "application/vnd.vcx": { "source": "iana", "extensions": ["vcx"] },
  "application/vnd.vd-study": { "source": "iana" },
  "application/vnd.vectorworks": { "source": "iana" },
  "application/vnd.vel+json": { "source": "iana", "compressible": true },
  "application/vnd.verimatrix.vcas": { "source": "iana" },
  "application/vnd.veritone.aion+json": { "source": "iana", "compressible": true },
  "application/vnd.veryant.thin": { "source": "iana" },
  "application/vnd.ves.encrypted": { "source": "iana" },
  "application/vnd.vidsoft.vidconference": { "source": "iana" },
  "application/vnd.visio": { "source": "iana", "extensions": ["vsd", "vst", "vss", "vsw"] },
  "application/vnd.visionary": { "source": "iana", "extensions": ["vis"] },
  "application/vnd.vividence.scriptfile": { "source": "iana" },
  "application/vnd.vsf": { "source": "iana", "extensions": ["vsf"] },
  "application/vnd.wap.sic": { "source": "iana" },
  "application/vnd.wap.slc": { "source": "iana" },
  "application/vnd.wap.wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["wbxml"] },
  "application/vnd.wap.wmlc": { "source": "iana", "extensions": ["wmlc"] },
  "application/vnd.wap.wmlscriptc": { "source": "iana", "extensions": ["wmlsc"] },
  "application/vnd.webturbo": { "source": "iana", "extensions": ["wtb"] },
  "application/vnd.wfa.dpp": { "source": "iana" },
  "application/vnd.wfa.p2p": { "source": "iana" },
  "application/vnd.wfa.wsc": { "source": "iana" },
  "application/vnd.windows.devicepairing": { "source": "iana" },
  "application/vnd.wmc": { "source": "iana" },
  "application/vnd.wmf.bootstrap": { "source": "iana" },
  "application/vnd.wolfram.mathematica": { "source": "iana" },
  "application/vnd.wolfram.mathematica.package": { "source": "iana" },
  "application/vnd.wolfram.player": { "source": "iana", "extensions": ["nbp"] },
  "application/vnd.wordperfect": { "source": "iana", "extensions": ["wpd"] },
  "application/vnd.wqd": { "source": "iana", "extensions": ["wqd"] },
  "application/vnd.wrq-hp3000-labelled": { "source": "iana" },
  "application/vnd.wt.stf": { "source": "iana", "extensions": ["stf"] },
  "application/vnd.wv.csp+wbxml": { "source": "iana" },
  "application/vnd.wv.csp+xml": { "source": "iana", "compressible": true },
  "application/vnd.wv.ssp+xml": { "source": "iana", "compressible": true },
  "application/vnd.xacml+json": { "source": "iana", "compressible": true },
  "application/vnd.xara": { "source": "iana", "extensions": ["xar"] },
  "application/vnd.xfdl": { "source": "iana", "extensions": ["xfdl"] },
  "application/vnd.xfdl.webform": { "source": "iana" },
  "application/vnd.xmi+xml": { "source": "iana", "compressible": true },
  "application/vnd.xmpie.cpkg": { "source": "iana" },
  "application/vnd.xmpie.dpkg": { "source": "iana" },
  "application/vnd.xmpie.plan": { "source": "iana" },
  "application/vnd.xmpie.ppkg": { "source": "iana" },
  "application/vnd.xmpie.xlim": { "source": "iana" },
  "application/vnd.yamaha.hv-dic": { "source": "iana", "extensions": ["hvd"] },
  "application/vnd.yamaha.hv-script": { "source": "iana", "extensions": ["hvs"] },
  "application/vnd.yamaha.hv-voice": { "source": "iana", "extensions": ["hvp"] },
  "application/vnd.yamaha.openscoreformat": { "source": "iana", "extensions": ["osf"] },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": { "source": "iana", "compressible": true, "extensions": ["osfpvg"] },
  "application/vnd.yamaha.remote-setup": { "source": "iana" },
  "application/vnd.yamaha.smaf-audio": { "source": "iana", "extensions": ["saf"] },
  "application/vnd.yamaha.smaf-phrase": { "source": "iana", "extensions": ["spf"] },
  "application/vnd.yamaha.through-ngn": { "source": "iana" },
  "application/vnd.yamaha.tunnel-udpencap": { "source": "iana" },
  "application/vnd.yaoweme": { "source": "iana" },
  "application/vnd.yellowriver-custom-menu": { "source": "iana", "extensions": ["cmp"] },
  "application/vnd.youtube.yt": { "source": "iana" },
  "application/vnd.zul": { "source": "iana", "extensions": ["zir", "zirz"] },
  "application/vnd.zzazz.deck+xml": { "source": "iana", "compressible": true, "extensions": ["zaz"] },
  "application/voicexml+xml": { "source": "iana", "compressible": true, "extensions": ["vxml"] },
  "application/voucher-cms+json": { "source": "iana", "compressible": true },
  "application/vq-rtcpxr": { "source": "iana" },
  "application/wasm": { "source": "iana", "compressible": true, "extensions": ["wasm"] },
  "application/watcherinfo+xml": { "source": "iana", "compressible": true, "extensions": ["wif"] },
  "application/webpush-options+json": { "source": "iana", "compressible": true },
  "application/whoispp-query": { "source": "iana" },
  "application/whoispp-response": { "source": "iana" },
  "application/widget": { "source": "iana", "extensions": ["wgt"] },
  "application/winhlp": { "source": "apache", "extensions": ["hlp"] },
  "application/wita": { "source": "iana" },
  "application/wordperfect5.1": { "source": "iana" },
  "application/wsdl+xml": { "source": "iana", "compressible": true, "extensions": ["wsdl"] },
  "application/wspolicy+xml": { "source": "iana", "compressible": true, "extensions": ["wspolicy"] },
  "application/x-7z-compressed": { "source": "apache", "compressible": false, "extensions": ["7z"] },
  "application/x-abiword": { "source": "apache", "extensions": ["abw"] },
  "application/x-ace-compressed": { "source": "apache", "extensions": ["ace"] },
  "application/x-amf": { "source": "apache" },
  "application/x-apple-diskimage": { "source": "apache", "extensions": ["dmg"] },
  "application/x-arj": { "compressible": false, "extensions": ["arj"] },
  "application/x-authorware-bin": { "source": "apache", "extensions": ["aab", "x32", "u32", "vox"] },
  "application/x-authorware-map": { "source": "apache", "extensions": ["aam"] },
  "application/x-authorware-seg": { "source": "apache", "extensions": ["aas"] },
  "application/x-bcpio": { "source": "apache", "extensions": ["bcpio"] },
  "application/x-bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/x-bittorrent": { "source": "apache", "extensions": ["torrent"] },
  "application/x-blorb": { "source": "apache", "extensions": ["blb", "blorb"] },
  "application/x-bzip": { "source": "apache", "compressible": false, "extensions": ["bz"] },
  "application/x-bzip2": { "source": "apache", "compressible": false, "extensions": ["bz2", "boz"] },
  "application/x-cbr": { "source": "apache", "extensions": ["cbr", "cba", "cbt", "cbz", "cb7"] },
  "application/x-cdlink": { "source": "apache", "extensions": ["vcd"] },
  "application/x-cfs-compressed": { "source": "apache", "extensions": ["cfs"] },
  "application/x-chat": { "source": "apache", "extensions": ["chat"] },
  "application/x-chess-pgn": { "source": "apache", "extensions": ["pgn"] },
  "application/x-chrome-extension": { "extensions": ["crx"] },
  "application/x-cocoa": { "source": "nginx", "extensions": ["cco"] },
  "application/x-compress": { "source": "apache" },
  "application/x-conference": { "source": "apache", "extensions": ["nsc"] },
  "application/x-cpio": { "source": "apache", "extensions": ["cpio"] },
  "application/x-csh": { "source": "apache", "extensions": ["csh"] },
  "application/x-deb": { "compressible": false },
  "application/x-debian-package": { "source": "apache", "extensions": ["deb", "udeb"] },
  "application/x-dgc-compressed": { "source": "apache", "extensions": ["dgc"] },
  "application/x-director": { "source": "apache", "extensions": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"] },
  "application/x-doom": { "source": "apache", "extensions": ["wad"] },
  "application/x-dtbncx+xml": { "source": "apache", "compressible": true, "extensions": ["ncx"] },
  "application/x-dtbook+xml": { "source": "apache", "compressible": true, "extensions": ["dtb"] },
  "application/x-dtbresource+xml": { "source": "apache", "compressible": true, "extensions": ["res"] },
  "application/x-dvi": { "source": "apache", "compressible": false, "extensions": ["dvi"] },
  "application/x-envoy": { "source": "apache", "extensions": ["evy"] },
  "application/x-eva": { "source": "apache", "extensions": ["eva"] },
  "application/x-font-bdf": { "source": "apache", "extensions": ["bdf"] },
  "application/x-font-dos": { "source": "apache" },
  "application/x-font-framemaker": { "source": "apache" },
  "application/x-font-ghostscript": { "source": "apache", "extensions": ["gsf"] },
  "application/x-font-libgrx": { "source": "apache" },
  "application/x-font-linux-psf": { "source": "apache", "extensions": ["psf"] },
  "application/x-font-pcf": { "source": "apache", "extensions": ["pcf"] },
  "application/x-font-snf": { "source": "apache", "extensions": ["snf"] },
  "application/x-font-speedo": { "source": "apache" },
  "application/x-font-sunos-news": { "source": "apache" },
  "application/x-font-type1": { "source": "apache", "extensions": ["pfa", "pfb", "pfm", "afm"] },
  "application/x-font-vfont": { "source": "apache" },
  "application/x-freearc": { "source": "apache", "extensions": ["arc"] },
  "application/x-futuresplash": { "source": "apache", "extensions": ["spl"] },
  "application/x-gca-compressed": { "source": "apache", "extensions": ["gca"] },
  "application/x-glulx": { "source": "apache", "extensions": ["ulx"] },
  "application/x-gnumeric": { "source": "apache", "extensions": ["gnumeric"] },
  "application/x-gramps-xml": { "source": "apache", "extensions": ["gramps"] },
  "application/x-gtar": { "source": "apache", "extensions": ["gtar"] },
  "application/x-gzip": { "source": "apache" },
  "application/x-hdf": { "source": "apache", "extensions": ["hdf"] },
  "application/x-httpd-php": { "compressible": true, "extensions": ["php"] },
  "application/x-install-instructions": { "source": "apache", "extensions": ["install"] },
  "application/x-iso9660-image": { "source": "apache", "extensions": ["iso"] },
  "application/x-iwork-keynote-sffkey": { "extensions": ["key"] },
  "application/x-iwork-numbers-sffnumbers": { "extensions": ["numbers"] },
  "application/x-iwork-pages-sffpages": { "extensions": ["pages"] },
  "application/x-java-archive-diff": { "source": "nginx", "extensions": ["jardiff"] },
  "application/x-java-jnlp-file": { "source": "apache", "compressible": false, "extensions": ["jnlp"] },
  "application/x-javascript": { "compressible": true },
  "application/x-keepass2": { "extensions": ["kdbx"] },
  "application/x-latex": { "source": "apache", "compressible": false, "extensions": ["latex"] },
  "application/x-lua-bytecode": { "extensions": ["luac"] },
  "application/x-lzh-compressed": { "source": "apache", "extensions": ["lzh", "lha"] },
  "application/x-makeself": { "source": "nginx", "extensions": ["run"] },
  "application/x-mie": { "source": "apache", "extensions": ["mie"] },
  "application/x-mobipocket-ebook": { "source": "apache", "extensions": ["prc", "mobi"] },
  "application/x-mpegurl": { "compressible": false },
  "application/x-ms-application": { "source": "apache", "extensions": ["application"] },
  "application/x-ms-shortcut": { "source": "apache", "extensions": ["lnk"] },
  "application/x-ms-wmd": { "source": "apache", "extensions": ["wmd"] },
  "application/x-ms-wmz": { "source": "apache", "extensions": ["wmz"] },
  "application/x-ms-xbap": { "source": "apache", "extensions": ["xbap"] },
  "application/x-msaccess": { "source": "apache", "extensions": ["mdb"] },
  "application/x-msbinder": { "source": "apache", "extensions": ["obd"] },
  "application/x-mscardfile": { "source": "apache", "extensions": ["crd"] },
  "application/x-msclip": { "source": "apache", "extensions": ["clp"] },
  "application/x-msdos-program": { "extensions": ["exe"] },
  "application/x-msdownload": { "source": "apache", "extensions": ["exe", "dll", "com", "bat", "msi"] },
  "application/x-msmediaview": { "source": "apache", "extensions": ["mvb", "m13", "m14"] },
  "application/x-msmetafile": { "source": "apache", "extensions": ["wmf", "wmz", "emf", "emz"] },
  "application/x-msmoney": { "source": "apache", "extensions": ["mny"] },
  "application/x-mspublisher": { "source": "apache", "extensions": ["pub"] },
  "application/x-msschedule": { "source": "apache", "extensions": ["scd"] },
  "application/x-msterminal": { "source": "apache", "extensions": ["trm"] },
  "application/x-mswrite": { "source": "apache", "extensions": ["wri"] },
  "application/x-netcdf": { "source": "apache", "extensions": ["nc", "cdf"] },
  "application/x-ns-proxy-autoconfig": { "compressible": true, "extensions": ["pac"] },
  "application/x-nzb": { "source": "apache", "extensions": ["nzb"] },
  "application/x-perl": { "source": "nginx", "extensions": ["pl", "pm"] },
  "application/x-pilot": { "source": "nginx", "extensions": ["prc", "pdb"] },
  "application/x-pkcs12": { "source": "apache", "compressible": false, "extensions": ["p12", "pfx"] },
  "application/x-pkcs7-certificates": { "source": "apache", "extensions": ["p7b", "spc"] },
  "application/x-pkcs7-certreqresp": { "source": "apache", "extensions": ["p7r"] },
  "application/x-pki-message": { "source": "iana" },
  "application/x-rar-compressed": { "source": "apache", "compressible": false, "extensions": ["rar"] },
  "application/x-redhat-package-manager": { "source": "nginx", "extensions": ["rpm"] },
  "application/x-research-info-systems": { "source": "apache", "extensions": ["ris"] },
  "application/x-sea": { "source": "nginx", "extensions": ["sea"] },
  "application/x-sh": { "source": "apache", "compressible": true, "extensions": ["sh"] },
  "application/x-shar": { "source": "apache", "extensions": ["shar"] },
  "application/x-shockwave-flash": { "source": "apache", "compressible": false, "extensions": ["swf"] },
  "application/x-silverlight-app": { "source": "apache", "extensions": ["xap"] },
  "application/x-sql": { "source": "apache", "extensions": ["sql"] },
  "application/x-stuffit": { "source": "apache", "compressible": false, "extensions": ["sit"] },
  "application/x-stuffitx": { "source": "apache", "extensions": ["sitx"] },
  "application/x-subrip": { "source": "apache", "extensions": ["srt"] },
  "application/x-sv4cpio": { "source": "apache", "extensions": ["sv4cpio"] },
  "application/x-sv4crc": { "source": "apache", "extensions": ["sv4crc"] },
  "application/x-t3vm-image": { "source": "apache", "extensions": ["t3"] },
  "application/x-tads": { "source": "apache", "extensions": ["gam"] },
  "application/x-tar": { "source": "apache", "compressible": true, "extensions": ["tar"] },
  "application/x-tcl": { "source": "apache", "extensions": ["tcl", "tk"] },
  "application/x-tex": { "source": "apache", "extensions": ["tex"] },
  "application/x-tex-tfm": { "source": "apache", "extensions": ["tfm"] },
  "application/x-texinfo": { "source": "apache", "extensions": ["texinfo", "texi"] },
  "application/x-tgif": { "source": "apache", "extensions": ["obj"] },
  "application/x-ustar": { "source": "apache", "extensions": ["ustar"] },
  "application/x-virtualbox-hdd": { "compressible": true, "extensions": ["hdd"] },
  "application/x-virtualbox-ova": { "compressible": true, "extensions": ["ova"] },
  "application/x-virtualbox-ovf": { "compressible": true, "extensions": ["ovf"] },
  "application/x-virtualbox-vbox": { "compressible": true, "extensions": ["vbox"] },
  "application/x-virtualbox-vbox-extpack": { "compressible": false, "extensions": ["vbox-extpack"] },
  "application/x-virtualbox-vdi": { "compressible": true, "extensions": ["vdi"] },
  "application/x-virtualbox-vhd": { "compressible": true, "extensions": ["vhd"] },
  "application/x-virtualbox-vmdk": { "compressible": true, "extensions": ["vmdk"] },
  "application/x-wais-source": { "source": "apache", "extensions": ["src"] },
  "application/x-web-app-manifest+json": { "compressible": true, "extensions": ["webapp"] },
  "application/x-www-form-urlencoded": { "source": "iana", "compressible": true },
  "application/x-x509-ca-cert": { "source": "iana", "extensions": ["der", "crt", "pem"] },
  "application/x-x509-ca-ra-cert": { "source": "iana" },
  "application/x-x509-next-ca-cert": { "source": "iana" },
  "application/x-xfig": { "source": "apache", "extensions": ["fig"] },
  "application/x-xliff+xml": { "source": "apache", "compressible": true, "extensions": ["xlf"] },
  "application/x-xpinstall": { "source": "apache", "compressible": false, "extensions": ["xpi"] },
  "application/x-xz": { "source": "apache", "extensions": ["xz"] },
  "application/x-zmachine": { "source": "apache", "extensions": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"] },
  "application/x400-bp": { "source": "iana" },
  "application/xacml+xml": { "source": "iana", "compressible": true },
  "application/xaml+xml": { "source": "apache", "compressible": true, "extensions": ["xaml"] },
  "application/xcap-att+xml": { "source": "iana", "compressible": true, "extensions": ["xav"] },
  "application/xcap-caps+xml": { "source": "iana", "compressible": true, "extensions": ["xca"] },
  "application/xcap-diff+xml": { "source": "iana", "compressible": true, "extensions": ["xdf"] },
  "application/xcap-el+xml": { "source": "iana", "compressible": true, "extensions": ["xel"] },
  "application/xcap-error+xml": { "source": "iana", "compressible": true },
  "application/xcap-ns+xml": { "source": "iana", "compressible": true, "extensions": ["xns"] },
  "application/xcon-conference-info+xml": { "source": "iana", "compressible": true },
  "application/xcon-conference-info-diff+xml": { "source": "iana", "compressible": true },
  "application/xenc+xml": { "source": "iana", "compressible": true, "extensions": ["xenc"] },
  "application/xhtml+xml": { "source": "iana", "compressible": true, "extensions": ["xhtml", "xht"] },
  "application/xhtml-voice+xml": { "source": "apache", "compressible": true },
  "application/xliff+xml": { "source": "iana", "compressible": true, "extensions": ["xlf"] },
  "application/xml": { "source": "iana", "compressible": true, "extensions": ["xml", "xsl", "xsd", "rng"] },
  "application/xml-dtd": { "source": "iana", "compressible": true, "extensions": ["dtd"] },
  "application/xml-external-parsed-entity": { "source": "iana" },
  "application/xml-patch+xml": { "source": "iana", "compressible": true },
  "application/xmpp+xml": { "source": "iana", "compressible": true },
  "application/xop+xml": { "source": "iana", "compressible": true, "extensions": ["xop"] },
  "application/xproc+xml": { "source": "apache", "compressible": true, "extensions": ["xpl"] },
  "application/xslt+xml": { "source": "iana", "compressible": true, "extensions": ["xsl", "xslt"] },
  "application/xspf+xml": { "source": "apache", "compressible": true, "extensions": ["xspf"] },
  "application/xv+xml": { "source": "iana", "compressible": true, "extensions": ["mxml", "xhvml", "xvml", "xvm"] },
  "application/yang": { "source": "iana", "extensions": ["yang"] },
  "application/yang-data+json": { "source": "iana", "compressible": true },
  "application/yang-data+xml": { "source": "iana", "compressible": true },
  "application/yang-patch+json": { "source": "iana", "compressible": true },
  "application/yang-patch+xml": { "source": "iana", "compressible": true },
  "application/yin+xml": { "source": "iana", "compressible": true, "extensions": ["yin"] },
  "application/zip": { "source": "iana", "compressible": false, "extensions": ["zip"] },
  "application/zlib": { "source": "iana" },
  "application/zstd": { "source": "iana" },
  "audio/1d-interleaved-parityfec": { "source": "iana" },
  "audio/32kadpcm": { "source": "iana" },
  "audio/3gpp": { "source": "iana", "compressible": false, "extensions": ["3gpp"] },
  "audio/3gpp2": { "source": "iana" },
  "audio/aac": { "source": "iana" },
  "audio/ac3": { "source": "iana" },
  "audio/adpcm": { "source": "apache", "extensions": ["adp"] },
  "audio/amr": { "source": "iana", "extensions": ["amr"] },
  "audio/amr-wb": { "source": "iana" },
  "audio/amr-wb+": { "source": "iana" },
  "audio/aptx": { "source": "iana" },
  "audio/asc": { "source": "iana" },
  "audio/atrac-advanced-lossless": { "source": "iana" },
  "audio/atrac-x": { "source": "iana" },
  "audio/atrac3": { "source": "iana" },
  "audio/basic": { "source": "iana", "compressible": false, "extensions": ["au", "snd"] },
  "audio/bv16": { "source": "iana" },
  "audio/bv32": { "source": "iana" },
  "audio/clearmode": { "source": "iana" },
  "audio/cn": { "source": "iana" },
  "audio/dat12": { "source": "iana" },
  "audio/dls": { "source": "iana" },
  "audio/dsr-es201108": { "source": "iana" },
  "audio/dsr-es202050": { "source": "iana" },
  "audio/dsr-es202211": { "source": "iana" },
  "audio/dsr-es202212": { "source": "iana" },
  "audio/dv": { "source": "iana" },
  "audio/dvi4": { "source": "iana" },
  "audio/eac3": { "source": "iana" },
  "audio/encaprtp": { "source": "iana" },
  "audio/evrc": { "source": "iana" },
  "audio/evrc-qcp": { "source": "iana" },
  "audio/evrc0": { "source": "iana" },
  "audio/evrc1": { "source": "iana" },
  "audio/evrcb": { "source": "iana" },
  "audio/evrcb0": { "source": "iana" },
  "audio/evrcb1": { "source": "iana" },
  "audio/evrcnw": { "source": "iana" },
  "audio/evrcnw0": { "source": "iana" },
  "audio/evrcnw1": { "source": "iana" },
  "audio/evrcwb": { "source": "iana" },
  "audio/evrcwb0": { "source": "iana" },
  "audio/evrcwb1": { "source": "iana" },
  "audio/evs": { "source": "iana" },
  "audio/flexfec": { "source": "iana" },
  "audio/fwdred": { "source": "iana" },
  "audio/g711-0": { "source": "iana" },
  "audio/g719": { "source": "iana" },
  "audio/g722": { "source": "iana" },
  "audio/g7221": { "source": "iana" },
  "audio/g723": { "source": "iana" },
  "audio/g726-16": { "source": "iana" },
  "audio/g726-24": { "source": "iana" },
  "audio/g726-32": { "source": "iana" },
  "audio/g726-40": { "source": "iana" },
  "audio/g728": { "source": "iana" },
  "audio/g729": { "source": "iana" },
  "audio/g7291": { "source": "iana" },
  "audio/g729d": { "source": "iana" },
  "audio/g729e": { "source": "iana" },
  "audio/gsm": { "source": "iana" },
  "audio/gsm-efr": { "source": "iana" },
  "audio/gsm-hr-08": { "source": "iana" },
  "audio/ilbc": { "source": "iana" },
  "audio/ip-mr_v2.5": { "source": "iana" },
  "audio/isac": { "source": "apache" },
  "audio/l16": { "source": "iana" },
  "audio/l20": { "source": "iana" },
  "audio/l24": { "source": "iana", "compressible": false },
  "audio/l8": { "source": "iana" },
  "audio/lpc": { "source": "iana" },
  "audio/melp": { "source": "iana" },
  "audio/melp1200": { "source": "iana" },
  "audio/melp2400": { "source": "iana" },
  "audio/melp600": { "source": "iana" },
  "audio/mhas": { "source": "iana" },
  "audio/midi": { "source": "apache", "extensions": ["mid", "midi", "kar", "rmi"] },
  "audio/mobile-xmf": { "source": "iana", "extensions": ["mxmf"] },
  "audio/mp3": { "compressible": false, "extensions": ["mp3"] },
  "audio/mp4": { "source": "iana", "compressible": false, "extensions": ["m4a", "mp4a"] },
  "audio/mp4a-latm": { "source": "iana" },
  "audio/mpa": { "source": "iana" },
  "audio/mpa-robust": { "source": "iana" },
  "audio/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"] },
  "audio/mpeg4-generic": { "source": "iana" },
  "audio/musepack": { "source": "apache" },
  "audio/ogg": { "source": "iana", "compressible": false, "extensions": ["oga", "ogg", "spx", "opus"] },
  "audio/opus": { "source": "iana" },
  "audio/parityfec": { "source": "iana" },
  "audio/pcma": { "source": "iana" },
  "audio/pcma-wb": { "source": "iana" },
  "audio/pcmu": { "source": "iana" },
  "audio/pcmu-wb": { "source": "iana" },
  "audio/prs.sid": { "source": "iana" },
  "audio/qcelp": { "source": "iana" },
  "audio/raptorfec": { "source": "iana" },
  "audio/red": { "source": "iana" },
  "audio/rtp-enc-aescm128": { "source": "iana" },
  "audio/rtp-midi": { "source": "iana" },
  "audio/rtploopback": { "source": "iana" },
  "audio/rtx": { "source": "iana" },
  "audio/s3m": { "source": "apache", "extensions": ["s3m"] },
  "audio/scip": { "source": "iana" },
  "audio/silk": { "source": "apache", "extensions": ["sil"] },
  "audio/smv": { "source": "iana" },
  "audio/smv-qcp": { "source": "iana" },
  "audio/smv0": { "source": "iana" },
  "audio/sofa": { "source": "iana" },
  "audio/sp-midi": { "source": "iana" },
  "audio/speex": { "source": "iana" },
  "audio/t140c": { "source": "iana" },
  "audio/t38": { "source": "iana" },
  "audio/telephone-event": { "source": "iana" },
  "audio/tetra_acelp": { "source": "iana" },
  "audio/tetra_acelp_bb": { "source": "iana" },
  "audio/tone": { "source": "iana" },
  "audio/tsvcis": { "source": "iana" },
  "audio/uemclip": { "source": "iana" },
  "audio/ulpfec": { "source": "iana" },
  "audio/usac": { "source": "iana" },
  "audio/vdvi": { "source": "iana" },
  "audio/vmr-wb": { "source": "iana" },
  "audio/vnd.3gpp.iufp": { "source": "iana" },
  "audio/vnd.4sb": { "source": "iana" },
  "audio/vnd.audiokoz": { "source": "iana" },
  "audio/vnd.celp": { "source": "iana" },
  "audio/vnd.cisco.nse": { "source": "iana" },
  "audio/vnd.cmles.radio-events": { "source": "iana" },
  "audio/vnd.cns.anp1": { "source": "iana" },
  "audio/vnd.cns.inf1": { "source": "iana" },
  "audio/vnd.dece.audio": { "source": "iana", "extensions": ["uva", "uvva"] },
  "audio/vnd.digital-winds": { "source": "iana", "extensions": ["eol"] },
  "audio/vnd.dlna.adts": { "source": "iana" },
  "audio/vnd.dolby.heaac.1": { "source": "iana" },
  "audio/vnd.dolby.heaac.2": { "source": "iana" },
  "audio/vnd.dolby.mlp": { "source": "iana" },
  "audio/vnd.dolby.mps": { "source": "iana" },
  "audio/vnd.dolby.pl2": { "source": "iana" },
  "audio/vnd.dolby.pl2x": { "source": "iana" },
  "audio/vnd.dolby.pl2z": { "source": "iana" },
  "audio/vnd.dolby.pulse.1": { "source": "iana" },
  "audio/vnd.dra": { "source": "iana", "extensions": ["dra"] },
  "audio/vnd.dts": { "source": "iana", "extensions": ["dts"] },
  "audio/vnd.dts.hd": { "source": "iana", "extensions": ["dtshd"] },
  "audio/vnd.dts.uhd": { "source": "iana" },
  "audio/vnd.dvb.file": { "source": "iana" },
  "audio/vnd.everad.plj": { "source": "iana" },
  "audio/vnd.hns.audio": { "source": "iana" },
  "audio/vnd.lucent.voice": { "source": "iana", "extensions": ["lvp"] },
  "audio/vnd.ms-playready.media.pya": { "source": "iana", "extensions": ["pya"] },
  "audio/vnd.nokia.mobile-xmf": { "source": "iana" },
  "audio/vnd.nortel.vbk": { "source": "iana" },
  "audio/vnd.nuera.ecelp4800": { "source": "iana", "extensions": ["ecelp4800"] },
  "audio/vnd.nuera.ecelp7470": { "source": "iana", "extensions": ["ecelp7470"] },
  "audio/vnd.nuera.ecelp9600": { "source": "iana", "extensions": ["ecelp9600"] },
  "audio/vnd.octel.sbc": { "source": "iana" },
  "audio/vnd.presonus.multitrack": { "source": "iana" },
  "audio/vnd.qcelp": { "source": "iana" },
  "audio/vnd.rhetorex.32kadpcm": { "source": "iana" },
  "audio/vnd.rip": { "source": "iana", "extensions": ["rip"] },
  "audio/vnd.rn-realaudio": { "compressible": false },
  "audio/vnd.sealedmedia.softseal.mpeg": { "source": "iana" },
  "audio/vnd.vmx.cvsd": { "source": "iana" },
  "audio/vnd.wave": { "compressible": false },
  "audio/vorbis": { "source": "iana", "compressible": false },
  "audio/vorbis-config": { "source": "iana" },
  "audio/wav": { "compressible": false, "extensions": ["wav"] },
  "audio/wave": { "compressible": false, "extensions": ["wav"] },
  "audio/webm": { "source": "apache", "compressible": false, "extensions": ["weba"] },
  "audio/x-aac": { "source": "apache", "compressible": false, "extensions": ["aac"] },
  "audio/x-aiff": { "source": "apache", "extensions": ["aif", "aiff", "aifc"] },
  "audio/x-caf": { "source": "apache", "compressible": false, "extensions": ["caf"] },
  "audio/x-flac": { "source": "apache", "extensions": ["flac"] },
  "audio/x-m4a": { "source": "nginx", "extensions": ["m4a"] },
  "audio/x-matroska": { "source": "apache", "extensions": ["mka"] },
  "audio/x-mpegurl": { "source": "apache", "extensions": ["m3u"] },
  "audio/x-ms-wax": { "source": "apache", "extensions": ["wax"] },
  "audio/x-ms-wma": { "source": "apache", "extensions": ["wma"] },
  "audio/x-pn-realaudio": { "source": "apache", "extensions": ["ram", "ra"] },
  "audio/x-pn-realaudio-plugin": { "source": "apache", "extensions": ["rmp"] },
  "audio/x-realaudio": { "source": "nginx", "extensions": ["ra"] },
  "audio/x-tta": { "source": "apache" },
  "audio/x-wav": { "source": "apache", "extensions": ["wav"] },
  "audio/xm": { "source": "apache", "extensions": ["xm"] },
  "chemical/x-cdx": { "source": "apache", "extensions": ["cdx"] },
  "chemical/x-cif": { "source": "apache", "extensions": ["cif"] },
  "chemical/x-cmdf": { "source": "apache", "extensions": ["cmdf"] },
  "chemical/x-cml": { "source": "apache", "extensions": ["cml"] },
  "chemical/x-csml": { "source": "apache", "extensions": ["csml"] },
  "chemical/x-pdb": { "source": "apache" },
  "chemical/x-xyz": { "source": "apache", "extensions": ["xyz"] },
  "font/collection": { "source": "iana", "extensions": ["ttc"] },
  "font/otf": { "source": "iana", "compressible": true, "extensions": ["otf"] },
  "font/sfnt": { "source": "iana" },
  "font/ttf": { "source": "iana", "compressible": true, "extensions": ["ttf"] },
  "font/woff": { "source": "iana", "extensions": ["woff"] },
  "font/woff2": { "source": "iana", "extensions": ["woff2"] },
  "image/aces": { "source": "iana", "extensions": ["exr"] },
  "image/apng": { "compressible": false, "extensions": ["apng"] },
  "image/avci": { "source": "iana", "extensions": ["avci"] },
  "image/avcs": { "source": "iana", "extensions": ["avcs"] },
  "image/avif": { "source": "iana", "compressible": false, "extensions": ["avif"] },
  "image/bmp": { "source": "iana", "compressible": true, "extensions": ["bmp"] },
  "image/cgm": { "source": "iana", "extensions": ["cgm"] },
  "image/dicom-rle": { "source": "iana", "extensions": ["drle"] },
  "image/emf": { "source": "iana", "extensions": ["emf"] },
  "image/fits": { "source": "iana", "extensions": ["fits"] },
  "image/g3fax": { "source": "iana", "extensions": ["g3"] },
  "image/gif": { "source": "iana", "compressible": false, "extensions": ["gif"] },
  "image/heic": { "source": "iana", "extensions": ["heic"] },
  "image/heic-sequence": { "source": "iana", "extensions": ["heics"] },
  "image/heif": { "source": "iana", "extensions": ["heif"] },
  "image/heif-sequence": { "source": "iana", "extensions": ["heifs"] },
  "image/hej2k": { "source": "iana", "extensions": ["hej2"] },
  "image/hsj2": { "source": "iana", "extensions": ["hsj2"] },
  "image/ief": { "source": "iana", "extensions": ["ief"] },
  "image/jls": { "source": "iana", "extensions": ["jls"] },
  "image/jp2": { "source": "iana", "compressible": false, "extensions": ["jp2", "jpg2"] },
  "image/jpeg": { "source": "iana", "compressible": false, "extensions": ["jpeg", "jpg", "jpe"] },
  "image/jph": { "source": "iana", "extensions": ["jph"] },
  "image/jphc": { "source": "iana", "extensions": ["jhc"] },
  "image/jpm": { "source": "iana", "compressible": false, "extensions": ["jpm"] },
  "image/jpx": { "source": "iana", "compressible": false, "extensions": ["jpx", "jpf"] },
  "image/jxr": { "source": "iana", "extensions": ["jxr"] },
  "image/jxra": { "source": "iana", "extensions": ["jxra"] },
  "image/jxrs": { "source": "iana", "extensions": ["jxrs"] },
  "image/jxs": { "source": "iana", "extensions": ["jxs"] },
  "image/jxsc": { "source": "iana", "extensions": ["jxsc"] },
  "image/jxsi": { "source": "iana", "extensions": ["jxsi"] },
  "image/jxss": { "source": "iana", "extensions": ["jxss"] },
  "image/ktx": { "source": "iana", "extensions": ["ktx"] },
  "image/ktx2": { "source": "iana", "extensions": ["ktx2"] },
  "image/naplps": { "source": "iana" },
  "image/pjpeg": { "compressible": false },
  "image/png": { "source": "iana", "compressible": false, "extensions": ["png"] },
  "image/prs.btif": { "source": "iana", "extensions": ["btif"] },
  "image/prs.pti": { "source": "iana", "extensions": ["pti"] },
  "image/pwg-raster": { "source": "iana" },
  "image/sgi": { "source": "apache", "extensions": ["sgi"] },
  "image/svg+xml": { "source": "iana", "compressible": true, "extensions": ["svg", "svgz"] },
  "image/t38": { "source": "iana", "extensions": ["t38"] },
  "image/tiff": { "source": "iana", "compressible": false, "extensions": ["tif", "tiff"] },
  "image/tiff-fx": { "source": "iana", "extensions": ["tfx"] },
  "image/vnd.adobe.photoshop": { "source": "iana", "compressible": true, "extensions": ["psd"] },
  "image/vnd.airzip.accelerator.azv": { "source": "iana", "extensions": ["azv"] },
  "image/vnd.cns.inf2": { "source": "iana" },
  "image/vnd.dece.graphic": { "source": "iana", "extensions": ["uvi", "uvvi", "uvg", "uvvg"] },
  "image/vnd.djvu": { "source": "iana", "extensions": ["djvu", "djv"] },
  "image/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "image/vnd.dwg": { "source": "iana", "extensions": ["dwg"] },
  "image/vnd.dxf": { "source": "iana", "extensions": ["dxf"] },
  "image/vnd.fastbidsheet": { "source": "iana", "extensions": ["fbs"] },
  "image/vnd.fpx": { "source": "iana", "extensions": ["fpx"] },
  "image/vnd.fst": { "source": "iana", "extensions": ["fst"] },
  "image/vnd.fujixerox.edmics-mmr": { "source": "iana", "extensions": ["mmr"] },
  "image/vnd.fujixerox.edmics-rlc": { "source": "iana", "extensions": ["rlc"] },
  "image/vnd.globalgraphics.pgb": { "source": "iana" },
  "image/vnd.microsoft.icon": { "source": "iana", "compressible": true, "extensions": ["ico"] },
  "image/vnd.mix": { "source": "iana" },
  "image/vnd.mozilla.apng": { "source": "iana" },
  "image/vnd.ms-dds": { "compressible": true, "extensions": ["dds"] },
  "image/vnd.ms-modi": { "source": "iana", "extensions": ["mdi"] },
  "image/vnd.ms-photo": { "source": "apache", "extensions": ["wdp"] },
  "image/vnd.net-fpx": { "source": "iana", "extensions": ["npx"] },
  "image/vnd.pco.b16": { "source": "iana", "extensions": ["b16"] },
  "image/vnd.radiance": { "source": "iana" },
  "image/vnd.sealed.png": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.gif": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.jpg": { "source": "iana" },
  "image/vnd.svf": { "source": "iana" },
  "image/vnd.tencent.tap": { "source": "iana", "extensions": ["tap"] },
  "image/vnd.valve.source.texture": { "source": "iana", "extensions": ["vtf"] },
  "image/vnd.wap.wbmp": { "source": "iana", "extensions": ["wbmp"] },
  "image/vnd.xiff": { "source": "iana", "extensions": ["xif"] },
  "image/vnd.zbrush.pcx": { "source": "iana", "extensions": ["pcx"] },
  "image/webp": { "source": "apache", "extensions": ["webp"] },
  "image/wmf": { "source": "iana", "extensions": ["wmf"] },
  "image/x-3ds": { "source": "apache", "extensions": ["3ds"] },
  "image/x-cmu-raster": { "source": "apache", "extensions": ["ras"] },
  "image/x-cmx": { "source": "apache", "extensions": ["cmx"] },
  "image/x-freehand": { "source": "apache", "extensions": ["fh", "fhc", "fh4", "fh5", "fh7"] },
  "image/x-icon": { "source": "apache", "compressible": true, "extensions": ["ico"] },
  "image/x-jng": { "source": "nginx", "extensions": ["jng"] },
  "image/x-mrsid-image": { "source": "apache", "extensions": ["sid"] },
  "image/x-ms-bmp": { "source": "nginx", "compressible": true, "extensions": ["bmp"] },
  "image/x-pcx": { "source": "apache", "extensions": ["pcx"] },
  "image/x-pict": { "source": "apache", "extensions": ["pic", "pct"] },
  "image/x-portable-anymap": { "source": "apache", "extensions": ["pnm"] },
  "image/x-portable-bitmap": { "source": "apache", "extensions": ["pbm"] },
  "image/x-portable-graymap": { "source": "apache", "extensions": ["pgm"] },
  "image/x-portable-pixmap": { "source": "apache", "extensions": ["ppm"] },
  "image/x-rgb": { "source": "apache", "extensions": ["rgb"] },
  "image/x-tga": { "source": "apache", "extensions": ["tga"] },
  "image/x-xbitmap": { "source": "apache", "extensions": ["xbm"] },
  "image/x-xcf": { "compressible": false },
  "image/x-xpixmap": { "source": "apache", "extensions": ["xpm"] },
  "image/x-xwindowdump": { "source": "apache", "extensions": ["xwd"] },
  "message/cpim": { "source": "iana" },
  "message/delivery-status": { "source": "iana" },
  "message/disposition-notification": { "source": "iana", "extensions": ["disposition-notification"] },
  "message/external-body": { "source": "iana" },
  "message/feedback-report": { "source": "iana" },
  "message/global": { "source": "iana", "extensions": ["u8msg"] },
  "message/global-delivery-status": { "source": "iana", "extensions": ["u8dsn"] },
  "message/global-disposition-notification": { "source": "iana", "extensions": ["u8mdn"] },
  "message/global-headers": { "source": "iana", "extensions": ["u8hdr"] },
  "message/http": { "source": "iana", "compressible": false },
  "message/imdn+xml": { "source": "iana", "compressible": true },
  "message/news": { "source": "iana" },
  "message/partial": { "source": "iana", "compressible": false },
  "message/rfc822": { "source": "iana", "compressible": true, "extensions": ["eml", "mime"] },
  "message/s-http": { "source": "iana" },
  "message/sip": { "source": "iana" },
  "message/sipfrag": { "source": "iana" },
  "message/tracking-status": { "source": "iana" },
  "message/vnd.si.simp": { "source": "iana" },
  "message/vnd.wfa.wsc": { "source": "iana", "extensions": ["wsc"] },
  "model/3mf": { "source": "iana", "extensions": ["3mf"] },
  "model/e57": { "source": "iana" },
  "model/gltf+json": { "source": "iana", "compressible": true, "extensions": ["gltf"] },
  "model/gltf-binary": { "source": "iana", "compressible": true, "extensions": ["glb"] },
  "model/iges": { "source": "iana", "compressible": false, "extensions": ["igs", "iges"] },
  "model/mesh": { "source": "iana", "compressible": false, "extensions": ["msh", "mesh", "silo"] },
  "model/mtl": { "source": "iana", "extensions": ["mtl"] },
  "model/obj": { "source": "iana", "extensions": ["obj"] },
  "model/step": { "source": "iana" },
  "model/step+xml": { "source": "iana", "compressible": true, "extensions": ["stpx"] },
  "model/step+zip": { "source": "iana", "compressible": false, "extensions": ["stpz"] },
  "model/step-xml+zip": { "source": "iana", "compressible": false, "extensions": ["stpxz"] },
  "model/stl": { "source": "iana", "extensions": ["stl"] },
  "model/vnd.collada+xml": { "source": "iana", "compressible": true, "extensions": ["dae"] },
  "model/vnd.dwf": { "source": "iana", "extensions": ["dwf"] },
  "model/vnd.flatland.3dml": { "source": "iana" },
  "model/vnd.gdl": { "source": "iana", "extensions": ["gdl"] },
  "model/vnd.gs-gdl": { "source": "apache" },
  "model/vnd.gs.gdl": { "source": "iana" },
  "model/vnd.gtw": { "source": "iana", "extensions": ["gtw"] },
  "model/vnd.moml+xml": { "source": "iana", "compressible": true },
  "model/vnd.mts": { "source": "iana", "extensions": ["mts"] },
  "model/vnd.opengex": { "source": "iana", "extensions": ["ogex"] },
  "model/vnd.parasolid.transmit.binary": { "source": "iana", "extensions": ["x_b"] },
  "model/vnd.parasolid.transmit.text": { "source": "iana", "extensions": ["x_t"] },
  "model/vnd.pytha.pyox": { "source": "iana" },
  "model/vnd.rosette.annotated-data-model": { "source": "iana" },
  "model/vnd.sap.vds": { "source": "iana", "extensions": ["vds"] },
  "model/vnd.usdz+zip": { "source": "iana", "compressible": false, "extensions": ["usdz"] },
  "model/vnd.valve.source.compiled-map": { "source": "iana", "extensions": ["bsp"] },
  "model/vnd.vtu": { "source": "iana", "extensions": ["vtu"] },
  "model/vrml": { "source": "iana", "compressible": false, "extensions": ["wrl", "vrml"] },
  "model/x3d+binary": { "source": "apache", "compressible": false, "extensions": ["x3db", "x3dbz"] },
  "model/x3d+fastinfoset": { "source": "iana", "extensions": ["x3db"] },
  "model/x3d+vrml": { "source": "apache", "compressible": false, "extensions": ["x3dv", "x3dvz"] },
  "model/x3d+xml": { "source": "iana", "compressible": true, "extensions": ["x3d", "x3dz"] },
  "model/x3d-vrml": { "source": "iana", "extensions": ["x3dv"] },
  "multipart/alternative": { "source": "iana", "compressible": false },
  "multipart/appledouble": { "source": "iana" },
  "multipart/byteranges": { "source": "iana" },
  "multipart/digest": { "source": "iana" },
  "multipart/encrypted": { "source": "iana", "compressible": false },
  "multipart/form-data": { "source": "iana", "compressible": false },
  "multipart/header-set": { "source": "iana" },
  "multipart/mixed": { "source": "iana" },
  "multipart/multilingual": { "source": "iana" },
  "multipart/parallel": { "source": "iana" },
  "multipart/related": { "source": "iana", "compressible": false },
  "multipart/report": { "source": "iana" },
  "multipart/signed": { "source": "iana", "compressible": false },
  "multipart/vnd.bint.med-plus": { "source": "iana" },
  "multipart/voice-message": { "source": "iana" },
  "multipart/x-mixed-replace": { "source": "iana" },
  "text/1d-interleaved-parityfec": { "source": "iana" },
  "text/cache-manifest": { "source": "iana", "compressible": true, "extensions": ["appcache", "manifest"] },
  "text/calendar": { "source": "iana", "extensions": ["ics", "ifb"] },
  "text/calender": { "compressible": true },
  "text/cmd": { "compressible": true },
  "text/coffeescript": { "extensions": ["coffee", "litcoffee"] },
  "text/cql": { "source": "iana" },
  "text/cql-expression": { "source": "iana" },
  "text/cql-identifier": { "source": "iana" },
  "text/css": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["css"] },
  "text/csv": { "source": "iana", "compressible": true, "extensions": ["csv"] },
  "text/csv-schema": { "source": "iana" },
  "text/directory": { "source": "iana" },
  "text/dns": { "source": "iana" },
  "text/ecmascript": { "source": "iana" },
  "text/encaprtp": { "source": "iana" },
  "text/enriched": { "source": "iana" },
  "text/fhirpath": { "source": "iana" },
  "text/flexfec": { "source": "iana" },
  "text/fwdred": { "source": "iana" },
  "text/gff3": { "source": "iana" },
  "text/grammar-ref-list": { "source": "iana" },
  "text/html": { "source": "iana", "compressible": true, "extensions": ["html", "htm", "shtml"] },
  "text/jade": { "extensions": ["jade"] },
  "text/javascript": { "source": "iana", "compressible": true },
  "text/jcr-cnd": { "source": "iana" },
  "text/jsx": { "compressible": true, "extensions": ["jsx"] },
  "text/less": { "compressible": true, "extensions": ["less"] },
  "text/markdown": { "source": "iana", "compressible": true, "extensions": ["markdown", "md"] },
  "text/mathml": { "source": "nginx", "extensions": ["mml"] },
  "text/mdx": { "compressible": true, "extensions": ["mdx"] },
  "text/mizar": { "source": "iana" },
  "text/n3": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["n3"] },
  "text/parameters": { "source": "iana", "charset": "UTF-8" },
  "text/parityfec": { "source": "iana" },
  "text/plain": { "source": "iana", "compressible": true, "extensions": ["txt", "text", "conf", "def", "list", "log", "in", "ini"] },
  "text/provenance-notation": { "source": "iana", "charset": "UTF-8" },
  "text/prs.fallenstein.rst": { "source": "iana" },
  "text/prs.lines.tag": { "source": "iana", "extensions": ["dsc"] },
  "text/prs.prop.logic": { "source": "iana" },
  "text/raptorfec": { "source": "iana" },
  "text/red": { "source": "iana" },
  "text/rfc822-headers": { "source": "iana" },
  "text/richtext": { "source": "iana", "compressible": true, "extensions": ["rtx"] },
  "text/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "text/rtp-enc-aescm128": { "source": "iana" },
  "text/rtploopback": { "source": "iana" },
  "text/rtx": { "source": "iana" },
  "text/sgml": { "source": "iana", "extensions": ["sgml", "sgm"] },
  "text/shaclc": { "source": "iana" },
  "text/shex": { "source": "iana", "extensions": ["shex"] },
  "text/slim": { "extensions": ["slim", "slm"] },
  "text/spdx": { "source": "iana", "extensions": ["spdx"] },
  "text/strings": { "source": "iana" },
  "text/stylus": { "extensions": ["stylus", "styl"] },
  "text/t140": { "source": "iana" },
  "text/tab-separated-values": { "source": "iana", "compressible": true, "extensions": ["tsv"] },
  "text/troff": { "source": "iana", "extensions": ["t", "tr", "roff", "man", "me", "ms"] },
  "text/turtle": { "source": "iana", "charset": "UTF-8", "extensions": ["ttl"] },
  "text/ulpfec": { "source": "iana" },
  "text/uri-list": { "source": "iana", "compressible": true, "extensions": ["uri", "uris", "urls"] },
  "text/vcard": { "source": "iana", "compressible": true, "extensions": ["vcard"] },
  "text/vnd.a": { "source": "iana" },
  "text/vnd.abc": { "source": "iana" },
  "text/vnd.ascii-art": { "source": "iana" },
  "text/vnd.curl": { "source": "iana", "extensions": ["curl"] },
  "text/vnd.curl.dcurl": { "source": "apache", "extensions": ["dcurl"] },
  "text/vnd.curl.mcurl": { "source": "apache", "extensions": ["mcurl"] },
  "text/vnd.curl.scurl": { "source": "apache", "extensions": ["scurl"] },
  "text/vnd.debian.copyright": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.dmclientscript": { "source": "iana" },
  "text/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "text/vnd.esmertec.theme-descriptor": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.familysearch.gedcom": { "source": "iana", "extensions": ["ged"] },
  "text/vnd.ficlab.flt": { "source": "iana" },
  "text/vnd.fly": { "source": "iana", "extensions": ["fly"] },
  "text/vnd.fmi.flexstor": { "source": "iana", "extensions": ["flx"] },
  "text/vnd.gml": { "source": "iana" },
  "text/vnd.graphviz": { "source": "iana", "extensions": ["gv"] },
  "text/vnd.hans": { "source": "iana" },
  "text/vnd.hgl": { "source": "iana" },
  "text/vnd.in3d.3dml": { "source": "iana", "extensions": ["3dml"] },
  "text/vnd.in3d.spot": { "source": "iana", "extensions": ["spot"] },
  "text/vnd.iptc.newsml": { "source": "iana" },
  "text/vnd.iptc.nitf": { "source": "iana" },
  "text/vnd.latex-z": { "source": "iana" },
  "text/vnd.motorola.reflex": { "source": "iana" },
  "text/vnd.ms-mediapackage": { "source": "iana" },
  "text/vnd.net2phone.commcenter.command": { "source": "iana" },
  "text/vnd.radisys.msml-basic-layout": { "source": "iana" },
  "text/vnd.senx.warpscript": { "source": "iana" },
  "text/vnd.si.uricatalogue": { "source": "iana" },
  "text/vnd.sosi": { "source": "iana" },
  "text/vnd.sun.j2me.app-descriptor": { "source": "iana", "charset": "UTF-8", "extensions": ["jad"] },
  "text/vnd.trolltech.linguist": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.wap.si": { "source": "iana" },
  "text/vnd.wap.sl": { "source": "iana" },
  "text/vnd.wap.wml": { "source": "iana", "extensions": ["wml"] },
  "text/vnd.wap.wmlscript": { "source": "iana", "extensions": ["wmls"] },
  "text/vtt": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["vtt"] },
  "text/x-asm": { "source": "apache", "extensions": ["s", "asm"] },
  "text/x-c": { "source": "apache", "extensions": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"] },
  "text/x-component": { "source": "nginx", "extensions": ["htc"] },
  "text/x-fortran": { "source": "apache", "extensions": ["f", "for", "f77", "f90"] },
  "text/x-gwt-rpc": { "compressible": true },
  "text/x-handlebars-template": { "extensions": ["hbs"] },
  "text/x-java-source": { "source": "apache", "extensions": ["java"] },
  "text/x-jquery-tmpl": { "compressible": true },
  "text/x-lua": { "extensions": ["lua"] },
  "text/x-markdown": { "compressible": true, "extensions": ["mkd"] },
  "text/x-nfo": { "source": "apache", "extensions": ["nfo"] },
  "text/x-opml": { "source": "apache", "extensions": ["opml"] },
  "text/x-org": { "compressible": true, "extensions": ["org"] },
  "text/x-pascal": { "source": "apache", "extensions": ["p", "pas"] },
  "text/x-processing": { "compressible": true, "extensions": ["pde"] },
  "text/x-sass": { "extensions": ["sass"] },
  "text/x-scss": { "extensions": ["scss"] },
  "text/x-setext": { "source": "apache", "extensions": ["etx"] },
  "text/x-sfv": { "source": "apache", "extensions": ["sfv"] },
  "text/x-suse-ymp": { "compressible": true, "extensions": ["ymp"] },
  "text/x-uuencode": { "source": "apache", "extensions": ["uu"] },
  "text/x-vcalendar": { "source": "apache", "extensions": ["vcs"] },
  "text/x-vcard": { "source": "apache", "extensions": ["vcf"] },
  "text/xml": { "source": "iana", "compressible": true, "extensions": ["xml"] },
  "text/xml-external-parsed-entity": { "source": "iana" },
  "text/yaml": { "compressible": true, "extensions": ["yaml", "yml"] },
  "video/1d-interleaved-parityfec": { "source": "iana" },
  "video/3gpp": { "source": "iana", "extensions": ["3gp", "3gpp"] },
  "video/3gpp-tt": { "source": "iana" },
  "video/3gpp2": { "source": "iana", "extensions": ["3g2"] },
  "video/av1": { "source": "iana" },
  "video/bmpeg": { "source": "iana" },
  "video/bt656": { "source": "iana" },
  "video/celb": { "source": "iana" },
  "video/dv": { "source": "iana" },
  "video/encaprtp": { "source": "iana" },
  "video/ffv1": { "source": "iana" },
  "video/flexfec": { "source": "iana" },
  "video/h261": { "source": "iana", "extensions": ["h261"] },
  "video/h263": { "source": "iana", "extensions": ["h263"] },
  "video/h263-1998": { "source": "iana" },
  "video/h263-2000": { "source": "iana" },
  "video/h264": { "source": "iana", "extensions": ["h264"] },
  "video/h264-rcdo": { "source": "iana" },
  "video/h264-svc": { "source": "iana" },
  "video/h265": { "source": "iana" },
  "video/iso.segment": { "source": "iana", "extensions": ["m4s"] },
  "video/jpeg": { "source": "iana", "extensions": ["jpgv"] },
  "video/jpeg2000": { "source": "iana" },
  "video/jpm": { "source": "apache", "extensions": ["jpm", "jpgm"] },
  "video/jxsv": { "source": "iana" },
  "video/mj2": { "source": "iana", "extensions": ["mj2", "mjp2"] },
  "video/mp1s": { "source": "iana" },
  "video/mp2p": { "source": "iana" },
  "video/mp2t": { "source": "iana", "extensions": ["ts"] },
  "video/mp4": { "source": "iana", "compressible": false, "extensions": ["mp4", "mp4v", "mpg4"] },
  "video/mp4v-es": { "source": "iana" },
  "video/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpeg", "mpg", "mpe", "m1v", "m2v"] },
  "video/mpeg4-generic": { "source": "iana" },
  "video/mpv": { "source": "iana" },
  "video/nv": { "source": "iana" },
  "video/ogg": { "source": "iana", "compressible": false, "extensions": ["ogv"] },
  "video/parityfec": { "source": "iana" },
  "video/pointer": { "source": "iana" },
  "video/quicktime": { "source": "iana", "compressible": false, "extensions": ["qt", "mov"] },
  "video/raptorfec": { "source": "iana" },
  "video/raw": { "source": "iana" },
  "video/rtp-enc-aescm128": { "source": "iana" },
  "video/rtploopback": { "source": "iana" },
  "video/rtx": { "source": "iana" },
  "video/scip": { "source": "iana" },
  "video/smpte291": { "source": "iana" },
  "video/smpte292m": { "source": "iana" },
  "video/ulpfec": { "source": "iana" },
  "video/vc1": { "source": "iana" },
  "video/vc2": { "source": "iana" },
  "video/vnd.cctv": { "source": "iana" },
  "video/vnd.dece.hd": { "source": "iana", "extensions": ["uvh", "uvvh"] },
  "video/vnd.dece.mobile": { "source": "iana", "extensions": ["uvm", "uvvm"] },
  "video/vnd.dece.mp4": { "source": "iana" },
  "video/vnd.dece.pd": { "source": "iana", "extensions": ["uvp", "uvvp"] },
  "video/vnd.dece.sd": { "source": "iana", "extensions": ["uvs", "uvvs"] },
  "video/vnd.dece.video": { "source": "iana", "extensions": ["uvv", "uvvv"] },
  "video/vnd.directv.mpeg": { "source": "iana" },
  "video/vnd.directv.mpeg-tts": { "source": "iana" },
  "video/vnd.dlna.mpeg-tts": { "source": "iana" },
  "video/vnd.dvb.file": { "source": "iana", "extensions": ["dvb"] },
  "video/vnd.fvt": { "source": "iana", "extensions": ["fvt"] },
  "video/vnd.hns.video": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.ttsavc": { "source": "iana" },
  "video/vnd.iptvforum.ttsmpeg2": { "source": "iana" },
  "video/vnd.motorola.video": { "source": "iana" },
  "video/vnd.motorola.videop": { "source": "iana" },
  "video/vnd.mpegurl": { "source": "iana", "extensions": ["mxu", "m4u"] },
  "video/vnd.ms-playready.media.pyv": { "source": "iana", "extensions": ["pyv"] },
  "video/vnd.nokia.interleaved-multimedia": { "source": "iana" },
  "video/vnd.nokia.mp4vr": { "source": "iana" },
  "video/vnd.nokia.videovoip": { "source": "iana" },
  "video/vnd.objectvideo": { "source": "iana" },
  "video/vnd.radgamettools.bink": { "source": "iana" },
  "video/vnd.radgamettools.smacker": { "source": "iana" },
  "video/vnd.sealed.mpeg1": { "source": "iana" },
  "video/vnd.sealed.mpeg4": { "source": "iana" },
  "video/vnd.sealed.swf": { "source": "iana" },
  "video/vnd.sealedmedia.softseal.mov": { "source": "iana" },
  "video/vnd.uvvu.mp4": { "source": "iana", "extensions": ["uvu", "uvvu"] },
  "video/vnd.vivo": { "source": "iana", "extensions": ["viv"] },
  "video/vnd.youtube.yt": { "source": "iana" },
  "video/vp8": { "source": "iana" },
  "video/vp9": { "source": "iana" },
  "video/webm": { "source": "apache", "compressible": false, "extensions": ["webm"] },
  "video/x-f4v": { "source": "apache", "extensions": ["f4v"] },
  "video/x-fli": { "source": "apache", "extensions": ["fli"] },
  "video/x-flv": { "source": "apache", "compressible": false, "extensions": ["flv"] },
  "video/x-m4v": { "source": "apache", "extensions": ["m4v"] },
  "video/x-matroska": { "source": "apache", "compressible": false, "extensions": ["mkv", "mk3d", "mks"] },
  "video/x-mng": { "source": "apache", "extensions": ["mng"] },
  "video/x-ms-asf": { "source": "apache", "extensions": ["asf", "asx"] },
  "video/x-ms-vob": { "source": "apache", "extensions": ["vob"] },
  "video/x-ms-wm": { "source": "apache", "extensions": ["wm"] },
  "video/x-ms-wmv": { "source": "apache", "compressible": false, "extensions": ["wmv"] },
  "video/x-ms-wmx": { "source": "apache", "extensions": ["wmx"] },
  "video/x-ms-wvx": { "source": "apache", "extensions": ["wvx"] },
  "video/x-msvideo": { "source": "apache", "extensions": ["avi"] },
  "video/x-sgi-movie": { "source": "apache", "extensions": ["movie"] },
  "video/x-smv": { "source": "apache", "extensions": ["smv"] },
  "x-conference/x-cooltalk": { "source": "apache", "extensions": ["ice"] },
  "x-shader/x-fragment": { "compressible": true },
  "x-shader/x-vertex": { "compressible": true }
};
var mimeDb;
var hasRequiredMimeDb;
function requireMimeDb() {
  if (hasRequiredMimeDb) return mimeDb;
  hasRequiredMimeDb = 1;
  mimeDb = require$$0;
  return mimeDb;
}
var hasRequiredMimeTypes;
function requireMimeTypes() {
  if (hasRequiredMimeTypes) return mimeTypes;
  hasRequiredMimeTypes = 1;
  (function(exports$1) {
    var db = requireMimeDb();
    var extname = path$1.extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports$1.charset = charset2;
    exports$1.charsets = { lookup: charset2 };
    exports$1.contentType = contentType2;
    exports$1.extension = extension;
    exports$1.extensions = /* @__PURE__ */ Object.create(null);
    exports$1.lookup = lookup;
    exports$1.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports$1.extensions, exports$1.types);
    function charset2(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType2(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports$1.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset3 = exports$1.charset(mime);
        if (charset3) mime += "; charset=" + charset3.toLowerCase();
      }
      return mime;
    }
    function extension(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var exts = match && exports$1.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path2) {
      if (!path2 || typeof path2 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path2).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports$1.types[extension2] || false;
    }
    function populateMaps(extensions, types2) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type2) {
        var mime = db[type2];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type2] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types2[extension2]) {
            var from2 = preference.indexOf(db[types2[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types2[extension2] !== "application/octet-stream" && (from2 > to || from2 === to && types2[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types2[extension2] = type2;
        }
      });
    }
  })(mimeTypes);
  return mimeTypes;
}
var hasRequiredTypeIs;
function requireTypeIs() {
  if (hasRequiredTypeIs) return typeIs.exports;
  hasRequiredTypeIs = 1;
  var typer = requireMediaTyper();
  var mime = requireMimeTypes();
  typeIs.exports = typeofrequest;
  typeIs.exports.is = typeis;
  typeIs.exports.hasBody = hasbody;
  typeIs.exports.normalize = normalize;
  typeIs.exports.match = mimeMatch;
  function typeis(value, types_) {
    var i;
    var types2 = types_;
    var val = tryNormalizeType(value);
    if (!val) {
      return false;
    }
    if (types2 && !Array.isArray(types2)) {
      types2 = new Array(arguments.length - 1);
      for (i = 0; i < types2.length; i++) {
        types2[i] = arguments[i + 1];
      }
    }
    if (!types2 || !types2.length) {
      return val;
    }
    var type2;
    for (i = 0; i < types2.length; i++) {
      if (mimeMatch(normalize(type2 = types2[i]), val)) {
        return type2[0] === "+" || type2.indexOf("*") !== -1 ? val : type2;
      }
    }
    return false;
  }
  function hasbody(req) {
    return req.headers["transfer-encoding"] !== void 0 || !isNaN(req.headers["content-length"]);
  }
  function typeofrequest(req, types_) {
    var types2 = types_;
    if (!hasbody(req)) {
      return null;
    }
    if (arguments.length > 2) {
      types2 = new Array(arguments.length - 1);
      for (var i = 0; i < types2.length; i++) {
        types2[i] = arguments[i + 1];
      }
    }
    var value = req.headers["content-type"];
    return typeis(value, types2);
  }
  function normalize(type2) {
    if (typeof type2 !== "string") {
      return false;
    }
    switch (type2) {
      case "urlencoded":
        return "application/x-www-form-urlencoded";
      case "multipart":
        return "multipart/*";
    }
    if (type2[0] === "+") {
      return "*/*" + type2;
    }
    return type2.indexOf("/") === -1 ? mime.lookup(type2) : type2;
  }
  function mimeMatch(expected, actual) {
    if (expected === false) {
      return false;
    }
    var actualParts = actual.split("/");
    var expectedParts = expected.split("/");
    if (actualParts.length !== 2 || expectedParts.length !== 2) {
      return false;
    }
    if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) {
      return false;
    }
    if (expectedParts[1].substr(0, 2) === "*+") {
      return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
    }
    if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) {
      return false;
    }
    return true;
  }
  function normalizeType(value) {
    var type2 = typer.parse(value);
    type2.parameters = void 0;
    return typer.format(type2);
  }
  function tryNormalizeType(value) {
    if (!value) {
      return null;
    }
    try {
      return normalizeType(value);
    } catch (err) {
      return null;
    }
  }
  return typeIs.exports;
}
var utils;
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  function parseContentType(str) {
    if (str.length === 0)
      return;
    const params = /* @__PURE__ */ Object.create(null);
    let i = 0;
    for (; i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (code !== 47 || i === 0)
          return;
        break;
      }
    }
    if (i === str.length)
      return;
    const type2 = str.slice(0, i).toLowerCase();
    const subtypeStart = ++i;
    for (; i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (i === subtypeStart)
          return;
        if (parseContentTypeParams(str, i, params) === void 0)
          return;
        break;
      }
    }
    if (i === subtypeStart)
      return;
    const subtype = str.slice(subtypeStart, i).toLowerCase();
    return { type: type2, subtype, params };
  }
  function parseContentTypeParams(str, i, params) {
    while (i < str.length) {
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        break;
      if (str.charCodeAt(i++) !== 59)
        return;
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        return;
      let name;
      const nameStart = i;
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code !== 61)
            return;
          break;
        }
      }
      if (i === str.length)
        return;
      name = str.slice(nameStart, i);
      ++i;
      if (i === str.length)
        return;
      let value = "";
      let valueStart;
      if (str.charCodeAt(i) === 34) {
        valueStart = ++i;
        let escaping = false;
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code === 92) {
            if (escaping) {
              valueStart = i;
              escaping = false;
            } else {
              value += str.slice(valueStart, i);
              escaping = true;
            }
            continue;
          }
          if (code === 34) {
            if (escaping) {
              valueStart = i;
              escaping = false;
              continue;
            }
            value += str.slice(valueStart, i);
            break;
          }
          if (escaping) {
            valueStart = i - 1;
            escaping = false;
          }
          if (QDTEXT[code] !== 1)
            return;
        }
        if (i === str.length)
          return;
        ++i;
      } else {
        valueStart = i;
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (TOKEN[code] !== 1) {
            if (i === valueStart)
              return;
            break;
          }
        }
        value = str.slice(valueStart, i);
      }
      name = name.toLowerCase();
      if (params[name] === void 0)
        params[name] = value;
    }
    return params;
  }
  function parseDisposition(str, defDecoder) {
    if (str.length === 0)
      return;
    const params = /* @__PURE__ */ Object.create(null);
    let i = 0;
    for (; i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (parseDispositionParams(str, i, params, defDecoder) === void 0)
          return;
        break;
      }
    }
    const type2 = str.slice(0, i).toLowerCase();
    return { type: type2, params };
  }
  function parseDispositionParams(str, i, params, defDecoder) {
    while (i < str.length) {
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        break;
      if (str.charCodeAt(i++) !== 59)
        return;
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        return;
      let name;
      const nameStart = i;
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code === 61)
            break;
          return;
        }
      }
      if (i === str.length)
        return;
      let value = "";
      let valueStart;
      let charset2;
      name = str.slice(nameStart, i);
      if (name.charCodeAt(name.length - 1) === 42) {
        const charsetStart = ++i;
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (CHARSET[code] !== 1) {
            if (code !== 39)
              return;
            break;
          }
        }
        if (i === str.length)
          return;
        charset2 = str.slice(charsetStart, i);
        ++i;
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code === 39)
            break;
        }
        if (i === str.length)
          return;
        ++i;
        if (i === str.length)
          return;
        valueStart = i;
        let encode2 = 0;
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (EXTENDED_VALUE[code] !== 1) {
            if (code === 37) {
              let hexUpper;
              let hexLower;
              if (i + 2 < str.length && (hexUpper = HEX_VALUES[str.charCodeAt(i + 1)]) !== -1 && (hexLower = HEX_VALUES[str.charCodeAt(i + 2)]) !== -1) {
                const byteVal = (hexUpper << 4) + hexLower;
                value += str.slice(valueStart, i);
                value += String.fromCharCode(byteVal);
                i += 2;
                valueStart = i + 1;
                if (byteVal >= 128)
                  encode2 = 2;
                else if (encode2 === 0)
                  encode2 = 1;
                continue;
              }
              return;
            }
            break;
          }
        }
        value += str.slice(valueStart, i);
        value = convertToUTF8(value, charset2, encode2);
        if (value === void 0)
          return;
      } else {
        ++i;
        if (i === str.length)
          return;
        if (str.charCodeAt(i) === 34) {
          valueStart = ++i;
          let escaping = false;
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (code === 92) {
              if (escaping) {
                valueStart = i;
                escaping = false;
              } else {
                value += str.slice(valueStart, i);
                escaping = true;
              }
              continue;
            }
            if (code === 34) {
              if (escaping) {
                valueStart = i;
                escaping = false;
                continue;
              }
              value += str.slice(valueStart, i);
              break;
            }
            if (escaping) {
              valueStart = i - 1;
              escaping = false;
            }
            if (QDTEXT[code] !== 1)
              return;
          }
          if (i === str.length)
            return;
          ++i;
        } else {
          valueStart = i;
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (TOKEN[code] !== 1) {
              if (i === valueStart)
                return;
              break;
            }
          }
          value = str.slice(valueStart, i);
        }
        value = defDecoder(value, 2);
        if (value === void 0)
          return;
      }
      name = name.toLowerCase();
      if (params[name] === void 0)
        params[name] = value;
    }
    return params;
  }
  function getDecoder(charset2) {
    let lc;
    while (true) {
      switch (charset2) {
        case "utf-8":
        case "utf8":
          return decoders.utf8;
        case "latin1":
        case "ascii":
        // TODO: Make these a separate, strict decoder?
        case "us-ascii":
        case "iso-8859-1":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "windows-1252":
        case "iso_8859-1:1987":
        case "cp1252":
        case "x-cp1252":
          return decoders.latin1;
        case "utf16le":
        case "utf-16le":
        case "ucs2":
        case "ucs-2":
          return decoders.utf16le;
        case "base64":
          return decoders.base64;
        default:
          if (lc === void 0) {
            lc = true;
            charset2 = charset2.toLowerCase();
            continue;
          }
          return decoders.other.bind(charset2);
      }
    }
  }
  const decoders = {
    utf8: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string") {
        if (hint < 2)
          return data;
        data = Buffer.from(data, "latin1");
      }
      return data.utf8Slice(0, data.length);
    },
    latin1: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        return data;
      return data.latin1Slice(0, data.length);
    },
    utf16le: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      return data.ucs2Slice(0, data.length);
    },
    base64: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      return data.base64Slice(0, data.length);
    },
    other: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      try {
        const decoder2 = new TextDecoder(this);
        return decoder2.decode(data);
      } catch {
      }
    }
  };
  function convertToUTF8(data, charset2, hint) {
    const decode2 = getDecoder(charset2);
    if (decode2)
      return decode2(data, hint);
  }
  function basename(path2) {
    if (typeof path2 !== "string")
      return "";
    for (let i = path2.length - 1; i >= 0; --i) {
      switch (path2.charCodeAt(i)) {
        case 47:
        // '/'
        case 92:
          path2 = path2.slice(i + 1);
          return path2 === ".." || path2 === "." ? "" : path2;
      }
    }
    return path2 === ".." || path2 === "." ? "" : path2;
  }
  const TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  const QDTEXT = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ];
  const CHARSET = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  const EXTENDED_VALUE = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  const HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  utils = {
    basename,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
  };
  return utils;
}
var sbmh;
var hasRequiredSbmh;
function requireSbmh() {
  if (hasRequiredSbmh) return sbmh;
  hasRequiredSbmh = 1;
  function memcmp(buf1, pos1, buf2, pos2, num) {
    for (let i = 0; i < num; ++i) {
      if (buf1[pos1 + i] !== buf2[pos2 + i])
        return false;
    }
    return true;
  }
  class SBMH {
    constructor(needle, cb) {
      if (typeof cb !== "function")
        throw new Error("Missing match callback");
      if (typeof needle === "string")
        needle = Buffer.from(needle);
      else if (!Buffer.isBuffer(needle))
        throw new Error(`Expected Buffer for needle, got ${typeof needle}`);
      const needleLen = needle.length;
      this.maxMatches = Infinity;
      this.matches = 0;
      this._cb = cb;
      this._lookbehindSize = 0;
      this._needle = needle;
      this._bufPos = 0;
      this._lookbehind = Buffer.allocUnsafe(needleLen);
      this._occ = [
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen
      ];
      if (needleLen > 1) {
        for (let i = 0; i < needleLen - 1; ++i)
          this._occ[needle[i]] = needleLen - 1 - i;
      }
    }
    reset() {
      this.matches = 0;
      this._lookbehindSize = 0;
      this._bufPos = 0;
    }
    push(chunk, pos2) {
      let result;
      if (!Buffer.isBuffer(chunk))
        chunk = Buffer.from(chunk, "latin1");
      const chunkLen = chunk.length;
      this._bufPos = pos2 || 0;
      while (result !== chunkLen && this.matches < this.maxMatches)
        result = feed(this, chunk);
      return result;
    }
    destroy() {
      const lbSize = this._lookbehindSize;
      if (lbSize)
        this._cb(false, this._lookbehind, 0, lbSize, false);
      this.reset();
    }
  }
  function feed(self2, data) {
    const len = data.length;
    const needle = self2._needle;
    const needleLen = needle.length;
    let pos2 = -self2._lookbehindSize;
    const lastNeedleCharPos = needleLen - 1;
    const lastNeedleChar = needle[lastNeedleCharPos];
    const end = len - needleLen;
    const occ = self2._occ;
    const lookbehind = self2._lookbehind;
    if (pos2 < 0) {
      while (pos2 < 0 && pos2 <= end) {
        const nextPos = pos2 + lastNeedleCharPos;
        const ch = nextPos < 0 ? lookbehind[self2._lookbehindSize + nextPos] : data[nextPos];
        if (ch === lastNeedleChar && matchNeedle(self2, data, pos2, lastNeedleCharPos)) {
          self2._lookbehindSize = 0;
          ++self2.matches;
          if (pos2 > -self2._lookbehindSize)
            self2._cb(true, lookbehind, 0, self2._lookbehindSize + pos2, false);
          else
            self2._cb(true, void 0, 0, 0, true);
          return self2._bufPos = pos2 + needleLen;
        }
        pos2 += occ[ch];
      }
      while (pos2 < 0 && !matchNeedle(self2, data, pos2, len - pos2))
        ++pos2;
      if (pos2 < 0) {
        const bytesToCutOff = self2._lookbehindSize + pos2;
        if (bytesToCutOff > 0) {
          self2._cb(false, lookbehind, 0, bytesToCutOff, false);
        }
        self2._lookbehindSize -= bytesToCutOff;
        lookbehind.copy(lookbehind, 0, bytesToCutOff, self2._lookbehindSize);
        lookbehind.set(data, self2._lookbehindSize);
        self2._lookbehindSize += len;
        self2._bufPos = len;
        return len;
      }
      self2._cb(false, lookbehind, 0, self2._lookbehindSize, false);
      self2._lookbehindSize = 0;
    }
    pos2 += self2._bufPos;
    const firstNeedleChar = needle[0];
    while (pos2 <= end) {
      const ch = data[pos2 + lastNeedleCharPos];
      if (ch === lastNeedleChar && data[pos2] === firstNeedleChar && memcmp(needle, 0, data, pos2, lastNeedleCharPos)) {
        ++self2.matches;
        if (pos2 > 0)
          self2._cb(true, data, self2._bufPos, pos2, true);
        else
          self2._cb(true, void 0, 0, 0, true);
        return self2._bufPos = pos2 + needleLen;
      }
      pos2 += occ[ch];
    }
    while (pos2 < len) {
      if (data[pos2] !== firstNeedleChar || !memcmp(data, pos2, needle, 0, len - pos2)) {
        ++pos2;
        continue;
      }
      data.copy(lookbehind, 0, pos2, len);
      self2._lookbehindSize = len - pos2;
      break;
    }
    if (pos2 > 0)
      self2._cb(false, data, self2._bufPos, pos2 < len ? pos2 : len, true);
    self2._bufPos = len;
    return len;
  }
  function matchNeedle(self2, data, pos2, len) {
    const lb = self2._lookbehind;
    const lbSize = self2._lookbehindSize;
    const needle = self2._needle;
    for (let i = 0; i < len; ++i, ++pos2) {
      const ch = pos2 < 0 ? lb[lbSize + pos2] : data[pos2];
      if (ch !== needle[i])
        return false;
    }
    return true;
  }
  sbmh = SBMH;
  return sbmh;
}
var multipart;
var hasRequiredMultipart;
function requireMultipart() {
  if (hasRequiredMultipart) return multipart;
  hasRequiredMultipart = 1;
  const { Readable, Writable } = require$$0$6;
  const StreamSearch = requireSbmh();
  const {
    basename,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
  } = requireUtils();
  const BUF_CRLF = Buffer.from("\r\n");
  const BUF_CR = Buffer.from("\r");
  const BUF_DASH = Buffer.from("-");
  function noop2() {
  }
  const MAX_HEADER_PAIRS = 2e3;
  const MAX_HEADER_SIZE = 16 * 1024;
  const HPARSER_NAME = 0;
  const HPARSER_PRE_OWS = 1;
  const HPARSER_VALUE = 2;
  class HeaderParser {
    constructor(cb) {
      this.header = /* @__PURE__ */ Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = "";
      this.value = "";
      this.crlf = 0;
      this.cb = cb;
    }
    reset() {
      this.header = /* @__PURE__ */ Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = "";
      this.value = "";
      this.crlf = 0;
    }
    push(chunk, pos2, end) {
      let start = pos2;
      while (pos2 < end) {
        switch (this.state) {
          case HPARSER_NAME: {
            let done = false;
            for (; pos2 < end; ++pos2) {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code = chunk[pos2];
              if (TOKEN[code] !== 1) {
                if (code !== 58)
                  return -1;
                this.name += chunk.latin1Slice(start, pos2);
                if (this.name.length === 0)
                  return -1;
                ++pos2;
                done = true;
                this.state = HPARSER_PRE_OWS;
                break;
              }
            }
            if (!done) {
              this.name += chunk.latin1Slice(start, pos2);
              break;
            }
          }
          case HPARSER_PRE_OWS: {
            let done = false;
            for (; pos2 < end; ++pos2) {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code = chunk[pos2];
              if (code !== 32 && code !== 9) {
                start = pos2;
                done = true;
                this.state = HPARSER_VALUE;
                break;
              }
            }
            if (!done)
              break;
          }
          case HPARSER_VALUE:
            switch (this.crlf) {
              case 0:
                for (; pos2 < end; ++pos2) {
                  if (this.byteCount === MAX_HEADER_SIZE)
                    return -1;
                  ++this.byteCount;
                  const code = chunk[pos2];
                  if (FIELD_VCHAR[code] !== 1) {
                    if (code !== 13)
                      return -1;
                    ++this.crlf;
                    break;
                  }
                }
                this.value += chunk.latin1Slice(start, pos2++);
                break;
              case 1:
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                if (chunk[pos2++] !== 10)
                  return -1;
                ++this.crlf;
                break;
              case 2: {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                const code = chunk[pos2];
                if (code === 32 || code === 9) {
                  start = pos2;
                  this.crlf = 0;
                } else {
                  if (++this.pairCount < MAX_HEADER_PAIRS) {
                    this.name = this.name.toLowerCase();
                    if (this.header[this.name] === void 0)
                      this.header[this.name] = [this.value];
                    else
                      this.header[this.name].push(this.value);
                  }
                  if (code === 13) {
                    ++this.crlf;
                    ++pos2;
                  } else {
                    start = pos2;
                    this.crlf = 0;
                    this.state = HPARSER_NAME;
                    this.name = "";
                    this.value = "";
                  }
                }
                break;
              }
              case 3: {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                if (chunk[pos2++] !== 10)
                  return -1;
                const header = this.header;
                this.reset();
                this.cb(header);
                return pos2;
              }
            }
            break;
        }
      }
      return pos2;
    }
  }
  class FileStream extends Readable {
    constructor(opts, owner) {
      super(opts);
      this.truncated = false;
      this._readcb = null;
      this.once("end", () => {
        this._read();
        if (--owner._fileEndsLeft === 0 && owner._finalcb) {
          const cb = owner._finalcb;
          owner._finalcb = null;
          process.nextTick(cb);
        }
      });
    }
    _read(n) {
      const cb = this._readcb;
      if (cb) {
        this._readcb = null;
        cb();
      }
    }
  }
  const ignoreData = {
    push: (chunk, pos2) => {
    },
    destroy: () => {
    }
  };
  function callAndUnsetCb(self2, err) {
    const cb = self2._writecb;
    self2._writecb = null;
    if (cb)
      cb();
  }
  function nullDecoder(val, hint) {
    return val;
  }
  class Multipart extends Writable {
    constructor(cfg) {
      const streamOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : void 0
      };
      super(streamOpts);
      if (!cfg.conType.params || typeof cfg.conType.params.boundary !== "string")
        throw new Error("Multipart: Boundary not found");
      const boundary = cfg.conType.params.boundary;
      const paramDecoder = typeof cfg.defParamCharset === "string" && cfg.defParamCharset ? getDecoder(cfg.defParamCharset) : nullDecoder;
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.fileHwm === "number" ? cfg.fileHwm : void 0
      };
      const limits = cfg.limits;
      const fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
      const fileSizeLimit = limits && typeof limits.fileSize === "number" ? limits.fileSize : Infinity;
      const filesLimit = limits && typeof limits.files === "number" ? limits.files : Infinity;
      const fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
      const partsLimit = limits && typeof limits.parts === "number" ? limits.parts : Infinity;
      let parts = -1;
      let fields = 0;
      let files = 0;
      let skipPart = false;
      this._fileEndsLeft = 0;
      this._fileStream = void 0;
      this._complete = false;
      let fileSize = 0;
      let field;
      let fieldSize = 0;
      let partCharset;
      let partEncoding;
      let partType;
      let partName;
      let partTruncated = false;
      let hitFilesLimit = false;
      let hitFieldsLimit = false;
      this._hparser = null;
      const hparser = new HeaderParser((header) => {
        this._hparser = null;
        skipPart = false;
        partType = "text/plain";
        partCharset = defCharset;
        partEncoding = "7bit";
        partName = void 0;
        partTruncated = false;
        let filename;
        if (!header["content-disposition"]) {
          skipPart = true;
          return;
        }
        const disp = parseDisposition(
          header["content-disposition"][0],
          paramDecoder
        );
        if (!disp || disp.type !== "form-data") {
          skipPart = true;
          return;
        }
        if (disp.params) {
          if (disp.params.name)
            partName = disp.params.name;
          if (disp.params["filename*"])
            filename = disp.params["filename*"];
          else if (disp.params.filename)
            filename = disp.params.filename;
          if (filename !== void 0 && !preservePath)
            filename = basename(filename);
        }
        if (header["content-type"]) {
          const conType = parseContentType(header["content-type"][0]);
          if (conType) {
            partType = `${conType.type}/${conType.subtype}`;
            if (conType.params && typeof conType.params.charset === "string")
              partCharset = conType.params.charset.toLowerCase();
          }
        }
        if (header["content-transfer-encoding"])
          partEncoding = header["content-transfer-encoding"][0].toLowerCase();
        if (partType === "application/octet-stream" || filename !== void 0) {
          if (files === filesLimit) {
            if (!hitFilesLimit) {
              hitFilesLimit = true;
              this.emit("filesLimit");
            }
            skipPart = true;
            return;
          }
          ++files;
          if (this.listenerCount("file") === 0) {
            skipPart = true;
            return;
          }
          fileSize = 0;
          this._fileStream = new FileStream(fileOpts, this);
          ++this._fileEndsLeft;
          this.emit(
            "file",
            partName,
            this._fileStream,
            {
              filename,
              encoding: partEncoding,
              mimeType: partType
            }
          );
        } else {
          if (fields === fieldsLimit) {
            if (!hitFieldsLimit) {
              hitFieldsLimit = true;
              this.emit("fieldsLimit");
            }
            skipPart = true;
            return;
          }
          ++fields;
          if (this.listenerCount("field") === 0) {
            skipPart = true;
            return;
          }
          field = [];
          fieldSize = 0;
        }
      });
      let matchPostBoundary = 0;
      const ssCb = (isMatch, data, start, end, isDataSafe) => {
        retrydata:
          while (data) {
            if (this._hparser !== null) {
              const ret = this._hparser.push(data, start, end);
              if (ret === -1) {
                this._hparser = null;
                hparser.reset();
                this.emit("error", new Error("Malformed part header"));
                break;
              }
              start = ret;
            }
            if (start === end)
              break;
            if (matchPostBoundary !== 0) {
              if (matchPostBoundary === 1) {
                switch (data[start]) {
                  case 45:
                    matchPostBoundary = 2;
                    ++start;
                    break;
                  case 13:
                    matchPostBoundary = 3;
                    ++start;
                    break;
                  default:
                    matchPostBoundary = 0;
                }
                if (start === end)
                  return;
              }
              if (matchPostBoundary === 2) {
                matchPostBoundary = 0;
                if (data[start] === 45) {
                  this._complete = true;
                  this._bparser = ignoreData;
                  return;
                }
                const writecb = this._writecb;
                this._writecb = noop2;
                ssCb(false, BUF_DASH, 0, 1, false);
                this._writecb = writecb;
              } else if (matchPostBoundary === 3) {
                matchPostBoundary = 0;
                if (data[start] === 10) {
                  ++start;
                  if (parts >= partsLimit)
                    break;
                  this._hparser = hparser;
                  if (start === end)
                    break;
                  continue retrydata;
                } else {
                  const writecb = this._writecb;
                  this._writecb = noop2;
                  ssCb(false, BUF_CR, 0, 1, false);
                  this._writecb = writecb;
                }
              }
            }
            if (!skipPart) {
              if (this._fileStream) {
                let chunk;
                const actualLen = Math.min(end - start, fileSizeLimit - fileSize);
                if (!isDataSafe) {
                  chunk = Buffer.allocUnsafe(actualLen);
                  data.copy(chunk, 0, start, start + actualLen);
                } else {
                  chunk = data.slice(start, start + actualLen);
                }
                fileSize += chunk.length;
                if (fileSize === fileSizeLimit) {
                  if (chunk.length > 0)
                    this._fileStream.push(chunk);
                  this._fileStream.emit("limit");
                  this._fileStream.truncated = true;
                  skipPart = true;
                } else if (!this._fileStream.push(chunk)) {
                  if (this._writecb)
                    this._fileStream._readcb = this._writecb;
                  this._writecb = null;
                }
              } else if (field !== void 0) {
                let chunk;
                const actualLen = Math.min(
                  end - start,
                  fieldSizeLimit - fieldSize
                );
                if (!isDataSafe) {
                  chunk = Buffer.allocUnsafe(actualLen);
                  data.copy(chunk, 0, start, start + actualLen);
                } else {
                  chunk = data.slice(start, start + actualLen);
                }
                fieldSize += actualLen;
                field.push(chunk);
                if (fieldSize === fieldSizeLimit) {
                  skipPart = true;
                  partTruncated = true;
                }
              }
            }
            break;
          }
        if (isMatch) {
          matchPostBoundary = 1;
          if (this._fileStream) {
            this._fileStream.push(null);
            this._fileStream = null;
          } else if (field !== void 0) {
            let data2;
            switch (field.length) {
              case 0:
                data2 = "";
                break;
              case 1:
                data2 = convertToUTF8(field[0], partCharset, 0);
                break;
              default:
                data2 = convertToUTF8(
                  Buffer.concat(field, fieldSize),
                  partCharset,
                  0
                );
            }
            field = void 0;
            fieldSize = 0;
            this.emit(
              "field",
              partName,
              data2,
              {
                nameTruncated: false,
                valueTruncated: partTruncated,
                encoding: partEncoding,
                mimeType: partType
              }
            );
          }
          if (++parts === partsLimit)
            this.emit("partsLimit");
        }
      };
      this._bparser = new StreamSearch(`\r
--${boundary}`, ssCb);
      this._writecb = null;
      this._finalcb = null;
      this.write(BUF_CRLF);
    }
    static detect(conType) {
      return conType.type === "multipart" && conType.subtype === "form-data";
    }
    _write(chunk, enc, cb) {
      this._writecb = cb;
      this._bparser.push(chunk, 0);
      if (this._writecb)
        callAndUnsetCb(this);
    }
    _destroy(err, cb) {
      this._hparser = null;
      this._bparser = ignoreData;
      if (!err)
        err = checkEndState(this);
      const fileStream = this._fileStream;
      if (fileStream) {
        this._fileStream = null;
        fileStream.destroy(err);
      }
      cb(err);
    }
    _final(cb) {
      this._bparser.destroy();
      if (!this._complete)
        return cb(new Error("Unexpected end of form"));
      if (this._fileEndsLeft)
        this._finalcb = finalcb.bind(null, this, cb);
      else
        finalcb(this, cb);
    }
  }
  function finalcb(self2, cb, err) {
    if (err)
      return cb(err);
    err = checkEndState(self2);
    cb(err);
  }
  function checkEndState(self2) {
    if (self2._hparser)
      return new Error("Malformed part header");
    const fileStream = self2._fileStream;
    if (fileStream) {
      self2._fileStream = null;
      fileStream.destroy(new Error("Unexpected end of file"));
    }
    if (!self2._complete)
      return new Error("Unexpected end of form");
  }
  const TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  const FIELD_VCHAR = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ];
  multipart = Multipart;
  return multipart;
}
var urlencoded;
var hasRequiredUrlencoded;
function requireUrlencoded() {
  if (hasRequiredUrlencoded) return urlencoded;
  hasRequiredUrlencoded = 1;
  const { Writable } = require$$0$6;
  const { getDecoder } = requireUtils();
  class URLEncoded extends Writable {
    constructor(cfg) {
      const streamOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : void 0
      };
      super(streamOpts);
      let charset2 = cfg.defCharset || "utf8";
      if (cfg.conType.params && typeof cfg.conType.params.charset === "string")
        charset2 = cfg.conType.params.charset;
      this.charset = charset2;
      const limits = cfg.limits;
      this.fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
      this.fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
      this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === "number" ? limits.fieldNameSize : 100;
      this._inKey = true;
      this._keyTrunc = false;
      this._valTrunc = false;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._fields = 0;
      this._key = "";
      this._val = "";
      this._byte = -2;
      this._lastPos = 0;
      this._encode = 0;
      this._decoder = getDecoder(charset2);
    }
    static detect(conType) {
      return conType.type === "application" && conType.subtype === "x-www-form-urlencoded";
    }
    _write(chunk, enc, cb) {
      if (this._fields >= this.fieldsLimit)
        return cb();
      let i = 0;
      const len = chunk.length;
      this._lastPos = 0;
      if (this._byte !== -2) {
        i = readPctEnc(this, chunk, i, len);
        if (i === -1)
          return cb(new Error("Malformed urlencoded form"));
        if (i >= len)
          return cb();
        if (this._inKey)
          ++this._bytesKey;
        else
          ++this._bytesVal;
      }
      main:
        while (i < len) {
          if (this._inKey) {
            i = skipKeyBytes(this, chunk, i, len);
            while (i < len) {
              switch (chunk[i]) {
                case 61:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._key = this._decoder(this._key, this._encode);
                  this._encode = 0;
                  this._inKey = false;
                  continue main;
                case 38:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._key = this._decoder(this._key, this._encode);
                  this._encode = 0;
                  if (this._bytesKey > 0) {
                    this.emit(
                      "field",
                      this._key,
                      "",
                      {
                        nameTruncated: this._keyTrunc,
                        valueTruncated: false,
                        encoding: this.charset,
                        mimeType: "text/plain"
                      }
                    );
                  }
                  this._key = "";
                  this._val = "";
                  this._keyTrunc = false;
                  this._valTrunc = false;
                  this._bytesKey = 0;
                  this._bytesVal = 0;
                  if (++this._fields >= this.fieldsLimit) {
                    this.emit("fieldsLimit");
                    return cb();
                  }
                  continue;
                case 43:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._key += " ";
                  this._lastPos = i + 1;
                  break;
                case 37:
                  if (this._encode === 0)
                    this._encode = 1;
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = i + 1;
                  this._byte = -1;
                  i = readPctEnc(this, chunk, i + 1, len);
                  if (i === -1)
                    return cb(new Error("Malformed urlencoded form"));
                  if (i >= len)
                    return cb();
                  ++this._bytesKey;
                  i = skipKeyBytes(this, chunk, i, len);
                  continue;
              }
              ++i;
              ++this._bytesKey;
              i = skipKeyBytes(this, chunk, i, len);
            }
            if (this._lastPos < i)
              this._key += chunk.latin1Slice(this._lastPos, i);
          } else {
            i = skipValBytes(this, chunk, i, len);
            while (i < len) {
              switch (chunk[i]) {
                case 38:
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._inKey = true;
                  this._val = this._decoder(this._val, this._encode);
                  this._encode = 0;
                  if (this._bytesKey > 0 || this._bytesVal > 0) {
                    this.emit(
                      "field",
                      this._key,
                      this._val,
                      {
                        nameTruncated: this._keyTrunc,
                        valueTruncated: this._valTrunc,
                        encoding: this.charset,
                        mimeType: "text/plain"
                      }
                    );
                  }
                  this._key = "";
                  this._val = "";
                  this._keyTrunc = false;
                  this._valTrunc = false;
                  this._bytesKey = 0;
                  this._bytesVal = 0;
                  if (++this._fields >= this.fieldsLimit) {
                    this.emit("fieldsLimit");
                    return cb();
                  }
                  continue main;
                case 43:
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._val += " ";
                  this._lastPos = i + 1;
                  break;
                case 37:
                  if (this._encode === 0)
                    this._encode = 1;
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = i + 1;
                  this._byte = -1;
                  i = readPctEnc(this, chunk, i + 1, len);
                  if (i === -1)
                    return cb(new Error("Malformed urlencoded form"));
                  if (i >= len)
                    return cb();
                  ++this._bytesVal;
                  i = skipValBytes(this, chunk, i, len);
                  continue;
              }
              ++i;
              ++this._bytesVal;
              i = skipValBytes(this, chunk, i, len);
            }
            if (this._lastPos < i)
              this._val += chunk.latin1Slice(this._lastPos, i);
          }
        }
      cb();
    }
    _final(cb) {
      if (this._byte !== -2)
        return cb(new Error("Malformed urlencoded form"));
      if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {
        if (this._inKey)
          this._key = this._decoder(this._key, this._encode);
        else
          this._val = this._decoder(this._val, this._encode);
        this.emit(
          "field",
          this._key,
          this._val,
          {
            nameTruncated: this._keyTrunc,
            valueTruncated: this._valTrunc,
            encoding: this.charset,
            mimeType: "text/plain"
          }
        );
      }
      cb();
    }
  }
  function readPctEnc(self2, chunk, pos2, len) {
    if (pos2 >= len)
      return len;
    if (self2._byte === -1) {
      const hexUpper = HEX_VALUES[chunk[pos2++]];
      if (hexUpper === -1)
        return -1;
      if (hexUpper >= 8)
        self2._encode = 2;
      if (pos2 < len) {
        const hexLower = HEX_VALUES[chunk[pos2++]];
        if (hexLower === -1)
          return -1;
        if (self2._inKey)
          self2._key += String.fromCharCode((hexUpper << 4) + hexLower);
        else
          self2._val += String.fromCharCode((hexUpper << 4) + hexLower);
        self2._byte = -2;
        self2._lastPos = pos2;
      } else {
        self2._byte = hexUpper;
      }
    } else {
      const hexLower = HEX_VALUES[chunk[pos2++]];
      if (hexLower === -1)
        return -1;
      if (self2._inKey)
        self2._key += String.fromCharCode((self2._byte << 4) + hexLower);
      else
        self2._val += String.fromCharCode((self2._byte << 4) + hexLower);
      self2._byte = -2;
      self2._lastPos = pos2;
    }
    return pos2;
  }
  function skipKeyBytes(self2, chunk, pos2, len) {
    if (self2._bytesKey > self2.fieldNameSizeLimit) {
      if (!self2._keyTrunc) {
        if (self2._lastPos < pos2)
          self2._key += chunk.latin1Slice(self2._lastPos, pos2 - 1);
      }
      self2._keyTrunc = true;
      for (; pos2 < len; ++pos2) {
        const code = chunk[pos2];
        if (code === 61 || code === 38)
          break;
        ++self2._bytesKey;
      }
      self2._lastPos = pos2;
    }
    return pos2;
  }
  function skipValBytes(self2, chunk, pos2, len) {
    if (self2._bytesVal > self2.fieldSizeLimit) {
      if (!self2._valTrunc) {
        if (self2._lastPos < pos2)
          self2._val += chunk.latin1Slice(self2._lastPos, pos2 - 1);
      }
      self2._valTrunc = true;
      for (; pos2 < len; ++pos2) {
        if (chunk[pos2] === 38)
          break;
        ++self2._bytesVal;
      }
      self2._lastPos = pos2;
    }
    return pos2;
  }
  const HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  urlencoded = URLEncoded;
  return urlencoded;
}
var lib;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  const { parseContentType } = requireUtils();
  function getInstance(cfg) {
    const headers = cfg.headers;
    const conType = parseContentType(headers["content-type"]);
    if (!conType)
      throw new Error("Malformed content type");
    for (const type2 of TYPES) {
      const matched = type2.detect(conType);
      if (!matched)
        continue;
      const instanceCfg = {
        limits: cfg.limits,
        headers,
        conType,
        highWaterMark: void 0,
        fileHwm: void 0,
        defCharset: void 0,
        defParamCharset: void 0,
        preservePath: false
      };
      if (cfg.highWaterMark)
        instanceCfg.highWaterMark = cfg.highWaterMark;
      if (cfg.fileHwm)
        instanceCfg.fileHwm = cfg.fileHwm;
      instanceCfg.defCharset = cfg.defCharset;
      instanceCfg.defParamCharset = cfg.defParamCharset;
      instanceCfg.preservePath = cfg.preservePath;
      return new type2(instanceCfg);
    }
    throw new Error(`Unsupported content type: ${headers["content-type"]}`);
  }
  const TYPES = [
    requireMultipart(),
    requireUrlencoded()
  ].filter(function(typemod) {
    return typeof typemod.detect === "function";
  });
  lib = (cfg) => {
    if (typeof cfg !== "object" || cfg === null)
      cfg = {};
    if (typeof cfg.headers !== "object" || cfg.headers === null || typeof cfg.headers["content-type"] !== "string") {
      throw new Error("Missing Content-Type");
    }
    return getInstance(cfg);
  };
  return lib;
}
var immutable;
var hasRequiredImmutable;
function requireImmutable() {
  if (hasRequiredImmutable) return immutable;
  hasRequiredImmutable = 1;
  immutable = extend2;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function extend2() {
    var target = {};
    for (var i = 0; i < arguments.length; i++) {
      var source2 = arguments[i];
      for (var key2 in source2) {
        if (hasOwnProperty.call(source2, key2)) {
          target[key2] = source2[key2];
        }
      }
    }
    return target;
  }
  return immutable;
}
var parsePath_1;
var hasRequiredParsePath;
function requireParsePath() {
  if (hasRequiredParsePath) return parsePath_1;
  hasRequiredParsePath = 1;
  var reFirstKey = /^[^\[]*/;
  var reDigitPath = /^\[(\d+)\]/;
  var reNormalPath = /^\[([^\]]+)\]/;
  function parsePath(key2) {
    function failure() {
      return [{ type: "object", key: key2, last: true }];
    }
    var firstKey = reFirstKey.exec(key2)[0];
    if (!firstKey) return failure();
    var len = key2.length;
    var pos2 = firstKey.length;
    var tail = { type: "object", key: firstKey };
    var steps = [tail];
    while (pos2 < len) {
      var m;
      if (key2[pos2] === "[" && key2[pos2 + 1] === "]") {
        pos2 += 2;
        tail.append = true;
        if (pos2 !== len) return failure();
        continue;
      }
      m = reDigitPath.exec(key2.substring(pos2));
      if (m !== null) {
        pos2 += m[0].length;
        tail.nextType = "array";
        tail = { type: "array", key: parseInt(m[1], 10) };
        steps.push(tail);
        continue;
      }
      m = reNormalPath.exec(key2.substring(pos2));
      if (m !== null) {
        pos2 += m[0].length;
        tail.nextType = "object";
        tail = { type: "object", key: m[1] };
        steps.push(tail);
        continue;
      }
      return failure();
    }
    tail.last = true;
    return steps;
  }
  parsePath_1 = parsePath;
  return parsePath_1;
}
var setValue_1;
var hasRequiredSetValue;
function requireSetValue() {
  if (hasRequiredSetValue) return setValue_1;
  hasRequiredSetValue = 1;
  function valueType(value) {
    if (value === void 0) return "undefined";
    if (Array.isArray(value)) return "array";
    if (typeof value === "object") return "object";
    return "scalar";
  }
  function setLastValue(context, step, currentValue, entryValue) {
    switch (valueType(currentValue)) {
      case "undefined":
        if (step.append) {
          context[step.key] = [entryValue];
        } else {
          context[step.key] = entryValue;
        }
        break;
      case "array":
        context[step.key].push(entryValue);
        break;
      case "object":
        return setLastValue(currentValue, { key: "" }, currentValue[""], entryValue);
      case "scalar":
        context[step.key] = [context[step.key], entryValue];
        break;
    }
    return context;
  }
  function setValue(context, step, currentValue, entryValue) {
    if (step.last) return setLastValue(context, step, currentValue, entryValue);
    var obj;
    switch (valueType(currentValue)) {
      case "undefined":
        if (step.nextType === "array") {
          context[step.key] = [];
        } else {
          context[step.key] = /* @__PURE__ */ Object.create(null);
        }
        return context[step.key];
      case "object":
        return context[step.key];
      case "array":
        if (step.nextType === "array") {
          return currentValue;
        }
        obj = /* @__PURE__ */ Object.create(null);
        context[step.key] = obj;
        currentValue.forEach(function(item, i) {
          if (item !== void 0) obj["" + i] = item;
        });
        return obj;
      case "scalar":
        obj = /* @__PURE__ */ Object.create(null);
        obj[""] = currentValue;
        context[step.key] = obj;
        return obj;
    }
  }
  setValue_1 = setValue;
  return setValue_1;
}
var appendField_1;
var hasRequiredAppendField;
function requireAppendField() {
  if (hasRequiredAppendField) return appendField_1;
  hasRequiredAppendField = 1;
  var parsePath = requireParsePath();
  var setValue = requireSetValue();
  function appendField(store, key2, value) {
    var steps = parsePath(key2);
    steps.reduce(function(context, step) {
      return setValue(context, step, context[step.key], value);
    }, store);
  }
  appendField_1 = appendField;
  return appendField_1;
}
var counter;
var hasRequiredCounter;
function requireCounter() {
  if (hasRequiredCounter) return counter;
  hasRequiredCounter = 1;
  var EventEmitter = require$$0$7.EventEmitter;
  function Counter() {
    EventEmitter.call(this);
    this.value = 0;
  }
  Counter.prototype = Object.create(EventEmitter.prototype);
  Counter.prototype.increment = function increment() {
    this.value++;
  };
  Counter.prototype.decrement = function decrement() {
    if (--this.value === 0) this.emit("zero");
  };
  Counter.prototype.isZero = function isZero() {
    return this.value === 0;
  };
  Counter.prototype.onceZero = function onceZero(fn) {
    if (this.isZero()) return fn();
    this.once("zero", fn);
  };
  counter = Counter;
  return counter;
}
var multerError;
var hasRequiredMulterError;
function requireMulterError() {
  if (hasRequiredMulterError) return multerError;
  hasRequiredMulterError = 1;
  var util2 = require$$1$2;
  var errorMessages = {
    LIMIT_PART_COUNT: "Too many parts",
    LIMIT_FILE_SIZE: "File too large",
    LIMIT_FILE_COUNT: "Too many files",
    LIMIT_FIELD_KEY: "Field name too long",
    LIMIT_FIELD_VALUE: "Field value too long",
    LIMIT_FIELD_COUNT: "Too many fields",
    LIMIT_UNEXPECTED_FILE: "Unexpected field",
    MISSING_FIELD_NAME: "Field name missing"
  };
  function MulterError(code, field) {
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
    this.message = errorMessages[code];
    this.code = code;
    if (field) this.field = field;
  }
  util2.inherits(MulterError, Error);
  multerError = MulterError;
  return multerError;
}
var fileAppender;
var hasRequiredFileAppender;
function requireFileAppender() {
  if (hasRequiredFileAppender) return fileAppender;
  hasRequiredFileAppender = 1;
  var objectAssign2 = requireObjectAssign();
  function arrayRemove(arr, item) {
    var idx = arr.indexOf(item);
    if (~idx) arr.splice(idx, 1);
  }
  function FileAppender(strategy, req) {
    this.strategy = strategy;
    this.req = req;
    switch (strategy) {
      case "NONE":
        break;
      case "VALUE":
        break;
      case "ARRAY":
        req.files = [];
        break;
      case "OBJECT":
        req.files = /* @__PURE__ */ Object.create(null);
        break;
      default:
        throw new Error("Unknown file strategy: " + strategy);
    }
  }
  FileAppender.prototype.insertPlaceholder = function(file2) {
    var placeholder = {
      fieldname: file2.fieldname
    };
    switch (this.strategy) {
      case "NONE":
        break;
      case "VALUE":
        break;
      case "ARRAY":
        this.req.files.push(placeholder);
        break;
      case "OBJECT":
        if (this.req.files[file2.fieldname]) {
          this.req.files[file2.fieldname].push(placeholder);
        } else {
          this.req.files[file2.fieldname] = [placeholder];
        }
        break;
    }
    return placeholder;
  };
  FileAppender.prototype.removePlaceholder = function(placeholder) {
    switch (this.strategy) {
      case "NONE":
        break;
      case "VALUE":
        break;
      case "ARRAY":
        arrayRemove(this.req.files, placeholder);
        break;
      case "OBJECT":
        if (this.req.files[placeholder.fieldname].length === 1) {
          delete this.req.files[placeholder.fieldname];
        } else {
          arrayRemove(this.req.files[placeholder.fieldname], placeholder);
        }
        break;
    }
  };
  FileAppender.prototype.replacePlaceholder = function(placeholder, file2) {
    if (this.strategy === "VALUE") {
      this.req.file = file2;
      return;
    }
    delete placeholder.fieldname;
    objectAssign2(placeholder, file2);
  };
  fileAppender = FileAppender;
  return fileAppender;
}
var removeUploadedFiles_1;
var hasRequiredRemoveUploadedFiles;
function requireRemoveUploadedFiles() {
  if (hasRequiredRemoveUploadedFiles) return removeUploadedFiles_1;
  hasRequiredRemoveUploadedFiles = 1;
  function removeUploadedFiles(uploadedFiles, remove2, cb) {
    var length = uploadedFiles.length;
    var errors = [];
    if (length === 0) return cb(null, errors);
    function handleFile(idx) {
      var file2 = uploadedFiles[idx];
      remove2(file2, function(err) {
        if (err) {
          err.file = file2;
          err.field = file2.fieldname;
          errors.push(err);
        }
        if (idx < length - 1) {
          handleFile(idx + 1);
        } else {
          cb(null, errors);
        }
      });
    }
    handleFile(0);
  }
  removeUploadedFiles_1 = removeUploadedFiles;
  return removeUploadedFiles_1;
}
var makeMiddleware_1;
var hasRequiredMakeMiddleware;
function requireMakeMiddleware() {
  if (hasRequiredMakeMiddleware) return makeMiddleware_1;
  hasRequiredMakeMiddleware = 1;
  var is2 = requireTypeIs();
  var Busboy = requireLib();
  var extend2 = requireImmutable();
  var appendField = requireAppendField();
  var Counter = requireCounter();
  var MulterError = requireMulterError();
  var FileAppender = requireFileAppender();
  var removeUploadedFiles = requireRemoveUploadedFiles();
  function drainStream(stream) {
    stream.on("readable", () => {
      while (stream.read() !== null) {
      }
    });
  }
  function makeMiddleware(setup) {
    return function multerMiddleware(req, res, next) {
      if (!is2(req, ["multipart"])) return next();
      var options = setup();
      var limits = options.limits;
      var storage = options.storage;
      var fileFilter = options.fileFilter;
      var fileStrategy = options.fileStrategy;
      var preservePath = options.preservePath;
      req.body = /* @__PURE__ */ Object.create(null);
      req.on("error", function(err) {
        abortWithError(err);
      });
      var busboy;
      try {
        busboy = Busboy({ headers: req.headers, limits, preservePath });
      } catch (err) {
        return next(err);
      }
      var appender = new FileAppender(fileStrategy, req);
      var isDone = false;
      var readFinished = false;
      var errorOccured = false;
      var pendingWrites = new Counter();
      var uploadedFiles = [];
      function done(err) {
        if (isDone) return;
        isDone = true;
        req.unpipe(busboy);
        drainStream(req);
        req.resume();
        setImmediate(() => {
          busboy.removeAllListeners();
        });
        next(err);
      }
      function indicateDone() {
        if (readFinished && pendingWrites.isZero() && !errorOccured) done();
      }
      function abortWithError(uploadError) {
        if (errorOccured) return;
        errorOccured = true;
        pendingWrites.onceZero(function() {
          function remove2(file2, cb) {
            storage._removeFile(req, file2, cb);
          }
          removeUploadedFiles(uploadedFiles, remove2, function(err, storageErrors) {
            if (err) return done(err);
            uploadError.storageErrors = storageErrors;
            done(uploadError);
          });
        });
      }
      function abortWithCode(code, optionalField) {
        abortWithError(new MulterError(code, optionalField));
      }
      busboy.on("field", function(fieldname, value, { nameTruncated, valueTruncated }) {
        if (fieldname == null) return abortWithCode("MISSING_FIELD_NAME");
        if (nameTruncated) return abortWithCode("LIMIT_FIELD_KEY");
        if (valueTruncated) return abortWithCode("LIMIT_FIELD_VALUE", fieldname);
        if (limits && Object.prototype.hasOwnProperty.call(limits, "fieldNameSize")) {
          if (fieldname.length > limits.fieldNameSize) return abortWithCode("LIMIT_FIELD_KEY");
        }
        appendField(req.body, fieldname, value);
      });
      busboy.on("file", function(fieldname, fileStream, { filename, encoding: encoding2, mimeType }) {
        var pendingWritesIncremented = false;
        fileStream.on("error", function(err) {
          if (pendingWritesIncremented) {
            pendingWrites.decrement();
          }
          abortWithError(err);
        });
        if (fieldname == null) return abortWithCode("MISSING_FIELD_NAME");
        if (!filename) return fileStream.resume();
        if (limits && Object.prototype.hasOwnProperty.call(limits, "fieldNameSize")) {
          if (fieldname.length > limits.fieldNameSize) return abortWithCode("LIMIT_FIELD_KEY");
        }
        var file2 = {
          fieldname,
          originalname: filename,
          encoding: encoding2,
          mimetype: mimeType
        };
        var placeholder = appender.insertPlaceholder(file2);
        fileFilter(req, file2, function(err, includeFile) {
          if (err) {
            appender.removePlaceholder(placeholder);
            return abortWithError(err);
          }
          if (!includeFile) {
            appender.removePlaceholder(placeholder);
            return fileStream.resume();
          }
          var aborting = false;
          pendingWritesIncremented = true;
          pendingWrites.increment();
          Object.defineProperty(file2, "stream", {
            configurable: true,
            enumerable: false,
            value: fileStream
          });
          fileStream.on("limit", function() {
            aborting = true;
            abortWithCode("LIMIT_FILE_SIZE", fieldname);
          });
          storage._handleFile(req, file2, function(err2, info) {
            if (aborting) {
              appender.removePlaceholder(placeholder);
              uploadedFiles.push(extend2(file2, info));
              return pendingWrites.decrement();
            }
            if (err2) {
              appender.removePlaceholder(placeholder);
              pendingWrites.decrement();
              return abortWithError(err2);
            }
            var fileInfo = extend2(file2, info);
            appender.replacePlaceholder(placeholder, fileInfo);
            uploadedFiles.push(fileInfo);
            pendingWrites.decrement();
            indicateDone();
          });
        });
      });
      busboy.on("error", function(err) {
        abortWithError(err);
      });
      busboy.on("partsLimit", function() {
        abortWithCode("LIMIT_PART_COUNT");
      });
      busboy.on("filesLimit", function() {
        abortWithCode("LIMIT_FILE_COUNT");
      });
      busboy.on("fieldsLimit", function() {
        abortWithCode("LIMIT_FIELD_COUNT");
      });
      busboy.on("close", function() {
        readFinished = true;
        indicateDone();
      });
      req.pipe(busboy);
    };
  }
  makeMiddleware_1 = makeMiddleware;
  return makeMiddleware_1;
}
var mkdirp;
var hasRequiredMkdirp;
function requireMkdirp() {
  if (hasRequiredMkdirp) return mkdirp;
  hasRequiredMkdirp = 1;
  var path2 = path$1;
  var fs2 = require$$0$4;
  var _0777 = parseInt("0777", 8);
  mkdirp = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
  function mkdirP(p, opts, f, made) {
    if (typeof opts === "function") {
      f = opts;
      opts = {};
    } else if (!opts || typeof opts !== "object") {
      opts = { mode: opts };
    }
    var mode2 = opts.mode;
    var xfs = opts.fs || fs2;
    if (mode2 === void 0) {
      mode2 = _0777;
    }
    if (!made) made = null;
    var cb = f || /* istanbul ignore next */
    function() {
    };
    p = path2.resolve(p);
    xfs.mkdir(p, mode2, function(er) {
      if (!er) {
        made = made || p;
        return cb(null, made);
      }
      switch (er.code) {
        case "ENOENT":
          if (path2.dirname(p) === p) return cb(er);
          mkdirP(path2.dirname(p), opts, function(er2, made2) {
            if (er2) cb(er2, made2);
            else mkdirP(p, opts, cb, made2);
          });
          break;
        // In the case of any other error, just see if there's a dir
        // there already.  If so, then hooray!  If not, then something
        // is borked.
        default:
          xfs.stat(p, function(er2, stat2) {
            if (er2 || !stat2.isDirectory()) cb(er, made);
            else cb(null, made);
          });
          break;
      }
    });
  }
  mkdirP.sync = function sync(p, opts, made) {
    if (!opts || typeof opts !== "object") {
      opts = { mode: opts };
    }
    var mode2 = opts.mode;
    var xfs = opts.fs || fs2;
    if (mode2 === void 0) {
      mode2 = _0777;
    }
    if (!made) made = null;
    p = path2.resolve(p);
    try {
      xfs.mkdirSync(p, mode2);
      made = made || p;
    } catch (err0) {
      switch (err0.code) {
        case "ENOENT":
          made = sync(path2.dirname(p), opts, made);
          sync(p, opts, made);
          break;
        // In the case of any other error, just see if there's a dir
        // there already.  If so, then hooray!  If not, then something
        // is borked.
        default:
          var stat2;
          try {
            stat2 = xfs.statSync(p);
          } catch (err1) {
            throw err0;
          }
          if (!stat2.isDirectory()) throw err0;
          break;
      }
    }
    return made;
  };
  return mkdirp;
}
var disk;
var hasRequiredDisk;
function requireDisk() {
  if (hasRequiredDisk) return disk;
  hasRequiredDisk = 1;
  var fs2 = require$$0$4;
  var os2 = require$$1$1;
  var path2 = path$1;
  var crypto2 = require$$0$b;
  var mkdirp2 = requireMkdirp();
  function getFilename(req, file2, cb) {
    crypto2.randomBytes(16, function(err, raw) {
      cb(err, err ? void 0 : raw.toString("hex"));
    });
  }
  function getDestination(req, file2, cb) {
    cb(null, os2.tmpdir());
  }
  function DiskStorage(opts) {
    this.getFilename = opts.filename || getFilename;
    if (typeof opts.destination === "string") {
      mkdirp2.sync(opts.destination);
      this.getDestination = function($0, $1, cb) {
        cb(null, opts.destination);
      };
    } else {
      this.getDestination = opts.destination || getDestination;
    }
  }
  DiskStorage.prototype._handleFile = function _handleFile(req, file2, cb) {
    var that = this;
    that.getDestination(req, file2, function(err, destination) {
      if (err) return cb(err);
      that.getFilename(req, file2, function(err2, filename) {
        if (err2) return cb(err2);
        var finalPath = path2.join(destination, filename);
        var outStream = fs2.createWriteStream(finalPath);
        file2.stream.pipe(outStream);
        outStream.on("error", cb);
        outStream.on("finish", function() {
          cb(null, {
            destination,
            filename,
            path: finalPath,
            size: outStream.bytesWritten
          });
        });
      });
    });
  };
  DiskStorage.prototype._removeFile = function _removeFile(req, file2, cb) {
    var path3 = file2.path;
    delete file2.destination;
    delete file2.filename;
    delete file2.path;
    fs2.unlink(path3, cb);
  };
  disk = function(opts) {
    return new DiskStorage(opts);
  };
  return disk;
}
var readableBrowser = { exports: {} };
var streamBrowser;
var hasRequiredStreamBrowser;
function requireStreamBrowser() {
  if (hasRequiredStreamBrowser) return streamBrowser;
  hasRequiredStreamBrowser = 1;
  streamBrowser = require$$0$7.EventEmitter;
  return streamBrowser;
}
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object2, enumerableOnly) {
    var keys = Object.keys(object2);
    if (Object.getOwnPropertySymbols) {
      var symbols2 = Object.getOwnPropertySymbols(object2);
      enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      })), keys.push.apply(keys, symbols2);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source2 = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source2), true).forEach(function(key2) {
        _defineProperty(target, key2, source2[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys(Object(source2)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
      });
    }
    return target;
  }
  function _defineProperty(obj, key2, value) {
    key2 = _toPropertyKey(key2);
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return typeof key2 === "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(input);
  }
  var _require = require$$0$8, Buffer2 = _require.Buffer;
  var _require2 = require$$1$2, inspect2 = _require2.inspect;
  var custom2 = inspect2 && inspect2.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer2.prototype.copy.call(src, target, offset);
  }
  buffer_list = /* @__PURE__ */ (function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push2(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) ret += s + p.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c2 = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c2;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c2 = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c2;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom2,
      value: function value(_, options) {
        return inspect2(this, _objectSpread(_objectSpread({}, options), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  })();
  return buffer_list;
}
var destroy_1;
var hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose) return;
    if (self2._readableState && !self2._readableState.emitClose) return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit("error", err);
  }
  destroy_1 = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return destroy_1;
}
var errorsBrowser = {};
var hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var codes = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage2(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    var NodeError = /* @__PURE__ */ (function(_Base) {
      _inheritsLoose(NodeError2, _Base);
      function NodeError2(arg1, arg2, arg3) {
        return _Base.call(this, getMessage2(arg1, arg2, arg3)) || this;
      }
      return NodeError2;
    })(Base);
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      var len = expected.length;
      expected = expected.map(function(i) {
        return String(i);
      });
      if (len > 2) {
        return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
      } else if (len === 2) {
        return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
      } else {
        return "of ".concat(thing, " ").concat(expected[0]);
      }
    } else {
      return "of ".concat(thing, " ").concat(String(expected));
    }
  }
  function startsWith(str, search, pos2) {
    return str.substr(0, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    var msg;
    if (endsWith(name, " argument")) {
      msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    } else {
      var type2 = includes(name, ".") ? "property" : "argument";
      msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    msg += ". Received type ".concat(typeof actual);
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  errorsBrowser.codes = codes;
  return errorsBrowser;
}
var state;
var hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var ERR_INVALID_OPT_VALUE = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state2, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state2.objectMode ? 16 : 16 * 1024;
  }
  state = {
    getHighWaterMark
  };
  return state;
}
var browser;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  browser = deprecate;
  function deprecate(fn, msg) {
    if (config2("noDeprecation")) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (config2("throwDeprecation")) {
          throw new Error(msg);
        } else if (config2("traceDeprecation")) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  }
  function config2(name) {
    try {
      if (!commonjsGlobal.localStorage) return false;
    } catch (_) {
      return false;
    }
    var val = commonjsGlobal.localStorage[name];
    if (null == val) return false;
    return String(val).toLowerCase() === "true";
  }
  return browser;
}
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  _stream_writable = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: requireBrowser()
  };
  var Stream = requireStreamBrowser();
  var Buffer2 = require$$0$8.Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  requireInherits_browser()(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object2) {
        if (realHasInstance.call(this, object2)) return true;
        if (this !== Writable) return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object2) {
      return object2 instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
  }
  function validChunk(stream, state2, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding2, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding2 === "function") {
      cb = encoding2;
      encoding2 = null;
    }
    if (isBuf) encoding2 = "buffer";
    else if (!encoding2) encoding2 = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding2, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding2) {
    if (typeof encoding2 === "string") encoding2 = encoding2.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding2 + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding2);
    this._writableState.defaultEncoding = encoding2;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding2) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding2);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state2, isBuf, chunk, encoding2, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding2);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding2 = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding: encoding2,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state2, false, len, chunk, encoding2, cb);
    }
    return ret;
  }
  function doWrite(stream, state2, writev, len, chunk, encoding2, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed) state2.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream._writev(chunk, state2.onwrite);
    else stream._write(chunk, encoding2, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream, state2, sync, er, cb) {
    --state2.pendingcb;
    if (sync) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream, state2);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream, er) {
    var state2 = stream._writableState;
    var sync = state2.sync;
    var cb = state2.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream, state2, sync, er, cb);
    else {
      var finished = needFinish(state2) || stream.destroyed;
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream, state2);
      }
      if (sync) {
        process.nextTick(afterWrite, stream, state2, finished, cb);
      } else {
        afterWrite(stream, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream, state2, finished, cb) {
    if (!finished) onwriteDrain(stream, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream, state2);
  }
  function onwriteDrain(stream, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer2 = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding2 = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream, state2, false, len, chunk, encoding2, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding2, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding2, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding2 = null;
    } else if (typeof encoding2 === "function") {
      cb = encoding2;
      encoding2 = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding2);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream, state2) {
    stream._final(function(err) {
      state2.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state2.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state2);
    });
  }
  function prefinish(stream, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream._final === "function" && !state2.destroyed) {
        state2.pendingcb++;
        state2.finalCalled = true;
        process.nextTick(callFinal, stream, state2);
      } else {
        state2.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream.emit("finish");
        if (state2.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state2, cb) {
    state2.ending = true;
    finishMaybe(stream, state2);
    if (cb) {
      if (state2.finished) process.nextTick(cb);
      else stream.once("finish", cb);
    }
    state2.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set2(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return _stream_writable;
}
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key2 in obj) keys2.push(key2);
    return keys2;
  };
  _stream_duplex = Duplex;
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  requireInherits_browser()(Duplex, Readable);
  {
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false) this.readable = false;
      if (options.writable === false) this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended) return;
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set2(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex;
}
var string_decoder = {};
var safeBuffer = { exports: {} };
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module, exports$1) {
    var buffer2 = require$$0$8;
    var Buffer2 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key2 in src) {
        dst[key2] = src[key2];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports$1);
      exports$1.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding2) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding2 === "string") {
          buf.fill(fill, encoding2);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer2 = requireSafeBuffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding2) {
    encoding2 = "" + encoding2;
    switch (encoding2 && encoding2.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding2) {
    this.encoding = normalizeEncoding(encoding2);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c2 = r.charCodeAt(r.length - 1);
        if (c2 >= 55296 && c2 <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder;
}
var endOfStream;
var hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var ERR_STREAM_PREMATURE_CLOSE = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once2(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop2() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once2(callback || noop2);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable) callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req) onrequest();
      else stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req) stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  endOfStream = eos;
  return endOfStream;
}
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key2, value) {
    key2 = _toPropertyKey(key2);
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key2 = _toPrimitive(arg, "string");
    return typeof key2 === "symbol" ? key2 : String(key2);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var finished = requireEndOfStream();
  var kLastResolve = /* @__PURE__ */ Symbol("lastResolve");
  var kLastReject = /* @__PURE__ */ Symbol("lastReject");
  var kError = /* @__PURE__ */ Symbol("error");
  var kEnded = /* @__PURE__ */ Symbol("ended");
  var kLastPromise = /* @__PURE__ */ Symbol("lastPromise");
  var kHandlePromise = /* @__PURE__ */ Symbol("handlePromise");
  var kStream = /* @__PURE__ */ Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve2 = iter[kLastResolve];
    if (resolve2 !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve2(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve2, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve2(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve2, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error2 = this[kError];
      if (error2 !== null) {
        return Promise.reject(error2);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve2, reject) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve2(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise2;
      if (lastPromise) {
        promise2 = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise2 = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise2;
      return promise2;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve2, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve2(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve2, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve2(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve2;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve2 = iterator[kLastResolve];
      if (resolve2 !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve2(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  async_iterator = createReadableStreamAsyncIterator;
  return async_iterator;
}
var fromBrowser;
var hasRequiredFromBrowser;
function requireFromBrowser() {
  if (hasRequiredFromBrowser) return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return fromBrowser;
}
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  _stream_readable = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  require$$0$7.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream = requireStreamBrowser();
  var Buffer2 = require$$0$8.Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = require$$1$2;
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList = requireBuffer_list();
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from2;
  requireInherits_browser()(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable)) return new Readable(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set2(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding2) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding2 = encoding2 || state2.defaultEncoding;
        if (encoding2 !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding2);
          encoding2 = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding2, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding2, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state2 = stream._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else addChunk(stream, state2, chunk, true);
        } else if (state2.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state2.destroyed) {
          return false;
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding2) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream, state2, chunk, false);
            else maybeReadMore(stream, state2);
          } else {
            addChunk(stream, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
        maybeReadMore(stream, state2);
      }
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      state2.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
    var decoder2 = new StringDecoder(enc);
    this._readableState.decoder = decoder2;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder2.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n = 0;
    } else {
      state2.length -= n;
      state2.awaitDrain = 0;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state2) {
    debug("onEofChunk");
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream);
    } else {
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        state2.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state2 = stream._readableState;
    debug("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state2 = stream._readableState;
    debug("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && (state2.length || state2.ended)) {
      stream.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      process.nextTick(maybeReadMore_, stream, state2);
    }
  }
  function maybeReadMore_(stream, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      var len = state2.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) process.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state2.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state2 = src._readableState;
      debug("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state2.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
        hasUnpiped: false
      });
      return this;
    }
    var index2 = indexOf(state2.pipes, dest);
    if (index2 === -1) return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state2 = this._readableState;
    if (ev === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false) this.resume();
    } else if (ev === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && !state2.paused) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug("resume");
      state2.flowing = !state2.readableListening;
      resume(this, state2);
    }
    state2.paused = false;
    return this;
  };
  function resume(stream, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process.nextTick(resume_, stream, state2);
    }
  }
  function resume_(stream, state2) {
    debug("resume", state2.reading);
    if (!state2.reading) {
      stream.read(0);
    }
    state2.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state2.flowing && !state2.reading) stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state2 = stream._readableState;
    debug("flow", state2.flowing);
    while (state2.flowing && stream.read() !== null) ;
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === void 0 && typeof stream[i] === "function") {
        this[i] = /* @__PURE__ */ (function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        })(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = requireAsync_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.flowing;
    },
    set: function set2(state2) {
      if (this._readableState) {
        this._readableState.flowing = state2;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.length;
    }
  });
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.first();
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n, state2.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state2 = stream._readableState;
    debug("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process.nextTick(endReadableNT, state2, stream);
    }
  }
  function endReadableNT(state2, stream) {
    debug("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state2.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from2 === void 0) {
        from2 = requireFromBrowser();
      }
      return from2(Readable, iterable, opts);
    };
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable;
}
var _stream_transform;
var hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1;
  _stream_transform = Transform;
  var _require$codes = requireErrorsBrowser().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require_stream_duplex();
  requireInherits_browser()(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding2) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding2);
  };
  Transform.prototype._transform = function(chunk, encoding2, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding2, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding2;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough;
var hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1;
  _stream_passthrough = PassThrough;
  var Transform = require_stream_transform();
  requireInherits_browser()(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding2, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough;
}
var pipeline_1;
var hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var eos;
  function once2(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = requireErrorsBrowser().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop2(err) {
    if (err) throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once2(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === void 0) eos = requireEndOfStream();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err) return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true;
      if (isRequest(stream)) return stream.abort();
      if (typeof stream.destroy === "function") return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe2(from2, to) {
    return from2.pipe(to);
  }
  function popCallback(streams2) {
    if (!streams2.length) return noop2;
    if (typeof streams2[streams2.length - 1] !== "function") return noop2;
    return streams2.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams2 = new Array(_len), _key = 0; _key < _len; _key++) {
      streams2[_key] = arguments[_key];
    }
    var callback = popCallback(streams2);
    if (Array.isArray(streams2[0])) streams2 = streams2[0];
    if (streams2.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error2;
    var destroys = streams2.map(function(stream, i) {
      var reading = i < streams2.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error2) error2 = err;
        if (err) destroys.forEach(call);
        if (reading) return;
        destroys.forEach(call);
        callback(error2);
      });
    });
    return streams2.reduce(pipe2);
  }
  pipeline_1 = pipeline;
  return pipeline_1;
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
  if (hasRequiredReadableBrowser) return readableBrowser.exports;
  hasRequiredReadableBrowser = 1;
  (function(module, exports$1) {
    exports$1 = module.exports = require_stream_readable();
    exports$1.Stream = exports$1;
    exports$1.Readable = exports$1;
    exports$1.Writable = require_stream_writable();
    exports$1.Duplex = require_stream_duplex();
    exports$1.Transform = require_stream_transform();
    exports$1.PassThrough = require_stream_passthrough();
    exports$1.finished = requireEndOfStream();
    exports$1.pipeline = requirePipeline();
  })(readableBrowser, readableBrowser.exports);
  return readableBrowser.exports;
}
var bufferFrom_1;
var hasRequiredBufferFrom;
function requireBufferFrom() {
  if (hasRequiredBufferFrom) return bufferFrom_1;
  hasRequiredBufferFrom = 1;
  var toString = Object.prototype.toString;
  var isModern = typeof Buffer !== "undefined" && typeof Buffer.alloc === "function" && typeof Buffer.allocUnsafe === "function" && typeof Buffer.from === "function";
  function isArrayBuffer(input) {
    return toString.call(input).slice(8, -1) === "ArrayBuffer";
  }
  function fromArrayBuffer(obj, byteOffset, length) {
    byteOffset >>>= 0;
    var maxLength = obj.byteLength - byteOffset;
    if (maxLength < 0) {
      throw new RangeError("'offset' is out of bounds");
    }
    if (length === void 0) {
      length = maxLength;
    } else {
      length >>>= 0;
      if (length > maxLength) {
        throw new RangeError("'length' is out of bounds");
      }
    }
    return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
  }
  function fromString(string2, encoding2) {
    if (typeof encoding2 !== "string" || encoding2 === "") {
      encoding2 = "utf8";
    }
    if (!Buffer.isEncoding(encoding2)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }
    return isModern ? Buffer.from(string2, encoding2) : new Buffer(string2, encoding2);
  }
  function bufferFrom(value, encodingOrOffset, length) {
    if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    if (isArrayBuffer(value)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    return isModern ? Buffer.from(value) : new Buffer(value);
  }
  bufferFrom_1 = bufferFrom;
  return bufferFrom_1;
}
var typedarray = {};
var hasRequiredTypedarray;
function requireTypedarray() {
  if (hasRequiredTypedarray) return typedarray;
  hasRequiredTypedarray = 1;
  (function(exports$1) {
    var undefined$1 = void 0;
    var MAX_ARRAY_LENGTH = 1e5;
    var ECMAScript = /* @__PURE__ */ (function() {
      var opts = Object.prototype.toString, ophop = Object.prototype.hasOwnProperty;
      return {
        // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
        Class: function(v) {
          return opts.call(v).replace(/^\[object *|\]$/g, "");
        },
        HasProperty: function(o, p) {
          return p in o;
        },
        HasOwnProperty: function(o, p) {
          return ophop.call(o, p);
        },
        IsCallable: function(o) {
          return typeof o === "function";
        },
        ToInt32: function(v) {
          return v >> 0;
        },
        ToUint32: function(v) {
          return v >>> 0;
        }
      };
    })();
    var LN2 = Math.LN2, abs2 = Math.abs, floor2 = Math.floor, log = Math.log, min2 = Math.min, pow2 = Math.pow, round2 = Math.round;
    function configureProperties(obj) {
      if (getOwnPropNames && defineProp) {
        var props = getOwnPropNames(obj), i;
        for (i = 0; i < props.length; i += 1) {
          defineProp(obj, props[i], {
            value: obj[props[i]],
            writable: false,
            enumerable: false,
            configurable: false
          });
        }
      }
    }
    var defineProp;
    if (Object.defineProperty && (function() {
      try {
        Object.defineProperty({}, "x", {});
        return true;
      } catch (e) {
        return false;
      }
    })()) {
      defineProp = Object.defineProperty;
    } else {
      defineProp = function(o, p, desc) {
        if (!o === Object(o)) throw new TypeError("Object.defineProperty called on non-object");
        if (ECMAScript.HasProperty(desc, "get") && Object.prototype.__defineGetter__) {
          Object.prototype.__defineGetter__.call(o, p, desc.get);
        }
        if (ECMAScript.HasProperty(desc, "set") && Object.prototype.__defineSetter__) {
          Object.prototype.__defineSetter__.call(o, p, desc.set);
        }
        if (ECMAScript.HasProperty(desc, "value")) {
          o[p] = desc.value;
        }
        return o;
      };
    }
    var getOwnPropNames = Object.getOwnPropertyNames || function(o) {
      if (o !== Object(o)) throw new TypeError("Object.getOwnPropertyNames called on non-object");
      var props = [], p;
      for (p in o) {
        if (ECMAScript.HasOwnProperty(o, p)) {
          props.push(p);
        }
      }
      return props;
    };
    function makeArrayAccessors(obj) {
      if (!defineProp) {
        return;
      }
      if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError("Array too large for polyfill");
      function makeArrayAccessor(index2) {
        defineProp(obj, index2, {
          "get": function() {
            return obj._getter(index2);
          },
          "set": function(v) {
            obj._setter(index2, v);
          },
          enumerable: true,
          configurable: false
        });
      }
      var i;
      for (i = 0; i < obj.length; i += 1) {
        makeArrayAccessor(i);
      }
    }
    function as_signed(value, bits) {
      var s = 32 - bits;
      return value << s >> s;
    }
    function as_unsigned(value, bits) {
      var s = 32 - bits;
      return value << s >>> s;
    }
    function packI8(n) {
      return [n & 255];
    }
    function unpackI8(bytes2) {
      return as_signed(bytes2[0], 8);
    }
    function packU8(n) {
      return [n & 255];
    }
    function unpackU8(bytes2) {
      return as_unsigned(bytes2[0], 8);
    }
    function packU8Clamped(n) {
      n = round2(Number(n));
      return [n < 0 ? 0 : n > 255 ? 255 : n & 255];
    }
    function packI16(n) {
      return [n >> 8 & 255, n & 255];
    }
    function unpackI16(bytes2) {
      return as_signed(bytes2[0] << 8 | bytes2[1], 16);
    }
    function packU16(n) {
      return [n >> 8 & 255, n & 255];
    }
    function unpackU16(bytes2) {
      return as_unsigned(bytes2[0] << 8 | bytes2[1], 16);
    }
    function packI32(n) {
      return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255];
    }
    function unpackI32(bytes2) {
      return as_signed(bytes2[0] << 24 | bytes2[1] << 16 | bytes2[2] << 8 | bytes2[3], 32);
    }
    function packU32(n) {
      return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255];
    }
    function unpackU32(bytes2) {
      return as_unsigned(bytes2[0] << 24 | bytes2[1] << 16 | bytes2[2] << 8 | bytes2[3], 32);
    }
    function packIEEE754(v, ebits, fbits) {
      var bias = (1 << ebits - 1) - 1, s, e, f, i, bits, str, bytes2;
      function roundToEven(n) {
        var w = floor2(n), f2 = n - w;
        if (f2 < 0.5)
          return w;
        if (f2 > 0.5)
          return w + 1;
        return w % 2 ? w + 1 : w;
      }
      if (v !== v) {
        e = (1 << ebits) - 1;
        f = pow2(2, fbits - 1);
        s = 0;
      } else if (v === Infinity || v === -Infinity) {
        e = (1 << ebits) - 1;
        f = 0;
        s = v < 0 ? 1 : 0;
      } else if (v === 0) {
        e = 0;
        f = 0;
        s = 1 / v === -Infinity ? 1 : 0;
      } else {
        s = v < 0;
        v = abs2(v);
        if (v >= pow2(2, 1 - bias)) {
          e = min2(floor2(log(v) / LN2), 1023);
          f = roundToEven(v / pow2(2, e) * pow2(2, fbits));
          if (f / pow2(2, fbits) >= 2) {
            e = e + 1;
            f = 1;
          }
          if (e > bias) {
            e = (1 << ebits) - 1;
            f = 0;
          } else {
            e = e + bias;
            f = f - pow2(2, fbits);
          }
        } else {
          e = 0;
          f = roundToEven(v / pow2(2, 1 - bias - fbits));
        }
      }
      bits = [];
      for (i = fbits; i; i -= 1) {
        bits.push(f % 2 ? 1 : 0);
        f = floor2(f / 2);
      }
      for (i = ebits; i; i -= 1) {
        bits.push(e % 2 ? 1 : 0);
        e = floor2(e / 2);
      }
      bits.push(s ? 1 : 0);
      bits.reverse();
      str = bits.join("");
      bytes2 = [];
      while (str.length) {
        bytes2.push(parseInt(str.substring(0, 8), 2));
        str = str.substring(8);
      }
      return bytes2;
    }
    function unpackIEEE754(bytes2, ebits, fbits) {
      var bits = [], i, j, b, str, bias, s, e, f;
      for (i = bytes2.length; i; i -= 1) {
        b = bytes2[i - 1];
        for (j = 8; j; j -= 1) {
          bits.push(b % 2 ? 1 : 0);
          b = b >> 1;
        }
      }
      bits.reverse();
      str = bits.join("");
      bias = (1 << ebits - 1) - 1;
      s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
      e = parseInt(str.substring(1, 1 + ebits), 2);
      f = parseInt(str.substring(1 + ebits), 2);
      if (e === (1 << ebits) - 1) {
        return f !== 0 ? NaN : s * Infinity;
      } else if (e > 0) {
        return s * pow2(2, e - bias) * (1 + f / pow2(2, fbits));
      } else if (f !== 0) {
        return s * pow2(2, -(bias - 1)) * (f / pow2(2, fbits));
      } else {
        return s < 0 ? -0 : 0;
      }
    }
    function unpackF64(b) {
      return unpackIEEE754(b, 11, 52);
    }
    function packF64(v) {
      return packIEEE754(v, 11, 52);
    }
    function unpackF32(b) {
      return unpackIEEE754(b, 8, 23);
    }
    function packF32(v) {
      return packIEEE754(v, 8, 23);
    }
    (function() {
      var ArrayBuffer2 = function ArrayBuffer3(length) {
        length = ECMAScript.ToInt32(length);
        if (length < 0) throw new RangeError("ArrayBuffer size is not a small enough positive integer");
        this.byteLength = length;
        this._bytes = [];
        this._bytes.length = length;
        var i;
        for (i = 0; i < this.byteLength; i += 1) {
          this._bytes[i] = 0;
        }
        configureProperties(this);
      };
      exports$1.ArrayBuffer = exports$1.ArrayBuffer || ArrayBuffer2;
      var ArrayBufferView = function ArrayBufferView2() {
      };
      function makeConstructor(bytesPerElement, pack, unpack) {
        var ctor;
        ctor = function(buffer2, byteOffset, length) {
          var array2, sequence, i, s;
          if (!arguments.length || typeof arguments[0] === "number") {
            this.length = ECMAScript.ToInt32(arguments[0]);
            if (length < 0) throw new RangeError("ArrayBufferView size is not a small enough positive integer");
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
          } else if (typeof arguments[0] === "object" && arguments[0].constructor === ctor) {
            array2 = arguments[0];
            this.length = array2.length;
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
            for (i = 0; i < this.length; i += 1) {
              this._setter(i, array2._getter(i));
            }
          } else if (typeof arguments[0] === "object" && !(arguments[0] instanceof ArrayBuffer2 || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
            sequence = arguments[0];
            this.length = ECMAScript.ToUint32(sequence.length);
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
            for (i = 0; i < this.length; i += 1) {
              s = sequence[i];
              this._setter(i, Number(s));
            }
          } else if (typeof arguments[0] === "object" && (arguments[0] instanceof ArrayBuffer2 || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
            this.buffer = buffer2;
            this.byteOffset = ECMAScript.ToUint32(byteOffset);
            if (this.byteOffset > this.buffer.byteLength) {
              throw new RangeError("byteOffset out of range");
            }
            if (this.byteOffset % this.BYTES_PER_ELEMENT) {
              throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
            }
            if (arguments.length < 3) {
              this.byteLength = this.buffer.byteLength - this.byteOffset;
              if (this.byteLength % this.BYTES_PER_ELEMENT) {
                throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
              }
              this.length = this.byteLength / this.BYTES_PER_ELEMENT;
            } else {
              this.length = ECMAScript.ToUint32(length);
              this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            }
            if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
              throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
          this.constructor = ctor;
          configureProperties(this);
          makeArrayAccessors(this);
        };
        ctor.prototype = new ArrayBufferView();
        ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
        ctor.prototype._pack = pack;
        ctor.prototype._unpack = unpack;
        ctor.BYTES_PER_ELEMENT = bytesPerElement;
        ctor.prototype._getter = function(index2) {
          if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
          index2 = ECMAScript.ToUint32(index2);
          if (index2 >= this.length) {
            return undefined$1;
          }
          var bytes2 = [], i, o;
          for (i = 0, o = this.byteOffset + index2 * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, o += 1) {
            bytes2.push(this.buffer._bytes[o]);
          }
          return this._unpack(bytes2);
        };
        ctor.prototype.get = ctor.prototype._getter;
        ctor.prototype._setter = function(index2, value) {
          if (arguments.length < 2) throw new SyntaxError("Not enough arguments");
          index2 = ECMAScript.ToUint32(index2);
          if (index2 >= this.length) {
            return undefined$1;
          }
          var bytes2 = this._pack(value), i, o;
          for (i = 0, o = this.byteOffset + index2 * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, o += 1) {
            this.buffer._bytes[o] = bytes2[i];
          }
        };
        ctor.prototype.set = function(index2, value) {
          if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
          var array2, sequence, offset, len, i, s, d, byteOffset, byteLength, tmp;
          if (typeof arguments[0] === "object" && arguments[0].constructor === this.constructor) {
            array2 = arguments[0];
            offset = ECMAScript.ToUint32(arguments[1]);
            if (offset + array2.length > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
            byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
            byteLength = array2.length * this.BYTES_PER_ELEMENT;
            if (array2.buffer === this.buffer) {
              tmp = [];
              for (i = 0, s = array2.byteOffset; i < byteLength; i += 1, s += 1) {
                tmp[i] = array2.buffer._bytes[s];
              }
              for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
                this.buffer._bytes[d] = tmp[i];
              }
            } else {
              for (i = 0, s = array2.byteOffset, d = byteOffset; i < byteLength; i += 1, s += 1, d += 1) {
                this.buffer._bytes[d] = array2.buffer._bytes[s];
              }
            }
          } else if (typeof arguments[0] === "object" && typeof arguments[0].length !== "undefined") {
            sequence = arguments[0];
            len = ECMAScript.ToUint32(sequence.length);
            offset = ECMAScript.ToUint32(arguments[1]);
            if (offset + len > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
            for (i = 0; i < len; i += 1) {
              s = sequence[i];
              this._setter(offset + i, Number(s));
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
        };
        ctor.prototype.subarray = function(start, end) {
          function clamp(v, min3, max2) {
            return v < min3 ? min3 : v > max2 ? max2 : v;
          }
          start = ECMAScript.ToInt32(start);
          end = ECMAScript.ToInt32(end);
          if (arguments.length < 1) {
            start = 0;
          }
          if (arguments.length < 2) {
            end = this.length;
          }
          if (start < 0) {
            start = this.length + start;
          }
          if (end < 0) {
            end = this.length + end;
          }
          start = clamp(start, 0, this.length);
          end = clamp(end, 0, this.length);
          var len = end - start;
          if (len < 0) {
            len = 0;
          }
          return new this.constructor(
            this.buffer,
            this.byteOffset + start * this.BYTES_PER_ELEMENT,
            len
          );
        };
        return ctor;
      }
      var Int8Array2 = makeConstructor(1, packI8, unpackI8);
      var Uint8Array2 = makeConstructor(1, packU8, unpackU8);
      var Uint8ClampedArray2 = makeConstructor(1, packU8Clamped, unpackU8);
      var Int16Array2 = makeConstructor(2, packI16, unpackI16);
      var Uint16Array2 = makeConstructor(2, packU16, unpackU16);
      var Int32Array2 = makeConstructor(4, packI32, unpackI32);
      var Uint32Array2 = makeConstructor(4, packU32, unpackU32);
      var Float32Array2 = makeConstructor(4, packF32, unpackF32);
      var Float64Array2 = makeConstructor(8, packF64, unpackF64);
      exports$1.Int8Array = exports$1.Int8Array || Int8Array2;
      exports$1.Uint8Array = exports$1.Uint8Array || Uint8Array2;
      exports$1.Uint8ClampedArray = exports$1.Uint8ClampedArray || Uint8ClampedArray2;
      exports$1.Int16Array = exports$1.Int16Array || Int16Array2;
      exports$1.Uint16Array = exports$1.Uint16Array || Uint16Array2;
      exports$1.Int32Array = exports$1.Int32Array || Int32Array2;
      exports$1.Uint32Array = exports$1.Uint32Array || Uint32Array2;
      exports$1.Float32Array = exports$1.Float32Array || Float32Array2;
      exports$1.Float64Array = exports$1.Float64Array || Float64Array2;
    })();
    (function() {
      function r(array2, index2) {
        return ECMAScript.IsCallable(array2.get) ? array2.get(index2) : array2[index2];
      }
      var IS_BIG_ENDIAN = (function() {
        var u16array = new exports$1.Uint16Array([4660]), u8array = new exports$1.Uint8Array(u16array.buffer);
        return r(u8array, 0) === 18;
      })();
      var DataView2 = function DataView3(buffer2, byteOffset, byteLength) {
        if (arguments.length === 0) {
          buffer2 = new exports$1.ArrayBuffer(0);
        } else if (!(buffer2 instanceof exports$1.ArrayBuffer || ECMAScript.Class(buffer2) === "ArrayBuffer")) {
          throw new TypeError("TypeError");
        }
        this.buffer = buffer2 || new exports$1.ArrayBuffer(0);
        this.byteOffset = ECMAScript.ToUint32(byteOffset);
        if (this.byteOffset > this.buffer.byteLength) {
          throw new RangeError("byteOffset out of range");
        }
        if (arguments.length < 3) {
          this.byteLength = this.buffer.byteLength - this.byteOffset;
        } else {
          this.byteLength = ECMAScript.ToUint32(byteLength);
        }
        if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
          throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
        }
        configureProperties(this);
      };
      function makeGetter(arrayType) {
        return function(byteOffset, littleEndian) {
          byteOffset = ECMAScript.ToUint32(byteOffset);
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
          byteOffset += this.byteOffset;
          var uint8Array = new exports$1.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT), bytes2 = [], i;
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
            bytes2.push(r(uint8Array, i));
          }
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes2.reverse();
          }
          return r(new arrayType(new exports$1.Uint8Array(bytes2).buffer), 0);
        };
      }
      DataView2.prototype.getUint8 = makeGetter(exports$1.Uint8Array);
      DataView2.prototype.getInt8 = makeGetter(exports$1.Int8Array);
      DataView2.prototype.getUint16 = makeGetter(exports$1.Uint16Array);
      DataView2.prototype.getInt16 = makeGetter(exports$1.Int16Array);
      DataView2.prototype.getUint32 = makeGetter(exports$1.Uint32Array);
      DataView2.prototype.getInt32 = makeGetter(exports$1.Int32Array);
      DataView2.prototype.getFloat32 = makeGetter(exports$1.Float32Array);
      DataView2.prototype.getFloat64 = makeGetter(exports$1.Float64Array);
      function makeSetter(arrayType) {
        return function(byteOffset, value, littleEndian) {
          byteOffset = ECMAScript.ToUint32(byteOffset);
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
          var typeArray = new arrayType([value]), byteArray = new exports$1.Uint8Array(typeArray.buffer), bytes2 = [], i, byteView;
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
            bytes2.push(r(byteArray, i));
          }
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes2.reverse();
          }
          byteView = new exports$1.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
          byteView.set(bytes2);
        };
      }
      DataView2.prototype.setUint8 = makeSetter(exports$1.Uint8Array);
      DataView2.prototype.setInt8 = makeSetter(exports$1.Int8Array);
      DataView2.prototype.setUint16 = makeSetter(exports$1.Uint16Array);
      DataView2.prototype.setInt16 = makeSetter(exports$1.Int16Array);
      DataView2.prototype.setUint32 = makeSetter(exports$1.Uint32Array);
      DataView2.prototype.setInt32 = makeSetter(exports$1.Int32Array);
      DataView2.prototype.setFloat32 = makeSetter(exports$1.Float32Array);
      DataView2.prototype.setFloat64 = makeSetter(exports$1.Float64Array);
      exports$1.DataView = exports$1.DataView || DataView2;
    })();
  })(typedarray);
  return typedarray;
}
var concatStream;
var hasRequiredConcatStream;
function requireConcatStream() {
  if (hasRequiredConcatStream) return concatStream;
  hasRequiredConcatStream = 1;
  var Writable = requireReadableBrowser().Writable;
  var inherits = requireInherits_browser();
  var bufferFrom = requireBufferFrom();
  if (typeof Uint8Array === "undefined") {
    var U8 = requireTypedarray().Uint8Array;
  } else {
    var U8 = Uint8Array;
  }
  function ConcatStream(opts, cb) {
    if (!(this instanceof ConcatStream)) return new ConcatStream(opts, cb);
    if (typeof opts === "function") {
      cb = opts;
      opts = {};
    }
    if (!opts) opts = {};
    var encoding2 = opts.encoding;
    var shouldInferEncoding = false;
    if (!encoding2) {
      shouldInferEncoding = true;
    } else {
      encoding2 = String(encoding2).toLowerCase();
      if (encoding2 === "u8" || encoding2 === "uint8") {
        encoding2 = "uint8array";
      }
    }
    Writable.call(this, { objectMode: true });
    this.encoding = encoding2;
    this.shouldInferEncoding = shouldInferEncoding;
    if (cb) this.on("finish", function() {
      cb(this.getBody());
    });
    this.body = [];
  }
  concatStream = ConcatStream;
  inherits(ConcatStream, Writable);
  ConcatStream.prototype._write = function(chunk, enc, next) {
    this.body.push(chunk);
    next();
  };
  ConcatStream.prototype.inferEncoding = function(buff) {
    var firstBuffer = buff === void 0 ? this.body[0] : buff;
    if (Buffer.isBuffer(firstBuffer)) return "buffer";
    if (typeof Uint8Array !== "undefined" && firstBuffer instanceof Uint8Array) return "uint8array";
    if (Array.isArray(firstBuffer)) return "array";
    if (typeof firstBuffer === "string") return "string";
    if (Object.prototype.toString.call(firstBuffer) === "[object Object]") return "object";
    return "buffer";
  };
  ConcatStream.prototype.getBody = function() {
    if (!this.encoding && this.body.length === 0) return [];
    if (this.shouldInferEncoding) this.encoding = this.inferEncoding();
    if (this.encoding === "array") return arrayConcat(this.body);
    if (this.encoding === "string") return stringConcat(this.body);
    if (this.encoding === "buffer") return bufferConcat(this.body);
    if (this.encoding === "uint8array") return u8Concat(this.body);
    return this.body;
  };
  function isArrayish(arr) {
    return /Array\]$/.test(Object.prototype.toString.call(arr));
  }
  function isBufferish(p) {
    return typeof p === "string" || isArrayish(p) || p && typeof p.subarray === "function";
  }
  function stringConcat(parts) {
    var strings = [];
    for (var i = 0; i < parts.length; i++) {
      var p = parts[i];
      if (typeof p === "string") {
        strings.push(p);
      } else if (Buffer.isBuffer(p)) {
        strings.push(p);
      } else if (isBufferish(p)) {
        strings.push(bufferFrom(p));
      } else {
        strings.push(bufferFrom(String(p)));
      }
    }
    if (Buffer.isBuffer(parts[0])) {
      strings = Buffer.concat(strings);
      strings = strings.toString("utf8");
    } else {
      strings = strings.join("");
    }
    return strings;
  }
  function bufferConcat(parts) {
    var bufs = [];
    for (var i = 0; i < parts.length; i++) {
      var p = parts[i];
      if (Buffer.isBuffer(p)) {
        bufs.push(p);
      } else if (isBufferish(p)) {
        bufs.push(bufferFrom(p));
      } else {
        bufs.push(bufferFrom(String(p)));
      }
    }
    return Buffer.concat(bufs);
  }
  function arrayConcat(parts) {
    var res = [];
    for (var i = 0; i < parts.length; i++) {
      res.push.apply(res, parts[i]);
    }
    return res;
  }
  function u8Concat(parts) {
    var len = 0;
    for (var i = 0; i < parts.length; i++) {
      if (typeof parts[i] === "string") {
        parts[i] = bufferFrom(parts[i]);
      }
      len += parts[i].length;
    }
    var u8 = new U8(len);
    for (var i = 0, offset = 0; i < parts.length; i++) {
      var part = parts[i];
      for (var j = 0; j < part.length; j++) {
        u8[offset++] = part[j];
      }
    }
    return u8;
  }
  return concatStream;
}
var memory;
var hasRequiredMemory;
function requireMemory() {
  if (hasRequiredMemory) return memory;
  hasRequiredMemory = 1;
  var concat = requireConcatStream();
  function MemoryStorage(opts) {
  }
  MemoryStorage.prototype._handleFile = function _handleFile(req, file2, cb) {
    file2.stream.pipe(concat({ encoding: "buffer" }, function(data) {
      cb(null, {
        buffer: data,
        size: data.length
      });
    }));
  };
  MemoryStorage.prototype._removeFile = function _removeFile(req, file2, cb) {
    delete file2.buffer;
    cb(null);
  };
  memory = function(opts) {
    return new MemoryStorage();
  };
  return memory;
}
var hasRequiredMulter;
function requireMulter() {
  if (hasRequiredMulter) return multer$1.exports;
  hasRequiredMulter = 1;
  var makeMiddleware = requireMakeMiddleware();
  var diskStorage = requireDisk();
  var memoryStorage = requireMemory();
  var MulterError = requireMulterError();
  function allowAll(req, file2, cb) {
    cb(null, true);
  }
  function Multer(options) {
    if (options.storage) {
      this.storage = options.storage;
    } else if (options.dest) {
      this.storage = diskStorage({ destination: options.dest });
    } else {
      this.storage = memoryStorage();
    }
    this.limits = options.limits;
    this.preservePath = options.preservePath;
    this.fileFilter = options.fileFilter || allowAll;
  }
  Multer.prototype._makeMiddleware = function(fields, fileStrategy) {
    function setup() {
      var fileFilter = this.fileFilter;
      var filesLeft = /* @__PURE__ */ Object.create(null);
      fields.forEach(function(field) {
        if (typeof field.maxCount === "number") {
          filesLeft[field.name] = field.maxCount;
        } else {
          filesLeft[field.name] = Infinity;
        }
      });
      function wrappedFileFilter(req, file2, cb) {
        if ((filesLeft[file2.fieldname] || 0) <= 0) {
          return cb(new MulterError("LIMIT_UNEXPECTED_FILE", file2.fieldname));
        }
        filesLeft[file2.fieldname] -= 1;
        fileFilter(req, file2, cb);
      }
      return {
        limits: this.limits,
        preservePath: this.preservePath,
        storage: this.storage,
        fileFilter: wrappedFileFilter,
        fileStrategy
      };
    }
    return makeMiddleware(setup.bind(this));
  };
  Multer.prototype.single = function(name) {
    return this._makeMiddleware([{ name, maxCount: 1 }], "VALUE");
  };
  Multer.prototype.array = function(name, maxCount) {
    return this._makeMiddleware([{ name, maxCount }], "ARRAY");
  };
  Multer.prototype.fields = function(fields) {
    return this._makeMiddleware(fields, "OBJECT");
  };
  Multer.prototype.none = function() {
    return this._makeMiddleware([], "NONE");
  };
  Multer.prototype.any = function() {
    function setup() {
      return {
        limits: this.limits,
        preservePath: this.preservePath,
        storage: this.storage,
        fileFilter: this.fileFilter,
        fileStrategy: "ARRAY"
      };
    }
    return makeMiddleware(setup.bind(this));
  };
  function multer2(options) {
    if (options === void 0) {
      return new Multer({});
    }
    if (typeof options === "object" && options !== null) {
      return new Multer(options);
    }
    throw new TypeError("Expected object for argument options");
  }
  multer$1.exports = multer2;
  multer$1.exports.diskStorage = diskStorage;
  multer$1.exports.memoryStorage = memoryStorage;
  multer$1.exports.MulterError = MulterError;
  return multer$1.exports;
}
var multerExports = requireMulter();
const multer = /* @__PURE__ */ getDefaultExportFromCjs(multerExports);
const __vite_import_meta_env__ = {};
const __filename$1 = fileURLToPath$1(import.meta.url);
const __dirname$2 = path$1.dirname(__filename$1);
let feDistPath = path$1.resolve(__dirname$2, "webui/");
if (!__vite_import_meta_env__) {
  feDistPath = path$1.join(__dirname$2, "../../../dist/webui/");
}
let globalLoginAttempt = {
  consecutiveFailures: 0,
  lockedUntil: null,
  lastAttempt: 0
};
const accessLogPath = path$1.join(LOG_DIR, "webui_access.log");
function logAccess(ip, method, path2, status, message) {
  const timestamp = (/* @__PURE__ */ new Date()).toISOString();
  const logEntry = `${timestamp} | IP: ${ip} | ${method} ${path2} | Status: ${status}${message ? ` | ${message}` : ""}
`;
  try {
    appendFileSync(accessLogPath, logEntry);
  } catch (err) {
    console.error(":", err);
  }
}
setInterval(() => {
  if (globalLoginAttempt.lockedUntil) {
    const now = Date.now();
    if (now >= globalLoginAttempt.lockedUntil) {
      globalLoginAttempt.consecutiveFailures = 0;
      globalLoginAttempt.lockedUntil = null;
    }
  }
}, 60 * 60 * 1e3);
class WebUIServer extends Service2 {
  constructor(ctx, config2) {
    super(ctx, "webuiServer", true);
    this.config = config2;
    this.uploadDir = path$1.join(TEMP_DIR, "webqq-uploads");
    if (!existsSync(this.uploadDir)) {
      mkdirSync(this.uploadDir, { recursive: true });
    }
    this.upload = multer({
      storage: multer.diskStorage({
        destination: this.uploadDir,
        filename: (req, file2, cb) => {
          const ext = path$1.extname(file2.originalname);
          cb(null, `${randomUUID$1()}${ext}`);
        }
      }),
      fileFilter: (req, file2, cb) => {
        const allowedTypes = ["image/jpeg", "image/png", "image/gif", "image/jpg"];
        if (allowedTypes.includes(file2.mimetype)) {
          cb(null, true);
        } else {
          cb(new Error(" JPGPNGGIF"));
        }
      },
      limits: {
        fileSize: 10 * 1024 * 1024
        // 10MB
      }
    });
    this.fileUpload = multer({
      storage: multer.diskStorage({
        destination: this.uploadDir,
        filename: (req, file2, cb) => {
          const ext = path$1.extname(file2.originalname);
          cb(null, `${randomUUID$1()}${ext}`);
        }
      })
    });
    this.initServer();
    this.setupMessageListener();
    ctx.on("llob/config-updated", (newConfig) => {
      const oldConfig = { ...this.config };
      this.setConfig(newConfig);
      const forcePort = oldConfig.port === newConfig.webui?.port ? this.currentPort : void 0;
      if (oldConfig.onlyLocalhost != newConfig.onlyLocalhost || oldConfig.enable != newConfig.webui?.enable || oldConfig.port != newConfig.webui?.port) {
        this.ctx.logger.info("WebUI :", this.config);
        setTimeout(() => this.restart(forcePort), 1e3);
      }
    });
  }
  server = null;
  app = express();
  connections = /* @__PURE__ */ new Set();
  currentPort;
  port = void 0;
  sseClients = /* @__PURE__ */ new Set();
  upload;
  fileUpload;
  // 
  uploadDir;
  static inject = ["ntLoginApi", "ntFriendApi", "ntGroupApi", "ntSystemApi", "ntMsgApi", "ntUserApi", "ntFileApi"];
  initServer() {
    this.app.use(express.json());
    this.app.use(cors());
    this.app.use("/api", (req, res, next) => {
      const clientIp = req.ip || req.socket.remoteAddress || "unknown";
      const token2 = webuiTokenUtil.getToken();
      if (!token2) {
        if (req.path === "/set-token") return next();
        logAccess(clientIp, req.method, req.path, 401, "");
        res.status(401).json({ success: false, message: "WebUI" });
        return;
      }
      if (globalLoginAttempt.lockedUntil) {
        const now = Date.now();
        if (now < globalLoginAttempt.lockedUntil) {
          const remainingMinutes = Math.ceil((globalLoginAttempt.lockedUntil - now) / (60 * 1e3));
          logAccess(clientIp, req.method, req.path, 403, `${remainingMinutes}`);
          res.status(403).json({
            success: false,
            message: ` ${remainingMinutes} `,
            locked: true,
            remainingMinutes
          });
          return;
        } else {
          globalLoginAttempt.consecutiveFailures = 0;
          globalLoginAttempt.lockedUntil = null;
        }
      }
      const reqToken = req.headers["x-webui-token"] || req.query?.token;
      if (!reqToken) {
        res.status(403).json({
          success: false,
          message: ``
        });
        return;
      }
      const hashedToken = hashPassword(token2);
      if (reqToken !== hashedToken) {
        globalLoginAttempt.consecutiveFailures++;
        globalLoginAttempt.lastAttempt = Date.now();
        const passwordFailureMax = 4;
        if (globalLoginAttempt.consecutiveFailures >= passwordFailureMax) {
          globalLoginAttempt.lockedUntil = Date.now() + 60 * 60 * 1e3;
          logAccess(clientIp, req.method, req.path, 403, `${passwordFailureMax - 1}1`);
          res.status(403).json({
            success: false,
            message: "31",
            locked: true,
            remainingMinutes: 60
          });
          return;
        }
        const remainingAttempts = passwordFailureMax - globalLoginAttempt.consecutiveFailures;
        logAccess(clientIp, req.method, req.path, 403, `Token${remainingAttempts}`);
        res.status(403).json({
          success: false,
          message: `Token${remainingAttempts}`,
          remainingAttempts
        });
        return;
      }
      if (globalLoginAttempt.consecutiveFailures > 0) {
        logAccess(clientIp, req.method, req.path, 200, "");
        globalLoginAttempt.consecutiveFailures = 0;
        globalLoginAttempt.lockedUntil = null;
      }
      logAccess(clientIp, req.method, req.path, 200);
      next();
    });
    this.app.post("/api/set-token", (req, res) => {
      const { token: token2 } = req.body;
      if (!token2) {
        res.status(400).json({ success: false, message: "Token" });
        return;
      }
      webuiTokenUtil.setToken(token2);
      res.json({ success: true, message: "Token" });
    });
    this.app.get("/api/config/", (req, res) => {
      try {
        const config2 = getConfigUtil().getConfig();
        const resJson = {
          config: config2,
          selfInfo
        };
        res.json({
          success: true,
          data: resJson
        });
      } catch (e) {
        res.status(500).json({ success: false, message: "", error: e });
      }
    });
    this.app.post("/api/config", (req, res) => {
      try {
        const { config: config2 } = req.body;
        const oldConfig = getConfigUtil().getConfig();
        const newConfig = { ...oldConfig, ...config2 };
        this.ctx.parallel("llob/config-updated", newConfig).then();
        getConfigUtil().setConfig(newConfig);
        res.json({ success: true, message: "" });
      } catch (e) {
        res.status(500).json({ success: false, message: "", error: e });
      }
    });
    this.app.get("/api/login-qrcode", async (req, res) => {
      this.ctx.ntLoginApi.getLoginQrCode().then(
        (data) => {
          res.json({
            success: true,
            data
          });
        }
      ).catch((e) => {
        res.status(500).json({ success: false, message: "", error: e });
      });
    });
    this.app.get("/api/quick-login-list", async (req, res) => {
      this.ctx.ntLoginApi.getQuickLoginList().then(
        (data) => {
          res.json({
            success: true,
            data
          });
        }
      ).catch((e) => {
        res.status(500).json({ success: false, message: "", error: e });
      });
    });
    this.app.post("/api/quick-login", async (req, res) => {
      const { uin } = req.body;
      if (!uin) {
        res.status(400).json({ success: false, message: "QQ" });
        return;
      }
      this.ctx.ntLoginApi.quickLoginWithUin(uin).then(
        (data) => {
          res.json({
            success: true,
            data,
            message: data.loginErrorInfo.errMsg
          });
        }
      ).catch((e) => {
        res.status(500).json({ success: false, message: "", error: e });
      });
    });
    this.app.get("/api/login-info", (req, res) => {
      res.json({ success: true, data: selfInfo });
    });
    this.app.get("/api/dashboard/stats", async (req, res) => {
      try {
        const app = this.ctx.get("app");
        if (!app) {
          res.status(503).json({ success: false, message: "" });
          return;
        }
        const friends = await this.ctx.ntFriendApi.getBuddyList();
        const groups = await this.ctx.ntGroupApi.getGroups(false);
        const qqInfo = await pmhq.getProcessInfo();
        const qqMemory = qqInfo?.memory?.rss || 0;
        const qqCpu = qqInfo?.cpu?.percent || 0;
        const qqTotalMem = qqInfo?.memory?.totalMem || 1;
        const qqMemoryPercent = qqMemory / qqTotalMem * 100;
        const os2 = await __vitePreload(() => import("os"), true ? [] : void 0);
        const botTotalMem = os2.totalmem();
        const cpuCores = os2.cpus().length;
        const memUsage = process.memoryUsage();
        const cpuUsage = process.cpuUsage();
        const botCpuPercent = (cpuUsage.user + cpuUsage.system) / 1e6 / process.uptime() / cpuCores * 100;
        const botMemoryPercent = memUsage.rss / botTotalMem * 100;
        res.json({
          success: true,
          data: {
            friendCount: friends.length,
            groupCount: groups.length,
            messageReceived: app.messageReceivedCount,
            messageSent: app.messageSentCount,
            startupTime: app.startupTime,
            lastMessageTime: app.lastMessageTime,
            bot: {
              memory: memUsage.rss,
              totalMemory: botTotalMem,
              memoryPercent: botMemoryPercent,
              cpu: botCpuPercent
            },
            qq: {
              memory: qqMemory,
              totalMemory: qqTotalMem,
              memoryPercent: qqMemoryPercent,
              cpu: qqCpu
            }
          }
        });
      } catch (e) {
        res.status(500).json({ success: false, message: "", error: e });
      }
    });
    this.app.get("/api/device-info", async (req, res) => {
      try {
        const deviceInfo = await this.ctx.ntSystemApi.getDeviceInfo();
        res.json({
          success: true,
          data: deviceInfo
        });
      } catch (e) {
        res.status(500).json({ success: false, message: "", error: e });
      }
    });
    this.app.get("/api/logs/stream", (req, res) => {
      res.setHeader("Content-Type", "text/event-stream");
      res.setHeader("Cache-Control", "no-cache");
      res.setHeader("Connection", "keep-alive");
      res.flushHeaders();
      res.write(`event: connected
data: {}

`);
      for (const record2 of getLogCache()) {
        res.write(`data: ${JSON.stringify(record2)}

`);
      }
      const dispose = this.ctx.on("llob/log", (record2) => {
        res.write(`data: ${JSON.stringify(record2)}

`);
      });
      req.on("close", () => {
        dispose();
      });
    });
    this.initWebQQRoutes();
    this.app.use(express.static(feDistPath));
    this.app.get("/", (req, res) => {
      res.sendFile(path$1.join(feDistPath, "index.html"));
    });
  }
  // WebQQ API 
  initWebQQRoutes() {
    this.app.get("/api/webqq/messages", async (req, res) => {
      try {
        const { chatType, peerId, beforeMsgSeq, afterMsgSeq, limit = "20" } = req.query;
        if (!chatType || !peerId) {
          res.status(400).json({ success: false, message: "" });
          return;
        }
        const chatTypeNum = Number(chatType);
        if (chatTypeNum !== ChatType.C2C && chatTypeNum !== ChatType.Group && chatTypeNum !== ChatType.TempC2CFromGroup) {
          res.status(400).json({ success: false, message: ` chatType: ${chatType} 1()2()  100()` });
          return;
        }
        let peerUid = peerId;
        if (chatTypeNum === ChatType.C2C || chatTypeNum === ChatType.TempC2CFromGroup) {
          const uid = await this.ctx.ntUserApi.getUidByUin(peerId);
          if (!uid) {
            res.status(400).json({ success: false, message: "" });
            return;
          }
          peerUid = uid;
        }
        const peer = {
          chatType: chatTypeNum,
          peerUid,
          guildId: ""
        };
        let result;
        if (afterMsgSeq) {
          result = await this.ctx.ntMsgApi.getMsgsBySeqAndCount(peer, afterMsgSeq, parseInt(limit), false, true);
        } else if (beforeMsgSeq && beforeMsgSeq !== "0") {
          result = await this.ctx.ntMsgApi.getMsgsBySeqAndCount(peer, beforeMsgSeq, parseInt(limit), true, true);
        } else {
          result = await this.ctx.ntMsgApi.getAioFirstViewLatestMsgs(peer, parseInt(limit));
        }
        const messages = result?.msgList || [];
        messages.sort((a, b) => parseInt(a.msgTime) - parseInt(b.msgTime));
        res.json({
          success: true,
          data: this.serializeResult({
            messages,
            hasMore: messages.length >= parseInt(limit)
          })
        });
      } catch (e) {
        this.ctx.logger.error(":", e);
        res.status(500).json({ success: false, message: "", error: e.message });
      }
    });
    this.app.post("/api/webqq/messages", async (req, res) => {
      try {
        const { chatType, peerId, content } = req.body;
        if (chatType === void 0 || chatType === null || !peerId || !content || content.length === 0) {
          res.status(400).json({ success: false, message: "" });
          return;
        }
        const chatTypeNum = Number(chatType);
        if (chatTypeNum !== ChatType.C2C && chatTypeNum !== ChatType.Group && chatTypeNum !== ChatType.TempC2CFromGroup) {
          res.status(400).json({ success: false, message: ` chatType: ${chatType} 1()2()  100()` });
          return;
        }
        let peerUid = peerId;
        if (chatTypeNum === ChatType.C2C || chatTypeNum === ChatType.TempC2CFromGroup) {
          const uid = await this.ctx.ntUserApi.getUidByUin(peerId);
          if (!uid) {
            res.status(400).json({ success: false, message: "" });
            return;
          }
          peerUid = uid;
        }
        const peer = {
          chatType: chatTypeNum,
          peerUid,
          guildId: ""
        };
        const elements = [];
        for (const item of content) {
          if (item.type === "reply" && item.msgId && item.msgSeq) {
            elements.push({
              elementType: ElementType.Reply,
              elementId: "",
              replyElement: {
                replayMsgId: item.msgId,
                replayMsgSeq: item.msgSeq,
                sourceMsgText: "",
                senderUid: "",
                senderUidStr: ""
              }
            });
          } else if (item.type === "text" && item.text) {
            elements.push({
              elementType: ElementType.Text,
              elementId: "",
              textElement: {
                content: item.text,
                atType: 0,
                atUid: "",
                atTinyId: "",
                atNtUid: ""
              }
            });
          } else if (item.type === "at" && item.uid) {
            const atUid = item.uid;
            const atUin = item.uin || "";
            const display = item.name ? `@${item.name}` : "@";
            elements.push({
              elementType: ElementType.Text,
              elementId: "",
              textElement: {
                content: display,
                atType: 2,
                // AtType.One
                atUid: atUin,
                atTinyId: "",
                atNtUid: atUid
              }
            });
          } else if (item.type === "image" && item.imagePath) {
            const picElement = await this.createPicElement(item.imagePath);
            if (picElement) {
              elements.push(picElement);
            }
          } else if (item.type === "face" && item.faceId !== void 0) {
            elements.push(SendElement.face(item.faceId));
          } else if (item.type === "file" && item.filePath && item.fileName) {
            const fileElement = await SendElement.file(this.ctx, item.filePath, item.fileName);
            elements.push(fileElement);
          }
        }
        if (elements.length === 0) {
          res.status(400).json({ success: false, message: "" });
          return;
        }
        const result = await this.ctx.ntMsgApi.sendMsg(peer, elements);
        res.json({
          success: true,
          data: { msgId: result.msgId }
        });
      } catch (e) {
        this.ctx.logger.error(":", e);
        res.status(500).json({ success: false, message: "", error: e.message });
      }
    });
    this.app.post("/api/webqq/upload", this.upload.single("image"), async (req, res) => {
      try {
        const imageUrl = req.body?.imageUrl;
        if (imageUrl) {
          const response2 = await fetch(imageUrl);
          if (!response2.ok) {
            res.status(400).json({ success: false, message: "" });
            return;
          }
          const buffer2 = Buffer.from(await response2.arrayBuffer());
          const ext = imageUrl.includes(".gif") ? ".gif" : imageUrl.includes(".png") ? ".png" : ".jpg";
          const filename = `url_${Date.now()}${ext}`;
          const filePath = path$1.join(this.uploadDir, filename);
          await promises.writeFile(filePath, buffer2);
          res.json({
            success: true,
            data: {
              imagePath: filePath,
              filename
            }
          });
          return;
        }
        if (!req.file) {
          res.status(400).json({ success: false, message: "" });
          return;
        }
        res.json({
          success: true,
          data: {
            imagePath: req.file.path,
            filename: req.file.filename
          }
        });
      } catch (e) {
        this.ctx.logger.error(":", e);
        res.status(500).json({ success: false, message: "", error: e.message });
      }
    });
    this.app.post("/api/webqq/upload-file", this.fileUpload.single("file"), async (req, res) => {
      try {
        if (!req.file) {
          res.status(400).json({ success: false, message: "" });
          return;
        }
        const fileName = Buffer.from(req.file.originalname, "latin1").toString("utf8");
        res.json({
          success: true,
          data: {
            filePath: req.file.path,
            fileName,
            fileSize: req.file.size
          }
        });
      } catch (e) {
        this.ctx.logger.error(":", e);
        res.status(500).json({ success: false, message: "", error: e.message });
      }
    });
    this.app.get("/api/webqq/members", async (req, res) => {
      try {
        const { groupCode } = req.query;
        if (!groupCode) {
          res.status(400).json({ success: false, message: "" });
          return;
        }
        const result = await this.ctx.ntGroupApi.getGroupMembers(groupCode);
        const members = [];
        if (result?.result?.infos) {
          for (const [uid, member] of result.result.infos) {
            const role = member.role === 4 ? "owner" : member.role === 3 ? "admin" : "member";
            members.push({
              uid: member.uid,
              uin: member.uin,
              nickname: member.nick,
              card: member.cardName || "",
              avatar: `https://q1.qlogo.cn/g?b=qq&nk=${member.uin}&s=640`,
              role,
              level: member.memberRealLevel || member.memberLevel || 0,
              specialTitle: member.memberSpecialTitle || ""
            });
          }
        }
        const roleOrder = { owner: 0, admin: 1, member: 2 };
        members.sort((a, b) => roleOrder[a.role] - roleOrder[b.role]);
        res.json({ success: true, data: members });
      } catch (e) {
        this.ctx.logger.error(":", e);
        res.status(500).json({ success: false, message: "", error: e.message });
      }
    });
    this.app.get("/api/webqq/user-info", async (req, res) => {
      try {
        const { uid } = req.query;
        if (!uid) {
          res.status(400).json({ success: false, message: " uid " });
          return;
        }
        const userInfo = await this.ctx.ntUserApi.getUserSimpleInfo(uid, false);
        const uin = await this.ctx.ntUserApi.getUinByUid(uid);
        res.json({
          success: true,
          data: {
            uid: userInfo.uid,
            uin: uin || "",
            nickname: userInfo.coreInfo?.nick || "",
            remark: userInfo.coreInfo?.remark || ""
          }
        });
      } catch (e) {
        this.ctx.logger.error(":", e);
        res.status(500).json({ success: false, message: "", error: e.message });
      }
    });
    this.app.post("/api/ntcall/:service/:method", async (req, res) => {
      try {
        const { service, method } = req.params;
        const args = req.body?.args || [];
        if (!service || !method) {
          res.status(400).json({ success: false, message: " service  method " });
          return;
        }
        const allowedServices = ["ntUserApi", "ntGroupApi", "ntFriendApi", "ntFileApi", "ntMsgApi", "pmhq"];
        if (!allowedServices.includes(service)) {
          res.status(400).json({ success: false, message: `: ${service}` });
          return;
        }
        const serviceInstance = service === "pmhq" ? pmhq : this.ctx[service];
        if (!serviceInstance) {
          res.status(400).json({ success: false, message: ` ${service} ` });
          return;
        }
        const methodFunc = serviceInstance[method];
        if (typeof methodFunc !== "function") {
          res.status(400).json({ success: false, message: ` ${service} : ${method}` });
          return;
        }
        const result = await methodFunc.apply(serviceInstance, args || []);
        const serializedResult = this.serializeResult(result);
        res.json({ success: true, data: serializedResult });
      } catch (e) {
        this.ctx.logger.error("NT API :", e);
        res.status(500).json({ success: false, message: "NT API ", error: e.message });
      }
    });
    this.app.get("/api/webqq/events", (req, res) => {
      res.setHeader("Content-Type", "text/event-stream");
      res.setHeader("Cache-Control", "no-cache");
      res.setHeader("Connection", "keep-alive");
      res.flushHeaders();
      res.write(`event: connected
data: {}

`);
      this.sseClients.add(res);
      req.on("close", () => {
        this.sseClients.delete(res);
      });
    });
    this.app.get("/api/webqq/file-proxy", async (req, res) => {
      try {
        const filePath = req.query.path;
        if (!filePath) {
          res.status(400).json({ success: false, message: "" });
          return;
        }
        const normalizedPath = path$1.normalize(filePath);
        if (!existsSync(normalizedPath)) {
          res.status(404).json({ success: false, message: "" });
          return;
        }
        const ext = path$1.extname(normalizedPath).toLowerCase();
        const mimeTypes2 = {
          ".jpg": "image/jpeg",
          ".jpeg": "image/jpeg",
          ".png": "image/png",
          ".gif": "image/gif",
          ".webp": "image/webp",
          ".mp4": "video/mp4",
          ".webm": "video/webm"
        };
        const contentType2 = mimeTypes2[ext] || "application/octet-stream";
        res.setHeader("Content-Type", contentType2);
        res.setHeader("Cache-Control", "public, max-age=86400");
        res.sendFile(normalizedPath);
      } catch (e) {
        this.ctx.logger.error(":", e);
        res.status(500).json({ success: false, message: "", error: e.message });
      }
    });
    this.app.get("/api/webqq/image-proxy", async (req, res) => {
      try {
        const urlParam = req.query.url;
        if (!urlParam) {
          res.status(400).json({ success: false, message: "URL" });
          return;
        }
        let url2 = decodeURIComponent(urlParam);
        this.ctx.logger.info(":", url2);
        let parsedUrl;
        try {
          parsedUrl = new URL(url2);
        } catch (e) {
          res.status(400).json({ success: false, message: "URL" });
          return;
        }
        const allowedHosts = ["gchat.qpic.cn", "multimedia.nt.qq.com.cn", "c2cpicdw.qpic.cn", "p.qlogo.cn", "q1.qlogo.cn"];
        if (!allowedHosts.some((host) => parsedUrl.hostname.includes(host))) {
          res.status(403).json({ success: false, message: "" });
          return;
        }
        if (!url2.includes("rkey=") && (parsedUrl.hostname.includes("multimedia.nt.qq.com.cn") || parsedUrl.hostname.includes("gchat.qpic.cn"))) {
          try {
            const appid = parsedUrl.searchParams.get("appid");
            if (appid && ["1406", "1407"].includes(appid)) {
              const rkeyData = await this.ctx.ntFileApi.rkeyManager.getRkey();
              const rkey = appid === "1406" ? rkeyData.private_rkey : rkeyData.group_rkey;
              if (rkey) {
                url2 = url2 + rkey;
                this.ctx.logger.info(" rkey  URL");
              }
            }
          } catch (e) {
            this.ctx.logger.warn(" rkey :", e);
          }
        }
        const response2 = await fetch(url2, {
          headers: {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            "Accept": "image/webp,image/apng,image/*,*/*;q=0.8",
            "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8"
          }
        });
        if (!response2.ok) {
          this.ctx.logger.warn(":", response2.status, response2.statusText);
          res.status(response2.status).json({ success: false, message: `: ${response2.statusText}` });
          return;
        }
        const contentType2 = response2.headers.get("content-type") || "image/png";
        res.setHeader("Content-Type", contentType2);
        res.setHeader("Cache-Control", "public, max-age=86400");
        res.setHeader("Access-Control-Allow-Origin", "*");
        const buffer2 = await response2.arrayBuffer();
        res.send(Buffer.from(buffer2));
      } catch (e) {
        this.ctx.logger.error(":", e);
        res.status(500).json({ success: false, message: "", error: e.message });
      }
    });
    this.app.get("/api/webqq/audio-proxy", async (req, res) => {
      try {
        const fileUuid = req.query.fileUuid;
        const filePath = req.query.filePath;
        const isGroup = req.query.isGroup === "true";
        if (!fileUuid && !filePath) {
          res.status(400).json({ success: false, message: " fileUuid  filePath " });
          return;
        }
        this.ctx.logger.info(":", { fileUuid, filePath, isGroup });
        const { decodeSilk: decodeSilk2 } = await __vitePreload(async () => {
          const { decodeSilk: decodeSilk3 } = await Promise.resolve().then(() => audio);
          return { decodeSilk: decodeSilk3 };
        }, true ? void 0 : void 0);
        const fs2 = await __vitePreload(() => import("fs/promises"), true ? [] : void 0);
        const path2 = await __vitePreload(() => import("path"), true ? [] : void 0);
        const os2 = await __vitePreload(() => import("os"), true ? [] : void 0);
        const { randomUUID: randomUUID2 } = await __vitePreload(async () => {
          const { randomUUID: randomUUID22 } = await import("crypto");
          return { randomUUID: randomUUID22 };
        }, true ? [] : void 0);
        let audioFilePath;
        if (filePath) {
          const decodedPath = decodeURIComponent(filePath);
          try {
            await fs2.access(decodedPath);
            audioFilePath = decodedPath;
            this.ctx.logger.info(":", audioFilePath);
          } catch {
            this.ctx.logger.warn("URL");
            audioFilePath = "";
          }
        } else {
          audioFilePath = "";
        }
        if (!audioFilePath && fileUuid) {
          const url2 = await this.ctx.ntFileApi.getPttUrl(fileUuid, isGroup);
          if (!url2) {
            res.status(404).json({ success: false, message: "URL" });
            return;
          }
          this.ctx.logger.info("URL:", url2);
          const response2 = await fetch(url2, {
            headers: {
              "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            }
          });
          if (!response2.ok) {
            this.ctx.logger.warn(":", response2.status, response2.statusText);
            res.status(response2.status).json({ success: false, message: `: ${response2.statusText}` });
            return;
          }
          const audioBuffer = Buffer.from(await response2.arrayBuffer());
          const tempDir = os2.tmpdir();
          audioFilePath = path2.join(tempDir, `ptt_${randomUUID2()}.silk`);
          await fs2.writeFile(audioFilePath, audioBuffer);
        }
        try {
          const mp3Path = await decodeSilk2(this.ctx, audioFilePath, "mp3");
          const mp3Buffer = await fs2.readFile(mp3Path);
          if (audioFilePath.includes(os2.tmpdir())) {
            fs2.unlink(audioFilePath).catch(() => {
            });
          }
          fs2.unlink(mp3Path).catch(() => {
          });
          res.setHeader("Content-Type", "audio/mpeg");
          res.setHeader("Cache-Control", "public, max-age=86400");
          res.setHeader("Access-Control-Allow-Origin", "*");
          res.send(mp3Buffer);
        } catch (decodeError) {
          this.ctx.logger.error("silk :", decodeError);
          res.status(500).json({ success: false, message: "", error: String(decodeError) });
        }
      } catch (e) {
        this.ctx.logger.error(":", e);
        res.status(500).json({ success: false, message: "", error: e.message });
      }
    });
  }
  // 
  extractAbstractContent(abstractContent) {
    if (!abstractContent || abstractContent.length === 0) return "";
    return abstractContent.map((item) => {
      if (item.type === "text") return item.content || "";
      if (item.type === "pic") return "[]";
      if (item.type === "face") return "[]";
      return "";
    }).join("");
  }
  // 
  async createPicElement(imagePath) {
    try {
      return await SendElement.pic(this.ctx, imagePath);
    } catch (e) {
      this.ctx.logger.error(":", e);
      return null;
    }
  }
  //  Map 
  serializeResult(result) {
    if (result === null || result === void 0) return result;
    if (result instanceof Map) {
      const obj = {};
      for (const [key2, value] of result) {
        obj[String(key2)] = this.serializeResult(value);
      }
      return obj;
    }
    if (Array.isArray(result)) {
      return result.map((item) => this.serializeResult(item));
    }
    if (typeof result === "object") {
      const obj = {};
      for (const [key2, value] of Object.entries(result)) {
        obj[key2] = this.serializeResult(value);
      }
      return obj;
    }
    return result;
  }
  //  SSE 
  broadcastMessage(event, data) {
    const serializedData = this.serializeResult(data);
    const message = `event: ${event}
data: ${JSON.stringify(serializedData)}

`;
    for (const client of this.sseClients) {
      client.write(message);
    }
  }
  // 
  setupMessageListener() {
    this.ctx.logger.info("WebQQ: ");
    this.ctx.on("nt/message-created", async (message) => {
      if (this.sseClients.size === 0) return;
      if (message.chatType === ChatType.C2C && (!message.peerUin || message.peerUin === "0") && message.peerUid) {
        const uin = await this.ctx.ntUserApi.getUinByUid(message.peerUid);
        if (uin) {
          message.peerUin = uin;
        }
      }
      this.broadcastMessage("message", {
        type: "message-created",
        data: message
      });
    });
    this.ctx.on("nt/message-sent", async (message) => {
      this.ctx.logger.info("WebQQ:  nt/message-sent , sseClients:", this.sseClients.size);
      if (this.sseClients.size === 0) return;
      if (message.chatType === ChatType.C2C && (!message.peerUin || message.peerUin === "0") && message.peerUid) {
        const uin = await this.ctx.ntUserApi.getUinByUid(message.peerUid);
        if (uin) {
          message.peerUin = uin;
        }
      }
      this.ctx.logger.info("WebQQ SSE :", {
        msgId: message.msgId,
        chatType: message.chatType,
        peerUin: message.peerUin,
        peerUid: message.peerUid,
        senderUin: message.senderUin,
        elementsCount: message.elements?.length
      });
      this.broadcastMessage("message", {
        type: "message-sent",
        data: message
      });
    });
    this.ctx.on("nt/message-deleted", async (message) => {
      if (this.sseClients.size === 0) return;
      const revokeElement = message.elements[0]?.grayTipElement?.revokeElement;
      if (message.chatType === ChatType.C2C && (!message.peerUin || message.peerUin === "0") && message.peerUid) {
        const uin = await this.ctx.ntUserApi.getUinByUid(message.peerUid);
        if (uin) {
          message.peerUin = uin;
        }
      }
      this.broadcastMessage("message", {
        type: "message-deleted",
        data: {
          msgId: message.msgId,
          msgSeq: message.msgSeq,
          chatType: message.chatType,
          peerUid: message.peerUid,
          peerUin: message.peerUin,
          operatorUid: revokeElement?.operatorUid,
          operatorNick: revokeElement?.operatorNick || revokeElement?.operatorMemRemark || revokeElement?.operatorRemark,
          isSelfOperate: revokeElement?.isSelfOperate,
          wording: revokeElement?.wording
        }
      });
    });
    pmhq.addResListener(async (data) => {
      if (this.sseClients.size === 0) return;
      if (data.type !== "recv" || data.data.cmd !== "trpc.msg.olpush.OlPushService.MsgPush") return;
      try {
        const { Msg: Msg2 } = await __vitePreload(async () => {
          const { Msg: Msg3 } = await import("./assets/index-BzaRbVUe.js");
          return { Msg: Msg3 };
        }, true ? [] : void 0);
        const pushMsg = Msg2.PushMsg.decode(Buffer.from(data.data.pb, "hex"));
        if (!pushMsg.message?.body) return;
        const { msgType, subType } = pushMsg.message?.contentHead ?? {};
        if (msgType === 732 && subType === 16) {
          const notify = Msg2.NotifyMessageBody.decode(pushMsg.message.body.msgContent.subarray(7));
          if (notify.field13 === 35) {
            const info = notify.reaction.data.body.info;
            const target = notify.reaction.data.body.target;
            const groupCode = String(notify.groupCode);
            const userId = await this.ctx.ntUserApi.getUinByUid(info.operatorUid);
            let userName = userId;
            try {
              const membersResult = await this.ctx.ntGroupApi.getGroupMembers(groupCode);
              if (membersResult?.result?.infos) {
                for (const [, member] of membersResult.result.infos) {
                  if (member.uid === info.operatorUid || member.uin === userId) {
                    userName = member.cardName || member.nick || userId;
                    break;
                  }
                }
              }
            } catch {
            }
            this.broadcastMessage("message", {
              type: "emoji-reaction",
              data: {
                groupCode,
                msgSeq: String(target.sequence),
                emojiId: info.code,
                userId,
                userName,
                isAdd: info.type === 1
              }
            });
          }
        }
      } catch (e) {
      }
    });
  }
  getHostPort() {
    const host = this.config.onlyLocalhost ? "127.0.0.1" : "";
    return { host, port: this.config.port };
  }
  async startServer(forcePort) {
    const { host, port } = this.getHostPort();
    const targetPort = forcePort !== void 0 ? forcePort : await getAvailablePort(port);
    this.server = this.app.listen(targetPort, host, () => {
      this.currentPort = targetPort;
      this.ctx.logger.info(`Webui  ${host}:${targetPort}`);
    });
    this.server.on("connection", (conn) => {
      this.connections.add(conn);
      conn.on("close", () => {
        this.connections.delete(conn);
      });
    });
    this.server.on("error", (err) => {
      if (err.code === "EADDRINUSE") {
        this.ctx.logger.error(`Webui  ${targetPort} `);
      } else {
        this.ctx.logger.error(`Webui :`, err);
      }
    });
    return targetPort;
  }
  stop() {
    return new Promise((resolve2) => {
      if (this.server) {
        if (this.connections.size > 0) {
          this.ctx.logger.info(`Webui  ${this.connections.size} ...`);
          for (const conn of this.connections) {
            conn.destroy();
          }
          this.connections.clear();
        }
        this.server.close((err) => {
          if (err) {
            this.ctx.logger.error(`Webui :`, err);
          } else {
            this.ctx.logger.info(`Webui `);
          }
          this.server = null;
          resolve2();
        });
      } else {
        this.ctx.logger.info(`Webui `);
        resolve2();
      }
    });
  }
  async restart(forcePort) {
    await this.stop();
    await new Promise((resolve2) => setTimeout(resolve2, 1e3));
    await this.startWithPort(forcePort);
  }
  setConfig(newConfig) {
    ({ ...this.config });
    this.config = { onlyLocalhost: newConfig.onlyLocalhost, ...newConfig.webui };
  }
  async start() {
    console.log("webui start");
    if (!this.config?.enable) {
      return;
    }
    this.port = await this.startServer();
    pmhq.tellPort(this.port).catch((err) => {
      this.ctx.logger.error(" WebUI :", err);
    });
  }
  async startWithPort(forcePort) {
    if (!this.config?.enable) {
      return;
    }
    this.port = await this.startServer(forcePort);
    pmhq.tellPort(this.port).catch((err) => {
      this.ctx.logger.error(" WebUI :", err);
    });
  }
}
const __dirname$1 = typeof window === "undefined" ? path__default.dirname(fileURLToPath(import.meta.url)) : "";
global.__dirname = __dirname$1;
async function onLoad() {
  if (!existsSync(DATA_DIR)) {
    mkdirSync(DATA_DIR, { recursive: true });
  }
  if (!existsSync(LOG_DIR)) {
    mkdirSync(LOG_DIR);
  }
  if (!existsSync(TEMP_DIR)) {
    mkdirSync(TEMP_DIR);
  }
  const ctx = new Context2();
  let config2 = getConfigUtil().getConfig();
  config2.milky.enable = false;
  config2.satori.enable = false;
  config2.ob11.enable = false;
  ctx.plugin(NTQQFileApi);
  ctx.plugin(NTQQFileCacheApi);
  ctx.plugin(NTQQFriendApi);
  ctx.plugin(NTQQGroupApi);
  ctx.plugin(NTLoginApi);
  ctx.plugin(NTQQMsgApi);
  ctx.plugin(NTQQUserApi);
  ctx.plugin(NTQQWebApi);
  ctx.plugin(NTQQSystemApi);
  ctx.plugin(Log, {
    enable: config2.log,
    filename: logFileName
  });
  ctx.plugin(WebUIServer, { ...config2.webui, onlyLocalhost: config2.onlyLocalhost });
  const loadPluginAfterLogin = () => {
    ctx.plugin(src_default$1);
    ctx.plugin(src_default, {
      path: path__default.join(dbDir, `${selfInfo.uin}.v2.db`)
    });
    ctx.plugin(Core, config2);
    ctx.plugin(OneBot11Adapter, {
      ...config2.ob11,
      onlyLocalhost: config2.onlyLocalhost,
      musicSignUrl: config2.musicSignUrl,
      enableLocalFile2Url: config2.enableLocalFile2Url,
      ffmpeg: config2.ffmpeg
    });
    ctx.plugin(SatoriAdapter, {
      ...config2.satori,
      ffmpeg: config2.ffmpeg,
      onlyLocalhost: config2.onlyLocalhost
    });
    ctx.plugin(MilkyAdapter, {
      ...config2.milky,
      onlyLocalhost: config2.onlyLocalhost
    });
    ctx.plugin(Store, {
      msgCacheExpire: config2.msgCacheExpire * 1e3
    });
  };
  let pmhqSelfInfo = { ...selfInfo };
  let checkLoginInterval = setInterval(async () => {
    try {
      pmhqSelfInfo = await pmhq.call("getSelfInfo", []);
    } catch (e) {
      ctx.logger.info("", e);
    }
    if (pmhqSelfInfo.online) {
      clearInterval(checkLoginInterval);
      selfInfo.uin = pmhqSelfInfo.uin;
      selfInfo.uid = pmhqSelfInfo.uid;
      selfInfo.nick = pmhqSelfInfo.nick;
      if (!selfInfo.uin) {
        let uin;
        for (let i = 0; i < 5; i++) {
          try {
            uin = await ctx.ntUserApi.getUinByUid(selfInfo.uid);
            selfInfo.uin = uin;
            break;
          } catch (e) {
            await sleep(1e3);
          }
        }
      }
      selfInfo.online = true;
      if (!selfInfo.nick) {
        await ctx.ntUserApi.getSelfNick(true).catch((e) => {
          ctx.logger.warn("", e);
        });
      }
      config2 = getConfigUtil(true).getConfig();
      getConfigUtil().listenChange((c2) => {
        ctx.parallel("llob/config-updated", c2);
      });
      ctx.parallel("llob/config-updated", config2);
      loadPluginAfterLogin();
    }
  }, 1e3);
  ctx.logger.info(`LLBot ${version$2}`);
  startHook();
  ctx.start().catch((e) => {
    console.error("Start error:", e);
  });
}
try {
  onLoad().then().catch((e) => console.log(e));
} catch (e) {
  console.error(e);
}
export {
  Action as A,
  Media as M,
  Notify as N,
  Oidb as O,
  Msg as a
};
//# sourceMappingURL=llbot.js.map
