# MemOS v2.0 功能说明与使用指南

## 一、新旧版本功能对比

### 存储系统

| 功能 | v1.0 (旧版) | v2.0 (新版) |
|------|------------|------------|
| 向量存储 | JSON 文件 + 内存列表 | **Qdrant 向量数据库** |
| 图存储 | ❌ 无 | **NetworkX 知识图谱** |
| 数据持久化 | JSON 文件 | Qdrant 本地存储 + JSON |
| 搜索性能 | 全量遍历 O(n) | **向量索引 O(log n)** |
| 最大容量 | ~1000 条（内存限制） | **无限制** |

### 记忆管理

| 功能 | v1.0 (旧版) | v2.0 (新版) |
|------|------------|------------|
| 基础添加 | ✅ | ✅ |
| LLM 加工 | ✅ | ✅ (优化版) |
| 语义搜索 | ✅ | ✅ (更快更准) |
| 重要度加权 | ❌ | **✅ final_score = similarity × 0.7 + importance × 0.3** |
| 自动去重 | 简单相似度 | **智能去重 + 合并** |
| 记忆合并 | ❌ | **✅ 相似记忆自动合并** |
| 批量操作 | ❌ | **✅ 批量添加/删除** |

### 知识图谱（全新功能）

| 功能 | v1.0 (旧版) | v2.0 (新版) |
|------|------------|------------|
| 实体管理 | ❌ | **✅ 创建/查询/删除实体** |
| 关系管理 | ❌ | **✅ 建立实体间关系** |
| 图查询 | ❌ | **✅ 相关实体查询** |
| 路径查找 | ❌ | **✅ 两点间路径** |
| 多跳推理 | ❌ | **✅ 支持 N 跳关联** |

### 高级特性

| 功能 | v1.0 (旧版) | v2.0 (新版) |
|------|------------|------------|
| 多用户支持 | 基础 | **✅ 完整隔离** |
| 混合检索 | ❌ | **✅ 向量+关键词** |
| 统计信息 | 基础 | **✅ 详细统计** |
| 健康检查 | ❌ | **✅ 组件级别检查** |

### 记忆类型系统（v2.1 新增）

| 功能 | v1.0 (旧版) | v2.0 (新版) |
|------|------------|------------|
| 类型分类 | ❌ 无 | **✅ 8种记忆类型** |
| 类型加权搜索 | ❌ | **✅ 偏好记忆权重 1.5x** |
| 偏好记忆管理 | ❌ | **✅ 完整 CRUD** |
| 偏好自动提取 | ❌ | **✅ LLM 提取** |
| 类型统计 | ❌ | **✅ 按类型查询** |

### 高级功能（v2.2 新增）

| 功能 | v1.0 (旧版) | v2.0 (新版) |
|------|------------|------------|
| 工具记忆 | ❌ | **✅ 记录工具使用历史** |
| 记忆反馈修正 | ❌ | **✅ 修正/补充/合并记忆** |
| 知识库导入 | ❌ | **✅ 文档/URL/PDF 导入** |
| 标签过滤搜索 | ❌ | **✅ 按标签筛选** |
| 图增强搜索 | ❌ | **✅ 知识图谱关联加分** |

### 企业级功能（v2.3 新增）

| 功能 | v1.0 (旧版) | v2.0 (新版) |
|------|------------|------------|
| 图像记忆 | ❌ | **✅ 图像存储/检索/描述生成** |
| 异步调度器 | ❌ | **✅ 任务队列/优先级/重试** |
| Redis Streams | ❌ | **✅ 可选高并发队列** |
| 用户配额控制 | ❌ | **✅ 每用户速率限制** |
| CLIP 图像向量化 | ❌ | **✅ 可选多模态检索** |

### 智能功能（v2.4 新增）

| 功能 | v1.0 (旧版) | v2.0 (新版) |
|------|------------|------------|
| LLM 实体提取 | ❌ | **✅ 自动识别人物/地点/概念** |
| 关系提取 | ❌ | **✅ 提取实体间的关系** |
| 图增强搜索 | ❌ | **✅ 通过图谱关联提升检索** |
| 实体-记忆关联 | ❌ | **✅ 双向链接查询** |
| 添加时自动提取 | ❌ | **✅ extract_entities 选项** |

---

## 二、API 端点完整列表

### 基础端点

```
GET  /                 # 服务信息
GET  /health           # 健康检查
GET  /stats            # 统计信息
GET  /docs             # API 文档（Swagger UI）
```

### 记忆管理

```
POST   /add            # 添加记忆（LLM 加工）
POST   /add_raw        # 直接添加记忆（支持指定类型）
POST   /search         # 搜索记忆（支持类型加权）
GET    /list           # 列出所有记忆
GET    /get/{id}       # 获取单条记忆
DELETE /delete/{id}    # 删除记忆
POST   /deduplicate    # 去重
POST   /migrate        # 迁移 JSON 数据到 Qdrant
```

### 记忆类型管理

```
GET    /memory-types              # 获取所有记忆类型及权重
GET    /memories/by-type/{type}   # 按类型获取记忆
POST   /memories/classify         # LLM 自动分类记忆类型
```

### 偏好管理

```
GET    /preferences               # 获取用户偏好列表
POST   /preferences               # 添加用户偏好
GET    /preferences/summary       # 获取偏好摘要
POST   /preferences/extract       # 从文本提取偏好（LLM）
POST   /preferences/search        # 搜索相关偏好
```

### 工具记忆（v2.2 新增）

```
GET    /tools/stats               # 工具使用统计
POST   /tools/record              # 记录工具使用
GET    /tools/frequently-used     # 获取常用工具
GET    /tools/recent              # 获取最近使用记录
GET    /tools/suggest/{tool_name} # 参数建议
```

### 记忆反馈（v2.2 新增）

```
POST   /memory/feedback           # 提交记忆反馈（修正/补充/删除/合并）
GET    /memory/{id}/history       # 获取记忆修改历史
```

### 知识库导入（v2.2 新增）

```
POST   /kb/import                 # 导入单个文档
POST   /kb/import/batch           # 批量导入文档
POST   /kb/import/url             # 从 URL 导入
```

### 知识图谱

```
GET    /graph/stats                    # 图谱统计
POST   /graph/entity                   # 添加实体
GET    /graph/entity/{id}              # 获取实体
DELETE /graph/entity/{id}              # 删除实体
GET    /graph/entities                 # 列出实体
POST   /graph/relation                 # 添加关系
GET    /graph/entity/{id}/relations    # 获取实体关系
POST   /graph/query/related            # 查找相关实体
GET    /graph/path                     # 查找路径
POST   /graph/search                   # 图谱搜索
```

---

## 三、使用示例

### 1. 启动服务

```bash
cd k:\neruo\my-neuro-main\memos_system
python api/memos_api_server_v2.py
```

启动后访问：
- API: http://127.0.0.1:8003
- 文档: http://127.0.0.1:8003/docs

### 2. 添加记忆

#### 方式一：直接添加（推荐日常使用）

```python
import requests

# 添加一条记忆
response = requests.post("http://127.0.0.1:8003/add_raw", json={
    "messages": [
        {"content": "用户喜欢吃四川火锅，特别是麻辣口味", "importance": 0.9}
    ],
    "user_id": "test_user"
})
print(response.json())
# {"status": "success", "message": "成功添加 1 条记忆", "added": 1}
```

#### 方式二：LLM 加工添加（对话中使用）

```python
# 从对话中提取记忆
response = requests.post("http://127.0.0.1:8003/add", json={
    "messages": [
        {"role": "user", "content": "我最近在学习 Python，感觉挺有意思的"},
        {"role": "assistant", "content": "Python 确实很适合入门！你主要用来做什么呢？"},
        {"role": "user", "content": "主要想做数据分析和机器学习"}
    ],
    "user_id": "test_user"
})
# LLM 会自动提取关键信息并存储
```

### 3. 搜索记忆

```python
# 语义搜索
response = requests.post("http://127.0.0.1:8003/search", json={
    "query": "用户喜欢什么食物",
    "top_k": 5,
    "user_id": "test_user",
    "similarity_threshold": 0.3
})

result = response.json()
for memory in result["memories"]:
    print(f"内容: {memory['content']}")
    print(f"相似度: {memory['similarity']}")
    print(f"重要度: {memory['importance']}")
    print(f"综合得分: {memory['final_score']}")
    print("---")
```

### 4. 知识图谱操作

#### 添加实体

```python
# 添加人物实体
requests.post("http://127.0.0.1:8003/graph/entity", json={
    "entity_type": "person",
    "name": "张三",
    "properties": {"age": 25, "city": "北京"},
    "user_id": "test_user"
})

# 添加食物实体
requests.post("http://127.0.0.1:8003/graph/entity", json={
    "entity_type": "food",
    "name": "四川火锅",
    "properties": {"spicy": True, "category": "川菜"},
    "user_id": "test_user"
})
```

#### 建立关系

```python
# 张三 喜欢 四川火锅
requests.post("http://127.0.0.1:8003/graph/relation", json={
    "source_id": "张三的entity_id",
    "target_id": "火锅的entity_id",
    "relation_type": "likes",
    "properties": {"frequency": "每周一次"}
})
```

#### 查询相关实体

```python
# 查找与张三相关的所有实体
response = requests.post(
    "http://127.0.0.1:8003/graph/query/related?entity_id=xxx&max_depth=2"
)
# 返回所有 2 跳内的相关实体
```

### 5. 查看统计信息

```python
# 完整统计
response = requests.get("http://127.0.0.1:8003/stats")
print(response.json())
# {
#     "total_count": 10,        # 总记忆数
#     "today_count": 3,         # 今日新增
#     "week_count": 8,          # 本周新增
#     "avg_importance": 0.75,   # 平均重要度
#     "storage_type": "qdrant", # 存储类型
#     "graph_enabled": true,    # 图谱状态
#     "entity_count": 5,        # 实体数
#     "relation_count": 3       # 关系数
# }
```

---

## 四、配置文件说明

配置文件位置：`config/memos_config.json`

```json
{
  "storage": {
    "vector": {
      "type": "qdrant",
      "path": "./data/qdrant",          // Qdrant 数据目录
      "collection_name": "memories",
      "vector_size": 1024               // 向量维度（与模型匹配）
    },
    "graph": {
      "type": "networkx",
      "path": "./data/graph_store.json", // 图数据文件
      "enabled": true                    // 是否启用图谱
    },
    "legacy_json": {
      "path": "./data/memory_store.json",
      "enabled": true                    // 是否加载旧数据
    }
  },
  "embedding": {
    "model_path": "../full-hub/rag-hub", // Embedding 模型路径
    "vector_size": 1024
  },
  "search": {
    "default_top_k": 5,
    "similarity_threshold": 0.5,         // 默认相似度阈值
    "importance_weight": 0.3             // 重要度权重
  },
  "llm": {
    "config": {
      "model": "deepseek-ai/DeepSeek-V3.2",
      "api_key": "你的API密钥",
      "base_url": "https://api.siliconflow.cn/v1"
    }
  }
}
```

---

## 五、实体类型参考

### 常用实体类型

| 类型 | 说明 | 示例 |
|------|------|------|
| person | 人物 | 用户、朋友、同事 |
| place | 地点 | 北京、公司、家 |
| food | 食物 | 火锅、咖啡、苹果 |
| hobby | 爱好 | 编程、游戏、运动 |
| profession | 职业 | 工程师、设计师 |
| concept | 概念 | AI、机器学习 |
| event | 事件 | 生日、会议 |
| item | 物品 | 手机、电脑 |
| color | 颜色 | 蓝色、红色 |
| time | 时间 | 周末、早上 |

### 常用关系类型

| 关系 | 说明 | 示例 |
|------|------|------|
| likes | 喜欢 | User -[likes]-> 火锅 |
| dislikes | 不喜欢 | User -[dislikes]-> 香菜 |
| prefers | 偏好 | User -[prefers]-> 蓝色 |
| works_as | 职业是 | User -[works_as]-> 工程师 |
| lives_in | 居住在 | User -[lives_in]-> 北京 |
| knows | 认识 | User -[knows]-> 张三 |
| owns | 拥有 | User -[owns]-> iPhone |
| interested_in | 感兴趣 | User -[interested_in]-> AI |
| related_to | 相关 | Python -[related_to]-> 编程 |

---

## 六、最佳实践

### 1. 记忆管理

- **日常对话**：使用 `/add` 让 LLM 自动提取关键信息
- **批量导入**：使用 `/add_raw` 直接添加
- **重要信息**：设置 importance > 0.8
- **一般信息**：保持默认 importance = 0.5

### 2. 知识图谱

- **核心实体**：先创建 "User" 作为中心节点
- **渐进构建**：随着对话积累逐步添加实体和关系
- **关系方向**：通常从 User 指向其他实体
- **属性丰富**：在 properties 中存储额外信息

### 3. 搜索优化

- **阈值调整**：
  - 高精度：similarity_threshold = 0.6
  - 高召回：similarity_threshold = 0.3
- **结果数量**：根据需求调整 top_k

---

## 七、数据文件位置

```
memos_system/
├── data/
│   ├── qdrant/              # Qdrant 向量数据
│   ├── graph_store.json     # 图谱数据
│   └── memory_store.json    # 旧版 JSON 备份
├── config/
│   └── memos_config.json    # 配置文件
└── api/
    ├── memos_api_server.py     # v1.0 旧版
    └── memos_api_server_v2.py  # v2.0 新版
```

---

## 八、故障排除

### 1. 服务无法启动

```bash
# 检查端口占用
netstat -ano | findstr :8003

# 杀死占用进程
taskkill /F /PID <进程ID>
```

### 2. 搜索无结果

- 检查 user_id 是否正确
- 降低 similarity_threshold
- 确认记忆已成功添加

### 3. 图谱功能异常

- 检查 config 中 graph.enabled = true
- 查看 /graph/stats 确认状态

---

## 九、与旧版本的兼容性

- ✅ 所有旧版 API 端点保持不变
- ✅ 旧版 JSON 数据自动加载
- ✅ 请求格式完全兼容
- ⚠️ 建议逐步迁移到新端点以使用新功能

---

## 十、主 LLM 调用方式

### JavaScript 客户端 (live-2d)

客户端文件位置：`live-2d/js/ai/memos-client.js`

#### 1. 初始化

```javascript
const { MemosClient } = require('./memos-client.js');

const memosClient = new MemosClient({
    memos: {
        enabled: true,
        api_url: 'http://127.0.0.1:8003',
        auto_inject: true,
        inject_top_k: 3,
        similarity_threshold: 0.5,
        save_interval: 10,
        graph_enabled: true  // v2.0 新增
    }
});
```

#### 2. 搜索记忆

```javascript
// 搜索相关记忆
const memories = await memosClient.search("用户喜欢什么食物");
console.log(memories);
// [{ content: "用户喜欢吃火锅", similarity: 0.85, importance: 0.9 }, ...]

// 格式化为 prompt
const promptText = memosClient.formatMemoriesForPrompt(memories);
// "- 用户喜欢吃火锅 【2025年1月20日】"
```

#### 3. 保存记忆

```javascript
// 直接保存
await memosClient.add([
    { role: "user", content: "我喜欢蓝色" },
    { role: "assistant", content: "好的，我记住了" }
]);

// 累积保存（每10轮自动触发）
await memosClient.addWithBuffer([
    { role: "user", content: "今天天气真好" }
]);

// 强制保存缓存
await memosClient.flushBuffer();
```

#### 4. 知识图谱操作 (v2.0 新增)

```javascript
// 添加实体
const entity = await memosClient.addEntity("四川火锅", "food", {
    spicy: true,
    category: "川菜"
});
// { entity_id: "xxx-xxx", name: "四川火锅" }

// 添加关系
await memosClient.addRelation(
    "user_entity_id",     // 源实体
    entity.entity_id,     // 目标实体
    "likes"               // 关系类型
);

// 查找实体
const entities = await memosClient.findEntity("火锅");
// [{ id: "xxx", name: "四川火锅", entity_type: "food" }, ...]

// 查找相关实体
const related = await memosClient.findRelatedEntities(entity.entity_id, 2);
// [{ name: "用户", entity_type: "person", depth: 1, path_relation: "likes" }, ...]

// 获取实体的关系
const relations = await memosClient.getEntityRelations(entity.entity_id);
// [{ source: "xxx", target: "yyy", relation_type: "likes", direction: "in" }, ...]
```

#### 5. 获取完整上下文

```javascript
// 获取记忆 + 图谱的完整上下文（用于注入 system prompt）
const context = await memosClient.getFullContextForPrompt("用户喜欢什么");
// 【相关记忆】
// - 用户喜欢吃火锅 【2025年1月20日】
// 【知识图谱】
// 用户(person): →[likes], →[prefers]
```

#### 6. 获取系统状态

```javascript
const status = await memosClient.getSystemStatus();
// {
//     online: true,
//     memory_count: 100,
//     entity_count: 15,
//     relation_count: 20,
//     qdrant_available: true,
//     graph_available: true
// }
```

### 在对话中自动使用

在 `llm-handler.js` 或对话处理逻辑中：

```javascript
async function handleUserMessage(userMessage) {
    // 1. 获取相关上下文
    const context = await memosClient.getFullContextForPrompt(userMessage);
    
    // 2. 构建系统提示
    const systemPrompt = `你是肥牛AI助手。
${context ? `\n以下是相关背景信息：\n${context}` : ''}
请根据这些信息回答用户的问题。`;
    
    // 3. 调用 LLM
    const response = await callLLM({
        messages: [
            { role: "system", content: systemPrompt },
            { role: "user", content: userMessage }
        ]
    });
    
    // 4. 保存对话到记忆（累积模式）
    await memosClient.addWithBuffer([
        { role: "user", content: userMessage },
        { role: "assistant", content: response }
    ]);
    
    return response;
}
```

### 配置文件示例

在 `config.json` 中添加：

```json
{
    "memos": {
        "enabled": true,
        "api_url": "http://127.0.0.1:8003",
        "auto_inject": true,
        "inject_top_k": 5,
        "similarity_threshold": 0.5,
        "save_interval": 10,
        "graph_enabled": true,
        "auto_extract_entities": false
    }
}
```

### 常用关系类型速查

| 关系 | 含义 | 示例 |
|------|------|------|
| likes | 喜欢 | 用户 -[likes]-> 火锅 |
| dislikes | 不喜欢 | 用户 -[dislikes]-> 香菜 |
| prefers | 偏好 | 用户 -[prefers]-> 蓝色 |
| knows | 认识 | 用户 -[knows]-> 张三 |
| works_as | 职业 | 用户 -[works_as]-> 程序员 |
| lives_in | 居住 | 用户 -[lives_in]-> 北京 |
| owns | 拥有 | 用户 -[owns]-> iPhone |
| interested_in | 感兴趣 | 用户 -[interested_in]-> AI |

### 常用实体类型速查

| 类型 | 说明 |
|------|------|
| person | 人物 |
| food | 食物 |
| place | 地点 |
| hobby | 爱好 |
| profession | 职业 |
| color | 颜色 |
| item | 物品 |
| concept | 概念 |

---

## 十一、记忆类型系统

### 记忆类型定义

基于认知科学的记忆分类，系统支持以下记忆类型：

| 类型 | 英文 | 说明 | 搜索权重 | 示例 |
|------|------|------|----------|------|
| 情景记忆 | episodic | 具体事件、对话、经历（有时间地点） | 1.0 | "2025年1月20日用户和AI玩了《鸣潮》" |
| 语义记忆 | semantic | 抽象知识、概念、用户属性 | 1.2 | "用户是医生" |
| 程序记忆 | procedural | 习惯、操作方式、行为模式 | 1.1 | "用户习惯晚睡" |
| 偏好记忆 | preference | 喜好、厌恶 | **1.5** | "用户喜欢火锅" |
| 事实记忆 | fact | 客观事实信息 | 1.3 | "用户养了一只猫" |
| 事件记忆 | event | 重要事件 | 1.0 | "用户的生日是5月10日" |
| 工具记忆 | tool | 工具使用记录 | 0.9 | "用户常用搜索功能" |
| 通用记忆 | general | 未分类 | 1.0 | 其他内容 |

### 添加带类型的记忆

```python
import requests

# 添加偏好记忆
requests.post("http://127.0.0.1:8003/add_raw", json={
    "messages": [
        {"content": "用户喜欢吃四川火锅", "importance": 0.9, "memory_type": "preference"},
        {"content": "用户是一名医生", "importance": 0.8, "memory_type": "semantic"},
        {"content": "用户习惯在深夜与AI对话", "importance": 0.7, "memory_type": "procedural"}
    ],
    "user_id": "test_user"
})
```

### 按类型查询记忆

```python
# 获取所有偏好记忆
response = requests.get("http://127.0.0.1:8003/memories/by-type/preference")
print(response.json())

# 获取所有语义记忆
response = requests.get("http://127.0.0.1:8003/memories/by-type/semantic")
```

### LLM 自动分类

```python
# 让 LLM 判断记忆类型
response = requests.post("http://127.0.0.1:8003/memories/classify", params={
    "content": "用户每天晚上12点后才睡觉"
})
print(response.json())
# {"content": "...", "classified_type": "procedural", "type_weight": 1.1}
```

### 搜索时的类型加权

搜索时，综合得分计算公式：

```
final_score = similarity × (1 + importance × 0.3 + (type_weight - 1) × 0.2)
```

偏好记忆（权重 1.5）在搜索结果中会排名更靠前。

---

## 十二、偏好记忆管理

### 添加用户偏好

```python
import requests

# 添加喜欢的食物
response = requests.post("http://127.0.0.1:8003/preferences", json={
    "item": "四川火锅",
    "category": "food",
    "preference_type": "like",
    "strength": 0.9,
    "reason": "用户多次提到喜欢麻辣口味"
})

# 添加不喜欢的食物
requests.post("http://127.0.0.1:8003/preferences", json={
    "item": "香菜",
    "category": "food", 
    "preference_type": "dislike",
    "strength": 0.8
})
```

### 偏好类别

| 类别 | 说明 |
|------|------|
| food | 食物 |
| color | 颜色 |
| hobby | 爱好 |
| music | 音乐 |
| movie | 电影 |
| place | 地点 |
| person | 人物 |
| style | 风格 |
| other | 其他 |

### 获取偏好列表

```python
# 获取所有偏好
response = requests.get("http://127.0.0.1:8003/preferences")

# 按类别筛选
response = requests.get("http://127.0.0.1:8003/preferences?category=food")

# 只获取喜欢的
response = requests.get("http://127.0.0.1:8003/preferences?preference_type=like")
```

### 获取偏好摘要

```python
response = requests.get("http://127.0.0.1:8003/preferences/summary")
print(response.json())
# {
#     "summary": {
#         "total_count": 10,
#         "likes_count": 7,
#         "dislikes_count": 3,
#         "by_category": {"food": 4, "hobby": 3, "color": 2, "other": 1}
#     }
# }
```

### 从对话中自动提取偏好

```python
# 使用 LLM 从文本中提取偏好
response = requests.post("http://127.0.0.1:8003/preferences/extract", json={
    "text": "我最喜欢吃火锅了，尤其是麻辣锅底。不过我不太喜欢香菜，每次都要求不加。"
})
print(response.json())
# {
#     "extracted": {
#         "likes": [{"item": "火锅", "category": "food", "strength": 0.9}],
#         "dislikes": [{"item": "香菜", "category": "food", "strength": 0.8}]
#     },
#     "added_count": 2
# }
```

### JavaScript 客户端调用

```javascript
// 添加偏好
await memosClient.addPreference("火锅", "food", {spicy: true});

// 搜索时自动考虑偏好权重
const results = await memosClient.search("用户喜欢什么");
// 偏好记忆会因为 1.5x 权重而排名更靠前
```

---

## 十三、工具记忆管理（v2.2 新增）

### 功能说明

工具记忆用于记录用户的工具使用历史，帮助 AI 了解：
- 用户常用哪些工具
- 使用工具时的常用参数
- 工具使用的成功率
- 用户的工具偏好

### 记录工具使用

```python
import requests

# 记录一次工具使用
response = requests.post("http://127.0.0.1:8003/tools/record", json={
    "tool_name": "bilibili_search",
    "tool_category": "media",        # search, media, utility, communication, creative, system, other
    "parameters": {"keyword": "AI教程", "page": 1},
    "success": True,
    "result_summary": "找到 50 个相关视频",
    "context": "用户想学习 AI",
    "user_intent": "查找学习资料"
})
print(response.json())
# {"status": "success", "record_id": "tool_xxx", "tool_name": "bilibili_search"}
```

### 获取工具统计

```python
# 获取工具使用统计
response = requests.get("http://127.0.0.1:8003/tools/stats")
print(response.json())
# {
#     "status": "enabled",
#     "total_usage": 50,
#     "total_tools": 8,
#     "overall_success_rate": 0.95,
#     "by_category": {"search": 20, "media": 15, "utility": 15},
#     "top_tools": ["bilibili_search", "web_search", "weather"]
# }
```

### 获取常用工具

```python
# 获取常用工具列表
response = requests.get("http://127.0.0.1:8003/tools/frequently-used?top_k=5")
print(response.json())
# {
#     "tools": [
#         {"tool_name": "bilibili_search", "category": "media", "use_count": 20, "success_rate": 0.95},
#         {"tool_name": "web_search", "category": "search", "use_count": 15, "success_rate": 1.0}
#     ]
# }
```

### 获取参数建议

```python
# 根据历史使用建议参数
response = requests.get("http://127.0.0.1:8003/tools/suggest/bilibili_search")
print(response.json())
# {"tool_name": "bilibili_search", "suggestions": {"keyword": ["AI", "编程", "游戏"]}}
```

---

## 十四、记忆反馈修正（v2.2 新增）

### 功能说明

用户可以对 AI 的记忆进行反馈修正，包括：
- **correct**: 修正错误内容
- **supplement**: 补充额外信息
- **delete**: 删除不需要的记忆
- **merge**: 合并重复记忆

### 修正记忆内容

```python
import requests

# 修正错误的记忆
response = requests.post("http://127.0.0.1:8003/memory/feedback", json={
    "memory_id": "xxx-xxx-xxx",
    "feedback_type": "correct",
    "correction": "用户喜欢川菜，特别是麻辣火锅",  # 修正后的内容
    "reason": "原来记录的是粤菜，但用户实际喜欢川菜"
})
print(response.json())
# {"status": "success", "action": "corrected", "memory_id": "xxx", "new_content": "..."}
```

### 补充信息

```python
# 补充额外信息到现有记忆
response = requests.post("http://127.0.0.1:8003/memory/feedback", json={
    "memory_id": "xxx-xxx-xxx",
    "feedback_type": "supplement",
    "correction": "用户还特别喜欢番茄锅底"
})
# 原内容会变成：原内容 + "\n[补充] 用户还特别喜欢番茄锅底"
```

### 删除记忆

```python
# 删除不需要的记忆
response = requests.post("http://127.0.0.1:8003/memory/feedback", json={
    "memory_id": "xxx-xxx-xxx",
    "feedback_type": "delete",
    "reason": "这条记忆已过时"
})
```

### 合并记忆

```python
# 将一条记忆合并到另一条
response = requests.post("http://127.0.0.1:8003/memory/feedback", json={
    "memory_id": "source_memory_id",      # 要合并的源记忆
    "feedback_type": "merge",
    "correction": "target_memory_id"       # 合并到的目标记忆 ID
})
# 源记忆内容会追加到目标记忆，然后源记忆被删除
```

### 查看修改历史

```python
# 获取记忆的修改历史
response = requests.get("http://127.0.0.1:8003/memory/xxx-xxx-xxx/history")
print(response.json())
# {
#     "memory_id": "xxx",
#     "current_content": "当前内容",
#     "created_at": "2025-01-20T10:00:00",
#     "updated_at": "2025-01-24T15:30:00",
#     "merge_count": 2,
#     "merged_from": ["id1", "id2"],
#     "correction_history": [
#         {"original": "旧内容", "corrected_at": "...", "reason": "修正原因"}
#     ]
# }
```

---

## 十五、知识库导入（v2.2 新增）

### 功能说明

支持从多种来源导入知识到记忆系统：
- 文本文件 (.txt)
- PDF 文件 (.pdf)
- Markdown 文件 (.md)
- 网页 URL

### 导入单个文档

```python
import requests

# 导入本地文档
response = requests.post("http://127.0.0.1:8003/kb/import", json={
    "source": "C:/docs/user_manual.pdf",
    "tags": ["manual", "help"],
    "user_id": "test_user"
})
print(response.json())
# {
#     "status": "success",
#     "source": "C:/docs/user_manual.pdf",
#     "chunks_count": 15,           # 总块数
#     "imported_count": 15,         # 成功导入数
#     "memory_ids": ["id1", "id2", ...],
#     "total_memory_ids": 15
# }
```

### 从 URL 导入

```python
# 从网页导入内容
response = requests.post("http://127.0.0.1:8003/kb/import/url", params={
    "url": "https://example.com/article",
    "tags": ["web", "article"]
})
```

### 批量导入

```python
# 批量导入多个文档
response = requests.post("http://127.0.0.1:8003/kb/import/batch", json={
    "sources": [
        "C:/docs/doc1.txt",
        "C:/docs/doc2.pdf",
        "https://example.com/page"
    ],
    "tags": ["batch_import"],
    "user_id": "test_user"
})
print(response.json())
# {
#     "total_sources": 3,
#     "total_imported": 45,
#     "total_failed": 0,
#     "details": [...]
# }
```

### 导入配置

在 `config/memos_config.json` 中添加知识库配置：

```json
{
    "kb": {
        "chunk_size": 500,       // 每块最大字符数
        "chunk_overlap": 50      // 块之间重叠字符数
    }
}
```

---

## 十六、搜索高级功能（v2.2 新增）

### 标签过滤搜索

```python
import requests

# 按标签过滤搜索
response = requests.post("http://127.0.0.1:8003/search", json={
    "query": "用户喜欢什么",
    "top_k": 5,
    "tags": ["important", "preference"],  # 只搜索带有这些标签的记忆
    "user_id": "test_user"
})
```

### 按记忆类型过滤

```python
# 只搜索特定类型的记忆
response = requests.post("http://127.0.0.1:8003/search", json={
    "query": "用户的爱好",
    "top_k": 5,
    "memory_types": ["preference", "semantic"],  # 只搜索偏好和语义记忆
    "user_id": "test_user"
})
```

### 图增强搜索

```python
# 启用知识图谱增强
response = requests.post("http://127.0.0.1:8003/search", json={
    "query": "用户喜欢吃什么",
    "top_k": 5,
    "use_graph": True,  # 启用图谱关联
    "user_id": "test_user"
})
# 与查询中实体相关联的记忆会获得额外加分
```

### 搜索结果字段说明

| 字段 | 说明 |
|------|------|
| content | 记忆内容 |
| similarity | 向量相似度 (0-1) |
| importance | 重要度 (0-1) |
| memory_type | 记忆类型 |
| type_weight | 类型权重 |
| graph_boost | 图谱关联加分 |
| final_score | 最终综合得分 |
| tags | 标签列表 |

### 综合得分计算公式

```
final_score = similarity × (1 + importance × 0.3 + (type_weight - 1) × 0.2) + graph_boost
```

- 偏好记忆 (type_weight=1.5) 会获得约 10% 的额外加分
- 图谱关联的记忆会获得 0.1 的固定加分

---

## 十七、图像记忆（v2.3 新增）

### 功能说明

图像记忆支持存储和检索图像，包括：
- 对话中的图片
- 文档中的图表
- 截图
- 参考图像

### 上传图像

```python
import requests
import base64

# 读取图像并转为 Base64
with open("photo.jpg", "rb") as f:
    image_data = base64.b64encode(f.read()).decode('utf-8')

# 上传图像
response = requests.post("http://127.0.0.1:8003/images/upload", json={
    "image_data": image_data,
    "filename": "photo.jpg",
    "image_type": "conversation",  # conversation, document, screenshot, avatar, reference, other
    "description": "用户分享的照片",  # 可选，不填则自动生成
    "tags": ["personal", "photo"],
    "user_id": "test_user",
    "auto_describe": True  # 使用 LLM 自动生成描述
})
print(response.json())
# {
#     "status": "success",
#     "image_id": "img_xxx",
#     "filename": "img_xxx.jpg",
#     "description": "一张户外风景照片...",
#     "size_bytes": 123456,
#     "dimensions": "1920x1080"
# }
```

### 搜索图像

```python
# 用文字描述搜索相关图像
response = requests.post("http://127.0.0.1:8003/images/search", params={
    "query": "风景照片",
    "top_k": 5,
    "user_id": "test_user"
})
print(response.json())
# {
#     "query": "风景照片",
#     "images": [
#         {"image_id": "img_xxx", "description": "...", "similarity": 0.85}
#     ],
#     "count": 1
# }
```

### 获取图像数据

```python
# 获取图像 Base64 数据
response = requests.get("http://127.0.0.1:8003/images/img_xxx/data?thumbnail=true")
image_base64 = response.json()['data']

# 获取图像信息
response = requests.get("http://127.0.0.1:8003/images/img_xxx")
print(response.json())
```

### 列出图像

```python
# 列出用户的所有图像
response = requests.get("http://127.0.0.1:8003/images", params={
    "user_id": "test_user",
    "image_type": "conversation",
    "limit": 50
})
```

### 配置选项

在 `config/memos_config.json` 中：

```json
{
    "image": {
        "enabled": true,
        "storage_path": "./data/images",
        "use_clip": false,        // 使用 CLIP 模型进行图像向量化
        "max_size_mb": 5,         // 最大图像大小
        "auto_describe": true     // 自动生成描述
    }
}
```

---

## 十八、异步任务调度器（v2.3 新增）

### 功能说明

异步调度器用于处理耗时任务，避免阻塞 API 请求：
- 基于 asyncio 的内存队列（默认）
- 支持 Redis Streams（可选）
- 任务优先级
- 自动重试
- 配额控制

### 启用调度器

在 `config/memos_config.json` 中：

```json
{
    "scheduler": {
        "enabled": true,
        "use_redis": false,       // 使用 Redis（需要安装 redis 包）
        "redis_url": "redis://localhost:6379",
        "max_workers": 4,         // 工作协程数
        "quota_per_user": 100     // 每用户每分钟配额
    }
}
```

### 提交异步任务

```python
import requests

# 提交异步记忆添加任务
response = requests.post("http://127.0.0.1:8003/scheduler/submit", json={
    "task_type": "add_memory",
    "payload": {
        "content": "用户喜欢吃火锅",
        "importance": 0.8,
        "memory_type": "preference"
    },
    "priority": 2,  # 0=low, 1=normal, 2=high, 3=critical
    "user_id": "test_user",
    "timeout": 60
})
print(response.json())
# {"status": "submitted", "task_id": "task_xxx", "task_type": "add_memory", "priority": 2}
```

### 查询任务状态

```python
# 获取任务状态
task_id = "task_xxx"
response = requests.get(f"http://127.0.0.1:8003/scheduler/task/{task_id}")
print(response.json())
# {
#     "id": "task_xxx",
#     "task_type": "add_memory",
#     "status": "completed",  # pending, running, completed, failed, timeout
#     "result": {"status": "success", "memory_id": "xxx"},
#     "created_at": "2025-01-24T10:00:00",
#     "completed_at": "2025-01-24T10:00:01"
# }
```

### 异步批量添加记忆

```python
# 使用异步接口批量添加记忆
response = requests.post("http://127.0.0.1:8003/async/add", json={
    "messages": [
        {"content": "用户喜欢蓝色", "importance": 0.7, "memory_type": "preference"},
        {"content": "用户是程序员", "importance": 0.8, "memory_type": "semantic"}
    ],
    "user_id": "test_user"
})
print(response.json())
# {"status": "submitted", "message": "已提交 2 个任务", "task_ids": ["task_1", "task_2"]}
```

### 获取调度器统计

```python
response = requests.get("http://127.0.0.1:8003/scheduler/stats")
print(response.json())
# {
#     "status": "enabled",
#     "running": true,
#     "workers": 4,
#     "queue_size": 5,
#     "use_redis": false,
#     "total_submitted": 100,
#     "total_completed": 95,
#     "total_failed": 3,
#     "total_timeout": 2
# }
```

### 任务类型

| 类型 | 说明 |
|------|------|
| add_memory | 添加记忆 |
| process_image | 处理图像 |
| extract_entities | 提取实体 |

### 优先级

| 值 | 级别 | 说明 |
|----|------|------|
| 0 | LOW | 低优先级，空闲时处理 |
| 1 | NORMAL | 普通优先级（默认） |
| 2 | HIGH | 高优先级，优先处理 |
| 3 | CRITICAL | 关键任务，立即处理 |

---

## 十九、API 端点完整列表（v2.3 更新）

### 基础端点
```
GET  /                 # 服务信息
GET  /health           # 健康检查
GET  /stats            # 统计信息
GET  /docs             # API 文档
```

### 记忆管理
```
POST   /add            # 添加记忆（LLM 加工）
POST   /add_raw        # 直接添加记忆
POST   /search         # 搜索记忆
GET    /list           # 列出记忆
GET    /get/{id}       # 获取记忆
DELETE /delete/{id}    # 删除记忆
POST   /memory/feedback # 记忆反馈修正
GET    /memory/{id}/history # 修改历史
```

### 图像记忆
```
GET    /images/stats           # 图像统计
POST   /images/upload          # 上传图像
POST   /images/search          # 搜索图像
GET    /images/{id}            # 获取图像信息
GET    /images/{id}/data       # 获取图像数据
DELETE /images/{id}            # 删除图像
GET    /images                 # 列出图像
```

### 异步调度器
```
GET    /scheduler/stats        # 调度器统计
POST   /scheduler/submit       # 提交任务
GET    /scheduler/task/{id}    # 任务状态
POST   /async/add              # 异步添加记忆
```

### 工具记忆
```
GET    /tools/stats            # 工具统计
POST   /tools/record           # 记录使用
GET    /tools/frequently-used  # 常用工具
GET    /tools/recent           # 最近使用
GET    /tools/suggest/{name}   # 参数建议
```

### 偏好管理
```
GET    /preferences            # 偏好列表
POST   /preferences            # 添加偏好
GET    /preferences/summary    # 偏好摘要
POST   /preferences/extract    # 提取偏好
POST   /preferences/search     # 搜索偏好
```

### 知识库
```
POST   /kb/import              # 导入文档
POST   /kb/import/batch        # 批量导入
POST   /kb/import/url          # URL 导入
```

### 知识图谱
```
GET    /graph/stats            # 图谱统计
POST   /graph/entity           # 添加实体
GET    /graph/entity/{id}      # 获取实体
DELETE /graph/entity/{id}      # 删除实体
GET    /graph/entities         # 列出实体
POST   /graph/relation         # 添加关系
POST   /graph/query/related    # 相关实体
GET    /graph/path             # 查找路径
```

### 实体提取
```
POST   /entities/extract       # 从文本提取实体和关系
GET    /entities/stats         # 实体统计
```

---

## 二十、实体提取与图增强搜索（v2.4 新增）

### 功能说明

实体提取功能使用 LLM 自动识别文本中的实体（人物、地点、概念等）和它们之间的关系，并存储到知识图谱中。图增强搜索利用这些关联信息提升检索准确性。

### 启用实体提取

在 `config/memos_config.json` 中：

```json
{
    "entity_extraction": {
        "enabled": true,
        "auto_extract_on_add": false
    }
}
```

### 从文本提取实体

```python
import requests

# 手动提取实体（不存储）
response = requests.post("http://127.0.0.1:8003/entities/extract", json={
    "text": "张三喜欢喝咖啡，他在北京工作，是李四的朋友。",
    "store_to_graph": False
})
print(response.json())
# {
#     "entities": [
#         {"name": "张三", "type": "person", "description": "...", "confidence": 0.9},
#         {"name": "咖啡", "type": "preference", "description": "...", "confidence": 0.8},
#         {"name": "北京", "type": "place", "description": "...", "confidence": 0.9},
#         {"name": "李四", "type": "person", "description": "...", "confidence": 0.8}
#     ],
#     "relations": [
#         {"source": "张三", "target": "咖啡", "type": "LIKES", "description": "喜欢喝"},
#         {"source": "张三", "target": "北京", "type": "LOCATED_AT", "description": "在北京工作"},
#         {"source": "张三", "target": "李四", "type": "KNOWS", "description": "是朋友"}
#     ],
#     "entity_count": 4,
#     "relation_count": 3
# }
```

### 提取并存储到图谱

```python
# 提取并存储到知识图谱
response = requests.post("http://127.0.0.1:8003/entities/extract", json={
    "text": "用户喜欢吃火锅和烧烤，最爱的颜色是蓝色。",
    "store_to_graph": True,
    "link_to_memory_id": "mem_xxx",  # 可选：关联到某条记忆
    "user_id": "test_user"
})
print(response.json())
# {
#     "entities": [...],
#     "relations": [...],
#     "stored_to_graph": true,
#     "stored_entities": [
#         {"id": "ent_abc123", "name": "火锅"},
#         {"id": "ent_def456", "name": "烧烤"},
#         {"id": "ent_ghi789", "name": "蓝色"}
#     ],
#     "stored_relations": 3
# }
```

### 添加记忆时自动提取实体

```python
# 添加记忆并自动提取实体
response = requests.post("http://127.0.0.1:8003/add_raw", json={
    "messages": [
        {"content": "我叫小明，我喜欢打篮球和游泳", "memory_type": "semantic"}
    ],
    "user_id": "test_user",
    "extract_entities": True  # 自动提取实体
})
print(response.json())
# {
#     "status": "success",
#     "added": 1,
#     "extracted_entities": [
#         {"id": "ent_xxx", "name": "小明"},
#         {"id": "ent_yyy", "name": "篮球"},
#         {"id": "ent_zzz", "name": "游泳"}
#     ],
#     "entity_count": 3
# }
```

### 图增强搜索

```python
# 启用图增强的搜索
response = requests.post("http://127.0.0.1:8003/search", json={
    "query": "小明喜欢什么运动",
    "top_k": 5,
    "use_graph": True,  # 启用图增强
    "user_id": "test_user"
})
# 搜索会：
# 1. 从查询中识别实体（如"小明"、"运动"）
# 2. 在图谱中查找匹配的实体
# 3. 获取相关实体（如"篮球"、"游泳"与"小明"的关系）
# 4. 为关联记忆添加 graph_boost 加分
# 5. 可能返回向量搜索未找到但通过图谱关联的记忆
```

### 实体类型

| 类型 | 说明 |
|------|------|
| person | 人物 |
| place | 地点 |
| object | 物品 |
| event | 事件 |
| concept | 概念 |
| preference | 偏好 |
| organization | 组织 |
| time | 时间 |

### 关系类型

| 类型 | 说明 |
|------|------|
| LIKES | 喜欢 |
| DISLIKES | 不喜欢 |
| KNOWS | 认识 |
| RELATED_TO | 相关 |
| PART_OF | 属于 |
| LOCATED_AT | 位于 |
| USES | 使用 |
| OWNS | 拥有 |

### 图增强搜索加分机制

| 场景 | 加分 |
|------|------|
| 记忆直接关联到匹配的实体 | +0.15 |
| 记忆的 entity_ids 包含匹配实体 | +0.10 |
| 仅通过图谱找到（向量未匹配） | +0.20 |
